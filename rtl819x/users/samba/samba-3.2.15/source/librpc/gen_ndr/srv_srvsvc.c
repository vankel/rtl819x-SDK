/*
 * Unix SMB/CIFS implementation.
 * server auto-generated by pidl. DO NOT MODIFY!
 */

#include "includes.h"
#include "librpc/gen_ndr/srv_srvsvc.h"

#if 0 /* tonywu */
static bool api_srvsvc_NetCharDevEnum(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetCharDevEnum *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETCHARDEVENUM];

	r = talloc(talloc_tos(), struct srvsvc_NetCharDevEnum);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetCharDevEnum, r);
	}

	ZERO_STRUCT(r->out);
	r->out.level = r->in.level;
	r->out.ctr = r->in.ctr;
	r->out.totalentries = talloc_zero(r, uint32_t);
	if (r->out.totalentries == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.resume_handle = r->in.resume_handle;
	r->out.result = _srvsvc_NetCharDevEnum(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetCharDevEnum, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetCharDevGetInfo(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetCharDevGetInfo *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETCHARDEVGETINFO];

	r = talloc(talloc_tos(), struct srvsvc_NetCharDevGetInfo);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetCharDevGetInfo, r);
	}

	ZERO_STRUCT(r->out);
	r->out.info = talloc_zero(r, union srvsvc_NetCharDevInfo);
	if (r->out.info == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _srvsvc_NetCharDevGetInfo(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetCharDevGetInfo, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetCharDevControl(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetCharDevControl *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETCHARDEVCONTROL];

	r = talloc(talloc_tos(), struct srvsvc_NetCharDevControl);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetCharDevControl, r);
	}

	r->out.result = _srvsvc_NetCharDevControl(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetCharDevControl, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetCharDevQEnum(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetCharDevQEnum *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETCHARDEVQENUM];

	r = talloc(talloc_tos(), struct srvsvc_NetCharDevQEnum);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetCharDevQEnum, r);
	}

	ZERO_STRUCT(r->out);
	r->out.level = r->in.level;
	r->out.ctr = r->in.ctr;
	r->out.totalentries = talloc_zero(r, uint32_t);
	if (r->out.totalentries == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.resume_handle = r->in.resume_handle;
	r->out.result = _srvsvc_NetCharDevQEnum(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetCharDevQEnum, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetCharDevQGetInfo(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetCharDevQGetInfo *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETCHARDEVQGETINFO];

	r = talloc(talloc_tos(), struct srvsvc_NetCharDevQGetInfo);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetCharDevQGetInfo, r);
	}

	ZERO_STRUCT(r->out);
	r->out.info = talloc_zero(r, union srvsvc_NetCharDevQInfo);
	if (r->out.info == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _srvsvc_NetCharDevQGetInfo(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetCharDevQGetInfo, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetCharDevQSetInfo(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetCharDevQSetInfo *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETCHARDEVQSETINFO];

	r = talloc(talloc_tos(), struct srvsvc_NetCharDevQSetInfo);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetCharDevQSetInfo, r);
	}

	ZERO_STRUCT(r->out);
	r->out.parm_error = r->in.parm_error;
	r->out.result = _srvsvc_NetCharDevQSetInfo(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetCharDevQSetInfo, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetCharDevQPurge(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetCharDevQPurge *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETCHARDEVQPURGE];

	r = talloc(talloc_tos(), struct srvsvc_NetCharDevQPurge);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetCharDevQPurge, r);
	}

	r->out.result = _srvsvc_NetCharDevQPurge(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetCharDevQPurge, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetCharDevQPurgeSelf(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetCharDevQPurgeSelf *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETCHARDEVQPURGESELF];

	r = talloc(talloc_tos(), struct srvsvc_NetCharDevQPurgeSelf);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetCharDevQPurgeSelf, r);
	}

	r->out.result = _srvsvc_NetCharDevQPurgeSelf(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetCharDevQPurgeSelf, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}
#endif

static bool api_srvsvc_NetConnEnum(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetConnEnum *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETCONNENUM];

	r = talloc(talloc_tos(), struct srvsvc_NetConnEnum);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetConnEnum, r);
	}

	ZERO_STRUCT(r->out);
	r->out.info_ctr = r->in.info_ctr;
	r->out.totalentries = talloc_zero(r, uint32_t);
	if (r->out.totalentries == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.resume_handle = r->in.resume_handle;
	r->out.result = _srvsvc_NetConnEnum(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetConnEnum, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetFileEnum(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetFileEnum *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETFILEENUM];

	r = talloc(talloc_tos(), struct srvsvc_NetFileEnum);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetFileEnum, r);
	}

	ZERO_STRUCT(r->out);
	r->out.info_ctr = r->in.info_ctr;
	r->out.totalentries = talloc_zero(r, uint32_t);
	if (r->out.totalentries == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.resume_handle = r->in.resume_handle;
	r->out.result = _srvsvc_NetFileEnum(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetFileEnum, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetFileGetInfo(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetFileGetInfo *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETFILEGETINFO];

	r = talloc(talloc_tos(), struct srvsvc_NetFileGetInfo);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetFileGetInfo, r);
	}

	ZERO_STRUCT(r->out);
	r->out.info = talloc_zero(r, union srvsvc_NetFileInfo);
	if (r->out.info == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _srvsvc_NetFileGetInfo(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetFileGetInfo, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetFileClose(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetFileClose *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETFILECLOSE];

	r = talloc(talloc_tos(), struct srvsvc_NetFileClose);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetFileClose, r);
	}

	r->out.result = _srvsvc_NetFileClose(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetFileClose, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetSessEnum(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetSessEnum *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETSESSENUM];

	r = talloc(talloc_tos(), struct srvsvc_NetSessEnum);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetSessEnum, r);
	}

	ZERO_STRUCT(r->out);
	r->out.info_ctr = r->in.info_ctr;
	r->out.totalentries = talloc_zero(r, uint32_t);
	if (r->out.totalentries == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.resume_handle = r->in.resume_handle;
	r->out.result = _srvsvc_NetSessEnum(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetSessEnum, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetSessDel(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetSessDel *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETSESSDEL];

	r = talloc(talloc_tos(), struct srvsvc_NetSessDel);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetSessDel, r);
	}

	r->out.result = _srvsvc_NetSessDel(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetSessDel, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetShareAdd(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetShareAdd *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETSHAREADD];

	r = talloc(talloc_tos(), struct srvsvc_NetShareAdd);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetShareAdd, r);
	}

	ZERO_STRUCT(r->out);
	r->out.parm_error = r->in.parm_error;
	r->out.result = _srvsvc_NetShareAdd(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetShareAdd, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetShareEnumAll(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetShareEnumAll *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETSHAREENUMALL];

	r = talloc(talloc_tos(), struct srvsvc_NetShareEnumAll);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetShareEnumAll, r);
	}

	ZERO_STRUCT(r->out);
	r->out.info_ctr = r->in.info_ctr;
	r->out.totalentries = talloc_zero(r, uint32_t);
	if (r->out.totalentries == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.resume_handle = r->in.resume_handle;
	r->out.result = _srvsvc_NetShareEnumAll(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetShareEnumAll, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetShareGetInfo(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetShareGetInfo *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETSHAREGETINFO];

	r = talloc(talloc_tos(), struct srvsvc_NetShareGetInfo);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetShareGetInfo, r);
	}

	ZERO_STRUCT(r->out);
	r->out.info = talloc_zero(r, union srvsvc_NetShareInfo);
	if (r->out.info == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _srvsvc_NetShareGetInfo(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetShareGetInfo, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetShareSetInfo(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetShareSetInfo *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETSHARESETINFO];

	r = talloc(talloc_tos(), struct srvsvc_NetShareSetInfo);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetShareSetInfo, r);
	}

	ZERO_STRUCT(r->out);
	r->out.parm_error = r->in.parm_error;
	r->out.result = _srvsvc_NetShareSetInfo(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetShareSetInfo, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetShareDel(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetShareDel *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETSHAREDEL];

	r = talloc(talloc_tos(), struct srvsvc_NetShareDel);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetShareDel, r);
	}

	r->out.result = _srvsvc_NetShareDel(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetShareDel, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetShareDelSticky(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetShareDelSticky *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETSHAREDELSTICKY];

	r = talloc(talloc_tos(), struct srvsvc_NetShareDelSticky);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetShareDelSticky, r);
	}

	r->out.result = _srvsvc_NetShareDelSticky(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetShareDelSticky, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetShareCheck(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetShareCheck *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETSHARECHECK];

	r = talloc(talloc_tos(), struct srvsvc_NetShareCheck);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetShareCheck, r);
	}

	ZERO_STRUCT(r->out);
	r->out.type = talloc_zero(r, enum srvsvc_ShareType);
	if (r->out.type == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _srvsvc_NetShareCheck(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetShareCheck, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetSrvGetInfo(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetSrvGetInfo *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETSRVGETINFO];

	r = talloc(talloc_tos(), struct srvsvc_NetSrvGetInfo);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetSrvGetInfo, r);
	}

	ZERO_STRUCT(r->out);
	r->out.info = talloc_zero(r, union srvsvc_NetSrvInfo);
	if (r->out.info == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _srvsvc_NetSrvGetInfo(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetSrvGetInfo, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetSrvSetInfo(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetSrvSetInfo *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETSRVSETINFO];

	r = talloc(talloc_tos(), struct srvsvc_NetSrvSetInfo);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetSrvSetInfo, r);
	}

	ZERO_STRUCT(r->out);
	r->out.parm_error = r->in.parm_error;
	r->out.result = _srvsvc_NetSrvSetInfo(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetSrvSetInfo, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetDiskEnum(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetDiskEnum *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETDISKENUM];

	r = talloc(talloc_tos(), struct srvsvc_NetDiskEnum);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetDiskEnum, r);
	}

	ZERO_STRUCT(r->out);
	r->out.info = r->in.info;
	r->out.totalentries = talloc_zero(r, uint32_t);
	if (r->out.totalentries == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.resume_handle = r->in.resume_handle;
	r->out.result = _srvsvc_NetDiskEnum(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetDiskEnum, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

#if 0 /* tonywu */
static bool api_srvsvc_NetServerStatisticsGet(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetServerStatisticsGet *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETSERVERSTATISTICSGET];

	r = talloc(talloc_tos(), struct srvsvc_NetServerStatisticsGet);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetServerStatisticsGet, r);
	}

	ZERO_STRUCT(r->out);
	r->out.stats = talloc_zero(r, struct srvsvc_Statistics);
	if (r->out.stats == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _srvsvc_NetServerStatisticsGet(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetServerStatisticsGet, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetTransportAdd(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetTransportAdd *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETTRANSPORTADD];

	r = talloc(talloc_tos(), struct srvsvc_NetTransportAdd);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetTransportAdd, r);
	}

	r->out.result = _srvsvc_NetTransportAdd(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetTransportAdd, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetTransportEnum(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetTransportEnum *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETTRANSPORTENUM];

	r = talloc(talloc_tos(), struct srvsvc_NetTransportEnum);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetTransportEnum, r);
	}

	ZERO_STRUCT(r->out);
	r->out.level = r->in.level;
	r->out.transports = r->in.transports;
	r->out.totalentries = talloc_zero(r, uint32_t);
	if (r->out.totalentries == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.resume_handle = r->in.resume_handle;
	r->out.result = _srvsvc_NetTransportEnum(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetTransportEnum, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetTransportDel(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetTransportDel *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETTRANSPORTDEL];

	r = talloc(talloc_tos(), struct srvsvc_NetTransportDel);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetTransportDel, r);
	}

	r->out.result = _srvsvc_NetTransportDel(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetTransportDel, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}
#endif

static bool api_srvsvc_NetRemoteTOD(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetRemoteTOD *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETREMOTETOD];

	r = talloc(talloc_tos(), struct srvsvc_NetRemoteTOD);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetRemoteTOD, r);
	}

	ZERO_STRUCT(r->out);
	r->out.info = talloc_zero(r, struct srvsvc_NetRemoteTODInfo *);
	if (r->out.info == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _srvsvc_NetRemoteTOD(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetRemoteTOD, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

#if 0 /* tonywu */
static bool api_srvsvc_NetSetServiceBits(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetSetServiceBits *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETSETSERVICEBITS];

	r = talloc(talloc_tos(), struct srvsvc_NetSetServiceBits);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetSetServiceBits, r);
	}

	r->out.result = _srvsvc_NetSetServiceBits(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetSetServiceBits, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetPathType(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetPathType *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETPATHTYPE];

	r = talloc(talloc_tos(), struct srvsvc_NetPathType);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetPathType, r);
	}

	ZERO_STRUCT(r->out);
	r->out.pathtype = talloc_zero(r, uint32_t);
	if (r->out.pathtype == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _srvsvc_NetPathType(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetPathType, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetPathCanonicalize(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetPathCanonicalize *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETPATHCANONICALIZE];

	r = talloc(talloc_tos(), struct srvsvc_NetPathCanonicalize);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetPathCanonicalize, r);
	}

	ZERO_STRUCT(r->out);
	r->out.can_path = talloc_zero_array(r, uint8_t, r->in.maxbuf);
	if (r->out.can_path == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.pathtype = r->in.pathtype;
	r->out.result = _srvsvc_NetPathCanonicalize(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetPathCanonicalize, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetPathCompare(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetPathCompare *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETPATHCOMPARE];

	r = talloc(talloc_tos(), struct srvsvc_NetPathCompare);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetPathCompare, r);
	}

	r->out.result = _srvsvc_NetPathCompare(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetPathCompare, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}
#endif

static bool api_srvsvc_NetNameValidate(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetNameValidate *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETNAMEVALIDATE];

	r = talloc(talloc_tos(), struct srvsvc_NetNameValidate);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetNameValidate, r);
	}

	r->out.result = _srvsvc_NetNameValidate(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetNameValidate, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

#if 0 /* tonywu */
static bool api_srvsvc_NETRPRNAMECANONICALIZE(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NETRPRNAMECANONICALIZE *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETRPRNAMECANONICALIZE];

	r = talloc(talloc_tos(), struct srvsvc_NETRPRNAMECANONICALIZE);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_IN_DEBUG(srvsvc_NETRPRNAMECANONICALIZE, r);
	}

	r->out.result = _srvsvc_NETRPRNAMECANONICALIZE(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NETRPRNAMECANONICALIZE, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetPRNameCompare(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetPRNameCompare *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETPRNAMECOMPARE];

	r = talloc(talloc_tos(), struct srvsvc_NetPRNameCompare);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetPRNameCompare, r);
	}

	r->out.result = _srvsvc_NetPRNameCompare(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetPRNameCompare, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetShareEnum(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetShareEnum *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETSHAREENUM];

	r = talloc(talloc_tos(), struct srvsvc_NetShareEnum);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetShareEnum, r);
	}

	ZERO_STRUCT(r->out);
	r->out.info_ctr = r->in.info_ctr;
	r->out.totalentries = talloc_zero(r, uint32_t);
	if (r->out.totalentries == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.resume_handle = r->in.resume_handle;
	r->out.result = _srvsvc_NetShareEnum(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetShareEnum, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetShareDelStart(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetShareDelStart *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETSHAREDELSTART];

	r = talloc(talloc_tos(), struct srvsvc_NetShareDelStart);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetShareDelStart, r);
	}

	ZERO_STRUCT(r->out);
	r->out.hnd = talloc_zero(r, struct policy_handle);
	if (r->out.hnd == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _srvsvc_NetShareDelStart(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetShareDelStart, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetShareDelCommit(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetShareDelCommit *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETSHAREDELCOMMIT];

	r = talloc(talloc_tos(), struct srvsvc_NetShareDelCommit);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetShareDelCommit, r);
	}

	ZERO_STRUCT(r->out);
	r->out.hnd = r->in.hnd;
	r->out.result = _srvsvc_NetShareDelCommit(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetShareDelCommit, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}
#endif

static bool api_srvsvc_NetGetFileSecurity(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetGetFileSecurity *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETGETFILESECURITY];

	r = talloc(talloc_tos(), struct srvsvc_NetGetFileSecurity);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetGetFileSecurity, r);
	}

	ZERO_STRUCT(r->out);
	r->out.sd_buf = talloc_zero(r, struct sec_desc_buf *);
	if (r->out.sd_buf == NULL) {
		talloc_free(r);
		return false;
	}

	r->out.result = _srvsvc_NetGetFileSecurity(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetGetFileSecurity, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetSetFileSecurity(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetSetFileSecurity *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETSETFILESECURITY];

	r = talloc(talloc_tos(), struct srvsvc_NetSetFileSecurity);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetSetFileSecurity, r);
	}

	r->out.result = _srvsvc_NetSetFileSecurity(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetSetFileSecurity, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

#if 0 /* tonywu */
static bool api_srvsvc_NetServerTransportAddEx(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetServerTransportAddEx *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETSERVERTRANSPORTADDEX];

	r = talloc(talloc_tos(), struct srvsvc_NetServerTransportAddEx);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetServerTransportAddEx, r);
	}

	r->out.result = _srvsvc_NetServerTransportAddEx(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetServerTransportAddEx, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NetServerSetServiceBitsEx(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NetServerSetServiceBitsEx *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETSERVERSETSERVICEBITSEX];

	r = talloc(talloc_tos(), struct srvsvc_NetServerSetServiceBitsEx);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_IN_DEBUG(srvsvc_NetServerSetServiceBitsEx, r);
	}

	r->out.result = _srvsvc_NetServerSetServiceBitsEx(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NetServerSetServiceBitsEx, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NETRDFSGETVERSION(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NETRDFSGETVERSION *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETRDFSGETVERSION];

	r = talloc(talloc_tos(), struct srvsvc_NETRDFSGETVERSION);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_IN_DEBUG(srvsvc_NETRDFSGETVERSION, r);
	}

	r->out.result = _srvsvc_NETRDFSGETVERSION(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NETRDFSGETVERSION, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NETRDFSCREATELOCALPARTITION(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NETRDFSCREATELOCALPARTITION *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETRDFSCREATELOCALPARTITION];

	r = talloc(talloc_tos(), struct srvsvc_NETRDFSCREATELOCALPARTITION);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_IN_DEBUG(srvsvc_NETRDFSCREATELOCALPARTITION, r);
	}

	r->out.result = _srvsvc_NETRDFSCREATELOCALPARTITION(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NETRDFSCREATELOCALPARTITION, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NETRDFSDELETELOCALPARTITION(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NETRDFSDELETELOCALPARTITION *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETRDFSDELETELOCALPARTITION];

	r = talloc(talloc_tos(), struct srvsvc_NETRDFSDELETELOCALPARTITION);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_IN_DEBUG(srvsvc_NETRDFSDELETELOCALPARTITION, r);
	}

	r->out.result = _srvsvc_NETRDFSDELETELOCALPARTITION(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NETRDFSDELETELOCALPARTITION, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NETRDFSSETLOCALVOLUMESTATE(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NETRDFSSETLOCALVOLUMESTATE *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETRDFSSETLOCALVOLUMESTATE];

	r = talloc(talloc_tos(), struct srvsvc_NETRDFSSETLOCALVOLUMESTATE);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_IN_DEBUG(srvsvc_NETRDFSSETLOCALVOLUMESTATE, r);
	}

	r->out.result = _srvsvc_NETRDFSSETLOCALVOLUMESTATE(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NETRDFSSETLOCALVOLUMESTATE, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NETRDFSSETSERVERINFO(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NETRDFSSETSERVERINFO *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETRDFSSETSERVERINFO];

	r = talloc(talloc_tos(), struct srvsvc_NETRDFSSETSERVERINFO);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_IN_DEBUG(srvsvc_NETRDFSSETSERVERINFO, r);
	}

	r->out.result = _srvsvc_NETRDFSSETSERVERINFO(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NETRDFSSETSERVERINFO, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NETRDFSCREATEEXITPOINT(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NETRDFSCREATEEXITPOINT *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETRDFSCREATEEXITPOINT];

	r = talloc(talloc_tos(), struct srvsvc_NETRDFSCREATEEXITPOINT);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_IN_DEBUG(srvsvc_NETRDFSCREATEEXITPOINT, r);
	}

	r->out.result = _srvsvc_NETRDFSCREATEEXITPOINT(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NETRDFSCREATEEXITPOINT, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NETRDFSDELETEEXITPOINT(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NETRDFSDELETEEXITPOINT *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETRDFSDELETEEXITPOINT];

	r = talloc(talloc_tos(), struct srvsvc_NETRDFSDELETEEXITPOINT);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_IN_DEBUG(srvsvc_NETRDFSDELETEEXITPOINT, r);
	}

	r->out.result = _srvsvc_NETRDFSDELETEEXITPOINT(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NETRDFSDELETEEXITPOINT, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NETRDFSMODIFYPREFIX(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NETRDFSMODIFYPREFIX *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETRDFSMODIFYPREFIX];

	r = talloc(talloc_tos(), struct srvsvc_NETRDFSMODIFYPREFIX);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_IN_DEBUG(srvsvc_NETRDFSMODIFYPREFIX, r);
	}

	r->out.result = _srvsvc_NETRDFSMODIFYPREFIX(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NETRDFSMODIFYPREFIX, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NETRDFSFIXLOCALVOLUME(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NETRDFSFIXLOCALVOLUME *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETRDFSFIXLOCALVOLUME];

	r = talloc(talloc_tos(), struct srvsvc_NETRDFSFIXLOCALVOLUME);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_IN_DEBUG(srvsvc_NETRDFSFIXLOCALVOLUME, r);
	}

	r->out.result = _srvsvc_NETRDFSFIXLOCALVOLUME(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NETRDFSFIXLOCALVOLUME, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NETRDFSMANAGERREPORTSITEINFO(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NETRDFSMANAGERREPORTSITEINFO *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETRDFSMANAGERREPORTSITEINFO];

	r = talloc(talloc_tos(), struct srvsvc_NETRDFSMANAGERREPORTSITEINFO);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_IN_DEBUG(srvsvc_NETRDFSMANAGERREPORTSITEINFO, r);
	}

	r->out.result = _srvsvc_NETRDFSMANAGERREPORTSITEINFO(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NETRDFSMANAGERREPORTSITEINFO, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}

static bool api_srvsvc_NETRSERVERTRANSPORTDELEX(pipes_struct *p)
{
	const struct ndr_interface_call *call;
	struct ndr_pull *pull;
	struct ndr_push *push;
	enum ndr_err_code ndr_err;
	DATA_BLOB blob;
	struct srvsvc_NETRSERVERTRANSPORTDELEX *r;

	call = &ndr_table_srvsvc.calls[NDR_SRVSVC_NETRSERVERTRANSPORTDELEX];

	r = talloc(talloc_tos(), struct srvsvc_NETRSERVERTRANSPORTDELEX);
	if (r == NULL) {
		return false;
	}

	if (!prs_data_blob(&p->in_data.data, &blob, r)) {
		talloc_free(r);
		return false;
	}

	pull = ndr_pull_init_blob(&blob, r);
	if (pull == NULL) {
		talloc_free(r);
		return false;
	}

	pull->flags |= LIBNDR_FLAG_REF_ALLOC;
	ndr_err = call->ndr_pull(pull, NDR_IN, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_IN_DEBUG(srvsvc_NETRSERVERTRANSPORTDELEX, r);
	}

	r->out.result = _srvsvc_NETRSERVERTRANSPORTDELEX(p, r);

	if (p->rng_fault_state) {
		talloc_free(r);
		/* Return true here, srv_pipe_hnd.c will take care */
		return true;
	}

	if (DEBUGLVL(10)) {
		NDR_PRINT_OUT_DEBUG(srvsvc_NETRSERVERTRANSPORTDELEX, r);
	}

	push = ndr_push_init_ctx(r);
	if (push == NULL) {
		talloc_free(r);
		return false;
	}

	ndr_err = call->ndr_push(push, NDR_OUT, r);
	if (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {
		talloc_free(r);
		return false;
	}

	blob = ndr_push_blob(push);
	if (!prs_copy_data_in(&p->out_data.rdata, (const char *)blob.data, (uint32_t)blob.length)) {
		talloc_free(r);
		return false;
	}

	talloc_free(r);

	return true;
}
#endif

static bool api_srvsvc_NADA(pipes_struct *p)
{
	return false;
}

/* Tables */
static struct api_struct api_srvsvc_cmds[] = 
{
  {"SRVSVC_NETCHARDEVENUM", NDR_SRVSVC_NETCHARDEVENUM, api_srvsvc_NADA},
  {"SRVSVC_NETCHARDEVGETINFO", NDR_SRVSVC_NETCHARDEVGETINFO, api_srvsvc_NADA},
  {"SRVSVC_NETCHARDEVCONTROL", NDR_SRVSVC_NETCHARDEVCONTROL, api_srvsvc_NADA},
  {"SRVSVC_NETCHARDEVQENUM", NDR_SRVSVC_NETCHARDEVQENUM, api_srvsvc_NADA},
  {"SRVSVC_NETCHARDEVQGETINFO", NDR_SRVSVC_NETCHARDEVQGETINFO, api_srvsvc_NADA},
  {"SRVSVC_NETCHARDEVQSETINFO", NDR_SRVSVC_NETCHARDEVQSETINFO, api_srvsvc_NADA},
  {"SRVSVC_NETCHARDEVQPURGE", NDR_SRVSVC_NETCHARDEVQPURGE, api_srvsvc_NADA},
  {"SRVSVC_NETCHARDEVQPURGESELF", NDR_SRVSVC_NETCHARDEVQPURGESELF, api_srvsvc_NADA},
  {"SRVSVC_NETCONNENUM", NDR_SRVSVC_NETCONNENUM, api_srvsvc_NetConnEnum},
  {"SRVSVC_NETFILEENUM", NDR_SRVSVC_NETFILEENUM, api_srvsvc_NetFileEnum},
  {"SRVSVC_NETFILEGETINFO", NDR_SRVSVC_NETFILEGETINFO, api_srvsvc_NetFileGetInfo},
  {"SRVSVC_NETFILECLOSE", NDR_SRVSVC_NETFILECLOSE, api_srvsvc_NetFileClose},
  {"SRVSVC_NETSESSENUM", NDR_SRVSVC_NETSESSENUM, api_srvsvc_NetSessEnum},
  {"SRVSVC_NETSESSDEL", NDR_SRVSVC_NETSESSDEL, api_srvsvc_NetSessDel},
  {"SRVSVC_NETSHAREADD", NDR_SRVSVC_NETSHAREADD, api_srvsvc_NetShareAdd},
  {"SRVSVC_NETSHAREENUMALL", NDR_SRVSVC_NETSHAREENUMALL, api_srvsvc_NetShareEnumAll},
  {"SRVSVC_NETSHAREGETINFO", NDR_SRVSVC_NETSHAREGETINFO, api_srvsvc_NetShareGetInfo},
  {"SRVSVC_NETSHARESETINFO", NDR_SRVSVC_NETSHARESETINFO, api_srvsvc_NetShareSetInfo},
  {"SRVSVC_NETSHAREDEL", NDR_SRVSVC_NETSHAREDEL, api_srvsvc_NetShareDel},
  {"SRVSVC_NETSHAREDELSTICKY", NDR_SRVSVC_NETSHAREDELSTICKY, api_srvsvc_NetShareDelSticky},
  {"SRVSVC_NETSHARECHECK", NDR_SRVSVC_NETSHARECHECK, api_srvsvc_NetShareCheck},
  {"SRVSVC_NETSRVGETINFO", NDR_SRVSVC_NETSRVGETINFO, api_srvsvc_NetSrvGetInfo},
  {"SRVSVC_NETSRVSETINFO", NDR_SRVSVC_NETSRVSETINFO, api_srvsvc_NetSrvSetInfo},
  {"SRVSVC_NETDISKENUM", NDR_SRVSVC_NETDISKENUM, api_srvsvc_NetDiskEnum},
  {"SRVSVC_NETSERVERSTATISTICSGET", NDR_SRVSVC_NETSERVERSTATISTICSGET, api_srvsvc_NADA},
  {"SRVSVC_NETTRANSPORTADD", NDR_SRVSVC_NETTRANSPORTADD, api_srvsvc_NADA},
  {"SRVSVC_NETTRANSPORTENUM", NDR_SRVSVC_NETTRANSPORTENUM, api_srvsvc_NADA},
  {"SRVSVC_NETTRANSPORTDEL", NDR_SRVSVC_NETTRANSPORTDEL, api_srvsvc_NADA},
  {"SRVSVC_NETREMOTETOD", NDR_SRVSVC_NETREMOTETOD, api_srvsvc_NetRemoteTOD},
  {"SRVSVC_NETSETSERVICEBITS", NDR_SRVSVC_NETSETSERVICEBITS, api_srvsvc_NADA},
  {"SRVSVC_NETPATHTYPE", NDR_SRVSVC_NETPATHTYPE, api_srvsvc_NADA},
  {"SRVSVC_NETPATHCANONICALIZE", NDR_SRVSVC_NETPATHCANONICALIZE, api_srvsvc_NADA},
  {"SRVSVC_NETPATHCOMPARE", NDR_SRVSVC_NETPATHCOMPARE, api_srvsvc_NADA},
  {"SRVSVC_NETNAMEVALIDATE", NDR_SRVSVC_NETNAMEVALIDATE, api_srvsvc_NetNameValidate},
  {"SRVSVC_NETRPRNAMECANONICALIZE", NDR_SRVSVC_NETRPRNAMECANONICALIZE, api_srvsvc_NADA},
  {"SRVSVC_NETPRNAMECOMPARE", NDR_SRVSVC_NETPRNAMECOMPARE, api_srvsvc_NADA},
  {"SRVSVC_NETSHAREENUM", NDR_SRVSVC_NETSHAREENUM, api_srvsvc_NADA},
  {"SRVSVC_NETSHAREDELSTART", NDR_SRVSVC_NETSHAREDELSTART, api_srvsvc_NADA},
  {"SRVSVC_NETSHAREDELCOMMIT", NDR_SRVSVC_NETSHAREDELCOMMIT, api_srvsvc_NADA},
  {"SRVSVC_NETGETFILESECURITY", NDR_SRVSVC_NETGETFILESECURITY, api_srvsvc_NetGetFileSecurity},
  {"SRVSVC_NETSETFILESECURITY", NDR_SRVSVC_NETSETFILESECURITY, api_srvsvc_NetSetFileSecurity},
  {"SRVSVC_NETSERVERTRANSPORTADDEX", NDR_SRVSVC_NETSERVERTRANSPORTADDEX, api_srvsvc_NADA},
  {"SRVSVC_NETSERVERSETSERVICEBITSEX", NDR_SRVSVC_NETSERVERSETSERVICEBITSEX, api_srvsvc_NADA},
  {"SRVSVC_NETRDFSGETVERSION", NDR_SRVSVC_NETRDFSGETVERSION, api_srvsvc_NADA},
  {"SRVSVC_NETRDFSCREATELOCALPARTITION", NDR_SRVSVC_NETRDFSCREATELOCALPARTITION, api_srvsvc_NADA},
  {"SRVSVC_NETRDFSDELETELOCALPARTITION", NDR_SRVSVC_NETRDFSDELETELOCALPARTITION, api_srvsvc_NADA},
  {"SRVSVC_NETRDFSSETLOCALVOLUMESTATE", NDR_SRVSVC_NETRDFSSETLOCALVOLUMESTATE, api_srvsvc_NADA},
  {"SRVSVC_NETRDFSSETSERVERINFO", NDR_SRVSVC_NETRDFSSETSERVERINFO, api_srvsvc_NADA},
  {"SRVSVC_NETRDFSCREATEEXITPOINT", NDR_SRVSVC_NETRDFSCREATEEXITPOINT, api_srvsvc_NADA},
  {"SRVSVC_NETRDFSDELETEEXITPOINT", NDR_SRVSVC_NETRDFSDELETEEXITPOINT, api_srvsvc_NADA},
  {"SRVSVC_NETRDFSMODIFYPREFIX", NDR_SRVSVC_NETRDFSMODIFYPREFIX, api_srvsvc_NADA},
  {"SRVSVC_NETRDFSFIXLOCALVOLUME", NDR_SRVSVC_NETRDFSFIXLOCALVOLUME, api_srvsvc_NADA},
  {"SRVSVC_NETRDFSMANAGERREPORTSITEINFO", NDR_SRVSVC_NETRDFSMANAGERREPORTSITEINFO, api_srvsvc_NADA},
  {"SRVSVC_NETRSERVERTRANSPORTDELEX", NDR_SRVSVC_NETRSERVERTRANSPORTDELEX, api_srvsvc_NADA},
};

void srvsvc_get_pipe_fns(struct api_struct **fns, int *n_fns)
{
	*fns = api_srvsvc_cmds;
	*n_fns = sizeof(api_srvsvc_cmds) / sizeof(struct api_struct);
}

NTSTATUS rpc_srvsvc_init(void)
{
	return rpc_pipe_register_commands(SMB_RPC_INTERFACE_VERSION, "srvsvc", "srvsvc", api_srvsvc_cmds, sizeof(api_srvsvc_cmds) / sizeof(struct api_struct));
}
