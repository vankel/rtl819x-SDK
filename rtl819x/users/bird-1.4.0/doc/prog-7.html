<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 1.0.9">
 <TITLE>BIRD Programmer's Documentation: Library functions</TITLE>
 <LINK HREF="prog-8.html" REL=next>
 <LINK HREF="prog-6.html" REL=previous>
 <LINK HREF="prog.html#toc7" REL=contents>
</HEAD>
<BODY>
<A HREF="prog-8.html">Next</A>
<A HREF="prog-6.html">Previous</A>
<A HREF="prog.html#toc7">Contents</A>
<HR>
<H2><A NAME="s7">7.</A> <A HREF="prog.html#toc7">Library functions</A></H2>

<H2><A NAME="ss7.1">7.1</A> <A HREF="prog.html#toc7.1">IP addresses</A>
</H2>

<P>
<P>BIRD uses its own abstraction of IP address in order to share the same
code for both IPv4 and IPv6. IP addresses are represented as entities
of type <I>ip_addr</I> which are never to be treated as numbers and instead
they must be manipulated using the following functions and macros.
<P>
<P><HR><H3>Function</H3>
<P><I>char *</I>
<B>ip_scope_text</B>
(<I>unsigned</I> <B>scope</B>) --     get textual representation of address scope
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>unsigned</I> <B>scope</B><DD><P>scope (<I>SCOPE_xxx</I>)
</DL>
<H3>Description</H3>
<P>Returns a pointer to a textual name of the scope given.


<HR><H3>Function</H3>
<P><I>int</I>
<B>ipa_equal</B>
(<I>ip_addr</I> <B>x</B>, <I>ip_addr</I> <B>y</B>) --     compare two IP addresses for equality
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>ip_addr</I> <B>x</B><DD><P>IP address
<DT><I>ip_addr</I> <B>y</B><DD><P>IP address
</DL>
<H3>Description</H3>
<P><B>ipa_equal()</B> returns 1 if <B>x</B> and <B>y</B> represent the same IP address, else 0.


<HR><H3>Function</H3>
<P><I>int</I>
<B>ipa_nonzero</B>
(<I>ip_addr</I> <B>x</B>) --     test if an IP address is defined
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>ip_addr</I> <B>x</B><DD><P>IP address
</DL>
<H3>Description</H3>
<P>ipa_nonzero returns 1 if <B>x</B> is a defined IP address (not all bits are zero),
else 0.
<P>The undefined all-zero address is reachable as a <CODE>IPA_NONE</CODE> macro.


<HR><H3>Function</H3>
<P><I>ip_addr</I>
<B>ipa_and</B>
(<I>ip_addr</I> <B>x</B>, <I>ip_addr</I> <B>y</B>) --     compute bitwise and of two IP addresses
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>ip_addr</I> <B>x</B><DD><P>IP address
<DT><I>ip_addr</I> <B>y</B><DD><P>IP address
</DL>
<H3>Description</H3>
<P>This function returns a bitwise and of <B>x</B> and <B>y</B>. It's primarily
used for network masking.


<HR><H3>Function</H3>
<P><I>ip_addr</I>
<B>ipa_or</B>
(<I>ip_addr</I> <B>x</B>, <I>ip_addr</I> <B>y</B>) --     compute bitwise or of two IP addresses
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>ip_addr</I> <B>x</B><DD><P>IP address
<DT><I>ip_addr</I> <B>y</B><DD><P>IP address
</DL>
<H3>Description</H3>
<P>This function returns a bitwise or of <B>x</B> and <B>y</B>.


<HR><H3>Function</H3>
<P><I>ip_addr</I>
<B>ipa_xor</B>
(<I>ip_addr</I> <B>x</B>, <I>ip_addr</I> <B>y</B>) --     compute bitwise xor of two IP addresses
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>ip_addr</I> <B>x</B><DD><P>IP address
<DT><I>ip_addr</I> <B>y</B><DD><P>IP address
</DL>
<H3>Description</H3>
<P>This function returns a bitwise xor of <B>x</B> and <B>y</B>.


<HR><H3>Function</H3>
<P><I>ip_addr</I>
<B>ipa_not</B>
(<I>ip_addr</I> <B>x</B>) --     compute bitwise negation of two IP addresses
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>ip_addr</I> <B>x</B><DD><P>IP address
</DL>
<H3>Description</H3>
<P>This function returns a bitwise negation of <B>x</B>.


<HR><H3>Function</H3>
<P><I>ip_addr</I>
<B>ipa_mkmask</B>
(<I>int</I> <B>x</B>) --     create a netmask
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>int</I> <B>x</B><DD><P>prefix length
</DL>
<H3>Description</H3>
<P>This function returns an <I>ip_addr</I> corresponding of a netmask
of an address prefix of size <B>x</B>.


<HR><H3>Function</H3>
<P><I>int</I>
<B>ipa_mklen</B>
(<I>ip_addr</I> <B>x</B>) --     calculate netmask length
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>ip_addr</I> <B>x</B><DD><P>IP address
</DL>
<H3>Description</H3>
<P>This function checks whether <B>x</B> represents a valid netmask and
returns the size of the associate network prefix or -1 for invalid
mask.


<HR><H3>Function</H3>
<P><I>int</I>
<B>ipa_hash</B>
(<I>ip_addr</I> <B>x</B>) --     hash IP addresses
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>ip_addr</I> <B>x</B><DD><P>IP address
</DL>
<H3>Description</H3>
<P><B>ipa_hash()</B> returns a 16-bit hash value of the IP address <B>x</B>.


<HR><H3>Function</H3>
<P><I>void</I>
<B>ipa_hton</B>
(<I>ip_addr</I> <B>x</B>) --     convert IP address to network order
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>ip_addr</I> <B>x</B><DD><P>IP address
</DL>
<H3>Description</H3>
<P>Converts the IP address <B>x</B> to the network byte order.
<P>Beware, this is a macro and it alters the argument!


<HR><H3>Function</H3>
<P><I>void</I>
<B>ipa_ntoh</B>
(<I>ip_addr</I> <B>x</B>) --     convert IP address to host order
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>ip_addr</I> <B>x</B><DD><P>IP address
</DL>
<H3>Description</H3>
<P>Converts the IP address <B>x</B> from the network byte order.
<P>Beware, this is a macro and it alters the argument!


<HR><H3>Function</H3>
<P><I>int</I>
<B>ipa_classify</B>
(<I>ip_addr</I> <B>x</B>) --     classify an IP address
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>ip_addr</I> <B>x</B><DD><P>IP address
</DL>
<H3>Description</H3>
<P><B>ipa_classify()</B> returns an address class of <B>x</B>, that is a bitwise or
of address type (<I>IADDR_INVALID</I>, <I>IADDR_HOST</I>, <I>IADDR_BROADCAST</I>, <I>IADDR_MULTICAST</I>)
with address scope (<I>SCOPE_HOST</I> to <I>SCOPE_UNIVERSE</I>) or -1 (<I>IADDR_INVALID</I>)
for an invalid address.


<HR><H3>Function</H3>
<P><I>ip_addr</I>
<B>ipa_class_mask</B>
(<I>ip_addr</I> <B>x</B>) --     guess netmask according to address class
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>ip_addr</I> <B>x</B><DD><P>IP address
</DL>
<H3>Description</H3>
<P>This function (available in IPv4 version only) returns a
network mask according to the address class of <B>x</B>. Although
classful addressing is nowadays obsolete, there still live
routing protocols transferring no prefix lengths nor netmasks
and this function could be useful to them.


<HR><H3>Function</H3>
<P><I>u32</I>
<B>ipa_from_u32</B>
(<I>ip_addr</I> <B>x</B>) --     convert IPv4 address to an integer
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>ip_addr</I> <B>x</B><DD><P>IP address
</DL>
<H3>Description</H3>
<P>This function takes an IPv4 address and returns its numeric
representation.


<HR><H3>Function</H3>
<P><I>ip_addr</I>
<B>ipa_to_u32</B>
(<I>u32</I> <B>x</B>) --     convert integer to IPv4 address
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>u32</I> <B>x</B><DD><P>a 32-bit integer
</DL>
<H3>Description</H3>
<P><B>ipa_to_u32()</B> takes a numeric representation of an IPv4 address
and converts it to the corresponding <I>ip_addr</I>.


<HR><H3>Function</H3>
<P><I>int</I>
<B>ipa_compare</B>
(<I>ip_addr</I> <B>x</B>, <I>ip_addr</I> <B>y</B>) --     compare two IP addresses for order
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>ip_addr</I> <B>x</B><DD><P>IP address
<DT><I>ip_addr</I> <B>y</B><DD><P>IP address
</DL>
<H3>Description</H3>
<P>The <B>ipa_compare()</B> function takes two IP addresses and returns
-1 if <B>x</B> is less than <B>y</B> in canonical ordering (lexicographical
order of the bit strings), 1 if <B>x</B> is greater than <B>y</B> and 0
if they are the same.


<HR><H3>Function</H3>
<P><I>ip_addr</I>
<B>ipa_build</B>
(<I>u32</I> <B>a1</B>, <I>u32</I> <B>a2</B>, <I>u32</I> <B>a3</B>, <I>u32</I> <B>a4</B>) --     build an IPv6 address from parts
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>u32</I> <B>a1</B><DD><P>part #1
<DT><I>u32</I> <B>a2</B><DD><P>part #2
<DT><I>u32</I> <B>a3</B><DD><P>part #3
<DT><I>u32</I> <B>a4</B><DD><P>part #4
</DL>
<H3>Description</H3>
<P><B>ipa_build()</B> takes <B>a1</B> to <B>a4</B> and assembles them to a single IPv6
address. It's used for example when a protocol wants to bind its
socket to a hard-wired multicast address.


<HR><H3>Function</H3>
<P><I>ip_addr</I>
<B>ipa_absolutize</B>
(<I>ip_addr</I> <B>x</B>, <I>ip_addr</I> <B>y</B>) --     convert link scope IPv6 address to universe scope
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>ip_addr</I> <B>x</B><DD><P>link scope IPv6 address
<DT><I>ip_addr</I> <B>y</B><DD><P>universe scope IPv6 prefix of the interface
</DL>
<H3>Description</H3>
<P>This function combines a link-scope IPv6 address <B>x</B> with the universe
scope prefix <B>x</B> of the network assigned to an interface to get a
universe scope form of <B>x</B>.


<HR><H3>Function</H3>
<P><I>char *</I>
<B>ip_ntop</B>
(<I>ip_addr</I> <B>a</B>, <I>char *</I> <B>buf</B>) --     convert IP address to textual representation
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>ip_addr</I> <B>a</B><DD><P>IP address
<DT><I>char *</I> <B>buf</B><DD><P>buffer of size at least <I>STD_ADDRESS_P_LENGTH</I>
</DL>
<H3>Description</H3>
<P>This function takes an IP address and creates its textual
representation for presenting to the user.


<HR><H3>Function</H3>
<P><I>char *</I>
<B>ip_ntox</B>
(<I>ip_addr</I> <B>a</B>, <I>char *</I> <B>buf</B>) --     convert IP address to hexadecimal representation
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>ip_addr</I> <B>a</B><DD><P>IP address
<DT><I>char *</I> <B>buf</B><DD><P>buffer of size at least <I>STD_ADDRESS_P_LENGTH</I>
</DL>
<H3>Description</H3>
<P>This function takes an IP address and creates its hexadecimal
textual representation. Primary use: debugging dumps.


<HR><H3>Function</H3>
<P><I>int</I>
<B>ip_pton</B>
(<I>char *</I> <B>a</B>, <I>ip_addr *</I> <B>o</B>) --     parse textual representation of IP address
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>char *</I> <B>a</B><DD><P>textual representation
<DT><I>ip_addr *</I> <B>o</B><DD><P>where to put the resulting address
</DL>
<H3>Description</H3>
<P>This function parses a textual IP address representation and
stores the decoded address to a variable pointed to by <B>o</B>.
Returns 0 if a parse error has occurred, else 0.

<H2><A NAME="ss7.2">7.2</A> <A HREF="prog.html#toc7.2">Linked lists</A>
</H2>

<P>
<P>The BIRD library provides a set of functions for operating on linked
lists. The lists are internally represented as standard doubly linked
lists with synthetic head and tail which makes all the basic operations
run in constant time and contain no extra end-of-list checks. Each list
is described by a <I>list</I> structure, nodes can have any format as long
as they start with a <I>node</I> structure. If you want your nodes to belong
to multiple lists at once, you can embed multiple <I>node</I> structures in them
and use the <B>SKIP_BACK()</B> macro to calculate a pointer to the start of the
structure from a <I>node</I> pointer, but beware of obscurity.
<P>There also exist safe linked lists (<I>slist</I>, <I>snode</I> and all functions
being prefixed with <CODE>s_</CODE>) which support asynchronous walking very
similar to that used in the <I>fib</I> structure.
<P>
<P><HR><H3>Function</H3>
<P><I>LIST_INLINE void</I>
<B>add_tail</B>
(<I>list *</I> <B>l</B>, <I>node *</I> <B>n</B>) --     append a node to a list
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>list *</I> <B>l</B><DD><P>linked list
<DT><I>node *</I> <B>n</B><DD><P>list node
</DL>
<H3>Description</H3>
<P><B>add_tail()</B> takes a node <B>n</B> and appends it at the end of the list <B>l</B>.


<HR><H3>Function</H3>
<P><I>LIST_INLINE void</I>
<B>add_head</B>
(<I>list *</I> <B>l</B>, <I>node *</I> <B>n</B>) --     prepend a node to a list
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>list *</I> <B>l</B><DD><P>linked list
<DT><I>node *</I> <B>n</B><DD><P>list node
</DL>
<H3>Description</H3>
<P><B>add_head()</B> takes a node <B>n</B> and prepends it at the start of the list <B>l</B>.


<HR><H3>Function</H3>
<P><I>LIST_INLINE void</I>
<B>insert_node</B>
(<I>node *</I> <B>n</B>, <I>node *</I> <B>after</B>) --     insert a node to a list
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>node *</I> <B>n</B><DD><P>a new list node
<DT><I>node *</I> <B>after</B><DD><P>a node of a list
</DL>
<H3>Description</H3>
<P>Inserts a node <B>n</B> to a linked list after an already inserted
node <B>after</B>.


<HR><H3>Function</H3>
<P><I>LIST_INLINE void</I>
<B>rem_node</B>
(<I>node *</I> <B>n</B>) --     remove a node from a list
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>node *</I> <B>n</B><DD><P>node to be removed
</DL>
<H3>Description</H3>
<P>Removes a node <B>n</B> from the list it's linked in.


<HR><H3>Function</H3>
<P><I>LIST_INLINE void</I>
<B>rem2_node</B>
(<I>node *</I> <B>n</B>) --     remove a node from a list, with cleanup
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>node *</I> <B>n</B><DD><P>node to be removed
</DL>
<H3>Description</H3>
<P>Removes a node <B>n</B> from the list it's linked in and resets its pointers to NULL.
Useful if you want to distinguish between linked and unlinked nodes.


<HR><H3>Function</H3>
<P><I>LIST_INLINE void</I>
<B>replace_node</B>
(<I>node *</I> <B>old</B>, <I>node *</I> <B>new</B>) --     replace a node in a list with another one
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>node *</I> <B>old</B><DD><P>node to be removed
<DT><I>node *</I> <B>new</B><DD><P>node to be inserted
</DL>
<H3>Description</H3>
<P>Replaces node <B>old</B> in the list it's linked in with node <B>new</B>.  Node
<B>old</B> may be a copy of the original node, which is not accessed
through the list. The function could be called with <B>old</B> == <B>new</B>,
which just fixes neighbors' pointers in the case that the node
was reallocated.


<HR><H3>Function</H3>
<P><I>LIST_INLINE void</I>
<B>init_list</B>
(<I>list *</I> <B>l</B>) --     create an empty list
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>list *</I> <B>l</B><DD><P>list
</DL>
<H3>Description</H3>
<P><B>init_list()</B> takes a <I>list</I> structure and initializes its
fields, so that it represents an empty list.


<HR><H3>Function</H3>
<P><I>LIST_INLINE void</I>
<B>add_tail_list</B>
(<I>list *</I> <B>to</B>, <I>list *</I> <B>l</B>) --     concatenate two lists
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>list *</I> <B>to</B><DD><P>destination list
<DT><I>list *</I> <B>l</B><DD><P>source list
</DL>
<H3>Description</H3>
<P>This function appends all elements of the list <B>l</B> to
the list <B>to</B> in constant time.

<H2><A NAME="ss7.3">7.3</A> <A HREF="prog.html#toc7.3">Miscellaneous functions.</A>
</H2>

<P>
<P>
<P><HR><H3>Function</H3>
<P><I>int</I>
<B>ipsum_verify</B>
(<I>void *</I> <B>frag</B>, <I>unsigned</I> <B>len</B>, <I>...</I> <B>...</B>) --     verify an IP checksum
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>void *</I> <B>frag</B><DD><P>first packet fragment
<DT><I>unsigned</I> <B>len</B><DD><P>length in bytes
<DT><I>...</I> <B>...</B><DD><P>variable arguments
</DL>
<H3>Description</H3>
<P>This function verifies whether a given fragmented packet
has correct one's complement checksum as used by the IP
protocol.
<P>It uses all the clever tricks described in RFC 1071 to speed
up checksum calculation as much as possible.
<H3>Result</H3>
<P>1 if the checksum is correct, 0 else.


<HR><H3>Function</H3>
<P><I>u16</I>
<B>ipsum_calculate</B>
(<I>void *</I> <B>frag</B>, <I>unsigned</I> <B>len</B>, <I>...</I> <B>...</B>) --     compute an IP checksum
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>void *</I> <B>frag</B><DD><P>first packet fragment
<DT><I>unsigned</I> <B>len</B><DD><P>length in bytes
<DT><I>...</I> <B>...</B><DD><P>variable arguments
</DL>
<H3>Description</H3>
<P>This function calculates a one's complement checksum of a given fragmented
packet.
<P>It uses all the clever tricks described in RFC 1071 to speed
up checksum calculation as much as possible.


<HR><H3>Function</H3>
<P><I>u32</I>
<B>u32_mkmask</B>
(<I>unsigned</I> <B>n</B>) --     create a bit mask
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>unsigned</I> <B>n</B><DD><P>number of bits
</DL>
<H3>Description</H3>
<P><B>u32_mkmask()</B> returns an unsigned 32-bit integer which binary
representation consists of <B>n</B> ones followed by zeroes.


<HR><H3>Function</H3>
<P><I>int</I>
<B>u32_masklen</B>
(<I>u32</I> <B>x</B>) --     calculate length of a bit mask
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>u32</I> <B>x</B><DD><P>bit mask
</DL>
<H3>Description</H3>
<P>This function checks whether the given integer <B>x</B> represents
a valid bit mask (binary representation contains first ones, then
zeroes) and returns the number of ones or -1 if the mask is invalid.


<HR><H3>Function</H3>
<P><I>u32</I>
<B>u32_log2</B>
(<I>u32</I> <B>v</B>) --     compute a binary logarithm.
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>u32</I> <B>v</B><DD><P>number
</DL>
<H3>Description</H3>
<P>This function computes a integral part of binary logarithm of given
integer <B>v</B> and returns it. The computed value is also an index of the
most significant non-zero bit position.


<HR><H3>Function</H3>
<P><I>int</I>
<B>patmatch</B>
(<I>byte *</I> <B>p</B>, <I>byte *</I> <B>s</B>) --     match shell-like patterns
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>byte *</I> <B>p</B><DD><P>pattern
<DT><I>byte *</I> <B>s</B><DD><P>string
</DL>
<H3>Description</H3>
<P><B>patmatch()</B> returns whether given string <B>s</B> matches the given shell-like
pattern <B>p</B>. The patterns consist of characters (which are matched literally),
question marks which match any single character, asterisks which match any
(possibly empty) string of characters and backslashes which are used to
escape any special characters and force them to be treated literally.
<P>The matching process is not optimized with respect to time, so please
avoid using this function for complex patterns.


<HR><H3>Function</H3>
<P><I>int</I>
<B>bvsnprintf</B>
(<I>char *</I> <B>buf</B>, <I>int</I> <B>size</B>, <I>const char *</I> <B>fmt</B>, <I>va_list</I> <B>args</B>) --     BIRD's <B>vsnprintf()</B>
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>char *</I> <B>buf</B><DD><P>destination buffer
<DT><I>int</I> <B>size</B><DD><P>size of the buffer
<DT><I>const char *</I> <B>fmt</B><DD><P>format string
<DT><I>va_list</I> <B>args</B><DD><P>a list of arguments to be formatted
</DL>
<H3>Description</H3>
<P>This functions acts like ordinary <B>sprintf()</B> except that it checks
available space to avoid buffer overflows and it allows some more
<H3>format specifiers</H3>
<P><CODE><I>I</I></CODE> for formatting of IP addresses (any non-zero
width is automatically replaced by standard IP address width which
depends on whether we use IPv4 or IPv6; <CODE>%#I</CODE> gives hexadecimal format),
<CODE><I>R</I></CODE> for Router / Network ID (u32 value printed as IPv4 address)
and <CODE><I>m</I></CODE> resp. <CODE><I>M</I></CODE> for error messages (uses <B>strerror()</B> to translate <B>errno</B> code to
message text). On the other hand, it doesn't support floating
point numbers.
<H3>Result</H3>
<P>number of characters of the output string or -1 if
the buffer space was insufficient.


<HR><H3>Function</H3>
<P><I>int</I>
<B>bvsprintf</B>
(<I>char *</I> <B>buf</B>, <I>const char *</I> <B>fmt</B>, <I>va_list</I> <B>args</B>) --     BIRD's <B>vsprintf()</B>
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>char *</I> <B>buf</B><DD><P>buffer
<DT><I>const char *</I> <B>fmt</B><DD><P>format string
<DT><I>va_list</I> <B>args</B><DD><P>a list of arguments to be formatted
</DL>
<H3>Description</H3>
<P>This function is equivalent to <B>bvsnprintf()</B> with an infinite
buffer size. Please use carefully only when you are absolutely
sure the buffer won't overflow.


<HR><H3>Function</H3>
<P><I>int</I>
<B>bsprintf</B>
(<I>char *</I> <B>buf</B>, <I>const char *</I> <B>fmt</B>, <I>...</I> <B>...</B>) --     BIRD's <B>sprintf()</B>
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>char *</I> <B>buf</B><DD><P>buffer
<DT><I>const char *</I> <B>fmt</B><DD><P>format string
<DT><I>...</I> <B>...</B><DD><P>variable arguments
</DL>
<H3>Description</H3>
<P>This function is equivalent to <B>bvsnprintf()</B> with an infinite
buffer size and variable arguments instead of a <I>va_list</I>.
Please use carefully only when you are absolutely
sure the buffer won't overflow.


<HR><H3>Function</H3>
<P><I>int</I>
<B>bsnprintf</B>
(<I>char *</I> <B>buf</B>, <I>int</I> <B>size</B>, <I>const char *</I> <B>fmt</B>, <I>...</I> <B>...</B>) --     BIRD's <B>snprintf()</B>
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>char *</I> <B>buf</B><DD><P>buffer
<DT><I>int</I> <B>size</B><DD><P>buffer size
<DT><I>const char *</I> <B>fmt</B><DD><P>format string
<DT><I>...</I> <B>...</B><DD><P>variable arguments
</DL>
<H3>Description</H3>
<P>This function is equivalent to <B>bsnprintf()</B> with variable arguments instead of a <I>va_list</I>.


<HR><H3>Function</H3>
<P><I>void *</I>
<B>xmalloc</B>
(<I>unsigned</I> <B>size</B>) --     malloc with checking
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>unsigned</I> <B>size</B><DD><P>block size
</DL>
<H3>Description</H3>
<P>This function is equivalent to <B>malloc()</B> except that in case of
failure it calls <B>die()</B> to quit the program instead of returning
a <I>NULL</I> pointer.
<P>Wherever possible, please use the memory resources instead.


<HR><H3>Function</H3>
<P><I>void *</I>
<B>xrealloc</B>
(<I>void *</I> <B>ptr</B>, <I>unsigned</I> <B>size</B>) --     realloc with checking
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>void *</I> <B>ptr</B><DD><P>original memory block
<DT><I>unsigned</I> <B>size</B><DD><P>block size
</DL>
<H3>Description</H3>
<P>This function is equivalent to <B>realloc()</B> except that in case of
failure it calls <B>die()</B> to quit the program instead of returning
a <I>NULL</I> pointer.
<P>Wherever possible, please use the memory resources instead.

<P>
<HR>
<A HREF="prog-8.html">Next</A>
<A HREF="prog-6.html">Previous</A>
<A HREF="prog.html#toc7">Contents</A>
</BODY>
</HTML>
