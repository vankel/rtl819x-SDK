/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf 17851 2009-11-30 16:46:06Z dts12 $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "ieee802dot11.h"

/*HF Add*/
#include "apmib.h"
#include "mibtbl.h"
#include <unistd.h>
#include <netinet/in.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <signal.h>
#include <fcntl.h>
#include <errno.h>
#include <linux/wireless.h>
#include <linux/if_arp.h>
#include <linux/if_ether.h>
#include <linux/if_packet.h>
#include <time.h>
#include <sys/time.h>

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#ifndef NETSNMP_OLDAPI_RONLY
#define NETSNMP_OLDAPI_RONLY RONLY
#endif

#ifndef NETSNMP_OLDAPI_RWRITE
#define NETSNMP_OLDAPI_RWRITE RWRITE
#endif

#define TABLE_SIZE 1

#define VAR ulong_ret
#define VALUE ulong_ret

/*HF Add End*/

/*
 * ieee802dot11_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             ieee802dot11_variables_oid[] = { 1, 2, 840, 10036 };

/*
 * variable4 ieee802dot11_variables:
 *   this variable defines function callbacks and type return information 
 *   for the ieee802dot11 mib section 
 */

struct variable4 ieee802dot11_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L, oidsuffix 
     */
#define DOT11RESOURCETYPEIDNAME		1
    {DOT11RESOURCETYPEIDNAME, ASN_OCTET_STR, NETSNMP_OLDAPI_RONLY,
     var_ieee802dot11, 3, {3, 1, 1}},

#define DOT11STATIONID		1
    {DOT11STATIONID, ASN_OCTET_STR, NETSNMP_OLDAPI_RWRITE,
     var_dot11StationConfigTable, 4, {1, 1, 1, 1}},
#define DOT11MEDIUMOCCUPANCYLIMIT		2
    {DOT11MEDIUMOCCUPANCYLIMIT, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11StationConfigTable, 4, {1, 1, 1, 2}},
#define DOT11CFPOLLABLE		3
    {DOT11CFPOLLABLE, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_dot11StationConfigTable, 4, {1, 1, 1, 3}},
#define DOT11CFPPERIOD		4
    {DOT11CFPPERIOD, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11StationConfigTable, 4, {1, 1, 1, 4}},
#define DOT11CFPMAXDURATION		5
    {DOT11CFPMAXDURATION, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11StationConfigTable, 4, {1, 1, 1, 5}},
#define DOT11AUTHENTICATIONRESPONSETIMEOUT		6
    {DOT11AUTHENTICATIONRESPONSETIMEOUT, ASN_UNSIGNED,
     NETSNMP_OLDAPI_RWRITE,
     var_dot11StationConfigTable, 4, {1, 1, 1, 6}},
#define DOT11PRIVACYOPTIONIMPLEMENTED		7
    {DOT11PRIVACYOPTIONIMPLEMENTED, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_dot11StationConfigTable, 4, {1, 1, 1, 7}},
#define DOT11POWERMANAGEMENTMODE		8
    {DOT11POWERMANAGEMENTMODE, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11StationConfigTable, 4, {1, 1, 1, 8}},
#define DOT11DESIREDSSID		9
    {DOT11DESIREDSSID, ASN_OCTET_STR, NETSNMP_OLDAPI_RWRITE,
     var_dot11StationConfigTable, 4, {1, 1, 1, 9}},
#define DOT11DESIREDBSSTYPE		10
    {DOT11DESIREDBSSTYPE, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11StationConfigTable, 4, {1, 1, 1, 10}},
#define DOT11OPERATIONALRATESET		11
    {DOT11OPERATIONALRATESET, ASN_OCTET_STR, NETSNMP_OLDAPI_RWRITE,
     var_dot11StationConfigTable, 4, {1, 1, 1, 11}},
#define DOT11BEACONPERIOD		12
    {DOT11BEACONPERIOD, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11StationConfigTable, 4, {1, 1, 1, 12}},
#define DOT11DTIMPERIOD		13
    {DOT11DTIMPERIOD, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11StationConfigTable, 4, {1, 1, 1, 13}},
#define DOT11ASSOCIATIONRESPONSETIMEOUT		14
    {DOT11ASSOCIATIONRESPONSETIMEOUT, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_dot11StationConfigTable, 4, {1, 1, 1, 14}},
#define DOT11DISASSOCIATEREASON		15
    {DOT11DISASSOCIATEREASON, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_dot11StationConfigTable, 4, {1, 1, 1, 15}},
#define DOT11DISASSOCIATESTATION		16
    {DOT11DISASSOCIATESTATION, ASN_OCTET_STR, NETSNMP_OLDAPI_RONLY,
     var_dot11StationConfigTable, 4, {1, 1, 1, 16}},
#define DOT11DEAUTHENTICATEREASON		17
    {DOT11DEAUTHENTICATEREASON, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_dot11StationConfigTable, 4, {1, 1, 1, 17}},
#define DOT11DEAUTHENTICATESTATION		18
    {DOT11DEAUTHENTICATESTATION, ASN_OCTET_STR, NETSNMP_OLDAPI_RONLY,
     var_dot11StationConfigTable, 4, {1, 1, 1, 18}},
#define DOT11AUTHENTICATEFAILSTATUS		19
    {DOT11AUTHENTICATEFAILSTATUS, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_dot11StationConfigTable, 4, {1, 1, 1, 19}},
#define DOT11AUTHENTICATEFAILSTATION		20
    {DOT11AUTHENTICATEFAILSTATION, ASN_OCTET_STR, NETSNMP_OLDAPI_RONLY,
     var_dot11StationConfigTable, 4, {1, 1, 1, 20}},
#define DOT11MULTIDOMAINCAPABILITYIMPLEMENTED		21
    {DOT11MULTIDOMAINCAPABILITYIMPLEMENTED, ASN_INTEGER,
     NETSNMP_OLDAPI_RWRITE,
     var_dot11StationConfigTable, 4, {1, 1, 1, 21}},
#define DOT11MULTIDOMAINCAPABILITYENABLED		22
    {DOT11MULTIDOMAINCAPABILITYENABLED, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11StationConfigTable, 4, {1, 1, 1, 22}},
#define DOT11COUNTRYSTRING		23
    {DOT11COUNTRYSTRING, ASN_OCTET_STR, NETSNMP_OLDAPI_RONLY,
     var_dot11StationConfigTable, 4, {1, 1, 1, 23}},
#define DOT11REGDOMAIN		24
    {DOT11REGDOMAIN, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11StationConfigTable, 4, {1, 1, 1, 24}},
#define DOT11DATARATE		25
    {DOT11DATARATE, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11StationConfigTable, 4, {1, 1, 1, 25}},
#define DOT11PROTECTIONDISABLED		26
    {DOT11PROTECTIONDISABLED, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11StationConfigTable, 4, {1, 1, 1, 26}},
#define DOT11NSTBC		27
    {DOT11NSTBC, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11StationConfigTable, 4, {1, 1, 1, 27}},
#define DOT11NCOEXIST		28
    {DOT11NCOEXIST, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11StationConfigTable, 4, {1, 1, 1, 28}},
#define DOT11NUSE40M		29
    {DOT11NUSE40M, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11StationConfigTable, 4, {1, 1, 1, 29}},
#define DOT11N2NDCHOFFSET		30
    {DOT11N2NDCHOFFSET, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11StationConfigTable, 4, {1, 1, 1, 30}},
#define DOT11NSHORTGIFOR20M		31
    {DOT11NSHORTGIFOR20M, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11StationConfigTable, 4, {1, 1, 1, 31}},
#define DOT11NSHORTGIFOR40M		32
    {DOT11NSHORTGIFOR40M, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11StationConfigTable, 4, {1, 1, 1, 32}},
#define DOT11NAMPDU		33
    {DOT11NAMPDU, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11StationConfigTable, 4, {1, 1, 1, 33}},
#define DOT11NAMSDU		34
    {DOT11NAMSDU, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11StationConfigTable, 4, {1, 1, 1, 34}},
#define DOT11AUTHENTICATIONALGORITHMSINDEX		1
    {DOT11AUTHENTICATIONALGORITHMSINDEX, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_dot11AuthenticationAlgorithmsTable, 4, {1, 2, 1, 1}},
#define DOT11AUTHENTICATIONALGORITHM		2
    {DOT11AUTHENTICATIONALGORITHM, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_dot11AuthenticationAlgorithmsTable, 4, {1, 2, 1, 2}},
#define DOT11AUTHENTICATIONALGORITHMSENABLE		3
    {DOT11AUTHENTICATIONALGORITHMSENABLE, ASN_INTEGER,
     NETSNMP_OLDAPI_RWRITE,
     var_dot11AuthenticationAlgorithmsTable, 4, {1, 2, 1, 3}},
#define DOT11WEPDEFAULTKEYINDEX		1
    {DOT11WEPDEFAULTKEYINDEX, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_dot11WEPDefaultKeysTable, 4, {1, 3, 1, 1}},
#define DOT11WEPDEFAULTKEYVALUE		2
    {DOT11WEPDEFAULTKEYVALUE, ASN_OCTET_STR, NETSNMP_OLDAPI_RWRITE,
     var_dot11WEPDefaultKeysTable, 4, {1, 3, 1, 2}},
#define DOT11WEPKEYMAPPINGINDEX		1
    {DOT11WEPKEYMAPPINGINDEX, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_dot11WEPKeyMappingsTable, 4, {1, 4, 1, 1}},
#define DOT11WEPKEYMAPPINGADDRESS		2
    {DOT11WEPKEYMAPPINGADDRESS, ASN_OCTET_STR, NETSNMP_OLDAPI_RWRITE,
     var_dot11WEPKeyMappingsTable, 4, {1, 4, 1, 2}},
#define DOT11WEPKEYMAPPINGWEPON		3
    {DOT11WEPKEYMAPPINGWEPON, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11WEPKeyMappingsTable, 4, {1, 4, 1, 3}},
#define DOT11WEPKEYMAPPINGVALUE		4
    {DOT11WEPKEYMAPPINGVALUE, ASN_OCTET_STR, NETSNMP_OLDAPI_RWRITE,
     var_dot11WEPKeyMappingsTable, 4, {1, 4, 1, 4}},
#define DOT11WEPKEYMAPPINGSTATUS		5
    {DOT11WEPKEYMAPPINGSTATUS, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11WEPKeyMappingsTable, 4, {1, 4, 1, 5}},
#define DOT11PRIVACYINVOKED		1
    {DOT11PRIVACYINVOKED, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11PrivacyTable, 4, {1, 5, 1, 1}},
#define DOT11WEPDEFAULTKEYID		2
    {DOT11WEPDEFAULTKEYID, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11PrivacyTable, 4, {1, 5, 1, 2}},
#define DOT11WEPKEYMAPPINGLENGTH		3
    {DOT11WEPKEYMAPPINGLENGTH, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_dot11PrivacyTable, 4, {1, 5, 1, 3}},
#define DOT11EXCLUDEUNENCRYPTED		4
    {DOT11EXCLUDEUNENCRYPTED, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11PrivacyTable, 4, {1, 5, 1, 4}},
#define DOT11WEPICVERRORCOUNT		5
    {DOT11WEPICVERRORCOUNT, ASN_COUNTER, NETSNMP_OLDAPI_RONLY,
     var_dot11PrivacyTable, 4, {1, 5, 1, 5}},
#define DOT11WEPEXCLUDEDCOUNT		6
    {DOT11WEPEXCLUDEDCOUNT, ASN_COUNTER, NETSNMP_OLDAPI_RONLY,
     var_dot11PrivacyTable, 4, {1, 5, 1, 6}},
#define DOT11MULTIDOMAINCAPABILITYINDEX		1
    {DOT11MULTIDOMAINCAPABILITYINDEX, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_dot11MultiDomainCapabilityTable, 4, {1, 7, 1, 1}},
#define DOT11FIRSTCHANNELNUMBER		2
    {DOT11FIRSTCHANNELNUMBER, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11MultiDomainCapabilityTable, 4, {1, 7, 1, 2}},
#define DOT11NUMBEROFCHANNELS		3
    {DOT11NUMBEROFCHANNELS, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11MultiDomainCapabilityTable, 4, {1, 7, 1, 3}},
#define DOT11MAXIMUMTRANSMITPOWERLEVEL		4
    {DOT11MAXIMUMTRANSMITPOWERLEVEL, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11MultiDomainCapabilityTable, 4, {1, 7, 1, 4}},
#define DOT11WPAKEYSINDEX		1
    {DOT11WPAKEYSINDEX, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11WPAKeysTable, 4, {1, 8, 1, 1}},
#define DOT11WPAKEYSFORMAT		2
    {DOT11WPAKEYSFORMAT, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11WPAKeysTable, 4, {1, 8, 1, 2}},
#define DOT11WPAKEYSVALUE		3
    {DOT11WPAKEYSVALUE, ASN_OCTET_STR, NETSNMP_OLDAPI_RWRITE,
     var_dot11WPAKeysTable, 4, {1, 8, 1, 3}},
#define DOT11WPA2KEYSINDEX		1
    {DOT11WPA2KEYSINDEX, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11WPA2KeysTable, 4, {1, 9, 1, 1}},
#define DOT11WPA2KEYSFORMAT		2
    {DOT11WPA2KEYSFORMAT, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11WPA2KeysTable, 4, {1, 9, 1, 2}},
#define DOT11WPA2KEYSVALUE		3
    {DOT11WPA2KEYSVALUE, ASN_OCTET_STR, NETSNMP_OLDAPI_RWRITE,
     var_dot11WPA2KeysTable, 4, {1, 9, 1, 3}},
#define DOT11RADIUSSERVERIPADDRESS		1
    {DOT11RADIUSSERVERIPADDRESS, ASN_IPADDRESS, NETSNMP_OLDAPI_RWRITE,
     var_dot11RadiusServerTable, 4, {1, 10, 1, 1}},
#define DOT11RADIUSSERVERPORT		2
    {DOT11RADIUSSERVERPORT, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11RadiusServerTable, 4, {1, 10, 1, 2}},
#define DOT11RADIUSSERVERPASSWORD		3
    {DOT11RADIUSSERVERPASSWORD, ASN_OCTET_STR, NETSNMP_OLDAPI_RWRITE,
     var_dot11RadiusServerTable, 4, {1, 10, 1, 3}},
#define DOT11MACADDRESS		1
    {DOT11MACADDRESS, ASN_OCTET_STR, NETSNMP_OLDAPI_RONLY,
     var_dot11OperationTable, 4, {2, 1, 1, 1}},
#define DOT11RTSTHRESHOLD		2
    {DOT11RTSTHRESHOLD, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11OperationTable, 4, {2, 1, 1, 2}},
#define DOT11SHORTRETRYLIMIT		3
    {DOT11SHORTRETRYLIMIT, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11OperationTable, 4, {2, 1, 1, 3}},
#define DOT11LONGRETRYLIMIT		4
    {DOT11LONGRETRYLIMIT, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11OperationTable, 4, {2, 1, 1, 4}},
#define DOT11FRAGMENTATIONTHRESHOLD		5
    {DOT11FRAGMENTATIONTHRESHOLD, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11OperationTable, 4, {2, 1, 1, 5}},
#define DOT11MAXTRANSMITMSDULIFETIME		6
    {DOT11MAXTRANSMITMSDULIFETIME, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_dot11OperationTable, 4, {2, 1, 1, 6}},
#define DOT11MAXRECEIVELIFETIME		7
    {DOT11MAXRECEIVELIFETIME, ASN_UNSIGNED, NETSNMP_OLDAPI_RWRITE,
     var_dot11OperationTable, 4, {2, 1, 1, 7}},
#define DOT11MANUFACTURERID		8
    {DOT11MANUFACTURERID, ASN_OCTET_STR, NETSNMP_OLDAPI_RONLY,
     var_dot11OperationTable, 4, {2, 1, 1, 8}},
#define DOT11PRODUCTID		9
    {DOT11PRODUCTID, ASN_OCTET_STR, NETSNMP_OLDAPI_RONLY,
     var_dot11OperationTable, 4, {2, 1, 1, 9}},
#define DOT11IAPPENABLE		10
    {DOT11IAPPENABLE, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11OperationTable, 4, {2, 1, 1, 10}},
#define DOT11BLOCKRELAY		11
    {DOT11BLOCKRELAY, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11OperationTable, 4, {2, 1, 1, 11}},
#define DOT11WIFISPECIFIC		12
    {DOT11WIFISPECIFIC, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11OperationTable, 4, {2, 1, 1, 12}},
#define DOT11QOSENABLE		13
    {DOT11QOSENABLE, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11OperationTable, 4, {2, 1, 1, 13}},
#define DOT11NETWORKTYPE		14
    {DOT11NETWORKTYPE, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11OperationTable, 4, {2, 1, 1, 14}},
#define DOT11LEDTYPE		15
    {DOT11LEDTYPE, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11OperationTable, 4, {2, 1, 1, 15}},
#define DOT11OPERATIONMODE		16
    {DOT11OPERATIONMODE, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11OperationTable, 4, {2, 1, 1, 16}},
#define DOT11BROADCASTSSID		17
    {DOT11BROADCASTSSID, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11OperationTable, 4, {2, 1, 1, 17}},
#define DOT11GUESTACCESS		18
    {DOT11GUESTACCESS, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11OperationTable, 4, {2, 1, 1, 18}},
#define DOT11TRANSMITTEDFRAGMENTCOUNT		1
    {DOT11TRANSMITTEDFRAGMENTCOUNT, ASN_COUNTER, NETSNMP_OLDAPI_RONLY,
     var_dot11CountersTable, 4, {2, 2, 1, 1}},
#define DOT11MULTICASTTRANSMITTEDFRAMECOUNT		2
    {DOT11MULTICASTTRANSMITTEDFRAMECOUNT, ASN_COUNTER,
     NETSNMP_OLDAPI_RONLY,
     var_dot11CountersTable, 4, {2, 2, 1, 2}},
#define DOT11FAILEDCOUNT		3
    {DOT11FAILEDCOUNT, ASN_COUNTER, NETSNMP_OLDAPI_RONLY,
     var_dot11CountersTable, 4, {2, 2, 1, 3}},
#define DOT11RETRYCOUNT		4
    {DOT11RETRYCOUNT, ASN_COUNTER, NETSNMP_OLDAPI_RONLY,
     var_dot11CountersTable, 4, {2, 2, 1, 4}},
#define DOT11MULTIPLERETRYCOUNT		5
    {DOT11MULTIPLERETRYCOUNT, ASN_COUNTER, NETSNMP_OLDAPI_RONLY,
     var_dot11CountersTable, 4, {2, 2, 1, 5}},
#define DOT11FRAMEDUPLICATECOUNT		6
    {DOT11FRAMEDUPLICATECOUNT, ASN_COUNTER, NETSNMP_OLDAPI_RONLY,
     var_dot11CountersTable, 4, {2, 2, 1, 6}},
#define DOT11RTSSUCCESSCOUNT		7
    {DOT11RTSSUCCESSCOUNT, ASN_COUNTER, NETSNMP_OLDAPI_RONLY,
     var_dot11CountersTable, 4, {2, 2, 1, 7}},
#define DOT11RTSFAILURECOUNT		8
    {DOT11RTSFAILURECOUNT, ASN_COUNTER, NETSNMP_OLDAPI_RONLY,
     var_dot11CountersTable, 4, {2, 2, 1, 8}},
#define DOT11ACKFAILURECOUNT		9
    {DOT11ACKFAILURECOUNT, ASN_COUNTER, NETSNMP_OLDAPI_RONLY,
     var_dot11CountersTable, 4, {2, 2, 1, 9}},
#define DOT11RECEIVEDFRAGMENTCOUNT		10
    {DOT11RECEIVEDFRAGMENTCOUNT, ASN_COUNTER, NETSNMP_OLDAPI_RONLY,
     var_dot11CountersTable, 4, {2, 2, 1, 10}},
#define DOT11MULTICASTRECEIVEDFRAMECOUNT		11
    {DOT11MULTICASTRECEIVEDFRAMECOUNT, ASN_COUNTER, NETSNMP_OLDAPI_RONLY,
     var_dot11CountersTable, 4, {2, 2, 1, 11}},
#define DOT11FCSERRORCOUNT		12
    {DOT11FCSERRORCOUNT, ASN_COUNTER, NETSNMP_OLDAPI_RONLY,
     var_dot11CountersTable, 4, {2, 2, 1, 12}},
#define DOT11TRANSMITTEDFRAMECOUNT		13
    {DOT11TRANSMITTEDFRAMECOUNT, ASN_COUNTER, NETSNMP_OLDAPI_RONLY,
     var_dot11CountersTable, 4, {2, 2, 1, 13}},
#define DOT11WEPUNDECRYPTABLECOUNT		14
    {DOT11WEPUNDECRYPTABLECOUNT, ASN_COUNTER, NETSNMP_OLDAPI_RONLY,
     var_dot11CountersTable, 4, {2, 2, 1, 14}},
#define DOT11GROUPADDRESSESINDEX		1
    {DOT11GROUPADDRESSESINDEX, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_dot11GroupAddressesTable, 4, {2, 3, 1, 1}},
#define DOT11ADDRESS		2
    {DOT11ADDRESS, ASN_OCTET_STR, NETSNMP_OLDAPI_RWRITE,
     var_dot11GroupAddressesTable, 4, {2, 3, 1, 2}},
#define DOT11GROUPADDRESSESSTATUS		3
    {DOT11GROUPADDRESSESSTATUS, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11GroupAddressesTable, 4, {2, 3, 1, 3}},
#define DOT11MANUFACTUREROUI		1
    {DOT11MANUFACTUREROUI, ASN_OCTET_STR, NETSNMP_OLDAPI_RONLY,
     var_dot11ResourceInfoTable, 5, {3, 1, 2, 1, 1}},
#define DOT11MANUFACTURERNAME		2
    {DOT11MANUFACTURERNAME, ASN_OCTET_STR, NETSNMP_OLDAPI_RONLY,
     var_dot11ResourceInfoTable, 5, {3, 1, 2, 1, 2}},
#define DOT11MANUFACTURERPRODUCTNAME		3
    {DOT11MANUFACTURERPRODUCTNAME, ASN_OCTET_STR, NETSNMP_OLDAPI_RONLY,
     var_dot11ResourceInfoTable, 5, {3, 1, 2, 1, 3}},
#define DOT11MANUFACTURERPRODUCTVERSION		4
    {DOT11MANUFACTURERPRODUCTVERSION, ASN_OCTET_STR, NETSNMP_OLDAPI_RONLY,
     var_dot11ResourceInfoTable, 5, {3, 1, 2, 1, 4}},
#define DOT11PHYTYPE		1
    {DOT11PHYTYPE, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_dot11PhyOperationTable, 4, {4, 1, 1, 1}},
#define DOT11CURRENTREGDOMAIN		2
    {DOT11CURRENTREGDOMAIN, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11PhyOperationTable, 4, {4, 1, 1, 2}},
#define DOT11TEMPTYPE		3
    {DOT11TEMPTYPE, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_dot11PhyOperationTable, 4, {4, 1, 1, 3}},
#define DOT11SHORTPREAMBLE		4
    {DOT11SHORTPREAMBLE, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11PhyOperationTable, 4, {4, 1, 1, 4}},
#define DOT11PHYBANDSELECT		5
    {DOT11PHYBANDSELECT, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11PhyOperationTable, 4, {4, 1, 1, 5}},
#define DOT11TRSWITCH		6
    {DOT11TRSWITCH, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11PhyOperationTable, 4, {4, 1, 1, 6}},
#define DOT11POWERSCALE		7
    {DOT11POWERSCALE, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11PhyOperationTable, 4, {4, 1, 1, 7}},
#define DOT11CURRENTTXANTENNA		1
    {DOT11CURRENTTXANTENNA, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11PhyAntennaTable, 4, {4, 2, 1, 1}},
#define DOT11DIVERSITYSUPPORT		2
    {DOT11DIVERSITYSUPPORT, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_dot11PhyAntennaTable, 4, {4, 2, 1, 2}},
#define DOT11CURRENTRXANTENNA		3
    {DOT11CURRENTRXANTENNA, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11PhyAntennaTable, 4, {4, 2, 1, 3}},
#define DOT11NUMBERSUPPORTEDPOWERLEVELS		1
    {DOT11NUMBERSUPPORTEDPOWERLEVELS, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_dot11PhyTxPowerTable, 4, {4, 3, 1, 1}},
#define DOT11TXPOWERLEVEL1		2
    {DOT11TXPOWERLEVEL1, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_dot11PhyTxPowerTable, 4, {4, 3, 1, 2}},
#define DOT11TXPOWERLEVEL2		3
    {DOT11TXPOWERLEVEL2, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_dot11PhyTxPowerTable, 4, {4, 3, 1, 3}},
#define DOT11TXPOWERLEVEL3		4
    {DOT11TXPOWERLEVEL3, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_dot11PhyTxPowerTable, 4, {4, 3, 1, 4}},
#define DOT11TXPOWERLEVEL4		5
    {DOT11TXPOWERLEVEL4, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_dot11PhyTxPowerTable, 4, {4, 3, 1, 5}},
#define DOT11TXPOWERLEVEL5		6
    {DOT11TXPOWERLEVEL5, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_dot11PhyTxPowerTable, 4, {4, 3, 1, 6}},
#define DOT11TXPOWERLEVEL6		7
    {DOT11TXPOWERLEVEL6, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_dot11PhyTxPowerTable, 4, {4, 3, 1, 7}},
#define DOT11TXPOWERLEVEL7		8
    {DOT11TXPOWERLEVEL7, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_dot11PhyTxPowerTable, 4, {4, 3, 1, 8}},
#define DOT11TXPOWERLEVEL8		9
    {DOT11TXPOWERLEVEL8, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_dot11PhyTxPowerTable, 4, {4, 3, 1, 9}},
#define DOT11CURRENTTXPOWERLEVEL		10
    {DOT11CURRENTTXPOWERLEVEL, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11PhyTxPowerTable, 4, {4, 3, 1, 10}},
#define DOT11HOPTIME		1
    {DOT11HOPTIME, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_dot11PhyFHSSTable, 4, {4, 4, 1, 1}},
#define DOT11CURRENTCHANNELNUMBER		2
    {DOT11CURRENTCHANNELNUMBER, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11PhyFHSSTable, 4, {4, 4, 1, 2}},
#define DOT11MAXDWELLTIME		3
    {DOT11MAXDWELLTIME, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_dot11PhyFHSSTable, 4, {4, 4, 1, 3}},
#define DOT11CURRENTDWELLTIME		4
    {DOT11CURRENTDWELLTIME, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11PhyFHSSTable, 4, {4, 4, 1, 4}},
#define DOT11CURRENTSET		5
    {DOT11CURRENTSET, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11PhyFHSSTable, 4, {4, 4, 1, 5}},
#define DOT11CURRENTPATTERN		6
    {DOT11CURRENTPATTERN, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11PhyFHSSTable, 4, {4, 4, 1, 6}},
#define DOT11CURRENTINDEX		7
    {DOT11CURRENTINDEX, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11PhyFHSSTable, 4, {4, 4, 1, 7}},
#define DOT11EHCCPRIMERADIX		8
    {DOT11EHCCPRIMERADIX, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11PhyFHSSTable, 4, {4, 4, 1, 8}},
#define DOT11EHCCNUMBEROFCHANNELSFAMILYINDEX		9
    {DOT11EHCCNUMBEROFCHANNELSFAMILYINDEX, ASN_INTEGER,
     NETSNMP_OLDAPI_RWRITE,
     var_dot11PhyFHSSTable, 4, {4, 4, 1, 9}},
#define DOT11EHCCCAPABILITYIMPLEMENTED		10
    {DOT11EHCCCAPABILITYIMPLEMENTED, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11PhyFHSSTable, 4, {4, 4, 1, 10}},
#define DOT11EHCCCAPABILITYENABLED		11
    {DOT11EHCCCAPABILITYENABLED, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11PhyFHSSTable, 4, {4, 4, 1, 11}},
#define DOT11HOPALGORITHMADOPTED		12
    {DOT11HOPALGORITHMADOPTED, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11PhyFHSSTable, 4, {4, 4, 1, 12}},
#define DOT11RANDOMTABLEFLAG		13
    {DOT11RANDOMTABLEFLAG, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11PhyFHSSTable, 4, {4, 4, 1, 13}},
#define DOT11NUMBEROFHOPPINGSETS		14
    {DOT11NUMBEROFHOPPINGSETS, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_dot11PhyFHSSTable, 4, {4, 4, 1, 14}},
#define DOT11HOPMODULUS		15
    {DOT11HOPMODULUS, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_dot11PhyFHSSTable, 4, {4, 4, 1, 15}},
#define DOT11HOPOFFSET		16
    {DOT11HOPOFFSET, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11PhyFHSSTable, 4, {4, 4, 1, 16}},
#define DOT11CURRENTCHANNEL		1
    {DOT11CURRENTCHANNEL, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11PhyDSSSTable, 4, {4, 5, 1, 1}},
#define DOT11CCAMODESUPPORTED		2
    {DOT11CCAMODESUPPORTED, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_dot11PhyDSSSTable, 4, {4, 5, 1, 2}},
#define DOT11CURRENTCCAMODE		3
    {DOT11CURRENTCCAMODE, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11PhyDSSSTable, 4, {4, 5, 1, 3}},
#define DOT11EDTHRESHOLD		4
    {DOT11EDTHRESHOLD, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11PhyDSSSTable, 4, {4, 5, 1, 4}},
#define DOT11CCAWATCHDOGTIMERMAX		1
    {DOT11CCAWATCHDOGTIMERMAX, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11PhyIRTable, 4, {4, 6, 1, 1}},
#define DOT11CCAWATCHDOGCOUNTMAX		2
    {DOT11CCAWATCHDOGCOUNTMAX, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11PhyIRTable, 4, {4, 6, 1, 2}},
#define DOT11CCAWATCHDOGTIMERMIN		3
    {DOT11CCAWATCHDOGTIMERMIN, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11PhyIRTable, 4, {4, 6, 1, 3}},
#define DOT11CCAWATCHDOGCOUNTMIN		4
    {DOT11CCAWATCHDOGCOUNTMIN, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11PhyIRTable, 4, {4, 6, 1, 4}},
#define DOT11REGDOMAINSSUPPORTEDINDEX		1
    {DOT11REGDOMAINSSUPPORTEDINDEX, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_dot11RegDomainsSupportedTable, 4, {4, 7, 1, 1}},
#define DOT11REGDOMAINSSUPPORTEDVALUE		2
    {DOT11REGDOMAINSSUPPORTEDVALUE, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_dot11RegDomainsSupportedTable, 4, {4, 7, 1, 2}},
#define DOT11ANTENNALISTINDEX		1
    {DOT11ANTENNALISTINDEX, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_dot11AntennasListTable, 4, {4, 8, 1, 1}},
#define DOT11SUPPORTEDTXANTENNA		2
    {DOT11SUPPORTEDTXANTENNA, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11AntennasListTable, 4, {4, 8, 1, 2}},
#define DOT11SUPPORTEDRXANTENNA		3
    {DOT11SUPPORTEDRXANTENNA, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11AntennasListTable, 4, {4, 8, 1, 3}},
#define DOT11DIVERSITYSELECTIONRX		4
    {DOT11DIVERSITYSELECTIONRX, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11AntennasListTable, 4, {4, 8, 1, 4}},
#define DOT11SUPPORTEDDATARATESTXINDEX		1
    {DOT11SUPPORTEDDATARATESTXINDEX, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_dot11SupportedDataRatesTxTable, 4, {4, 9, 1, 1}},
#define DOT11SUPPORTEDDATARATESTXVALUE		2
    {DOT11SUPPORTEDDATARATESTXVALUE, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_dot11SupportedDataRatesTxTable, 4, {4, 9, 1, 2}},
#define DOT11SUPPORTEDDATARATESRXINDEX		1
    {DOT11SUPPORTEDDATARATESRXINDEX, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_dot11SupportedDataRatesRxTable, 4, {4, 10, 1, 1}},
#define DOT11SUPPORTEDDATARATESRXVALUE		2
    {DOT11SUPPORTEDDATARATESRXVALUE, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_dot11SupportedDataRatesRxTable, 4, {4, 10, 1, 2}},
#define DOT11CURRENTFREQUENCY		1
    {DOT11CURRENTFREQUENCY, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11PhyOFDMTable, 4, {4, 11, 1, 1}},
#define DOT11TITHRESHOLD		2
    {DOT11TITHRESHOLD, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11PhyOFDMTable, 4, {4, 11, 1, 2}},
#define DOT11FREQUENCYBANDSSUPPORTED		3
    {DOT11FREQUENCYBANDSSUPPORTED, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_dot11PhyOFDMTable, 4, {4, 11, 1, 3}},
#define DOT11SHORTPREAMBLEOPTIONIMPLEMENTED		1
    {DOT11SHORTPREAMBLEOPTIONIMPLEMENTED, ASN_INTEGER,
     NETSNMP_OLDAPI_RONLY,
     var_dot11PhyHRDSSSTable, 4, {4, 12, 1, 1}},
#define DOT11PBCCOPTIONIMPLEMENTED		2
    {DOT11PBCCOPTIONIMPLEMENTED, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_dot11PhyHRDSSSTable, 4, {4, 12, 1, 2}},
#define DOT11CHANNELAGILITYPRESENT		3
    {DOT11CHANNELAGILITYPRESENT, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_dot11PhyHRDSSSTable, 4, {4, 12, 1, 3}},
#define DOT11CHANNELAGILITYENABLED		4
    {DOT11CHANNELAGILITYENABLED, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_dot11PhyHRDSSSTable, 4, {4, 12, 1, 4}},
#define DOT11HRCCAMODESUPPORTED		5
    {DOT11HRCCAMODESUPPORTED, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_dot11PhyHRDSSSTable, 4, {4, 12, 1, 5}},
#define DOT11HOPPINGPATTERNINDEX		1
    {DOT11HOPPINGPATTERNINDEX, ASN_INTEGER, NETSNMP_OLDAPI_RONLY,
     var_dot11HoppingPatternTable, 4, {4, 13, 1, 1}},
#define DOT11RANDOMTABLEFIELDNUMBER		2
    {DOT11RANDOMTABLEFIELDNUMBER, ASN_INTEGER, NETSNMP_OLDAPI_RWRITE,
     var_dot11HoppingPatternTable, 4, {4, 13, 1, 2}},
};

/*HF Add*/
#define SIOCGSNMPMIB 0x8B3D
#define UNI_OID_LEN 5
#define MAX_DATA_SIZE MAX_OID_LEN * UNI_OID_LEN
#define IOCTL_SNMP(interface, oid, len, out, plen)  _ioctl_snmp(interface, oid, len, out, plen)
#define OID_TAIL(oid) oid + 4
#define OID_COUNT_LEN 2
#define NO_SUCH_INSTANCE() return NULL

int charToAscii(char hex, char *string)
{
        if(NULL == string)
                return -1;
	/*hex is char, if high bit is 1 need and 0xff*/
        sprintf(string,"%02x",(hex & 0xff));
        return 0;
}
int hexKeyToString(char *keyHex, char *string, int len)
{
        int i;
        for(i=0;i<len;i++)
        {
            charToAscii(keyHex[i],string+(i*2));
        }
	string[len*2] = '\0';
	return 0;
}

static inline int
iw_get_ext(int                  skfd,           /* Socket to the kernel */
           char *               ifname,         /* Device name */
           int                  request,        /* WE ID */
           struct iwreq *       pwrq)           /* Fixed part of the request */
{
	/* Set device name */
	strncpy(pwrq->ifr_name, ifname, IFNAMSIZ);
	
	/* Do the request */
	return(ioctl(skfd, request, pwrq));
}

static int get_wlan_mib(char *interface, char *oid, unsigned char *out, u_long *len)
{
    int skfd;
    struct iwreq wrq;
    unsigned char data[MAX_DATA_SIZE];

    skfd = socket(AF_INET, SOCK_DGRAM, 0);

    /* Get wireless name */
    if ( iw_get_ext(skfd, interface, SIOCGIWNAME, &wrq) < 0)
      /* If no wireless name : no wireless extensions */
        return -1;

	strcpy(data, oid);
    wrq.u.data.pointer = (caddr_t)data;
    wrq.u.data.length = strlen(data);
    if (iw_get_ext(skfd, interface, SIOCGSNMPMIB, &wrq) < 0)
		return -1;
    close(skfd);
    
    memcpy(out, data, wrq.u.data.length);
    *len = wrq.u.data.length;	
	return 1;
}

void oid2str(char *str, oid *name, size_t oid_len){
	int i;
	int str_len;

	str_len = 0;
	for(i = 0; i < oid_len; i++ ) {
	    sprintf(str + str_len, "%d.", name[i]);
	    str_len += strlen(str + str_len);
	}
	str[str_len - 1] = '\0';
}

static int _ioctl_snmp(char *interface, oid *oid, size_t len, unsigned char *out, u_long *plen){
	unsigned char name[MAX_DATA_SIZE];
	
	oid2str(name, oid, len);

	return get_wlan_mib(interface, name, out, plen);
}

int _translateWordToByte( u_char * ucString,int iLens )
{
	int i;
	u_char * pEnd;
	char pTmp[3] ="FF";
	
	pEnd = ucString;

	for(i=0 ; i < (iLens/2) ; i++ )
	{
		memcpy( pTmp,&ucString[i*2],2 );
		ucString[i] = strtol (pTmp,NULL,16);
	}
	return (iLens / 2) ;
}
/*
	translate a string for Rate setting to 2byte format
	to match Apmib format
*/
u_long _translateOperationRateTo8186( u_char * ucString,int iLens )
{
	int ret_val = 0;
	int i;
	u_long ul_ret = 0;

	for( i = 0 ; i < iLens ; i++ )
	{
		if( ucString[i] == 108 ) ul_ret |= TX_RATE_54M;
		if( ucString[i] == 96 )  ul_ret |= TX_RATE_48M;
		if( ucString[i] == 72 )  ul_ret |= TX_RATE_36M;
		if( ucString[i] == 48 )  ul_ret |= TX_RATE_24M;
		if( ucString[i] == 36 )  ul_ret |= TX_RATE_18M;
		if( ucString[i] == 24 )  ul_ret |= TX_RATE_12M;
		if( ucString[i] == 18 )  ul_ret |= TX_RATE_9M;
		if( ucString[i] == 12 )  ul_ret |= TX_RATE_6M;
		if( ucString[i] == 22 )  ul_ret |= TX_RATE_11M;
		if( ucString[i] == 10 )  ul_ret |= TX_RATE_5M;
		if( ucString[i] == 4 )   ul_ret |= TX_RATE_2M;
		if( ucString[i] == 2 )   ul_ret |= TX_RATE_1M;
	}

//	snmp_log(LOG_INFO, "translate: ul_ret = %x\n",ul_ret);
	return ul_ret;
}
int _translateOperationRateToIEEE( u_long rate_set,u_char * ret_value )
{
	int ret_val = 0;
	int i;

	snmp_log(LOG_INFO, "u_short rate_set = %x\n",rate_set);

	if( rate_set & TX_RATE_54M )
	{
		ret_value[ret_val] = 108;
		ret_val++;
	}
	if( rate_set & TX_RATE_48M)
	{
		ret_value[ret_val] = 96;
		ret_val++;
	}
	if( rate_set & TX_RATE_36M )
	{
		ret_value[ret_val] = 72;
		ret_val++;
	}
	if( rate_set & TX_RATE_24M )
	{
		ret_value[ret_val] = 48;
		ret_val++;
	}
	if( rate_set & TX_RATE_18M )
	{
		ret_value[ret_val] = 36;
		ret_val++;
	}
	if( rate_set & TX_RATE_12M )
	{
		ret_value[ret_val] = 24;
		ret_val++;
	}
	if( rate_set & TX_RATE_9M )
	{
		ret_value[ret_val] = 18;
		ret_val++;
	}
	if( rate_set & TX_RATE_6M )
	{
		ret_value[ret_val] = 12;
		ret_val++;
	}
	if( rate_set & TX_RATE_11M )
	{
		ret_value[ret_val] = 22;
		ret_val++;
	}
	if( rate_set & TX_RATE_5M )
	{
		ret_value[ret_val] = 10;
		ret_val++;
	}
	if( rate_set & TX_RATE_2M )
	{
		ret_value[ret_val] = 4;
		ret_val++;
	}
	if( rate_set & TX_RATE_1M )
	{
		ret_value[ret_val] = 2;
		ret_val++;
	}

	return ret_val;
}

/*HF Add End*/

/*
 * (L = length of the oidsuffix) 
 */


/** Initializes the ieee802dot11 module */
void
init_ieee802dot11(void)
{

    DEBUGMSGTL(("ieee802dot11", "Initializing\n"));

    /*
     * register ourselves with the agent to handle our mib tree 
     */
    REGISTER_MIB("ieee802dot11", ieee802dot11_variables, variable4,
                 ieee802dot11_variables_oid);

    /*
     * place any other initialization junk you need here 
     */

	/*HF Add*/
	if ( apmib_init() == 0 ){
		//snmp_log(LOG_INFO, "ieee802dot11: init apmib failed\n");
    }
    else{
		//snmp_log(LOG_INFO, "ieee802dot11: success\n");
    } 
	/*HF Add End*/
}

/*
 * var_ieee802dot11():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char  *
var_ieee802dot11(struct variable *vp,
                 oid * name,
                 size_t *length,
                 int exact, size_t *var_len, WriteMethod ** write_method)
{
    /*
     * variables we may use later 
     */
    static long     long_ret;
    static u_long   ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid      objid[MAX_OID_LEN];
    static struct counter64 c64;

    if (header_generic(vp, name, length, exact, var_len, write_method)
        == MATCH_FAILED)
        return NULL;

	/*HF Add*/
	u_long len;
	if(IOCTL_SNMP("wlan0", OID_TAIL(name), 4, string, &len) == -1){
		//snmp_log(LOG_INFO, "var_ieee802dot11: IOCT_SNMP failed");
		return NULL;
	};
	/*HF Add End*/
	
    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT11RESOURCETYPEIDNAME:
		*var_len = len - 1;
        return  (u_char *) string + 1;
		
    default:
        ERROR_MSG("");
    }
    return NULL;
}


/*
 * var_dot11StationConfigTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ieee802dot11 above.
 */
unsigned char  *
var_dot11StationConfigTable(struct variable *vp,
                            oid * name,
                            size_t *length,
                            int exact,
                            size_t *var_len, WriteMethod ** write_method)
{
    /*
     * variables we may use later 
     */
    static long     long_ret;
    static u_long   ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid      objid[MAX_OID_LEN];
    static struct counter64 c64;

	/*HF Add*/
	u_long table_size;
	u_long len;
	oid count_id[] = {6, 1};
	if(IOCTL_SNMP("wlan0", count_id, OID_COUNT_LEN, string, &len) == -1){
		snmp_log(LOG_INFO, "var_dot11StationConfigTable: IOCT_SNMP failed 1\n");
		return NULL;
	};
	table_size = *(string+1);
	/*HF Add End*/	

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED)
        return NULL;


	/*HF Add*/
#define OID_STATIONCONFIG_LEN 5
	if(IOCTL_SNMP("wlan0", OID_TAIL(name), OID_STATIONCONFIG_LEN, string, &len) == -1){
		//	snmp_log(LOG_INFO, "var_dot11StationConfigTable: IOCT_SNMP failed \n");
		return NULL;
	};
	/*HF Add End*/

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT11STATIONID:
        *write_method = write_dot11StationID;
        *var_len = 6;
		apmib_get(MIB_WLAN_WLAN_MAC_ADDR,string);
        return (unsigned char *) string;

    case DOT11MEDIUMOCCUPANCYLIMIT:
        *write_method = write_dot11MediumOccupancyLimit;
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *(string + 1);
		
		return	(u_char *) &ulong_ret;

    case DOT11CFPOLLABLE:
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *(string + 1);
		
		return	(u_char *) &ulong_ret;

    case DOT11CFPPERIOD:
        *write_method = write_dot11CFPPeriod;
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *(string + 1);

        return  (u_char *) &ulong_ret;

    case DOT11CFPMAXDURATION:
        *write_method = write_dot11CFPMaxDuration;
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *(string + 1);

        return  (u_char *) &ulong_ret;

    case DOT11AUTHENTICATIONRESPONSETIMEOUT:
        *write_method = write_dot11AuthenticationResponseTimeOut;
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *((int *)(string + 1));
		
        return  (u_char *) &ulong_ret;

    case DOT11PRIVACYOPTIONIMPLEMENTED:
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *(string + 1);

        return  (u_char *) &ulong_ret;

    case DOT11POWERMANAGEMENTMODE:
        *write_method = write_dot11PowerManagementMode;
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *(string + 1);

        return  (u_char *) &ulong_ret;

    case DOT11DESIREDSSID:
        *write_method = write_dot11DesiredSSID;
		apmib_get(MIB_WLAN_SSID,string);
		*var_len = strlen(string);
        return (unsigned char *) string;

    case DOT11DESIREDBSSTYPE:
        *write_method = write_dot11DesiredBSSType;
		apmib_get(MIB_WLAN_NETWORK_TYPE,(void *)&ulong_ret);
		// translate between 8186 and agent
		// 8186                     agent
		// infrastructure---->0     ----->1
		// Ad hoc ----------->1     ----->2		
		ulong_ret++;
        return  (u_char *) &ulong_ret;

    case DOT11OPERATIONALRATESET:
        *write_method = write_dot11OperationalRateSet;
		apmib_get(MIB_WLAN_SUPPORTED_RATES,(void *)&ulong_ret);
		*var_len = _translateOperationRateToIEEE( ulong_ret, string);
        return  (u_char *) &string;

    case DOT11BEACONPERIOD:
        *write_method = write_dot11BeaconPeriod;
 		apmib_get(MIB_WLAN_BEACON_INTERVAL,&ulong_ret);
        return  (u_char *) &ulong_ret;

    case DOT11DTIMPERIOD:
        *write_method = write_dot11DTIMPeriod;
 		apmib_get(MIB_WLAN_DTIM_PERIOD,&ulong_ret);
        return  (u_char *) &ulong_ret;

    case DOT11ASSOCIATIONRESPONSETIMEOUT:
        *write_method = write_dot11AssociationResponseTimeOut;
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *((int *)(string + 1));

        return  (u_char *) &ulong_ret;

    case DOT11DISASSOCIATEREASON:
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *((int *)(string + 1));

        return  (u_char *) &ulong_ret;

    case DOT11DISASSOCIATESTATION:
		*var_len = len - 1;
        return  (u_char *) string + 1;

    case DOT11DEAUTHENTICATEREASON:
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *((int *)(string + 1));

        return  (u_char *) &ulong_ret;

    case DOT11DEAUTHENTICATESTATION:
		*var_len = len - 1;
        return  (u_char *) string + 1;

    case DOT11AUTHENTICATEFAILSTATUS:
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *((int *)(string + 1));

        return  (u_char *) &ulong_ret;

    case DOT11AUTHENTICATEFAILSTATION:
		*var_len = len - 1;
        return  (u_char *) string + 1;

    case DOT11MULTIDOMAINCAPABILITYIMPLEMENTED:
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *((int *)(string + 1));

        return  (u_char *) &ulong_ret;

    case DOT11MULTIDOMAINCAPABILITYENABLED:
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *((int *)(string + 1));

        return  (u_char *) &ulong_ret;

    case DOT11COUNTRYSTRING:
		*var_len = 2;
		strcpy(string,"us");
       	return  (u_char *) string;
		
    case DOT11REGDOMAIN:
        *write_method = write_dot11RegDomain;
        apmib_get(MIB_HW_REG_DOMAIN, &ulong_ret);

		return  (u_char *) &ulong_ret;
		
    case DOT11DATARATE:
        *write_method = write_dot11DataRate;
		apmib_get(MIB_WLAN_RATE_ADAPTIVE_ENABLED, (void *)&ulong_ret);
		if(ulong_ret == 0) {	
			apmib_get(MIB_WLAN_FIX_RATE, &ulong_ret);
		}
		
		return  (u_char *) &ulong_ret;

    case DOT11PROTECTIONDISABLED:
        *write_method = write_dot11ProtectionDisabled;
		apmib_get(MIB_WLAN_PROTECTION_DISABLED, (void *)&ulong_ret);
		
        return  (u_char *) &ulong_ret;
		
    case DOT11NSTBC:
	if(len == 1)
        	ulong_ret = 0;
        else
        	ulong_ret = *((int *)(string + 1));

        return  (u_char *) &ulong_ret;

    case DOT11NCOEXIST:
	if(len == 1)
        	ulong_ret = 0;
        else
        	ulong_ret = *((int *)(string + 1));

        return  (u_char *) &ulong_ret;

    case DOT11NUSE40M:
        *write_method = write_dot11nUse40M;
		apmib_get(MIB_WLAN_CHANNEL_BONDING, (void *)&ulong_ret);
		
        return  (u_char *) &ulong_ret;

    case DOT11N2NDCHOFFSET:
        *write_method = write_dot11n2ndChOffset;
		apmib_get(MIB_WLAN_CONTROL_SIDEBAND, (void *)&long_ret);
		if(0 == long_ret) {
			/*below dot11n2ndChOffset = 1*/
			ulong_ret = 1;
		}
		else if(1 == long_ret){
			/*above dot11n2ndChOffset = 2*/
			ulong_ret = 2;
		}
		
        return  (u_char *) &ulong_ret;

    case DOT11NSHORTGIFOR20M:
        *write_method = write_dot11nShortGIfor20M;
		apmib_get(MIB_WLAN_SHORT_GI, &ulong_ret);
		
        return  (u_char *) &ulong_ret;

    case DOT11NSHORTGIFOR40M:
        *write_method = write_dot11nShortGIfor40M;
		apmib_get(MIB_WLAN_SHORT_GI, (void *)&ulong_ret);
		
        return  (u_char *) &ulong_ret;

    case DOT11NAMPDU:
        *write_method = write_dot11nAMPDU;
		apmib_get(MIB_WLAN_AGGREGATION, (void *)&long_ret);
		if( (0 == long_ret) || (2 == long_ret) ) {
			ulong_ret = 0;
		} else if ( ( 1 == long_ret) || ( 3 == long_ret ) ) {
			ulong_ret = 1;
		}
        return  (u_char *) &ulong_ret;

    case DOT11NAMSDU:
        *write_method = write_dot11nAMSDU;
		apmib_get(MIB_WLAN_AGGREGATION, (void *)&long_ret);
		if( (0 == long_ret) || (1 == long_ret) ) {
			ulong_ret = 0;
		} else if ( ( 2 == long_ret) || ( 3 == long_ret ) ) {
			ulong_ret = 1;
		}
        return  (u_char *) &ulong_ret;

    default:
        ERROR_MSG("");
    }
    return NULL;
}

/*
 * var_dot11AuthenticationAlgorithmsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ieee802dot11 above.
 */
unsigned char  *
var_dot11AuthenticationAlgorithmsTable(struct variable *vp,
                                       oid * name,
                                       size_t *length,
                                       int exact,
                                       size_t *var_len,
                                       WriteMethod ** write_method)
{
    /*
     * variables we may use later 
     */
    static long     long_ret;
    static u_long   ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid      objid[MAX_OID_LEN];
    static struct counter64 c64;

	/*HF Add.*/
	u_long table_size;
	u_long len;	
	oid count_id[] = {6, 2};
	u_long	table_value,auth_type;
	
	if(IOCTL_SNMP("wlan0", count_id, OID_COUNT_LEN, string, &len) == -1){
			//snmp_log(LOG_INFO, "var_dot11StationConfigTable: IOCT_SNMP failed \n");
			return NULL;
	};
	table_size = *(string+1);
	/*HF Add End*/	

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED)
        return NULL;
	
	/*HF Add*/
#define OID_STATIONCONFIG_LEN 5
	if(IOCTL_SNMP("wlan0", OID_TAIL(name), OID_STATIONCONFIG_LEN, string, &len) == -1){
		//	snmp_log(LOG_INFO, "var_dot11StationConfigTable: IOCT_SNMP failed \n");
		return NULL;
	};
	/*HF Add End*/	

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT11AUTHENTICATIONALGORITHMSINDEX:
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *(string + 1);

        return  (u_char *) &ulong_ret;

    case DOT11AUTHENTICATIONALGORITHM:
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *(string + 1);
		
        return  (u_char *) &ulong_ret;

    case DOT11AUTHENTICATIONALGORITHMSENABLE:
        *write_method = write_dot11AuthenticationAlgorithmsEnable;
		table_value = name[*length-1];
		
		apmib_get(MIB_WLAN_AUTH_TYPE, (void *)&auth_type);
		auth_type = auth_type + 1;
		if( table_value & auth_type )
		{
			ulong_ret = 1;		
		}
		else
		{
			ulong_ret = 0;		
		}
        return  (u_char *) &ulong_ret;

    default:
        ERROR_MSG("");
    }
    return NULL;
}

/*
 * var_dot11WEPDefaultKeysTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ieee802dot11 above.
 */
unsigned char  *
var_dot11WEPDefaultKeysTable(struct variable *vp,
                             oid * name,
                             size_t *length,
                             int exact,
                             size_t *var_len, WriteMethod ** write_method)
{
    /*
     * variables we may use later 
     */
    static long     long_ret;
    static u_long   ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid      objid[MAX_OID_LEN];
    static struct counter64 c64;

	/*HF Add*/
	int  wep_offset,wep;
	u_long table_size;
	oid count_id[] = {6, 3};
	u_long len;
	if(IOCTL_SNMP("wlan0", count_id, OID_COUNT_LEN, string, &len) == -1){
		//snmp_log(LOG_INFO, "var_dot11StationConfigTable: IOCT_SNMP failed \n");
		return NULL;
	};
	table_size = *(string+1);
	/*HF Add End*/

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED)
        return NULL;

	/*HF*/
#define OID_WEPDEFALKEYS_LEN 5
		if(IOCTL_SNMP("wlan0", OID_TAIL(name), OID_WEPDEFALKEYS_LEN, string, &len) == -1){
			//snmp_log(LOG_INFO, "var_dot11StationConfigTable: IOCT_SNMP failed \n");
			return NULL;
		};
	/*HF*/

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT11WEPDEFAULTKEYINDEX:
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *(string + 1);

        return  (u_char *) &ulong_ret;

    case DOT11WEPDEFAULTKEYVALUE:
        *write_method = write_dot11WEPDefaultKeyValue;
	{
		int keylen,wep_key_type;
		char keyHex[26];
		wep_offset = name[*length-1] - 1;
//		snmp_log(LOG_INFO, "wep_offset = %d\n",wep_offset);
//		snmp_log(LOG_INFO, "MIB_WLAN_WEP64_KEY1+wep_offset = %d\n",MIB_WLAN_WEP64_KEY1+wep_offset );
		apmib_get(MIB_WLAN_WEP, (void *)&wep);
		apmib_get(MIB_WLAN_WEP_KEY_TYPE, (void *)&wep_key_type); /*ASCII 0 HEX 1*/

		if (wep == 1) 
		{
			apmib_get(MIB_WLAN_WEP64_KEY1+wep_offset ,string);
			keylen=10;
		}
		else
		{
			apmib_get(MIB_WLAN_WEP128_KEY1+wep_offset ,string);
			keylen=26;
		}
		if(1 == wep_key_type)
		{
			memcpy(keyHex,string,(keylen/2));
			hexKeyToString(keyHex,string,(keylen/2));
				
		}	
		*var_len = strlen(string);
	}
		return (unsigned char *) string;

    default:
        ERROR_MSG("var_dot11WEPDefaultKeysTable: Error!!!\n");
    }
    return NULL;
}

/*
 * var_dot11WEPKeyMappingsTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ieee802dot11 above.
 */
unsigned char  *
var_dot11WEPKeyMappingsTable(struct variable *vp,
                             oid * name,
                             size_t *length,
                             int exact,
                             size_t *var_len, WriteMethod ** write_method)
{
    /*
     * variables we may use later 
     */
    static long     long_ret;
    static u_long   ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid      objid[MAX_OID_LEN];
    static struct counter64 c64;

	/*HF Add*/
	oid count_id[] = {6, 4};
	u_long table_size;
	u_long len;
	if(IOCTL_SNMP("wlan0", count_id, OID_COUNT_LEN, string, &len) == -1){
		//	snmp_log(LOG_INFO, "var_dot11StationConfigTable: IOCT_SNMP failed \n");
		return NULL;
	};
	table_size = *(string+1);
	/*HF Add End*/

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED)
        return NULL;

	/*HF Add*/
#define OID_WEPDEFALKEYS_LEN 5
	if(IOCTL_SNMP("wlan0", OID_TAIL(name), OID_WEPDEFALKEYS_LEN, string, &len) == -1){
		//snmp_log(LOG_INFO, "var_dot11StationConfigTable: IOCT_SNMP failed \n");
		return NULL;
	};
	/*HF Add End*/	

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT11WEPKEYMAPPINGINDEX:
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *(string + 1);

        return  (u_char *) &ulong_ret;

    case DOT11WEPKEYMAPPINGADDRESS:
        *write_method = write_dot11WEPKeyMappingAddress;
		*var_len = len - 1;
        return  (u_char *) string + 1;

    case DOT11WEPKEYMAPPINGWEPON:
        *write_method = write_dot11WEPKeyMappingWEPOn;
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *(string + 1);
		
        return  (u_char *) &ulong_ret;

    case DOT11WEPKEYMAPPINGVALUE:
        *write_method = write_dot11WEPKeyMappingValue;
		*var_len = len - 1;
        return  (u_char *) string + 1;

    case DOT11WEPKEYMAPPINGSTATUS:
        *write_method = write_dot11WEPKeyMappingStatus;
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *(string + 1);
		
        return  (u_char *) &ulong_ret;

    default:
        ERROR_MSG("var_dot11WEPKeyMappingsTable: Error!!!\n");
    }
    return NULL;
}

/*
 * var_dot11PrivacyTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ieee802dot11 above.
 */
unsigned char  *
var_dot11PrivacyTable(struct variable *vp,
                      oid * name,
                      size_t *length,
                      int exact,
                      size_t *var_len, WriteMethod ** write_method)
{
    /*
     * variables we may use later 
     */
    static long     long_ret;
    static u_long   ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid      objid[MAX_OID_LEN];
    static struct counter64 c64;

	/*HF Add*/
	oid count_id[] = {6, 5};
	u_long table_size;
	u_long len;
	if(IOCTL_SNMP("wlan0", count_id, OID_COUNT_LEN, string, &len) == -1){
		//	snmp_log(LOG_INFO, "var_dot11StationConfigTable: IOCT_SNMP failed \n");
		return NULL;
	};
	table_size = *(string+1);
	/*HF Add End*/

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED)
        return NULL;

	/*HF*/
#define OID_PRIVACY_LEN 5
		if(IOCTL_SNMP("wlan0", OID_TAIL(name), OID_PRIVACY_LEN, string, &len) == -1){
			//snmp_log(LOG_INFO, "var_dot11WEPKeyMappingsTable: IOCT_SNMP failed \n");
			return NULL;
		};
	/*HF*/	

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT11PRIVACYINVOKED:
        *write_method = write_dot11PrivacyInvoked;
		apmib_get(MIB_WLAN_ENCRYPT, (void *)&ulong_ret);
		return (u_char *) &ulong_ret;

    case DOT11WEPDEFAULTKEYID:
        *write_method = write_dot11WEPDefaultKeyID;
		apmib_get(MIB_WLAN_WEP_DEFAULT_KEY, (void *)&ulong_ret);
		return (u_char *) &ulong_ret;

    case DOT11WEPKEYMAPPINGLENGTH:
        *write_method = write_dot11WEPKeyMappingLength;
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *(string + 1);

		return (u_char *) &ulong_ret;

    case DOT11EXCLUDEUNENCRYPTED:
        *write_method = write_dot11ExcludeUnencrypted;
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *((u_long *)(string + 1));

		return (u_char *) &ulong_ret;

    case DOT11WEPICVERRORCOUNT:
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *((u_long *)(string + 1));

		return (u_char *) &ulong_ret;

    case DOT11WEPEXCLUDEDCOUNT:
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *((u_long *)(string + 1));

		return (u_char *) &ulong_ret;

    default:
        ERROR_MSG("var_dot11PrivacyTable: Error!!!\n");
    }
    return NULL;
}

/*
 * var_dot11MultiDomainCapabilityTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ieee802dot11 above.
 */
unsigned char  *
var_dot11MultiDomainCapabilityTable(struct variable *vp,
                                    oid * name,
                                    size_t *length,
                                    int exact,
                                    size_t *var_len,
                                    WriteMethod ** write_method)
{
    /*
     * variables we may use later 
     */
    static long     long_ret;
    static u_long   ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid      objid[MAX_OID_LEN];
    static struct counter64 c64;
	
	/*HF Add*/
	oid count_id[] = {6, 19};
	u_long table_size;
	u_long len;
	if(IOCTL_SNMP("wlan0", count_id, OID_COUNT_LEN, string, &len) == -1){
		//	snmp_log(LOG_INFO, "var_dot11StationConfigTable: IOCT_SNMP failed \n");
		return NULL;
	};
	table_size = *(string+1);
	/*HF Add End*/

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED)
        return NULL;

	/*HF*/
#define OID_MULTIDOMAINCAPABILITY_LEN 5
	if(IOCTL_SNMP("wlan0", OID_TAIL(name), OID_MULTIDOMAINCAPABILITY_LEN, string, &len) == -1){
		//snmp_log(LOG_INFO, "var_dot11WEPKeyMappingsTable: IOCT_SNMP failed \n");
		return NULL;
	};
	/*HF*/	

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT11MULTIDOMAINCAPABILITYINDEX:
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *(string + 1);

		return (u_char *) &ulong_ret;

    case DOT11FIRSTCHANNELNUMBER:
        *write_method = write_dot11FirstChannelNumber;
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *(string + 1);

		return (u_char *) &ulong_ret;

    case DOT11NUMBEROFCHANNELS:
        *write_method = write_dot11NumberofChannels;
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *(string + 1);

		return (u_char *) &ulong_ret;

    case DOT11MAXIMUMTRANSMITPOWERLEVEL:
        *write_method = write_dot11MaximumTransmitPowerLevel;
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *(string + 1);

		return (u_char *) &ulong_ret;

    default:
        ERROR_MSG("var_dot11MultiDomainCapabilityTable Error!");
    }
    return NULL;
}

/*
 * var_dot11WPAKeysTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ieee802dot11 above.
 */
unsigned char  *
var_dot11WPAKeysTable(struct variable *vp,
                      oid * name,
                      size_t *length,
                      int exact,
                      size_t *var_len, WriteMethod ** write_method)
{
    /*
     * variables we may use later 
     */
    static long     long_ret;
    static u_long   ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid      objid[MAX_OID_LEN];
    static struct counter64 c64;

	/*HF Add*/
	oid count_id[] = {6, 20};
	u_long table_size;
	u_long len;
	if(IOCTL_SNMP("wlan0", count_id, OID_COUNT_LEN, string, &len) == -1){
		//	snmp_log(LOG_INFO, "var_dot11StationConfigTable: IOCT_SNMP failed \n");
		return NULL;
	};
	table_size = *(string+1);
	/*HF Add End*/



    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED)
        return NULL;

	/*HF*/
#define OID_WPAKEY_LEN 5
	if(IOCTL_SNMP("wlan0", OID_TAIL(name), OID_WPAKEY_LEN, string, &len) == -1){
		//snmp_log(LOG_INFO, "var_dot11WEPKeyMappingsTable: IOCT_SNMP failed \n");
		return NULL;
	};
	/*HF*/	

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT11WPAKEYSINDEX:
        *write_method = write_dot11WPAKeysIndex;
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *(string + 1);

		return (u_char *) &ulong_ret;

    case DOT11WPAKEYSFORMAT:
        *write_method = write_dot11WPAKeysFormat;
		apmib_get(MIB_WLAN_PSK_FORMAT, (void *)&ulong_ret);

		return (u_char *) &ulong_ret;

    case DOT11WPAKEYSVALUE:
        *write_method = write_dot11WPAKeysValue;
		apmib_get(MIB_WLAN_WPA_PSK, (void *)string);
		*var_len = strlen(string);

		return (u_char *) string;

    default:
        ERROR_MSG("var_dot11WPAKeysTable Error!");
    }
    return NULL;
}

/*
 * var_dot11WPA2KeysTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ieee802dot11 above.
 */
unsigned char  *
var_dot11WPA2KeysTable(struct variable *vp,
                       oid * name,
                       size_t *length,
                       int exact,
                       size_t *var_len, WriteMethod ** write_method)
{
    /*
     * variables we may use later 
     */
    static long     long_ret;
    static u_long   ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid      objid[MAX_OID_LEN];
    static struct counter64 c64;

	/*HF Add*/
	oid count_id[] = {6, 21};
	u_long table_size;
	u_long len;
	if(IOCTL_SNMP("wlan0", count_id, OID_COUNT_LEN, string, &len) == -1){
		//	snmp_log(LOG_INFO, "var_dot11StationConfigTable: IOCT_SNMP failed \n");
		return NULL;
	};
	table_size = *(string+1);
	/*HF Add End*/

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED)
        return NULL;

	/*HF*/
#define OID_WPA2KEY_LEN 5
	if(IOCTL_SNMP("wlan0", OID_TAIL(name), OID_WPA2KEY_LEN, string, &len) == -1){
		//snmp_log(LOG_INFO, "var_dot11WEPKeyMappingsTable: IOCT_SNMP failed \n");
		return NULL;
	};
	/*HF*/	

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT11WPA2KEYSINDEX:
        *write_method = write_dot11WPA2KeysIndex;
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *(string + 1);

		return (u_char *) &ulong_ret;

    case DOT11WPA2KEYSFORMAT:
        *write_method = write_dot11WPA2KeysFormat;
		apmib_get(MIB_WLAN_PSK_FORMAT, (void *)&ulong_ret);

		return (u_char *) &ulong_ret;

    case DOT11WPA2KEYSVALUE:
        *write_method = write_dot11WPA2KeysValue;
		apmib_get(MIB_WLAN_WPA_PSK, (void *)string);
		*var_len = strlen(string);

		return (u_char *) string;

    default:
        ERROR_MSG("");
    }
    return NULL;
}

/*
 * var_dot11RadiusServerTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ieee802dot11 above.
 */
unsigned char  *
var_dot11RadiusServerTable(struct variable *vp,
                           oid * name,
                           size_t *length,
                           int exact,
                           size_t *var_len, WriteMethod ** write_method)
{
    /*
     * variables we may use later 
     */
    static long     long_ret;
    static u_long   ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid      objid[MAX_OID_LEN];
    static struct counter64 c64;

	/*HF Add*/
	oid count_id[] = {6, 22};
	u_long table_size;
	u_long len;
	if(IOCTL_SNMP("wlan0", count_id, OID_COUNT_LEN, string, &len) == -1){
		//	snmp_log(LOG_INFO, "var_dot11StationConfigTable: IOCT_SNMP failed \n");
		return NULL;
	};
	table_size = *(string+1);
	/*HF Add End*/

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED)
        return NULL;

	/*HF*/
#define OID_RADIUSSERVER_LEN 5
	if(IOCTL_SNMP("wlan0", OID_TAIL(name), OID_RADIUSSERVER_LEN, string, &len) == -1){
		//snmp_log(LOG_INFO, "var_dot11WEPKeyMappingsTable: IOCT_SNMP failed \n");
		return NULL;
	};
	/*HF*/	

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT11RADIUSSERVERIPADDRESS:
        *write_method = write_dot11RadiusServerIPAddress;
		apmib_get(MIB_WLAN_RS_IP,&ulong_ret);
		return (u_char *) &ulong_ret;
		
    case DOT11RADIUSSERVERPORT:
        *write_method = write_dot11RadiusServerPort;
      	apmib_get(MIB_WLAN_RS_PORT,&ulong_ret);
		return (u_char *) &ulong_ret;
		
    case DOT11RADIUSSERVERPASSWORD:
        *write_method = write_dot11RadiusServerPassword;
        apmib_get(MIB_WLAN_RS_PASSWORD,(void *)string);
	*var_len = strlen(string);
        return (u_char *) string;
		
    default:
        ERROR_MSG("var_dot11RadiusServerTable,Error!");
    }
    return NULL;
}

/*
 * var_dot11OperationTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ieee802dot11 above.
 */
unsigned char  *
var_dot11OperationTable(struct variable *vp,
                        oid * name,
                        size_t *length,
                        int exact,
                        size_t *var_len, WriteMethod ** write_method)
{
    /*
     * variables we may use later 
     */
    static long     long_ret;
    static u_long   ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid      objid[MAX_OID_LEN];
    static struct counter64 c64;

	/*HF Add*/
	oid count_id[] = {6, 10};
	u_long table_size;
	u_long len;
	if(IOCTL_SNMP("wlan0", count_id, OID_COUNT_LEN, string, &len) == -1){
		//	snmp_log(LOG_INFO, "var_dot11StationConfigTable: IOCT_SNMP failed \n");
		return NULL;
	};
	table_size = *(string+1);
	/*HF Add End*/

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED)
        return NULL;

	/*HF*/
#define OID_OPERATION_LEN 5
	if(IOCTL_SNMP("wlan0", OID_TAIL(name), OID_OPERATION_LEN, string, &len) == -1){
		//snmp_log(LOG_INFO, "var_dot11WEPKeyMappingsTable: IOCT_SNMP failed \n");
		return NULL;
	};
	/*HF*/	

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT11MACADDRESS:
		*var_len = len - 1;
        return  (u_char *) string + 1;

    case DOT11RTSTHRESHOLD:
        *write_method = write_dot11RTSThreshold;
		apmib_get(MIB_WLAN_RTS_THRESHOLD, (void *)&ulong_ret);
		return (u_char *) &ulong_ret;

    case DOT11SHORTRETRYLIMIT:
        *write_method = write_dot11ShortRetryLimit;
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *((u_long *)(string + 1));

		return (u_char *) &ulong_ret;

    case DOT11LONGRETRYLIMIT:
        *write_method = write_dot11LongRetryLimit;
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *((u_long *)(string + 1));

		return (u_char *) &ulong_ret;

    case DOT11FRAGMENTATIONTHRESHOLD:
        *write_method = write_dot11FragmentationThreshold;
		apmib_get(MIB_WLAN_FRAG_THRESHOLD, (void *)&ulong_ret);
		return (u_char *) &ulong_ret;

    case DOT11MAXTRANSMITMSDULIFETIME:
        *write_method = write_dot11MaxTransmitMSDULifetime;
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *(string + 1);

		ulong_ret++;
		return (u_char *) &ulong_ret;

    case DOT11MAXRECEIVELIFETIME:
        *write_method = write_dot11MaxReceiveLifetime;
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *((u_long *)(string + 1));
		
		ulong_ret++;
		return (u_char *) &ulong_ret;

    case DOT11MANUFACTURERID:
		*var_len = len - 1;
        return  (u_char *) string + 1;

    case DOT11PRODUCTID:
		*var_len = len - 1;
        return  (u_char *) string + 1;

    case DOT11IAPPENABLE:
        *write_method = write_dot11IappEnable;
		apmib_get(MIB_WLAN_IAPP_DISABLED,&ulong_ret);
		return (u_char *) &ulong_ret;

    case DOT11BLOCKRELAY:
        *write_method = write_dot11BlockRelay;
		apmib_get(MIB_WLAN_BLOCK_RELAY,&ulong_ret);
		return (u_char *) &ulong_ret;

    case DOT11WIFISPECIFIC:
        *write_method = write_dot11WIFISpecific;
		apmib_get(MIB_WIFI_SPECIFIC,&ulong_ret);
		return (u_char *) &ulong_ret;

    case DOT11QOSENABLE:
        *write_method = write_dot11QosEnable;
		apmib_get(MIB_WLAN_WMM_ENABLED,&ulong_ret);
		return (u_char *) &ulong_ret;

    case DOT11NETWORKTYPE:
        *write_method = write_dot11NetworkType;
		apmib_get(MIB_WLAN_NETWORK_TYPE,&ulong_ret);
		return (u_char *) &ulong_ret;

    case DOT11LEDTYPE:
        *write_method = write_dot11LedType;
		apmib_get(MIB_HW_LED_TYPE,&ulong_ret);
		return (u_char *) &ulong_ret;

    case DOT11OPERATIONMODE:
        *write_method = write_dot11OperationMode;
		apmib_get(MIB_WLAN_MODE,&ulong_ret);
		return (u_char *) &ulong_ret;

    case DOT11BROADCASTSSID:
        *write_method = write_dot11BroadCastSSID;
		apmib_get(MIB_WLAN_HIDDEN_SSID,&ulong_ret);
		return (u_char *) &ulong_ret;

    case DOT11GUESTACCESS:
        *write_method = write_dot11GuestAccess;
		apmib_get(MIB_WLAN_ACCESS,&ulong_ret);
		return (u_char *) &ulong_ret;

    default:
        ERROR_MSG("var_dot11OperationTable,Error!");
    }
    return NULL;
}

/*
 * var_dot11CountersTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ieee802dot11 above.
 */
unsigned char  *
var_dot11CountersTable(struct variable *vp,
                       oid * name,
                       size_t *length,
                       int exact,
                       size_t *var_len, WriteMethod ** write_method)
{
    /*
     * variables we may use later 
     */
    static long     long_ret;
    static u_long   ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid      objid[MAX_OID_LEN];
    static struct counter64 c64;

	/*HF Add*/
	oid count_id[] = {6, 11};
	u_long table_size;
	u_long len;
	if(IOCTL_SNMP("wlan0", count_id, OID_COUNT_LEN, string, &len) == -1){
		//	snmp_log(LOG_INFO, "var_dot11StationConfigTable: IOCT_SNMP failed \n");
		return NULL;
	};
	table_size = *(string+1);
	/*HF Add End*/

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED)
        return NULL;

	/*HF*/
#define OID_COUNTERS_LEN 5
	if(IOCTL_SNMP("wlan0", OID_TAIL(name), OID_COUNTERS_LEN, string, &len) == -1){
		//snmp_log(LOG_INFO, "var_dot11WEPKeyMappingsTable: IOCT_SNMP failed \n");
		return NULL;
	};
	/*HF*/	

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT11TRANSMITTEDFRAGMENTCOUNT:
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *((u_long *)(string + 1));

		return (u_char *) &ulong_ret;

    case DOT11MULTICASTTRANSMITTEDFRAMECOUNT:
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *((u_long *)(string + 1));

		return (u_char *) &ulong_ret;

    case DOT11FAILEDCOUNT:
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *((u_long *)(string + 1));

		return (u_char *) &ulong_ret;

    case DOT11RETRYCOUNT:
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *((u_long *)(string + 1));

		return (u_char *) &ulong_ret;

    case DOT11MULTIPLERETRYCOUNT:
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *((u_long *)(string + 1));

		return (u_char *) &ulong_ret;

    case DOT11FRAMEDUPLICATECOUNT:
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *((u_long *)(string + 1));

		return (u_char *) &ulong_ret;

    case DOT11RTSSUCCESSCOUNT:
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *((u_long *)(string + 1));

		return (u_char *) &ulong_ret;

    case DOT11RTSFAILURECOUNT:
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *((u_long *)(string + 1));

		return (u_char *) &ulong_ret;

    case DOT11ACKFAILURECOUNT:
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *((u_long *)(string + 1));

		return (u_char *) &ulong_ret;

    case DOT11RECEIVEDFRAGMENTCOUNT:
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *((u_long *)(string + 1));

		return (u_char *) &ulong_ret;

    case DOT11MULTICASTRECEIVEDFRAMECOUNT:
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *((u_long *)(string + 1));

		return (u_char *) &ulong_ret;

    case DOT11FCSERRORCOUNT:
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *((u_long *)(string + 1));

		return (u_char *) &ulong_ret;

    case DOT11TRANSMITTEDFRAMECOUNT:
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *((u_long *)(string + 1));

		return (u_char *) &ulong_ret;

    case DOT11WEPUNDECRYPTABLECOUNT:
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *((u_long *)(string + 1));

		return (u_char *) &ulong_ret;

    default:
        ERROR_MSG("var_dot11CountersTable, Error!");
    }
    return NULL;
}

/*
 * var_dot11GroupAddressesTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ieee802dot11 above.
 */
unsigned char  *
var_dot11GroupAddressesTable(struct variable *vp,
                             oid * name,
                             size_t *length,
                             int exact,
                             size_t *var_len, WriteMethod ** write_method)
{
    /*
     * variables we may use later 
     */
    static long     long_ret;
    static u_long   ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid      objid[MAX_OID_LEN];
    static struct counter64 c64;

	/*HF Add*/
	oid count_id[] = {6, 12};
	u_long table_size;
	u_long len;
	if(IOCTL_SNMP("wlan0", count_id, OID_COUNT_LEN, string, &len) == -1){
		//	snmp_log(LOG_INFO, "var_dot11StationConfigTable: IOCT_SNMP failed \n");
		return NULL;
	};
	table_size = *(string+1);
	/*HF Add End*/

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED)
        return NULL;

	/*HF*/
#define OID_GROUPADDRESSES_LEN 5
	if(IOCTL_SNMP("wlan0", OID_TAIL(name), OID_GROUPADDRESSES_LEN, string, &len) == -1){
		//snmp_log(LOG_INFO, "var_dot11WEPKeyMappingsTable: IOCT_SNMP failed \n");
		return NULL;
	};
	/*HF*/	

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT11GROUPADDRESSESINDEX:
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *(string + 1);

		return (u_char *) &ulong_ret;

    case DOT11ADDRESS:
        *write_method = write_dot11Address;
		*var_len = len - 1;
        return  (u_char *) string + 1;

    case DOT11GROUPADDRESSESSTATUS:
        *write_method = write_dot11GroupAddressesStatus;
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *(string + 1);

		return (u_char *) &ulong_ret;

    default:
        ERROR_MSG("var_dot11GroupAddressesTable, Error!");
    }
    return NULL;
}

/*
 * var_dot11ResourceInfoTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ieee802dot11 above.
 */
unsigned char  *
var_dot11ResourceInfoTable(struct variable *vp,
                           oid * name,
                           size_t *length,
                           int exact,
                           size_t *var_len, WriteMethod ** write_method)
{
    /*
     * variables we may use later 
     */
    static long     long_ret;
    static u_long   ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid      objid[MAX_OID_LEN];
    static struct counter64 c64;

	/*HF Add*/
	oid count_id[] = {6, 13};
	u_long table_size;
	u_long len;
	if(IOCTL_SNMP("wlan0", count_id, OID_COUNT_LEN, string, &len) == -1){
		//	snmp_log(LOG_INFO, "var_dot11StationConfigTable: IOCT_SNMP failed \n");
		return NULL;
	};
	table_size = *(string+1);
	/*HF Add End*/

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED)
        return NULL;

	/*HF*/
#define OID_RESOURCEINFO_LEN 6
	if(IOCTL_SNMP("wlan0", OID_TAIL(name), OID_RESOURCEINFO_LEN, string, &len) == -1){
		//snmp_log(LOG_INFO, "var_dot11WEPKeyMappingsTable: IOCT_SNMP failed \n");
		return NULL;
	};
	/*HF*/	

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT11MANUFACTUREROUI:
		*var_len = len - 1;
        return  (u_char *) string + 1;

    case DOT11MANUFACTURERNAME:
		*var_len = len - 1;
        return  (u_char *) string + 1;

    case DOT11MANUFACTURERPRODUCTNAME:
		*var_len = len - 1;
        return  (u_char *) string + 1;

    case DOT11MANUFACTURERPRODUCTVERSION:
		*var_len = len - 1;
        return  (u_char *) string + 1;;
    default:
        ERROR_MSG("var_dot11ResourceInfoTable, Error!");
    }
    return NULL;
}

/*
 * var_dot11PhyOperationTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ieee802dot11 above.
 */
unsigned char  *
var_dot11PhyOperationTable(struct variable *vp,
                           oid * name,
                           size_t *length,
                           int exact,
                           size_t *var_len, WriteMethod ** write_method)
{
    /*
     * variables we may use later 
     */
    static long     long_ret;
    static u_long   ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid      objid[MAX_OID_LEN];
    static struct counter64 c64;

	/*HF Add*/
	oid count_id[] = {6, 14};
	u_long table_size;
	u_long len;
	if(IOCTL_SNMP("wlan0", count_id, OID_COUNT_LEN, string, &len) == -1){
		//	snmp_log(LOG_INFO, "var_dot11StationConfigTable: IOCT_SNMP failed \n");
		return NULL;
	};
	table_size = *(string+1);
	/*HF Add End*/

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED)
        return NULL;

	/*HF*/
#define OID_PHYOPERATION_LEN 5
	if(IOCTL_SNMP("wlan0", OID_TAIL(name), OID_PHYOPERATION_LEN, string, &len) == -1){
		//snmp_log(LOG_INFO, "var_dot11WEPKeyMappingsTable: IOCT_SNMP failed \n");
		return NULL;
	};
	/*HF*/	

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT11PHYTYPE:
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *(string + 1);

		return (u_char *) &ulong_ret;

    case DOT11CURRENTREGDOMAIN:
        *write_method = write_dot11CurrentRegDomain;
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *((u_long *)(string + 1));

		return (u_char *) &ulong_ret;

    case DOT11TEMPTYPE:
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *(string + 1);

		return (u_char *) &ulong_ret;

    case DOT11SHORTPREAMBLE:
        *write_method = write_dot11ShortPreamble;
		apmib_get(MIB_WLAN_PREAMBLE_TYPE,&ulong_ret);
		return (u_char *) &ulong_ret;

    case DOT11PHYBANDSELECT:
        *write_method = write_dot11PhyBandSelect;
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *(string + 1);

		return (u_char *) &ulong_ret;


    case DOT11TRSWITCH:
        *write_method = write_dot11TrSwitch;
		apmib_get(MIB_HW_11N_TRSWITCH,&ulong_ret);
		return (u_char *) &ulong_ret;

    case DOT11POWERSCALE:
        *write_method = write_dot11PowerScale;
		apmib_get(MIB_WLAN_RFPOWER_SCALE,&ulong_ret);
		return (u_char *) &ulong_ret;

    default:
        ERROR_MSG("var_dot11PhyOperationTable, Error!");
    }
    return NULL;
}

/*
 * var_dot11PhyAntennaTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ieee802dot11 above.
 */
unsigned char  *
var_dot11PhyAntennaTable(struct variable *vp,
                         oid * name,
                         size_t *length,
                         int exact,
                         size_t *var_len, WriteMethod ** write_method)
{
    /*
     * variables we may use later 
     */
    static long     long_ret;
    static u_long   ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid      objid[MAX_OID_LEN];
    static struct counter64 c64;

	/*HF Add*/
	oid count_id[] = {6, 15};
	u_long table_size;
	u_long len;
	if(IOCTL_SNMP("wlan0", count_id, OID_COUNT_LEN, string, &len) == -1){
		//	snmp_log(LOG_INFO, "var_dot11StationConfigTable: IOCT_SNMP failed \n");
		return NULL;
	};
	table_size = *(string+1);
	/*HF Add End*/

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED)
        return NULL;

	/*HF*/
#define OID_PHYANTENNA_LEN 5
	if(IOCTL_SNMP("wlan0", OID_TAIL(name), OID_PHYANTENNA_LEN, string, &len) == -1){
		//snmp_log(LOG_INFO, "var_dot11WEPKeyMappingsTable: IOCT_SNMP failed \n");
		return NULL;
	};
	/*HF*/	

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT11CURRENTTXANTENNA:
        *write_method = write_dot11CurrentTxAntenna;
		apmib_get( MIB_HW_TX_ANT, (void *)&ulong_ret);
		ulong_ret++;
//		snmp_log(LOG_INFO, "get_ulong_ret = %d \n",ulong_ret);
		return (u_char *) &ulong_ret;

    case DOT11DIVERSITYSUPPORT:
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *(string + 1);

		return (u_char *) &ulong_ret;

    case DOT11CURRENTRXANTENNA:
        *write_method = write_dot11CurrentRxAntenna;
		apmib_get(MIB_HW_TX_ANT, (void *)&ulong_ret);
		ulong_ret++;
//		snmp_log(LOG_INFO, "get_ulong_ret = %d \n",ulong_ret);		
		return (u_char *) &ulong_ret;

    default:
        ERROR_MSG("var_dot11PhyAntennaTable, Error!!!");
    }
    return NULL;
}

/*
 * var_dot11PhyTxPowerTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ieee802dot11 above.
 */
unsigned char  *
var_dot11PhyTxPowerTable(struct variable *vp,
                         oid * name,
                         size_t *length,
                         int exact,
                         size_t *var_len, WriteMethod ** write_method)
{
    /*
     * variables we may use later 
     */
    static long     long_ret;
    static u_long   ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid      objid[MAX_OID_LEN];
    static struct counter64 c64;

	/*HF Add*/
	oid count_id[] = {6, 16};
	u_long table_size;
	u_long len;
	if(IOCTL_SNMP("wlan0", count_id, OID_COUNT_LEN, string, &len) == -1){
		//	snmp_log(LOG_INFO, "var_dot11StationConfigTable: IOCT_SNMP failed \n");
		return NULL;
	};
	table_size = *(string+1);
	/*HF Add End*/

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED)
        return NULL;

	
	/*HF*/
#define OID_TXPOWER_LEN 5
	if(IOCTL_SNMP("wlan0", OID_TAIL(name), OID_TXPOWER_LEN, string, &len) == -1){
		//snmp_log(LOG_INFO, "var_dot11WEPKeyMappingsTable: IOCT_SNMP failed \n");
		return NULL;
	};
	/*HF*/	

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT11NUMBERSUPPORTEDPOWERLEVELS:
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *(string + 1);

		return (u_char *) &ulong_ret;

    case DOT11TXPOWERLEVEL1:
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *(string + 1);

		return (u_char *) &ulong_ret;

    case DOT11TXPOWERLEVEL2:
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *(string + 1);

		return (u_char *) &ulong_ret;

    case DOT11TXPOWERLEVEL3:
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *(string + 1);

		return (u_char *) &ulong_ret;

    case DOT11TXPOWERLEVEL4:
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *(string + 1);

		return (u_char *) &ulong_ret;

    case DOT11TXPOWERLEVEL5:
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *(string + 1);

		return (u_char *) &ulong_ret;

    case DOT11TXPOWERLEVEL6:
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *(string + 1);

		return (u_char *) &ulong_ret;

    case DOT11TXPOWERLEVEL7:
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *(string + 1);

		return (u_char *) &ulong_ret;

    case DOT11TXPOWERLEVEL8:
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *(string + 1);

		return (u_char *) &ulong_ret;

    case DOT11CURRENTTXPOWERLEVEL:
        *write_method = write_dot11CurrentTxPowerLevel;
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *(string + 1);

		return (u_char *) &ulong_ret;

    default:
        ERROR_MSG("var_dot11PhyTxPowerTable, Error!!!!");
    }
    return NULL;
}

/*
 * var_dot11PhyFHSSTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ieee802dot11 above.
 */
unsigned char  *
var_dot11PhyFHSSTable(struct variable *vp,
                      oid * name,
                      size_t *length,
                      int exact,
                      size_t *var_len, WriteMethod ** write_method)
{
    /*
     * variables we may use later 
     */
    static long     long_ret;
    static u_long   ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid      objid[MAX_OID_LEN];
    static struct counter64 c64;

	/*HF Add*/
	NO_SUCH_INSTANCE();
	/*HF Add End*/
	
    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, TABLE_SIZE)
        == MATCH_FAILED)
        return NULL;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT11HOPTIME:
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    case DOT11CURRENTCHANNELNUMBER:
        *write_method = write_dot11CurrentChannelNumber;
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    case DOT11MAXDWELLTIME:
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    case DOT11CURRENTDWELLTIME:
        *write_method = write_dot11CurrentDwellTime;
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    case DOT11CURRENTSET:
        *write_method = write_dot11CurrentSet;
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    case DOT11CURRENTPATTERN:
        *write_method = write_dot11CurrentPattern;
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    case DOT11CURRENTINDEX:
        *write_method = write_dot11CurrentIndex;
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    case DOT11EHCCPRIMERADIX:
        *write_method = write_dot11EHCCPrimeRadix;
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    case DOT11EHCCNUMBEROFCHANNELSFAMILYINDEX:
        *write_method = write_dot11EHCCNumberofChannelsFamilyIndex;
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    case DOT11EHCCCAPABILITYIMPLEMENTED:
        *write_method = write_dot11EHCCCapabilityImplemented;
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    case DOT11EHCCCAPABILITYENABLED:
        *write_method = write_dot11EHCCCapabilityEnabled;
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    case DOT11HOPALGORITHMADOPTED:
        *write_method = write_dot11HopAlgorithmAdopted;
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    case DOT11RANDOMTABLEFLAG:
        *write_method = write_dot11RandomTableFlag;
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    case DOT11NUMBEROFHOPPINGSETS:
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    case DOT11HOPMODULUS:
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    case DOT11HOPOFFSET:
        *write_method = write_dot11HopOffset;
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    default:
        ERROR_MSG("var_dot11PhyFHSSTable, Error!!!");
    }
    return NULL;
}

/*
 * var_dot11PhyDSSSTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ieee802dot11 above.
 */
unsigned char  *
var_dot11PhyDSSSTable(struct variable *vp,
                      oid * name,
                      size_t *length,
                      int exact,
                      size_t *var_len, WriteMethod ** write_method)
{
    /*
     * variables we may use later 
     */
    static long     long_ret;
    static u_long   ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid      objid[MAX_OID_LEN];
    static struct counter64 c64;

	/*HF Add*/
	oid count_id[] = {6, 17};
	u_long table_size;
	u_long len;
	if(IOCTL_SNMP("wlan0", count_id, OID_COUNT_LEN, string, &len) == -1){
		//	snmp_log(LOG_INFO, "var_dot11StationConfigTable: IOCT_SNMP failed \n");
		return NULL;
	};
	table_size = *(string+1);
	/*HF Add End*/

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED)
        return NULL;

	
	/*HF*/
#define OID_PHYANTENNA_LEN 5
	if(IOCTL_SNMP("wlan0", OID_TAIL(name), OID_PHYANTENNA_LEN, string, &len) == -1){
		//snmp_log(LOG_INFO, "var_dot11WEPKeyMappingsTable: IOCT_SNMP failed \n");
		return NULL;
	};
	/*HF*/	

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT11CURRENTCHANNEL:
        *write_method = write_dot11CurrentChannel;
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *((u_long *)(string + 1));

		return (u_char *) &ulong_ret;

    case DOT11CCAMODESUPPORTED:
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *((u_long *)(string + 1));

		return (u_char *) &ulong_ret;

    case DOT11CURRENTCCAMODE:
        *write_method = write_dot11CurrentCCAMode;
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *(string + 1);

		return (u_char *) &ulong_ret;

    case DOT11EDTHRESHOLD:
        *write_method = write_dot11EDThreshold;
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *(string + 1);

		return (u_char *) &ulong_ret;

    default:
        ERROR_MSG("var_dot11PhyDSSSTable: Error!!!\n");
    }
    return NULL;
}

/*
 * var_dot11PhyIRTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ieee802dot11 above.
 */
unsigned char  *
var_dot11PhyIRTable(struct variable *vp,
                    oid * name,
                    size_t *length,
                    int exact,
                    size_t *var_len, WriteMethod ** write_method)
{
    /*
     * variables we may use later 
     */
    static long     long_ret;
    static u_long   ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid      objid[MAX_OID_LEN];
    static struct counter64 c64;

	/*HF Add*/
	NO_SUCH_INSTANCE();
	/*HF Add End*/

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, TABLE_SIZE)
        == MATCH_FAILED)
        return NULL;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT11CCAWATCHDOGTIMERMAX:
        *write_method = write_dot11CCAWatchdogTimerMax;
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    case DOT11CCAWATCHDOGCOUNTMAX:
        *write_method = write_dot11CCAWatchdogCountMax;
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    case DOT11CCAWATCHDOGTIMERMIN:
        *write_method = write_dot11CCAWatchdogTimerMin;
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    case DOT11CCAWATCHDOGCOUNTMIN:
        *write_method = write_dot11CCAWatchdogCountMin;
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    default:
        ERROR_MSG("");
    }
    return NULL;
}

/*
 * var_dot11RegDomainsSupportedTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ieee802dot11 above.
 */
unsigned char  *
var_dot11RegDomainsSupportedTable(struct variable *vp,
                                  oid * name,
                                  size_t *length,
                                  int exact,
                                  size_t *var_len,
                                  WriteMethod ** write_method)
{
    /*
     * variables we may use later 
     */
    static long     long_ret;
    static u_long   ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid      objid[MAX_OID_LEN];
    static struct counter64 c64;

	/*HF Add*/
	oid count_id[] = {6, 18};
	u_long table_size;
	u_long len;
	if(IOCTL_SNMP("wlan0", count_id, OID_COUNT_LEN, string, &len) == -1){
		//	snmp_log(LOG_INFO, "var_dot11StationConfigTable: IOCT_SNMP failed \n");
		return NULL;
	};
	table_size = *(string+1);
	/*HF Add End*/

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED)
        return NULL;

	/*HF*/
#define OID_PHYANTENNA_LEN 5
	if(IOCTL_SNMP("wlan0", OID_TAIL(name), OID_PHYANTENNA_LEN, string, &len) == -1){
		//snmp_log(LOG_INFO, "var_dot11WEPKeyMappingsTable: IOCT_SNMP failed \n");
		return NULL;
	};
	/*HF*/	

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT11REGDOMAINSSUPPORTEDINDEX:
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *(string + 1);

		return (u_char *) &ulong_ret;

    case DOT11REGDOMAINSSUPPORTEDVALUE:
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *(string + 1);

		return (u_char *) &ulong_ret;

    default:
        ERROR_MSG("var_dot11RegDomainsSupportedTable: Error!!!\n");
    }
    return NULL;
}

/*
 * var_dot11AntennasListTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ieee802dot11 above.
 */
unsigned char  *
var_dot11AntennasListTable(struct variable *vp,
                           oid * name,
                           size_t *length,
                           int exact,
                           size_t *var_len, WriteMethod ** write_method)
{
    /*
     * variables we may use later 
     */
    static long     long_ret;
    static u_long   ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid      objid[MAX_OID_LEN];
    static struct counter64 c64;

	/*HF Add*/
	oid count_id[] = {6, 19};
	u_long table_size;
	u_long len;
	if(IOCTL_SNMP("wlan0", count_id, OID_COUNT_LEN, string, &len) == -1){
		//	snmp_log(LOG_INFO, "var_dot11StationConfigTable: IOCT_SNMP failed \n");
		return NULL;
	};
	table_size = *(string+1);
	/*HF Add End*/

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED)
        return NULL;

	/*HF*/
#define OID_ANTENNASLIST_LEN 5
	if(IOCTL_SNMP("wlan0", OID_TAIL(name), OID_ANTENNASLIST_LEN, string, &len) == -1){
		//snmp_log(LOG_INFO, "var_dot11WEPKeyMappingsTable: IOCT_SNMP failed \n");
		return NULL;
	};
	/*HF*/	

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT11ANTENNALISTINDEX:
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *(string + 1);

		return (u_char *) &ulong_ret;

    case DOT11SUPPORTEDTXANTENNA:
        *write_method = write_dot11SupportedTxAntenna;
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *(string + 1);

		return (u_char *) &ulong_ret;

    case DOT11SUPPORTEDRXANTENNA:
        *write_method = write_dot11SupportedRxAntenna;
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *(string + 1);

		return (u_char *) &ulong_ret;

    case DOT11DIVERSITYSELECTIONRX:
        *write_method = write_dot11DiversitySelectionRx;
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *(string + 1);

		return (u_char *) &ulong_ret;

    default:
        ERROR_MSG("var_dot11SupportedDataRatesTxTable: Error!!!\n");
    }
    return NULL;
}

/*
 * var_dot11SupportedDataRatesTxTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ieee802dot11 above.
 */
unsigned char  *
var_dot11SupportedDataRatesTxTable(struct variable *vp,
                                   oid * name,
                                   size_t *length,
                                   int exact,
                                   size_t *var_len,
                                   WriteMethod ** write_method)
{
    /*
     * variables we may use later 
     */
    static long     long_ret;
    static u_long   ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid      objid[MAX_OID_LEN];
    static struct counter64 c64;

	/*HF Add*/
	oid count_id[] = {6, 20};
	u_long table_size;
	u_long len;
	if(IOCTL_SNMP("wlan0", count_id, OID_COUNT_LEN, string, &len) == -1){
		//	snmp_log(LOG_INFO, "var_dot11StationConfigTable: IOCT_SNMP failed \n");
		return NULL;
	};
	table_size = *(string+1);
	/*HF Add End*/

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED)
        return NULL;

	
	
	/*HF*/
#define OID_SUPPORTEDDATARATESTX_LEN 5
	if(IOCTL_SNMP("wlan0", OID_TAIL(name), OID_SUPPORTEDDATARATESTX_LEN, string, &len) == -1){
		//snmp_log(LOG_INFO, "var_dot11WEPKeyMappingsTable: IOCT_SNMP failed \n");
		return NULL;
	};
	/*HF*/	

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT11SUPPORTEDDATARATESTXINDEX:
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *(string + 1);

		return (u_char *) &ulong_ret;

    case DOT11SUPPORTEDDATARATESTXVALUE:
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *(string + 1);

		return (u_char *) &ulong_ret;

    default:
        ERROR_MSG("var_dot11SupportedDataRatesTxTable: Error!!!\n");
    }
    return NULL;
}

/*
 * var_dot11SupportedDataRatesRxTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ieee802dot11 above.
 */
unsigned char  *
var_dot11SupportedDataRatesRxTable(struct variable *vp,
                                   oid * name,
                                   size_t *length,
                                   int exact,
                                   size_t *var_len,
                                   WriteMethod ** write_method)
{
    /*
     * variables we may use later 
     */
    static long     long_ret;
    static u_long   ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid      objid[MAX_OID_LEN];
    static struct counter64 c64;

	/*HF Add*/
	oid count_id[] = {6, 21};
	u_long table_size;
	u_long len;
	if(IOCTL_SNMP("wlan0", count_id, OID_COUNT_LEN, string, &len) == -1){
		//	snmp_log(LOG_INFO, "var_dot11StationConfigTable: IOCT_SNMP failed \n");
		return NULL;
	};
	table_size = *(string+1);
	/*HF Add End*/

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, table_size)
        == MATCH_FAILED)
        return NULL;

	/*HF*/
#define OID_SUPPORTEDDATARATESRX_LEN 5
	if(IOCTL_SNMP("wlan0", OID_TAIL(name), OID_SUPPORTEDDATARATESRX_LEN, string, &len) == -1){
		//snmp_log(LOG_INFO, "var_dot11WEPKeyMappingsTable: IOCT_SNMP failed \n");
		return NULL;
	};
	/*HF*/	

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT11SUPPORTEDDATARATESRXINDEX:
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *(string + 1);

		return (u_char *) &ulong_ret;

    case DOT11SUPPORTEDDATARATESRXVALUE:
		if(len == 1)
			ulong_ret = 0;
		else
			ulong_ret = *((u_long *)(string + 1));

		return (u_char *) &ulong_ret;

    default:
        ERROR_MSG("var_dot11SupportedDataRatesRxTable: Error!!!\n");
    }
    return NULL;
}

/*
 * var_dot11PhyOFDMTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ieee802dot11 above.
 */
unsigned char  *
var_dot11PhyOFDMTable(struct variable *vp,
                      oid * name,
                      size_t *length,
                      int exact,
                      size_t *var_len, WriteMethod ** write_method)
{
    /*
     * variables we may use later 
     */
    static long     long_ret;
    static u_long   ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid      objid[MAX_OID_LEN];
    static struct counter64 c64;

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, TABLE_SIZE)
        == MATCH_FAILED)
        return NULL;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT11CURRENTFREQUENCY:
        *write_method = write_dot11CurrentFrequency;
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    case DOT11TITHRESHOLD:
        *write_method = write_dot11TIThreshold;
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    case DOT11FREQUENCYBANDSSUPPORTED:
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    default:
        ERROR_MSG("");
    }
    return NULL;
}

/*
 * var_dot11PhyHRDSSSTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ieee802dot11 above.
 */
unsigned char  *
var_dot11PhyHRDSSSTable(struct variable *vp,
                        oid * name,
                        size_t *length,
                        int exact,
                        size_t *var_len, WriteMethod ** write_method)
{
    /*
     * variables we may use later 
     */
    static long     long_ret;
    static u_long   ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid      objid[MAX_OID_LEN];
    static struct counter64 c64;

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, TABLE_SIZE)
        == MATCH_FAILED)
        return NULL;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT11SHORTPREAMBLEOPTIONIMPLEMENTED:
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    case DOT11PBCCOPTIONIMPLEMENTED:
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    case DOT11CHANNELAGILITYPRESENT:
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    case DOT11CHANNELAGILITYENABLED:
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    case DOT11HRCCAMODESUPPORTED:
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    default:
        ERROR_MSG("");
    }
    return NULL;
}

/*
 * var_dot11HoppingPatternTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_ieee802dot11 above.
 */
unsigned char  *
var_dot11HoppingPatternTable(struct variable *vp,
                             oid * name,
                             size_t *length,
                             int exact,
                             size_t *var_len, WriteMethod ** write_method)
{
    /*
     * variables we may use later 
     */
    static long     long_ret;
    static u_long   ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid      objid[MAX_OID_LEN];
    static struct counter64 c64;

    /*
     * This assumes that the table is a 'simple' table.
     *  See the implementation documentation for the meaning of this.
     *  You will need to provide the correct value for the TABLE_SIZE parameter
     *
     * If this table does not meet the requirements for a simple table,
     *  you will need to provide the replacement code yourself.
     *  Mib2c is not smart enough to write this for you.
     *    Again, see the implementation documentation for what is required.
     */
    if (header_simple_table
        (vp, name, length, exact, var_len, write_method, TABLE_SIZE)
        == MATCH_FAILED)
        return NULL;

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case DOT11HOPPINGPATTERNINDEX:
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    case DOT11RANDOMTABLEFIELDNUMBER:
        *write_method = write_dot11RandomTableFieldNumber;
        VAR = VALUE;            /* XXX */
        return (u_char *) & VAR;
    default:
        ERROR_MSG("");
    }
    return NULL;
}


int
write_dot11StationID(int action,
                     u_char * var_val,
                     u_char var_val_type,
                     size_t var_val_len,
                     u_char * statP, oid * name, size_t name_len)
{
    char            value;
    int             size;
	int 			i;
	char			ucTmp[2]="F";

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to ieee802dot11 not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len != 12) {
            fprintf(stderr, "write to ieee802dot11 value is wrong\n");
            return SNMP_ERR_WRONGLENGTH;
        }

		for( i = 0 ; i < var_val_len ; i++ )
		{
			memcpy(ucTmp,&var_val[i],1);

			if( (*ucTmp >= 0x30 )&&( *ucTmp <= 0x39)|| 		// 0--9
				(*ucTmp >= 0x41 )&&( *ucTmp <= 0x46)|| 		// A--F
				(*ucTmp >= 0x61 )&&( *ucTmp <= 0x66))		// a--f
			{
//				snmp_log(LOG_INFO, "Continue\n");
				continue;
			}
			return SNMP_ERR_WRONGVALUE;
		}
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        var_val_len = _translateWordToByte( var_val ,var_val_len );
		apmib_set( MIB_WLAN_WLAN_MAC_ADDR,var_val );
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11MediumOccupancyLimit(int action,
                                u_char * var_val,
                                u_char var_val_type,
                                size_t var_val_len,
                                u_char * statP,
                                oid * name, size_t name_len)
{
    long            value;
    int             size;
	// not implement
    return SNMP_ERR_NOERROR;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11CFPPeriod(int action,
                     u_char * var_val,
                     u_char var_val_type,
                     size_t var_val_len,
                     u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
    return SNMP_ERR_NOERROR;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11CFPMaxDuration(int action,
                          u_char * var_val,
                          u_char var_val_type,
                          size_t var_val_len,
                          u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	// not implement
    return SNMP_ERR_NOERROR;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11AuthenticationResponseTimeOut(int action,
                                         u_char * var_val,
                                         u_char var_val_type,
                                         size_t var_val_len,
                                         u_char * statP,
                                         oid * name, size_t name_len)
{
    u_long          value;
    int             size;
	// not implement
    return SNMP_ERR_NOERROR;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_UNSIGNED) {
            fprintf(stderr, "write to ieee802dot11 not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11PowerManagementMode(int action,
                               u_char * var_val,
                               u_char var_val_type,
                               size_t var_val_len,
                               u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	// not implement
    return SNMP_ERR_NOERROR;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11DesiredSSID(int action,
                       u_char * var_val,
                       u_char var_val_type,
                       size_t var_val_len,
                       u_char * statP, oid * name, size_t name_len)
{
    char            value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to ieee802dot11 not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > 32 ) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
	var_val[ var_val_len ] = '\0';
	apmib_set(MIB_WLAN_SSID,var_val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11DesiredBSSType(int action,
                          u_char * var_val,
                          u_char var_val_type,
                          size_t var_val_len,
                          u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
//	 	snmp_log(LOG_INFO, "write_dot11DesiredBSSType: var_val = %d\n",*var_val);

		// translate between 8186 and agent
		// 8186                     agent
		// infrastructure---->0     ----->1
		// Ad hoc ----------->1     ----->2		
		value--;
		apmib_set( MIB_WLAN_NETWORK_TYPE,&value );
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11OperationalRateSet(int action,
                              u_char * var_val,
                              u_char var_val_type,
                              size_t var_val_len,
                              u_char * statP, oid * name, size_t name_len)
{
    char            value;
    int             size;
	u_long			ul_set;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to ieee802dot11 not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if ( (var_val_len % 2) != 0 ) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
		/*
        if (var_val_len > sizeof(char)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;
		*/
    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
		var_val_len = _translateWordToByte( var_val ,var_val_len );
		ul_set = _translateOperationRateTo8186( var_val ,var_val_len );
		snmp_log(LOG_INFO, "ul_set = %x\n",ul_set );		
		apmib_set(MIB_WLAN_SUPPORTED_RATES,(void *)&ul_set  );
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11BeaconPeriod(int action,
                        u_char * var_val,
                        u_char var_val_type,
                        size_t var_val_len,
                        u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;

	value = *(long *) var_val;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        apmib_set( MIB_WLAN_BEACON_INTERVAL,&value );
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11DTIMPeriod(int action,
                      u_char * var_val,
                      u_char var_val_type,
                      size_t var_val_len,
                      u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	value = *(long *) var_val;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */     
        apmib_set(MIB_WLAN_DTIM_PERIOD,&value);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11AssociationResponseTimeOut(int action,
                                      u_char * var_val,
                                      u_char var_val_type,
                                      size_t var_val_len,
                                      u_char * statP,
                                      oid * name, size_t name_len)
{
    u_long          value;
    int             size;
	// not implement
    return SNMP_ERR_NOERROR;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_UNSIGNED) {
            fprintf(stderr, "write to ieee802dot11 not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11MultiDomainCapabilityImplemented(int action,
                                            u_char * var_val,
                                            u_char var_val_type,
                                            size_t var_val_len,
                                            u_char * statP,
                                            oid * name, size_t name_len)
{
    long            value;
    int             size;
	// not implement
    return SNMP_ERR_NOERROR;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11MultiDomainCapabilityEnabled(int action,
                                        u_char * var_val,
                                        u_char var_val_type,
                                        size_t var_val_len,
                                        u_char * statP,
                                        oid * name, size_t name_len)
{
    long            value;
    int             size;
	// not implement
    return SNMP_ERR_NOERROR;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11RegDomain(int action,
                     u_char * var_val,
                     u_char var_val_type,
                     size_t var_val_len,
                     u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	value = *(long *) var_val;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        apmib_set(MIB_HW_REG_DOMAIN,&value);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11DataRate(int action,
                    u_char * var_val,
                    u_char var_val_type,
                    size_t var_val_len,
                    u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	value = *(long *) var_val;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        if(0 == value) {
		/*Set AutoRate*/
			int val=1;
			apmib_set(MIB_WLAN_RATE_ADAPTIVE_ENABLED,&val);
		} else {
		/*Set Fixed Rate*/
			int val=0;
			apmib_set(MIB_WLAN_RATE_ADAPTIVE_ENABLED,&val);
			apmib_set(MIB_WLAN_FIX_RATE,&value);
		}
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11ProtectionDisabled(int action,
                              u_char * var_val,
                              u_char var_val_type,
                              size_t var_val_len,
                              u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	value = *(long *) var_val;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        apmib_set(MIB_WLAN_PROTECTION_DISABLED,&value);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11nSTBC(int action,
                 u_char * var_val,
                 u_char var_val_type,
                 size_t var_val_len,
                 u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
    // not implement yet
    return SNMP_ERR_NOERROR;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11nCoexist(int action,
                    u_char * var_val,
                    u_char var_val_type,
                    size_t var_val_len,
                    u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
    // not implement yet
    return SNMP_ERR_NOERROR;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11nUse40M(int action,
                   u_char * var_val,
                   u_char var_val_type,
                   size_t var_val_len,
                   u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	value = *(long *) var_val;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        apmib_set(MIB_WLAN_CHANNEL_BONDING,&value);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11n2ndChOffset(int action,
                        u_char * var_val,
                        u_char var_val_type,
                        size_t var_val_len,
                        u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	value = *(long *) var_val;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        if(1 == value) {
			/*below*/
			value--;
		} else if(2 == value) {
			/*Above*/
			value --;
		}
		/*0 means don not care*/
        apmib_set(MIB_WLAN_CONTROL_SIDEBAND,&value);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11nShortGIfor20M(int action,
                          u_char * var_val,
                          u_char var_val_type,
                          size_t var_val_len,
                          u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	value = *(long *) var_val;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*Set ShortGI wherer 20M or 40M*/
		apmib_set(MIB_WLAN_SHORT_GI,&value);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11nShortGIfor40M(int action,
                          u_char * var_val,
                          u_char var_val_type,
                          size_t var_val_len,
                          u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	value = *(long *) var_val;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        /*Set ShortGI wherer 20M or 40M*/
		apmib_set(MIB_WLAN_SHORT_GI,&value);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11nAMPDU(int action,
                  u_char * var_val,
                  u_char var_val_type,
                  size_t var_val_len,
                  u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	value = *(long *) var_val;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
	{
        	int aggregation;
		apmib_get(MIB_WLAN_AGGREGATION,&aggregation);
		switch(aggregation) {
			case 0:
					/*ampdu 0 amsdu 0*/
					if(value)
						aggregation = 2;
					break;
			case 1:
					/*ampdu 1 amsdu 0*/
					if(value)
						aggregation = 3;
					break;
			case 2:
					/*ampdu 0 amsdu 1*/
					if(0 == value)
						aggregation = 0;
					break;
			case 3:
					/*ampdu 1 amsdu 1*/
					if(0 == value)
						aggregation = 1;
					break;
			default:
				break;
		}
		apmib_set(MIB_WLAN_AGGREGATION,&aggregation);
	}
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11nAMSDU(int action,
                  u_char * var_val,
                  u_char var_val_type,
                  size_t var_val_len,
                  u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	value = *(long *) var_val;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
	{
        	int aggregation;
		apmib_get(MIB_WLAN_AGGREGATION,&aggregation);
		switch(aggregation) {
			case 0:
					/*ampdu 0 amsdu 0*/
					if(value)
						aggregation = 1;
					break;
			case 1:
					/*ampdu 1 amsdu 0*/
					if(0 == value)
						aggregation = 0;
					break;
			case 2:
					/*ampdu 0 amsdu 1*/
					if(value)
						aggregation = 3;
					break;
			case 3:
					/*ampdu 1 amsdu 1*/
					if(0 == value)
						aggregation = 2;
					break;
			default:
				break;
		}
		apmib_set(MIB_WLAN_AGGREGATION,&aggregation);
	}
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11AuthenticationAlgorithmsEnable(int action,
                                          u_char * var_val,
                                          u_char var_val_type,
                                          size_t var_val_len,
                                          u_char * statP,
                                          oid * name, size_t name_len)
{
    long            value;
    int             size;
	int 			table_value,auth_type;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
     	value = *(long *) var_val;
		table_value = name[name_len-1];

		if( value == 0 )
		{
			if( table_value == 1 )
			{
				value = 2;
			}
			else
			{
				value = 1;
			}
			value = value - 1;
			apmib_set(MIB_WLAN_AUTH_TYPE,&value);				
		}
		else
		{
			apmib_get(MIB_WLAN_AUTH_TYPE, (void *)&auth_type);
			auth_type = auth_type + 1;
			auth_type = auth_type | table_value;
			auth_type = auth_type - 1;
			apmib_set(MIB_WLAN_AUTH_TYPE,&auth_type);
		}
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11WEPDefaultKeyValue(int action,
                              u_char * var_val,
                              u_char var_val_type,
                              size_t var_val_len,
                              u_char * statP, oid * name, size_t name_len)
{
    char            value;
    int             size;
	int 			wep_offset,wep;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to ieee802dot11 not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }

		apmib_get(MIB_WLAN_WEP, (void *)&wep);

		if( wep == 1 )
		{
	        if (var_val_len != 5 ) 
			{
	            fprintf(stderr, "write to ieee802dot11: bad length\n");
	            return SNMP_ERR_WRONGLENGTH;
		    }		
		}
		else
		{
	        if (var_val_len != 13 ) 
			{
	            fprintf(stderr, "write to ieee802dot11: bad length\n");
	            return SNMP_ERR_WRONGLENGTH;
        	}		
		}

        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        wep_offset = name[name_len-1] - 1;
		apmib_get(MIB_WLAN_WEP, (void *)&wep);
	//			snmp_log(LOG_INFO, "wep = %d\n",wep);
	//			snmp_log(LOG_INFO, "wep_offset = %d\n",wep_offset);
	//			snmp_log(LOG_INFO, "MIB_WLAN_WEP64_KEY1+wep_offset = %d\n",MIB_WLAN_WEP64_KEY1+wep_offset );
		if (wep == 1) 
		{
			apmib_set(MIB_WLAN_WEP64_KEY1+wep_offset ,var_val);
		}
		else
		{
			apmib_set(MIB_WLAN_WEP128_KEY1+wep_offset ,var_val);
		}
	//			*var_len = strlen(string);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11WEPKeyMappingAddress(int action,
                                u_char * var_val,
                                u_char var_val_type,
                                size_t var_val_len,
                                u_char * statP,
                                oid * name, size_t name_len)
{
    char            value;
    int             size;
	// not implement
    return SNMP_ERR_NOERROR;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to ieee802dot11 not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(char)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11WEPKeyMappingWEPOn(int action,
                              u_char * var_val,
                              u_char var_val_type,
                              size_t var_val_len,
                              u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	// not implement
    return SNMP_ERR_NOERROR;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11WEPKeyMappingValue(int action,
                              u_char * var_val,
                              u_char var_val_type,
                              size_t var_val_len,
                              u_char * statP, oid * name, size_t name_len)
{
    char            value;
    int             size;
	// not implement
    return SNMP_ERR_NOERROR;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to ieee802dot11 not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(char)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11WEPKeyMappingStatus(int action,
                               u_char * var_val,
                               u_char var_val_type,
                               size_t var_val_len,
                               u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	// not implement
    return SNMP_ERR_NOERROR;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11PrivacyInvoked(int action,
                          u_char * var_val,
                          u_char var_val_type,
                          size_t var_val_len,
                          u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	value = *(long *) var_val;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */		
        if( value != 0) value = 1;
			apmib_set( MIB_WLAN_ENCRYPT, &value );
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11WEPDefaultKeyID(int action,
                           u_char * var_val,
                           u_char var_val_type,
                           size_t var_val_len,
                           u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	value = *(long *) var_val;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */         
		apmib_set(MIB_WLAN_WEP_DEFAULT_KEY, (void *)&value);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11WEPKeyMappingLength(int action,
                               u_char * var_val,
                               u_char var_val_type,
                               size_t var_val_len,
                               u_char * statP, oid * name, size_t name_len)
{
    u_long          value;
    int             size;
	// not implement
    return SNMP_ERR_NOERROR;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_UNSIGNED) {
            fprintf(stderr, "write to ieee802dot11 not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11ExcludeUnencrypted(int action,
                              u_char * var_val,
                              u_char var_val_type,
                              size_t var_val_len,
                              u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	// not implement
    return SNMP_ERR_NOERROR;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11FirstChannelNumber(int action,
                              u_char * var_val,
                              u_char var_val_type,
                              size_t var_val_len,
                              u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	// not implement
    return SNMP_ERR_NOERROR;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11NumberofChannels(int action,
                            u_char * var_val,
                            u_char var_val_type,
                            size_t var_val_len,
                            u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	// not implement
    return SNMP_ERR_NOERROR;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11MaximumTransmitPowerLevel(int action,
                                     u_char * var_val,
                                     u_char var_val_type,
                                     size_t var_val_len,
                                     u_char * statP,
                                     oid * name, size_t name_len)
{
    long            value;
    int             size;
	// not implement
    return SNMP_ERR_NOERROR;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11WPAKeysIndex(int action,
                        u_char * var_val,
                        u_char var_val_type,
                        size_t var_val_len,
                        u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	// not implement
    return SNMP_ERR_NOERROR;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11WPAKeysFormat(int action,
                         u_char * var_val,
                         u_char var_val_type,
                         size_t var_val_len,
                         u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	value = *(long *) var_val;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        apmib_set(MIB_WLAN_PSK_FORMAT,&value);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11WPAKeysValue(int action,
                        u_char * var_val,
                        u_char var_val_type,
                        size_t var_val_len,
                        u_char * statP, oid * name, size_t name_len)
{
    char            value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to ieee802dot11 not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len < 8) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        apmib_set(MIB_WLAN_WPA_PSK,var_val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11WPA2KeysIndex(int action,
                         u_char * var_val,
                         u_char var_val_type,
                         size_t var_val_len,
                         u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	// not implement
    return SNMP_ERR_NOERROR;
	
    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11WPA2KeysFormat(int action,
                          u_char * var_val,
                          u_char var_val_type,
                          size_t var_val_len,
                          u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	value = *(long *) var_val;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        apmib_set(MIB_WLAN_PSK_FORMAT,&value);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11WPA2KeysValue(int action,
                         u_char * var_val,
                         u_char var_val_type,
                         size_t var_val_len,
                         u_char * statP, oid * name, size_t name_len)
{
    char            value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to ieee802dot11 not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len < 8) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
         
        apmib_set(MIB_WLAN_WPA_PSK,var_val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11RadiusServerIPAddress(int action,
                                 u_char * var_val,
                                 u_char var_val_type,
                                 size_t var_val_len,
                                 u_char * statP,
                                 oid * name, size_t name_len)
{
    in_addr_t       value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_IPADDRESS) {
            fprintf(stderr, "write to ieee802dot11 not ASN_IPADDRESS\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(in_addr_t)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(in_addr_t *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        apmib_set(MIB_WLAN_RS_IP,var_val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11RadiusServerPort(int action,
                            u_char * var_val,
                            u_char var_val_type,
                            size_t var_val_len,
                            u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	value = *(long *) var_val;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        apmib_set(MIB_WLAN_RS_PORT,&value);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11RadiusServerPassword(int action,
                                u_char * var_val,
                                u_char var_val_type,
                                size_t var_val_len,
                                u_char * statP,
                                oid * name, size_t name_len)
{
    char            value;
    int             size;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to ieee802dot11 not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len < 4) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        apmib_set(MIB_WLAN_RS_PASSWORD,var_val);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11RTSThreshold(int action,
                        u_char * var_val,
                        u_char var_val_type,
                        size_t var_val_len,
                        u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	value = *(long *) var_val;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        apmib_set(MIB_WLAN_RTS_THRESHOLD,&value);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11ShortRetryLimit(int action,
                           u_char * var_val,
                           u_char var_val_type,
                           size_t var_val_len,
                           u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	// not implement
    return SNMP_ERR_NOERROR;


    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11LongRetryLimit(int action,
                          u_char * var_val,
                          u_char var_val_type,
                          size_t var_val_len,
                          u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	// not implement
    return SNMP_ERR_NOERROR;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11FragmentationThreshold(int action,
                                  u_char * var_val,
                                  u_char var_val_type,
                                  size_t var_val_len,
                                  u_char * statP,
                                  oid * name, size_t name_len)
{
    long            value;
    int             size;
	value = *(long *) var_val;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */        
		apmib_set(MIB_WLAN_FRAG_THRESHOLD, &value);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11MaxTransmitMSDULifetime(int action,
                                   u_char * var_val,
                                   u_char var_val_type,
                                   size_t var_val_len,
                                   u_char * statP,
                                   oid * name, size_t name_len)
{
    u_long          value;
    int             size;
	// not implement
    return SNMP_ERR_NOERROR;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_UNSIGNED) {
            fprintf(stderr, "write to ieee802dot11 not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11MaxReceiveLifetime(int action,
                              u_char * var_val,
                              u_char var_val_type,
                              size_t var_val_len,
                              u_char * statP, oid * name, size_t name_len)
{
    u_long          value;
    int             size;
	// not implement
    return SNMP_ERR_NOERROR;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_UNSIGNED) {
            fprintf(stderr, "write to ieee802dot11 not ASN_UNSIGNED\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(u_long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(u_long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11IappEnable(int action,
                      u_char * var_val,
                      u_char var_val_type,
                      size_t var_val_len,
                      u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	value = *(long *) var_val;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        apmib_set(MIB_WLAN_IAPP_DISABLED,&value);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11BlockRelay(int action,
                      u_char * var_val,
                      u_char var_val_type,
                      size_t var_val_len,
                      u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	value = *(long *) var_val;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        apmib_set(MIB_WLAN_BLOCK_RELAY,&value);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11WIFISpecific(int action,
                        u_char * var_val,
                        u_char var_val_type,
                        size_t var_val_len,
                        u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	value = *(long *) var_val;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        apmib_set(MIB_WIFI_SPECIFIC,&value);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11QosEnable(int action,
                     u_char * var_val,
                     u_char var_val_type,
                     size_t var_val_len,
                     u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	value = *(long *) var_val;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        apmib_set(MIB_WLAN_WMM_ENABLED,&value);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11NetworkType(int action,
                       u_char * var_val,
                       u_char var_val_type,
                       size_t var_val_len,
                       u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	value = *(long *) var_val;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        apmib_set(MIB_WLAN_NETWORK_TYPE,&value);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11LedType(int action,
                   u_char * var_val,
                   u_char var_val_type,
                   size_t var_val_len,
                   u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	value = *(long *) var_val;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        apmib_set(MIB_HW_LED_TYPE,&value);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11OperationMode(int action,
                         u_char * var_val,
                         u_char var_val_type,
                         size_t var_val_len,
                         u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	value = *(long *) var_val;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        apmib_set(MIB_WLAN_MODE,&value);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11BroadCastSSID(int action,
                         u_char * var_val,
                         u_char var_val_type,
                         size_t var_val_len,
                         u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	value = *(long *) var_val;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        apmib_set(MIB_WLAN_HIDDEN_SSID,&value);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11GuestAccess(int action,
                       u_char * var_val,
                       u_char var_val_type,
                       size_t var_val_len,
                       u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	value = *(long *) var_val;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        apmib_set(MIB_WLAN_ACCESS,&value);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11Address(int action,
                   u_char * var_val,
                   u_char var_val_type,
                   size_t var_val_len,
                   u_char * statP, oid * name, size_t name_len)
{
    char            value;
    int             size;
	// not implement
    return SNMP_ERR_NOERROR;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_OCTET_STR) {
            fprintf(stderr, "write to ieee802dot11 not ASN_OCTET_STR\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(char)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(char *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11GroupAddressesStatus(int action,
                                u_char * var_val,
                                u_char var_val_type,
                                size_t var_val_len,
                                u_char * statP,
                                oid * name, size_t name_len)
{
    long            value;
    int             size;
	// not implement
    return SNMP_ERR_NOERROR;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11CurrentRegDomain(int action,
                            u_char * var_val,
                            u_char var_val_type,
                            size_t var_val_len,
                            u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	// not implement
    return SNMP_ERR_NOERROR;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11ShortPreamble(int action,
                         u_char * var_val,
                         u_char var_val_type,
                         size_t var_val_len,
                         u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	value = *(long *) var_val;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        apmib_set(MIB_WLAN_PREAMBLE_TYPE,&value);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11PhyBandSelect(int action,
                         u_char * var_val,
                         u_char var_val_type,
                         size_t var_val_len,
                         u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	// not implement
    return SNMP_ERR_NOERROR;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11TrSwitch(int action,
                    u_char * var_val,
                    u_char var_val_type,
                    size_t var_val_len,
                    u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	value = *(long *) var_val;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        apmib_set(MIB_HW_11N_TRSWITCH,&value);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11PowerScale(int action,
                      u_char * var_val,
                      u_char var_val_type,
                      size_t var_val_len,
                      u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	value = *(long *) var_val;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        apmib_set(MIB_WLAN_RFPOWER_SCALE,&value);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11CurrentTxAntenna(int action,
                            u_char * var_val,
                            u_char var_val_type,
                            size_t var_val_len,
                            u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	value = *(long *) var_val;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        value--;
		apmib_set(MIB_HW_TX_ANT,(void *)&value);
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11CurrentRxAntenna(int action,
                            u_char * var_val,
                            u_char var_val_type,
                            size_t var_val_len,
                            u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	value = *(long *) var_val;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        value--;
		apmib_set(MIB_HW_TX_ANT,(void *)&value); 
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11CurrentTxPowerLevel(int action,
                               u_char * var_val,
                               u_char var_val_type,
                               size_t var_val_len,
                               u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;

	// not implement
    return SNMP_ERR_NOERROR;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11CurrentChannelNumber(int action,
                                u_char * var_val,
                                u_char var_val_type,
                                size_t var_val_len,
                                u_char * statP,
                                oid * name, size_t name_len)
{
    long            value;
    int             size;
	// not implement
    return SNMP_ERR_NOERROR;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11CurrentDwellTime(int action,
                            u_char * var_val,
                            u_char var_val_type,
                            size_t var_val_len,
                            u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	// not implement
    return SNMP_ERR_NOERROR;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11CurrentSet(int action,
                      u_char * var_val,
                      u_char var_val_type,
                      size_t var_val_len,
                      u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	// not implement
    return SNMP_ERR_NOERROR;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11CurrentPattern(int action,
                          u_char * var_val,
                          u_char var_val_type,
                          size_t var_val_len,
                          u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	// not implement
    return SNMP_ERR_NOERROR;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11CurrentIndex(int action,
                        u_char * var_val,
                        u_char var_val_type,
                        size_t var_val_len,
                        u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	// not implement
    return SNMP_ERR_NOERROR;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11EHCCPrimeRadix(int action,
                          u_char * var_val,
                          u_char var_val_type,
                          size_t var_val_len,
                          u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	// not implement
    return SNMP_ERR_NOERROR;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11EHCCNumberofChannelsFamilyIndex(int action,
                                           u_char * var_val,
                                           u_char var_val_type,
                                           size_t var_val_len,
                                           u_char * statP,
                                           oid * name, size_t name_len)
{
    long            value;
    int             size;
	// not implement
    return SNMP_ERR_NOERROR;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11EHCCCapabilityImplemented(int action,
                                     u_char * var_val,
                                     u_char var_val_type,
                                     size_t var_val_len,
                                     u_char * statP,
                                     oid * name, size_t name_len)
{
    long            value;
    int             size;
	// not implement
    return SNMP_ERR_NOERROR;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11EHCCCapabilityEnabled(int action,
                                 u_char * var_val,
                                 u_char var_val_type,
                                 size_t var_val_len,
                                 u_char * statP,
                                 oid * name, size_t name_len)
{
    long            value;
    int             size;
	// not implement
    return SNMP_ERR_NOERROR;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11HopAlgorithmAdopted(int action,
                               u_char * var_val,
                               u_char var_val_type,
                               size_t var_val_len,
                               u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	// not implement
    return SNMP_ERR_NOERROR;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11RandomTableFlag(int action,
                           u_char * var_val,
                           u_char var_val_type,
                           size_t var_val_len,
                           u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	// not implement
    return SNMP_ERR_NOERROR;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11HopOffset(int action,
                     u_char * var_val,
                     u_char var_val_type,
                     size_t var_val_len,
                     u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	// not implement
    return SNMP_ERR_NOERROR;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11CurrentChannel(int action,
                          u_char * var_val,
                          u_char var_val_type,
                          size_t var_val_len,
                          u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	// not implement
    return SNMP_ERR_NOERROR;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11CurrentCCAMode(int action,
                          u_char * var_val,
                          u_char var_val_type,
                          size_t var_val_len,
                          u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	// not implement
    return SNMP_ERR_NOERROR;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11EDThreshold(int action,
                       u_char * var_val,
                       u_char var_val_type,
                       size_t var_val_len,
                       u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	// not implement
    return SNMP_ERR_NOERROR;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11CCAWatchdogTimerMax(int action,
                               u_char * var_val,
                               u_char var_val_type,
                               size_t var_val_len,
                               u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	// not implement
    return SNMP_ERR_NOERROR;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11CCAWatchdogCountMax(int action,
                               u_char * var_val,
                               u_char var_val_type,
                               size_t var_val_len,
                               u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	// not implement
    return SNMP_ERR_NOERROR;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11CCAWatchdogTimerMin(int action,
                               u_char * var_val,
                               u_char var_val_type,
                               size_t var_val_len,
                               u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	// not implement
    return SNMP_ERR_NOERROR;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11CCAWatchdogCountMin(int action,
                               u_char * var_val,
                               u_char var_val_type,
                               size_t var_val_len,
                               u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	// not implement
    return SNMP_ERR_NOERROR;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11SupportedTxAntenna(int action,
                              u_char * var_val,
                              u_char var_val_type,
                              size_t var_val_len,
                              u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	// not implement
    return SNMP_ERR_NOERROR;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11SupportedRxAntenna(int action,
                              u_char * var_val,
                              u_char var_val_type,
                              size_t var_val_len,
                              u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	// not implement
    return SNMP_ERR_NOERROR;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11DiversitySelectionRx(int action,
                                u_char * var_val,
                                u_char var_val_type,
                                size_t var_val_len,
                                u_char * statP,
                                oid * name, size_t name_len)
{
    long            value;
    int             size;
	// not implement
    return SNMP_ERR_NOERROR;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11CurrentFrequency(int action,
                            u_char * var_val,
                            u_char var_val_type,
                            size_t var_val_len,
                            u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	// not implement
    return SNMP_ERR_NOERROR;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11TIThreshold(int action,
                       u_char * var_val,
                       u_char var_val_type,
                       size_t var_val_len,
                       u_char * statP, oid * name, size_t name_len)
{
    long            value;
    int             size;
	// not implement
    return SNMP_ERR_NOERROR;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_dot11RandomTableFieldNumber(int action,
                                  u_char * var_val,
                                  u_char var_val_type,
                                  size_t var_val_len,
                                  u_char * statP,
                                  oid * name, size_t name_len)
{
    long            value;
    int             size;
	// not implement
    return SNMP_ERR_NOERROR;

    switch (action) {
    case RESERVE1:
        if (var_val_type != ASN_INTEGER) {
            fprintf(stderr, "write to ieee802dot11 not ASN_INTEGER\n");
            return SNMP_ERR_WRONGTYPE;
        }
        if (var_val_len > sizeof(long)) {
            fprintf(stderr, "write to ieee802dot11: bad length\n");
            return SNMP_ERR_WRONGLENGTH;
        }
        break;

    case RESERVE2:
        size = var_val_len;
        value = *(long *) var_val;

        break;

    case FREE:
        /*
         * Release any resources that have been allocated 
         */
        break;

    case ACTION:
        /*
         * The variable has been stored in 'value' for you to use,
         * and you have just been asked to do something with it.
         * Note that anything done here must be reversable in the UNDO case
         */
        break;

    case UNDO:
        /*
         * Back out any changes made in the ACTION case 
         */
        break;

    case COMMIT:
        /*
         * Things are working well, so it's now safe to make the change
         * permanently.  Make sure that anything done here can't fail!
         */
        break;
    }
    return SNMP_ERR_NOERROR;
}
