/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf 11805 2005-01-07 09:37:18Z dts12 $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "TRENDnet.h"
#include "apmib.h"
#include "mibtbl.h"
#include <unistd.h>
#include <netinet/in.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <signal.h>
#include <fcntl.h>
#include <errno.h>
#include <linux/wireless.h>
#include <linux/if_arp.h>
#include <linux/if_ether.h>
#include <linux/if_packet.h>
#include <time.h>
#include <sys/time.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

/*
 *	IOCTL to under layer WLAN driver.
 */
#define SIOCGSNMPMIB 		0x8B3D
#define MAX_DATA_SIZE 		1024

static int iw_get_ext(
			int                  skfd,           /* Socket to the kernel */
			char                 *ifname,        /* Device name */
			int                  request,        /* WE ID */
			struct iwreq         *pwrq)          /* Fixed part of the request */
{
	/* Set device name */
	strncpy(pwrq->ifr_name, ifname, IFNAMSIZ);
	
	/* Do the request */
	return(ioctl(skfd, request, pwrq));
}

static int get_wlan_snmpmib(char *interface, oid *oid, size_t oid_len, unsigned char *out, unsigned long *out_len) 
{
	int 			i;
	int				skfd;
	unsigned char	data[MAX_DATA_SIZE];
	unsigned long	data_len;
	struct iwreq 	wrq;
	
    skfd = socket(AF_INET, SOCK_DGRAM, 0);

    /* Get wireless name */
	if (iw_get_ext(skfd, interface, SIOCGIWNAME, &wrq) < 0) {
		/* If no wireless name : no wireless extensions */
		close(skfd);
        return -1;
    }

	data_len = 0;
	for(i = 0; i < oid_len; i++) {
	    data_len += sprintf(data + data_len, "%d.", oid[i]);
	}
	data[data_len] = '\0';

    wrq.u.data.pointer = (caddr_t)data;
    wrq.u.data.length = (size_t)data_len;
    if (iw_get_ext(skfd, interface, SIOCGSNMPMIB, &wrq) < 0) {
    	close(skfd);
		return -1;
	}
    
    /* First byte is the $(VAL_TYPE) */
    wrq.u.data.length--;
    if (!wrq.u.data.length) {
    	*out_len = 0;
    } else {
	    if (wrq.u.data.length > *out_len) {
	    	memcpy(out, (data+1), *out_len);
	    } else {
	    	memcpy(out, (data+1), wrq.u.data.length);
	    	*out_len = wrq.u.data.length;
	    }
	}
    close(skfd);
	return 1;
}

/*
 *	translate a string for Rate setting to 2byte format to match APMIB format.
 */
static int _translateOperationlRateToIEEE(int rate_set, char *ret_value)
{
	int dot = 0;
	char *p = ret_value;

	if (rate_set & TX_RATE_1M) {
		p += sprintf(p, "2");	
		dot = 1;
	}
	if (rate_set & TX_RATE_2M) {
		if (dot == 1) {
			p += sprintf(p, ",");
		}
		p += sprintf(p, "4");
		dot = 1;	
	}
	if (rate_set & TX_RATE_5M) {
		if (dot == 1) {
			p += sprintf(p, ",");
		}
		p += sprintf(p, "11");
		dot = 1;	
	}
	if (rate_set & TX_RATE_6M) {
		if (dot == 1) {
			p += sprintf(p, ",");
		}
		p += sprintf(p, "12");
		dot = 1;	
	}
	if (rate_set & TX_RATE_9M) {
		if (dot == 1) {
			p += sprintf(p, ",");
		}
		p += sprintf(p, "18");
		dot = 1;	
	}
	if (rate_set & TX_RATE_11M) {
		if (dot == 1) {
			p += sprintf(p, ",");
		}
		p += sprintf(p, "22");
		dot = 1;	
	}
	if (rate_set & TX_RATE_12M) {
		if (dot == 1) {
			p += sprintf(p, ",");
		}
		p += sprintf(p, "24");
		dot = 1;	
	}
	if (rate_set & TX_RATE_18M) {
		if (dot == 1) {
			p += sprintf(p, ",");
		}
		p += sprintf(p, "36");
		dot = 1;	
	}
	if (rate_set & TX_RATE_24M) {
		if (dot == 1) {
			p += sprintf(p, ",");
		}
		p += sprintf(p, "48");
		dot = 1;	
	}
	if (rate_set & TX_RATE_36M) {
		if (dot == 1) {
			p += sprintf(p, ",");
		}
		p += sprintf(p, "72");
		dot = 1;	
	}
	if (rate_set & TX_RATE_48M) {
		if (dot == 1) {
			p += sprintf(p, ",");
		}
		p += sprintf(p, "96");
		dot = 1;	
	}
	if (rate_set & TX_RATE_54M) {
		if (dot == 1) {
			p += sprintf(p, ",");
		}
		p += sprintf(p, "108");
	}
	
	return (p - ret_value);
}
	
	
/** Initializes the TRENDnet module */
void
init_TRENDnet(void)
{
    static oid      enterpriseAPSysConfigSave_oid[] =
        { 1, 3, 6, 1, 4, 1, 28866, 4, 1, 1, 1 };
    static oid      enterpriseAPSysReboot_oid[] =
        { 1, 3, 6, 1, 4, 1, 28866, 4, 1, 1, 2 };
    static oid      enterpriseAPSysConfigApply_oid[] =
        { 1, 3, 6, 1, 4, 1, 28866, 4, 1, 1, 3 };
    static oid      dot11StationID_oid[] =
        { 1, 3, 6, 1, 4, 1, 28866, 4, 1, 3, 1, 1, 1 };
    static oid      dot11PrivacyOptionImplemented_oid[] =
        { 1, 3, 6, 1, 4, 1, 28866, 4, 1, 3, 1, 1, 2 };
    static oid      dot11DesiredSSID_oid[] =
        { 1, 3, 6, 1, 4, 1, 28866, 4, 1, 3, 1, 1, 3 };
    static oid      dot11DesiredBSSType_oid[] =
        { 1, 3, 6, 1, 4, 1, 28866, 4, 1, 3, 1, 1, 4 };
    static oid      dot11OperationalRateSet_oid[] =
        { 1, 3, 6, 1, 4, 1, 28866, 4, 1, 3, 1, 1, 5 };
    static oid      dot11BeaconPeriod_oid[] =
        { 1, 3, 6, 1, 4, 1, 28866, 4, 1, 3, 1, 1, 6 };
    static oid      dot11DTIMPeriod_oid[] =
        { 1, 3, 6, 1, 4, 1, 28866, 4, 1, 3, 1, 1, 7 };
    static oid      dot11AuthenticationAlgorithm_oid[] =
        { 1, 3, 6, 1, 4, 1, 28866, 4, 1, 3, 1, 3, 1 };
    static oid      dot11PrivacyInvoked_oid[] =
        { 1, 3, 6, 1, 4, 1, 28866, 4, 1, 3, 1, 3, 2 };
    static oid      dot11WEPDefaultKeyID_oid[] =
        { 1, 3, 6, 1, 4, 1, 28866, 4, 1, 3, 1, 3, 3 };
    static oid      dot11WEPKeyLength_oid[] =
        { 1, 3, 6, 1, 4, 1, 28866, 4, 1, 3, 1, 3, 4 };
    static oid      dot11WEPKeyMappingLength_oid[] =
        { 1, 3, 6, 1, 4, 1, 28866, 4, 1, 3, 1, 3, 5 };
    static oid      dot11ExcludeUnencrypted_oid[] =
        { 1, 3, 6, 1, 4, 1, 28866, 4, 1, 3, 1, 3, 6 };
    static oid      dot11WEPICVErrorCount_oid[] =
        { 1, 3, 6, 1, 4, 1, 28866, 4, 1, 3, 1, 3, 7 };
    static oid      dot11WEPExcludedCount_oid[] =
        { 1, 3, 6, 1, 4, 1, 28866, 4, 1, 3, 1, 3, 8 };
    static oid      dot11DisassociateReason_oid[] =
        { 1, 3, 6, 1, 4, 1, 28866, 4, 1, 3, 1, 4, 1 };
    static oid      dot11DisassociateStation_oid[] =
        { 1, 3, 6, 1, 4, 1, 28866, 4, 1, 3, 1, 4, 2 };
    static oid      dot11DeauthenticateReason_oid[] =
        { 1, 3, 6, 1, 4, 1, 28866, 4, 1, 3, 1, 4, 3 };
    static oid      dot11DeauthenticateStation_oid[] =
        { 1, 3, 6, 1, 4, 1, 28866, 4, 1, 3, 1, 4, 4 };
    static oid      dot11AuthenticateFailStatus_oid[] =
        { 1, 3, 6, 1, 4, 1, 28866, 4, 1, 3, 1, 4, 5 };
    static oid      dot11AuthenticateFailStation_oid[] =
        { 1, 3, 6, 1, 4, 1, 28866, 4, 1, 3, 1, 4, 6 };
    static oid      dot11MACAddress_oid[] =
        { 1, 3, 6, 1, 4, 1, 28866, 4, 1, 3, 2, 1, 1 };
    static oid      dot11RTSThreshold_oid[] =
        { 1, 3, 6, 1, 4, 1, 28866, 4, 1, 3, 2, 1, 2 };
    static oid      dot11ShortRetryLimit_oid[] =
        { 1, 3, 6, 1, 4, 1, 28866, 4, 1, 3, 2, 1, 3 };
    static oid      dot11LongRetryLimit_oid[] =
        { 1, 3, 6, 1, 4, 1, 28866, 4, 1, 3, 2, 1, 4 };
    static oid      dot11FragmentationThreshold_oid[] =
        { 1, 3, 6, 1, 4, 1, 28866, 4, 1, 3, 2, 1, 5 };
    static oid      dot11SSIDBroadcast_oid[] =
        { 1, 3, 6, 1, 4, 1, 28866, 4, 1, 3, 2, 1, 6 };
    static oid      dot11PreambleType_oid[] =
        { 1, 3, 6, 1, 4, 1, 28866, 4, 1, 3, 2, 1, 7 };
    static oid      dot11MaxTransmitMSDULifetime_oid[] =
        { 1, 3, 6, 1, 4, 1, 28866, 4, 1, 3, 2, 1, 8 };
    static oid      dot11MaxReceiveLifetime_oid[] =
        { 1, 3, 6, 1, 4, 1, 28866, 4, 1, 3, 2, 1, 9 };
    static oid      dot11ManufacturerID_oid[] =
        { 1, 3, 6, 1, 4, 1, 28866, 4, 1, 3, 2, 1, 10 };
    static oid      dot11ProductID_oid[] =
        { 1, 3, 6, 1, 4, 1, 28866, 4, 1, 3, 2, 1, 11 };
    static oid      dot11TransmittedFragmentCount_oid[] =
        { 1, 3, 6, 1, 4, 1, 28866, 4, 1, 3, 2, 2, 1 };
    static oid      dot11MulticastTransmittedFrameCount_oid[] =
        { 1, 3, 6, 1, 4, 1, 28866, 4, 1, 3, 2, 2, 2 };
    static oid      dot11FailedCount_oid[] =
        { 1, 3, 6, 1, 4, 1, 28866, 4, 1, 3, 2, 2, 3 };
    static oid      dot11RetryCount_oid[] =
        { 1, 3, 6, 1, 4, 1, 28866, 4, 1, 3, 2, 2, 4 };
    static oid      dot11MultipleRetryCount_oid[] =
        { 1, 3, 6, 1, 4, 1, 28866, 4, 1, 3, 2, 2, 5 };
    static oid      dot11FrameDuplicateCount_oid[] =
        { 1, 3, 6, 1, 4, 1, 28866, 4, 1, 3, 2, 2, 6 };
    static oid      dot11RTSSuccessCount_oid[] =
        { 1, 3, 6, 1, 4, 1, 28866, 4, 1, 3, 2, 2, 7 };
    static oid      dot11RTSFailureCount_oid[] =
        { 1, 3, 6, 1, 4, 1, 28866, 4, 1, 3, 2, 2, 8 };
    static oid      dot11ACKFailureCount_oid[] =
        { 1, 3, 6, 1, 4, 1, 28866, 4, 1, 3, 2, 2, 9 };
    static oid      dot11ReceivedFragmentCount_oid[] =
        { 1, 3, 6, 1, 4, 1, 28866, 4, 1, 3, 2, 2, 10 };
    static oid      dot11MulticastReceivedFrameCount_oid[] =
        { 1, 3, 6, 1, 4, 1, 28866, 4, 1, 3, 2, 2, 11 };
    static oid      dot11FCSErrorCount_oid[] =
        { 1, 3, 6, 1, 4, 1, 28866, 4, 1, 3, 2, 2, 12 };
    static oid      dot11TransmittedFrameCount_oid[] =
        { 1, 3, 6, 1, 4, 1, 28866, 4, 1, 3, 2, 2, 13 };
    static oid      dot11WEPUndecryptableCount_oid[] =
        { 1, 3, 6, 1, 4, 1, 28866, 4, 1, 3, 2, 2, 14 };
    static oid      dot11manufacturerOUI_oid[] =
        { 1, 3, 6, 1, 4, 1, 28866, 4, 1, 3, 3, 1, 1, 1 };
    static oid      dot11manufacturerName_oid[] =
        { 1, 3, 6, 1, 4, 1, 28866, 4, 1, 3, 3, 1, 1, 2 };
    static oid      dot11manufacturerProductName_oid[] =
        { 1, 3, 6, 1, 4, 1, 28866, 4, 1, 3, 3, 1, 1, 3 };
    static oid      dot11manufacturerProductVersion_oid[] =
        { 1, 3, 6, 1, 4, 1, 28866, 4, 1, 3, 3, 1, 1, 4 };
    static oid      dot11CurrentRegDomain_oid[] =
        { 1, 3, 6, 1, 4, 1, 28866, 4, 1, 3, 4, 1, 1 };
    static oid      dot11SupportedDataRatesTxValue_oid[] =
        { 1, 3, 6, 1, 4, 1, 28866, 4, 1, 3, 4, 1, 2 };
    static oid      dot11SupportedDataRatesRxValue_oid[] =
        { 1, 3, 6, 1, 4, 1, 28866, 4, 1, 3, 4, 1, 3 };
    static oid      dot11CurrentTxRate_oid[] =
        { 1, 3, 6, 1, 4, 1, 28866, 4, 1, 3, 4, 1, 4 };
    static oid      dot11CurrentTxAntenna_oid[] =
        { 1, 3, 6, 1, 4, 1, 28866, 4, 1, 3, 4, 2, 1 };
    static oid      dot11DiversitySupport_oid[] =
        { 1, 3, 6, 1, 4, 1, 28866, 4, 1, 3, 4, 2, 2 };
    static oid      dot11CurrentRxAntenna_oid[] =
        { 1, 3, 6, 1, 4, 1, 28866, 4, 1, 3, 4, 2, 3 };
    static oid      dot11CurrentChannel_oid[] =
        { 1, 3, 6, 1, 4, 1, 28866, 4, 1, 3, 4, 3, 1 };
    static oid      dot11ShortPreambleOptionImplemented_oid[] =
        { 1, 3, 6, 1, 4, 1, 28866, 4, 1, 3, 4, 3, 2 };

    DEBUGMSGTL(("TRENDnet", "Initializing\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("enterpriseAPSysConfigSave",
                             handle_enterpriseAPSysConfigSave,
                             enterpriseAPSysConfigSave_oid,
                             OID_LENGTH(enterpriseAPSysConfigSave_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("enterpriseAPSysReboot",
                             handle_enterpriseAPSysReboot,
                             enterpriseAPSysReboot_oid,
                             OID_LENGTH(enterpriseAPSysReboot_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("enterpriseAPSysConfigApply",
                             handle_enterpriseAPSysConfigApply,
                             enterpriseAPSysConfigApply_oid,
                             OID_LENGTH(enterpriseAPSysConfigApply_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dot11StationID", handle_dot11StationID,
                             dot11StationID_oid,
                             OID_LENGTH(dot11StationID_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dot11PrivacyOptionImplemented",
                             handle_dot11PrivacyOptionImplemented,
                             dot11PrivacyOptionImplemented_oid,
                             OID_LENGTH(dot11PrivacyOptionImplemented_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dot11DesiredSSID", handle_dot11DesiredSSID,
                             dot11DesiredSSID_oid,
                             OID_LENGTH(dot11DesiredSSID_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dot11DesiredBSSType",
                             handle_dot11DesiredBSSType,
                             dot11DesiredBSSType_oid,
                             OID_LENGTH(dot11DesiredBSSType_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dot11OperationalRateSet",
                             handle_dot11OperationalRateSet,
                             dot11OperationalRateSet_oid,
                             OID_LENGTH(dot11OperationalRateSet_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dot11BeaconPeriod", handle_dot11BeaconPeriod,
                             dot11BeaconPeriod_oid,
                             OID_LENGTH(dot11BeaconPeriod_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dot11DTIMPeriod", handle_dot11DTIMPeriod,
                             dot11DTIMPeriod_oid,
                             OID_LENGTH(dot11DTIMPeriod_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dot11AuthenticationAlgorithm",
                             handle_dot11AuthenticationAlgorithm,
                             dot11AuthenticationAlgorithm_oid,
                             OID_LENGTH(dot11AuthenticationAlgorithm_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dot11PrivacyInvoked",
                             handle_dot11PrivacyInvoked,
                             dot11PrivacyInvoked_oid,
                             OID_LENGTH(dot11PrivacyInvoked_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dot11WEPDefaultKeyID",
                             handle_dot11WEPDefaultKeyID,
                             dot11WEPDefaultKeyID_oid,
                             OID_LENGTH(dot11WEPDefaultKeyID_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dot11WEPKeyLength", handle_dot11WEPKeyLength,
                             dot11WEPKeyLength_oid,
                             OID_LENGTH(dot11WEPKeyLength_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dot11WEPKeyMappingLength",
                             handle_dot11WEPKeyMappingLength,
                             dot11WEPKeyMappingLength_oid,
                             OID_LENGTH(dot11WEPKeyMappingLength_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dot11ExcludeUnencrypted",
                             handle_dot11ExcludeUnencrypted,
                             dot11ExcludeUnencrypted_oid,
                             OID_LENGTH(dot11ExcludeUnencrypted_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dot11WEPICVErrorCount",
                             handle_dot11WEPICVErrorCount,
                             dot11WEPICVErrorCount_oid,
                             OID_LENGTH(dot11WEPICVErrorCount_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dot11WEPExcludedCount",
                             handle_dot11WEPExcludedCount,
                             dot11WEPExcludedCount_oid,
                             OID_LENGTH(dot11WEPExcludedCount_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dot11DisassociateReason",
                             handle_dot11DisassociateReason,
                             dot11DisassociateReason_oid,
                             OID_LENGTH(dot11DisassociateReason_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dot11DisassociateStation",
                             handle_dot11DisassociateStation,
                             dot11DisassociateStation_oid,
                             OID_LENGTH(dot11DisassociateStation_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dot11DeauthenticateReason",
                             handle_dot11DeauthenticateReason,
                             dot11DeauthenticateReason_oid,
                             OID_LENGTH(dot11DeauthenticateReason_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dot11DeauthenticateStation",
                             handle_dot11DeauthenticateStation,
                             dot11DeauthenticateStation_oid,
                             OID_LENGTH(dot11DeauthenticateStation_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dot11AuthenticateFailStatus",
                             handle_dot11AuthenticateFailStatus,
                             dot11AuthenticateFailStatus_oid,
                             OID_LENGTH(dot11AuthenticateFailStatus_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dot11AuthenticateFailStation",
                             handle_dot11AuthenticateFailStation,
                             dot11AuthenticateFailStation_oid,
                             OID_LENGTH(dot11AuthenticateFailStation_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dot11MACAddress", handle_dot11MACAddress,
                             dot11MACAddress_oid,
                             OID_LENGTH(dot11MACAddress_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dot11RTSThreshold", handle_dot11RTSThreshold,
                             dot11RTSThreshold_oid,
                             OID_LENGTH(dot11RTSThreshold_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dot11ShortRetryLimit",
                             handle_dot11ShortRetryLimit,
                             dot11ShortRetryLimit_oid,
                             OID_LENGTH(dot11ShortRetryLimit_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dot11LongRetryLimit",
                             handle_dot11LongRetryLimit,
                             dot11LongRetryLimit_oid,
                             OID_LENGTH(dot11LongRetryLimit_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dot11FragmentationThreshold",
                             handle_dot11FragmentationThreshold,
                             dot11FragmentationThreshold_oid,
                             OID_LENGTH(dot11FragmentationThreshold_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dot11SSIDBroadcast",
                             handle_dot11SSIDBroadcast,
                             dot11SSIDBroadcast_oid,
                             OID_LENGTH(dot11SSIDBroadcast_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dot11PreambleType", handle_dot11PreambleType,
                             dot11PreambleType_oid,
                             OID_LENGTH(dot11PreambleType_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dot11MaxTransmitMSDULifetime",
                             handle_dot11MaxTransmitMSDULifetime,
                             dot11MaxTransmitMSDULifetime_oid,
                             OID_LENGTH(dot11MaxTransmitMSDULifetime_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dot11MaxReceiveLifetime",
                             handle_dot11MaxReceiveLifetime,
                             dot11MaxReceiveLifetime_oid,
                             OID_LENGTH(dot11MaxReceiveLifetime_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dot11ManufacturerID",
                             handle_dot11ManufacturerID,
                             dot11ManufacturerID_oid,
                             OID_LENGTH(dot11ManufacturerID_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dot11ProductID", handle_dot11ProductID,
                             dot11ProductID_oid,
                             OID_LENGTH(dot11ProductID_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dot11TransmittedFragmentCount",
                             handle_dot11TransmittedFragmentCount,
                             dot11TransmittedFragmentCount_oid,
                             OID_LENGTH(dot11TransmittedFragmentCount_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dot11MulticastTransmittedFrameCount",
                             handle_dot11MulticastTransmittedFrameCount,
                             dot11MulticastTransmittedFrameCount_oid,
                             OID_LENGTH
                             (dot11MulticastTransmittedFrameCount_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dot11FailedCount", handle_dot11FailedCount,
                             dot11FailedCount_oid,
                             OID_LENGTH(dot11FailedCount_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dot11RetryCount", handle_dot11RetryCount,
                             dot11RetryCount_oid,
                             OID_LENGTH(dot11RetryCount_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dot11MultipleRetryCount",
                             handle_dot11MultipleRetryCount,
                             dot11MultipleRetryCount_oid,
                             OID_LENGTH(dot11MultipleRetryCount_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dot11FrameDuplicateCount",
                             handle_dot11FrameDuplicateCount,
                             dot11FrameDuplicateCount_oid,
                             OID_LENGTH(dot11FrameDuplicateCount_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dot11RTSSuccessCount",
                             handle_dot11RTSSuccessCount,
                             dot11RTSSuccessCount_oid,
                             OID_LENGTH(dot11RTSSuccessCount_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dot11RTSFailureCount",
                             handle_dot11RTSFailureCount,
                             dot11RTSFailureCount_oid,
                             OID_LENGTH(dot11RTSFailureCount_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dot11ACKFailureCount",
                             handle_dot11ACKFailureCount,
                             dot11ACKFailureCount_oid,
                             OID_LENGTH(dot11ACKFailureCount_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dot11ReceivedFragmentCount",
                             handle_dot11ReceivedFragmentCount,
                             dot11ReceivedFragmentCount_oid,
                             OID_LENGTH(dot11ReceivedFragmentCount_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dot11MulticastReceivedFrameCount",
                             handle_dot11MulticastReceivedFrameCount,
                             dot11MulticastReceivedFrameCount_oid,
                             OID_LENGTH
                             (dot11MulticastReceivedFrameCount_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dot11FCSErrorCount",
                             handle_dot11FCSErrorCount,
                             dot11FCSErrorCount_oid,
                             OID_LENGTH(dot11FCSErrorCount_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dot11TransmittedFrameCount",
                             handle_dot11TransmittedFrameCount,
                             dot11TransmittedFrameCount_oid,
                             OID_LENGTH(dot11TransmittedFrameCount_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dot11WEPUndecryptableCount",
                             handle_dot11WEPUndecryptableCount,
                             dot11WEPUndecryptableCount_oid,
                             OID_LENGTH(dot11WEPUndecryptableCount_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dot11manufacturerOUI",
                             handle_dot11manufacturerOUI,
                             dot11manufacturerOUI_oid,
                             OID_LENGTH(dot11manufacturerOUI_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dot11manufacturerName",
                             handle_dot11manufacturerName,
                             dot11manufacturerName_oid,
                             OID_LENGTH(dot11manufacturerName_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dot11manufacturerProductName",
                             handle_dot11manufacturerProductName,
                             dot11manufacturerProductName_oid,
                             OID_LENGTH(dot11manufacturerProductName_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dot11manufacturerProductVersion",
                             handle_dot11manufacturerProductVersion,
                             dot11manufacturerProductVersion_oid,
                             OID_LENGTH
                             (dot11manufacturerProductVersion_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dot11CurrentRegDomain",
                             handle_dot11CurrentRegDomain,
                             dot11CurrentRegDomain_oid,
                             OID_LENGTH(dot11CurrentRegDomain_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dot11SupportedDataRatesTxValue",
                             handle_dot11SupportedDataRatesTxValue,
                             dot11SupportedDataRatesTxValue_oid,
                             OID_LENGTH
                             (dot11SupportedDataRatesTxValue_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dot11SupportedDataRatesRxValue",
                             handle_dot11SupportedDataRatesRxValue,
                             dot11SupportedDataRatesRxValue_oid,
                             OID_LENGTH
                             (dot11SupportedDataRatesRxValue_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dot11CurrentTxRate",
                             handle_dot11CurrentTxRate,
                             dot11CurrentTxRate_oid,
                             OID_LENGTH(dot11CurrentTxRate_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dot11CurrentTxAntenna",
                             handle_dot11CurrentTxAntenna,
                             dot11CurrentTxAntenna_oid,
                             OID_LENGTH(dot11CurrentTxAntenna_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dot11DiversitySupport",
                             handle_dot11DiversitySupport,
                             dot11DiversitySupport_oid,
                             OID_LENGTH(dot11DiversitySupport_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dot11CurrentRxAntenna",
                             handle_dot11CurrentRxAntenna,
                             dot11CurrentRxAntenna_oid,
                             OID_LENGTH(dot11CurrentRxAntenna_oid),
                             HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dot11CurrentChannel",
                             handle_dot11CurrentChannel,
                             dot11CurrentChannel_oid,
                             OID_LENGTH(dot11CurrentChannel_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("dot11ShortPreambleOptionImplemented",
                             handle_dot11ShortPreambleOptionImplemented,
                             dot11ShortPreambleOptionImplemented_oid,
                             OID_LENGTH
                             (dot11ShortPreambleOptionImplemented_oid),
                             HANDLER_CAN_RONLY));

    /* Don't forget to initialize APMIB !! */                             
    apmib_init();                         
}

int
handle_enterpriseAPSysConfigSave(netsnmp_mib_handler *handler,
                                 netsnmp_handler_registration *reginfo,
                                 netsnmp_agent_request_info *reqinfo,
                                 netsnmp_request_info *requests)
{
    int             ret;
    int             value;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
    	netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        ret = netsnmp_check_vb_int_range(requests->requestvb, 1, 1);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */
        if (0 /* XXX if malloc, or whatever, failed: */ ) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_RESOURCEUNAVAILABLE);
        }
        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */
        if (!apmib_update(CURRENT_SETTING)) {
            netsnmp_set_request_error(reqinfo, requests, /* some error */
                                      SNMP_ERR_GENERR);
        }
        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */
        if (0 /* XXX: error? */ ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */
        if (0 /* XXX: error? */ ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_UNDOFAILED);
        }
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_enterpriseAPSysConfigSave\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_enterpriseAPSysReboot(netsnmp_mib_handler *handler,
                             netsnmp_handler_registration *reginfo,
                             netsnmp_agent_request_info *reqinfo,
                             netsnmp_request_info *requests)
{
    int             ret;
    int             value;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
    	netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        ret = netsnmp_check_vb_int_range(requests->requestvb, 1, 1);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */
        if (0 /* XXX if malloc, or whatever, failed: */ ) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_RESOURCEUNAVAILABLE);
        }
        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */
        if (system("reboot") == -1) {
            netsnmp_set_request_error(reqinfo, requests, /* some error */
                                      SNMP_ERR_GENERR);
        }
        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */
        if (0 /* XXX: error? */ ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */
        if (0 /* XXX: error? */ ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_UNDOFAILED);
        }
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_enterpriseAPSysReboot\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_enterpriseAPSysConfigApply(netsnmp_mib_handler *handler,
                                  netsnmp_handler_registration *reginfo,
                                  netsnmp_agent_request_info *reqinfo,
                                  netsnmp_request_info *requests)
{
    int             ret;
    int             value;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        ret = netsnmp_check_vb_int_range(requests->requestvb, 1, 1);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */
        if (0 /* XXX if malloc, or whatever, failed: */ ) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_RESOURCEUNAVAILABLE);
        }
        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */
        if (!apmib_update(CURRENT_SETTING) || (system("reboot") == -1)) {
            netsnmp_set_request_error(reqinfo, requests, /* some error */
                                      SNMP_ERR_GENERR);
        }
        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */
        if (0 /* XXX: error? */ ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */
        if (0 /* XXX: error? */ ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_UNDOFAILED);
        }
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_enterpriseAPSysConfigApply\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dot11StationID(netsnmp_mib_handler *handler,
                      netsnmp_handler_registration *reginfo,
                      netsnmp_agent_request_info *reqinfo,
                      netsnmp_request_info *requests)
{
    unsigned char   data[6];
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
    	if (!apmib_get(MIB_HW_WLAN_ADDR, (void *)data)) {
    		netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
    	}
    	else {
        	snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *)data, sizeof(data));
        }
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_dot11StationID\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dot11PrivacyOptionImplemented(netsnmp_mib_handler *handler,
                                     netsnmp_handler_registration *reginfo,
                                     netsnmp_agent_request_info *reqinfo,
                                     netsnmp_request_info *requests)
{
    int             value;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
    	value = TV_TRUE;
   		snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&value, sizeof(value));
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_dot11PrivacyOptionImplemented\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dot11DesiredSSID(netsnmp_mib_handler *handler,
                        netsnmp_handler_registration *reginfo,
                        netsnmp_agent_request_info *reqinfo,
                        netsnmp_request_info *requests)
{
    int             ret;
    char            value[33];
    static char     reserved_value[33];
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
    	if (!apmib_get(MIB_WLAN_SSID, (void *)value)) {
    		netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
    	}
    	else {
        	snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *)value, strlen(value));
        }
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        ret = netsnmp_check_vb_type_and_max_size(requests->requestvb, ASN_OCTET_STR, 32);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */
     	if (!apmib_get(MIB_WLAN_SSID, (void *)reserved_value)) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_RESOURCEUNAVAILABLE);
    	}
        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */
        memcpy(value, requests->requestvb->val.string, requests->requestvb->val_len);
        value[requests->requestvb->val_len] = '\0';
        if (!apmib_set(MIB_WLAN_SSID, (void *)value)) {
            netsnmp_set_request_error(reqinfo, requests, /* some error */
                                      SNMP_ERR_GENERR);
        }         
        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */
        if (0 /* XXX: error? */ ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */
        if (!apmib_set(MIB_WLAN_SSID, (void *)reserved_value)) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_UNDOFAILED);
        }
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_dot11DesiredSSID\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dot11DesiredBSSType(netsnmp_mib_handler *handler,
                           netsnmp_handler_registration *reginfo,
                           netsnmp_agent_request_info *reqinfo,
                           netsnmp_request_info *requests)
{
	int             value;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
    	if (!apmib_get(MIB_WLAN_NETWORK_TYPE, (void *)&value)) {
    		netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
    	}
    	else {
    		if (value == INFRASTRUCTURE) {
    			value = 1;
    		} else if (value == ADHOC) {
    			value = 2;
    		} else {
    			netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_GENERR);
    		}
        	snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&value, sizeof(value));
        }
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_dot11DesiredBSSType\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dot11OperationalRateSet(netsnmp_mib_handler *handler,
                               netsnmp_handler_registration *reginfo,
                               netsnmp_agent_request_info *reqinfo,
                               netsnmp_request_info *requests)
{
	int             ret;
	char			value[127];
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
    	if (!apmib_get(MIB_WLAN_SUPPORTED_RATE, (void *)&ret)) {
    		netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
    	}
    	else {
    		ret = _translateOperationlRateToIEEE(ret, value);
        	snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *)value, (size_t)ret);
        }
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_dot11OperationalRateSet\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dot11BeaconPeriod(netsnmp_mib_handler *handler,
                         netsnmp_handler_registration *reginfo,
                         netsnmp_agent_request_info *reqinfo,
                         netsnmp_request_info *requests)
{
    int             ret;
    int             value;
    static int      reserved_value;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
     	if (!apmib_get(MIB_WLAN_BEACON_INTERVAL, (void *)&value)) {
    		netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
    	}
    	else {
        	snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&value, sizeof(value));
        }
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        ret = netsnmp_check_vb_int_range(requests->requestvb, 20, 1000);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */
     	if (!apmib_get(MIB_WLAN_BEACON_INTERVAL, (void *)&reserved_value)) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_RESOURCEUNAVAILABLE);
    	}
        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */
        value = *requests->requestvb->val.integer; 
        if (!apmib_set(MIB_WLAN_BEACON_INTERVAL, (void *)&value)) {
            netsnmp_set_request_error(reqinfo, requests, /* some error */
                                      SNMP_ERR_GENERR);
        }
        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */
        if (0 /* XXX: error? */ ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */
        if (!apmib_set(MIB_WLAN_BEACON_INTERVAL, (void *)&reserved_value)) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_UNDOFAILED);
        }
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_dot11BeaconPeriod\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dot11DTIMPeriod(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info *reqinfo,
                       netsnmp_request_info *requests)
{
    int             ret;
    int             value;
    static int      reserved_value;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
     	if (!apmib_get(MIB_WLAN_DTIM_PERIOD, (void *)&value)) {
    		netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
    	}
    	else {
        	snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&value, sizeof(value));
        }
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        ret = netsnmp_check_vb_int_range(requests->requestvb, 1, 255);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */
        if (!apmib_get(MIB_WLAN_DTIM_PERIOD, (void *)&reserved_value)) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_RESOURCEUNAVAILABLE);
        }
        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */
        value = *requests->requestvb->val.integer;
        if (!apmib_set(MIB_WLAN_DTIM_PERIOD, (void *)&value)) {
            netsnmp_set_request_error(reqinfo, requests, /* some error */
                                      SNMP_ERR_GENERR);
        }
        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */
        if (0 /* XXX: error? */ ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */
        if (!apmib_set(MIB_WLAN_DTIM_PERIOD, (void *)&reserved_value)) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_UNDOFAILED);
        }
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_dot11DTIMPeriod\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dot11AuthenticationAlgorithm(netsnmp_mib_handler *handler,
                                    netsnmp_handler_registration *reginfo,
                                    netsnmp_agent_request_info *reqinfo,
                                    netsnmp_request_info *requests)
{
    int             ret;
    int             value;
    static int      reserved_value;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */
	// APMIB                    SNMP MIB
	// Open System ------> 0    -----> 1
	// Shared Key -------> 1    -----> 2
	// Auto -------------> 2    -----> !? 		

    switch (reqinfo->mode) {

    case MODE_GET:
     	if (!apmib_get(MIB_WLAN_AUTH_TYPE, (void *)&value)) {
    		netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
    	}
    	else {
    		if (value == 0) {
    			value = 1;
    		} else if (value == 1) {
    			value = 2;
    		} else {
    			/* XXX auto !? */
    			value = 1;
    		}
        	snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&value, sizeof(value));
        }
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        ret = netsnmp_check_vb_int_range(requests->requestvb, 1, 2);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */
        if (!apmib_get(MIB_WLAN_AUTH_TYPE, (void *)&reserved_value)) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_RESOURCEUNAVAILABLE);
        }
        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */
        value = *requests->requestvb->val.integer;
        if (!apmib_set(MIB_WLAN_AUTH_TYPE, (void *)&value)) {
            netsnmp_set_request_error(reqinfo, requests, /* some error */
                                      SNMP_ERR_GENERR);
        }
        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */
        if (0 /* XXX: error? */ ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */
        if (!apmib_set(MIB_WLAN_AUTH_TYPE, (void *)&reserved_value)) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_UNDOFAILED);
        }
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_dot11AuthenticationAlgorithm\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dot11PrivacyInvoked(netsnmp_mib_handler *handler,
                           netsnmp_handler_registration *reginfo,
                           netsnmp_agent_request_info *reqinfo,
                           netsnmp_request_info *requests)
{
    int             ret;
    int             value;
    static int      reserved_value;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
     	if (!apmib_get(MIB_WLAN_ENCRYPT, (void *)&value)) {
    		netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
    	}
    	else {
    		if (value == ENCRYPT_WEP) {
    			value = TV_TRUE;
    		} else {
    			value = TV_FALSE;
    		}
    		/*
    		if (value != ENCRYPT_DISABLED) {
    			value = TV_TRUE;
    		} else {
    			value = TV_FALSE;
    		}
    		*/
        	snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&value, sizeof(value));
        }
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        ret = netsnmp_check_vb_truthvalue(requests->requestvb);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */
        if (!apmib_get(MIB_WLAN_ENCRYPT, (void *)&reserved_value)) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_RESOURCEUNAVAILABLE);
        }
        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */
        value = *requests->requestvb->val.integer;
        if (value != TV_TRUE) {
        	break;
        }
       	value = ENCRYPT_WEP;
        if (!apmib_set(MIB_WLAN_ENCRYPT, (void *)&value)) {
            netsnmp_set_request_error(reqinfo, requests, /* some error */
                                      SNMP_ERR_GENERR);
        }
        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */
        if (0 /* XXX: error? */ ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */
        if (!apmib_set(MIB_WLAN_ENCRYPT, (void *)&reserved_value)) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_UNDOFAILED);
        }
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_dot11PrivacyInvoked\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dot11WEPDefaultKeyID(netsnmp_mib_handler *handler,
                            netsnmp_handler_registration *reginfo,
                            netsnmp_agent_request_info *reqinfo,
                            netsnmp_request_info *requests)
{
    int             ret;
    int             value;
    static int      reserved_value;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
     	if (!apmib_get(MIB_WLAN_WEP_DEFAULT_KEY, (void *)&value)) {
    		netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
    	}
    	else {
        	snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&value, sizeof(value));
        }
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        ret = netsnmp_check_vb_int_range(requests->requestvb, 0, 3);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */
        if (!apmib_get(MIB_WLAN_WEP_DEFAULT_KEY, (void *)&reserved_value)) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_RESOURCEUNAVAILABLE);
        }
        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */
        value = *requests->requestvb->val.integer; 
        if (!apmib_set(MIB_WLAN_WEP_DEFAULT_KEY, (void *)&value)) {
            netsnmp_set_request_error(reqinfo, requests, /* some error */
                                      SNMP_ERR_GENERR);
        }
        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */
        if (0 /* XXX: error? */ ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */
        if (!apmib_set(MIB_WLAN_WEP_DEFAULT_KEY, (void *)&reserved_value)) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_UNDOFAILED);
        }
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_dot11WEPDefaultKeyID\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dot11WEPKeyLength(netsnmp_mib_handler *handler,
                         netsnmp_handler_registration *reginfo,
                         netsnmp_agent_request_info *reqinfo,
                         netsnmp_request_info *requests)
{
    int             ret;
    int             value;
    static int      reserved_value;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
     	if (!apmib_get(MIB_WLAN_WEP, (void *)&value)) {
    		netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
    	}
    	else {
    		if (value == WEP_DISABLED) {
    			value = 1;
    		}
        	snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&value, sizeof(value));
        }
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        ret = netsnmp_check_vb_int_range(requests->requestvb, 1, 2);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */
        if (!apmib_get(MIB_WLAN_WEP, (void *)&reserved_value)) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_RESOURCEUNAVAILABLE);
        }
        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */
        value = *requests->requestvb->val.integer; 
        if (!apmib_set(MIB_WLAN_WEP, (void *)&value)) {
            netsnmp_set_request_error(reqinfo, requests, /* some error */
                                      SNMP_ERR_GENERR);
        }
        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */
        if (0 /* XXX: error? */ ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */
        if (!apmib_set(MIB_WLAN_WEP, (void *)&reserved_value)) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_UNDOFAILED);
        }
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_dot11WEPKeyLength\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dot11WEPKeyMappingLength(netsnmp_mib_handler *handler,
                                netsnmp_handler_registration *reginfo,
                                netsnmp_agent_request_info *reqinfo,
                                netsnmp_request_info *requests)
{
    int             value;
    unsigned char   data[sizeof(value)];
    unsigned long   data_len = sizeof(value);
	oid             rtk_oid[] = {1, 5, 1, 3, 1};
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
		if (get_wlan_snmpmib("wlan0", rtk_oid, OID_LENGTH(rtk_oid), data, &data_len) == -1) {
			netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
		} else {
			if (data_len == 0) {
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_GENERR);
			} else {
				value = (int)*data;
			}
    		snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&value, sizeof(value));
		}
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_dot11WEPKeyMappingLength\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dot11ExcludeUnencrypted(netsnmp_mib_handler *handler,
                               netsnmp_handler_registration *reginfo,
                               netsnmp_agent_request_info *reqinfo,
                               netsnmp_request_info *requests)
{
    int             value;
    unsigned char   data[sizeof(value)];
    unsigned long   data_len = sizeof(value);
	oid             rtk_oid[] = {1, 5, 1, 4, 1};
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
		if (get_wlan_snmpmib("wlan0", rtk_oid, OID_LENGTH(rtk_oid), data, &data_len) == -1) {
			netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
		} else {
			if (data_len == 0) {
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_GENERR);
			} else {
				value = *((int *)data);
			}
    		snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&value, sizeof(value));
		}
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_dot11ExcludeUnencrypted\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dot11WEPICVErrorCount(netsnmp_mib_handler *handler,
                             netsnmp_handler_registration *reginfo,
                             netsnmp_agent_request_info *reqinfo,
                             netsnmp_request_info *requests)
{
    unsigned int    value;
    unsigned char   data[sizeof(value)];
    unsigned long   data_len = sizeof(value);
	oid             rtk_oid[] = {1, 5, 1, 5, 1};
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
		if (get_wlan_snmpmib("wlan0", rtk_oid, OID_LENGTH(rtk_oid), data, &data_len) == -1) {
			netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
		} else {
			if (data_len == 0) {
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_GENERR);
			} else {
				value = *((unsigned int *)data);
			}
    		snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&value, sizeof(value));
		}
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_dot11WEPICVErrorCount\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dot11WEPExcludedCount(netsnmp_mib_handler *handler,
                             netsnmp_handler_registration *reginfo,
                             netsnmp_agent_request_info *reqinfo,
                             netsnmp_request_info *requests)
{
    unsigned int    value;
    unsigned char   data[sizeof(value)];
    unsigned long   data_len = sizeof(value);
	oid             rtk_oid[] = {1, 5, 1, 6, 1};
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
		if (get_wlan_snmpmib("wlan0", rtk_oid, OID_LENGTH(rtk_oid), data, &data_len) == -1) {
			netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
		} else {
			if (data_len == 0) {
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_GENERR);
			} else {
				value = *((unsigned int *)data);
			}
    		snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&value, sizeof(value));
		}
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_dot11WEPExcludedCount\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dot11DisassociateReason(netsnmp_mib_handler *handler,
                               netsnmp_handler_registration *reginfo,
                               netsnmp_agent_request_info *reqinfo,
                               netsnmp_request_info *requests)
{
    int             value;
    unsigned char   data[sizeof(value)];
    unsigned long   data_len = sizeof(value);
	oid             rtk_oid[] = {1, 1, 1, 15, 1};
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
		if (get_wlan_snmpmib("wlan0", rtk_oid, OID_LENGTH(rtk_oid), data, &data_len) == -1) {
			netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
		} else {
			if (data_len == 0) {
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_GENERR);
			} else {
				value = *((int *)data);
			}
    		snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&value, sizeof(value));
		}
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_dot11DisassociateReason\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dot11DisassociateStation(netsnmp_mib_handler *handler,
                                netsnmp_handler_registration *reginfo,
                                netsnmp_agent_request_info *reqinfo,
                                netsnmp_request_info *requests)
{
    unsigned char   data[6];
    unsigned long   data_len = sizeof(data);
	oid             rtk_oid[] = {1, 1, 1, 16, 1};
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
		if (get_wlan_snmpmib("wlan0", rtk_oid, OID_LENGTH(rtk_oid), data, &data_len) == -1) {
			netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
		} else {
			if (data_len != sizeof(data)) {
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_GENERR);
			}
    		snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *)data, (size_t)data_len);
		}
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_dot11DisassociateStation\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dot11DeauthenticateReason(netsnmp_mib_handler *handler,
                                 netsnmp_handler_registration *reginfo,
                                 netsnmp_agent_request_info *reqinfo,
                                 netsnmp_request_info *requests)
{
    int             value;
    unsigned char   data[sizeof(value)];
    unsigned long   data_len = sizeof(value);
	oid             rtk_oid[] = {1, 1, 1, 17, 1};
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
		if (get_wlan_snmpmib("wlan0", rtk_oid, OID_LENGTH(rtk_oid), data, &data_len) == -1) {
			netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
		} else {
			if (data_len == 0) {
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_GENERR);
			} else {
				value = *((int *)data);
			}
    		snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&value, sizeof(value));
		}
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_dot11DeauthenticateReason\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dot11DeauthenticateStation(netsnmp_mib_handler *handler,
                                  netsnmp_handler_registration *reginfo,
                                  netsnmp_agent_request_info *reqinfo,
                                  netsnmp_request_info *requests)
{
    unsigned char   data[6];
    unsigned long   data_len = sizeof(data);
	oid             rtk_oid[] = {1, 1, 1, 18, 1};
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
		if (get_wlan_snmpmib("wlan0", rtk_oid, OID_LENGTH(rtk_oid), data, &data_len) == -1) {
			netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
		} else {
			if (data_len != sizeof(data)) {
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_GENERR);
			}
    		snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *)data, (size_t)data_len);
		}
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_dot11DeauthenticateStation\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dot11AuthenticateFailStatus(netsnmp_mib_handler *handler,
                                   netsnmp_handler_registration *reginfo,
                                   netsnmp_agent_request_info *reqinfo,
                                   netsnmp_request_info *requests)
{
    int             value;
    unsigned char   data[sizeof(value)];
    unsigned long   data_len = sizeof(value);
	oid             rtk_oid[] = {1, 1, 1, 19, 1};
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
		if (get_wlan_snmpmib("wlan0", rtk_oid, OID_LENGTH(rtk_oid), data, &data_len) == -1) {
			netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
		} else {
			if (data_len == 0) {
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_GENERR);
			} else {
				value = *((int *)data);
			}
    		snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&value, sizeof(value));
		}
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_dot11AuthenticateFailStatus\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dot11AuthenticateFailStation(netsnmp_mib_handler *handler,
                                    netsnmp_handler_registration *reginfo,
                                    netsnmp_agent_request_info *reqinfo,
                                    netsnmp_request_info *requests)
{
    unsigned char   data[6];
    unsigned long   data_len = sizeof(data);
	oid             rtk_oid[] = {1, 1, 1, 20, 1};
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
		if (get_wlan_snmpmib("wlan0", rtk_oid, OID_LENGTH(rtk_oid), data, &data_len) == -1) {
			netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
		} else {
			if (data_len != sizeof(data)) {
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_GENERR);
			}
    		snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *)data, (size_t)data_len);
		}
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_dot11AuthenticateFailStation\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dot11MACAddress(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info *reqinfo,
                       netsnmp_request_info *requests)
{
    unsigned char   data[6];
    unsigned long   data_len = sizeof(data);
	oid             rtk_oid[] = {2, 1, 1, 1, 1};
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
		if (get_wlan_snmpmib("wlan0", rtk_oid, OID_LENGTH(rtk_oid), data, &data_len) == -1) {
			netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
		} else {
			if (data_len != sizeof(data)) {
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_GENERR);
			}
    		snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *)data, (size_t)data_len);
		}
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_dot11MACAddress\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dot11RTSThreshold(netsnmp_mib_handler *handler,
                         netsnmp_handler_registration *reginfo,
                         netsnmp_agent_request_info *reqinfo,
                         netsnmp_request_info *requests)
{
    int             ret;
    int             value;
    static int      reserved_value;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
     	if (!apmib_get(MIB_WLAN_RTS_THRESHOLD, (void *)&value)) {
    		netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
    	}
    	else {
        	snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&value, sizeof(value));
        }
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        ret = netsnmp_check_vb_int_range(requests->requestvb, 256, 2346);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */
        if (!apmib_get(MIB_WLAN_RTS_THRESHOLD, (void *)&reserved_value)) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_RESOURCEUNAVAILABLE);
        }
        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */
        value = *requests->requestvb->val.integer;
        if (!apmib_set(MIB_WLAN_RTS_THRESHOLD, (void *)&value)) {
            netsnmp_set_request_error(reqinfo, requests, /* some error */
                                      SNMP_ERR_GENERR);
        }
        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */
        if (0 /* XXX: error? */ ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */
        if (!apmib_set(MIB_WLAN_RTS_THRESHOLD, (void *)&reserved_value)) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_UNDOFAILED);
        }
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_dot11RTSThreshold\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dot11ShortRetryLimit(netsnmp_mib_handler *handler,
                            netsnmp_handler_registration *reginfo,
                            netsnmp_agent_request_info *reqinfo,
                            netsnmp_request_info *requests)
{
    int             value;
    unsigned char   data[sizeof(value)];
    unsigned long   data_len = sizeof(value);
	oid             rtk_oid[] = {2, 1, 1, 3, 1};
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
		if (get_wlan_snmpmib("wlan0", rtk_oid, OID_LENGTH(rtk_oid), data, &data_len) == -1) {
			netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
		} else {
			if (data_len == 0) {
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_GENERR);
			} else {
				value = *((int *)data);
			}
    		snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&value, sizeof(value));
		}
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_dot11ShortRetryLimit\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dot11LongRetryLimit(netsnmp_mib_handler *handler,
                           netsnmp_handler_registration *reginfo,
                           netsnmp_agent_request_info *reqinfo,
                           netsnmp_request_info *requests)
{
    int             value;
    unsigned char   data[sizeof(value)];
    unsigned long   data_len = sizeof(value);
	oid             rtk_oid[] = {2, 1, 1, 4, 1};
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
		if (get_wlan_snmpmib("wlan0", rtk_oid, OID_LENGTH(rtk_oid), data, &data_len) == -1) {
			netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
		} else {
			if (data_len == 0) {
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_GENERR);
			} else {
				value = *((int *)data);
			}
    		snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&value, sizeof(value));
		}
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_dot11LongRetryLimit\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dot11FragmentationThreshold(netsnmp_mib_handler *handler,
                                   netsnmp_handler_registration *reginfo,
                                   netsnmp_agent_request_info *reqinfo,
                                   netsnmp_request_info *requests)
{
    int             ret;
    int             value;
    static int      reserved_value;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
     	if (!apmib_get(MIB_WLAN_FRAG_THRESHOLD, (void *)&value)) {
    		netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
    	}
    	else {
        	snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&value, sizeof(value));
        }
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        ret = netsnmp_check_vb_int_range(requests->requestvb, 1500, 2346);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */
        if (!apmib_get(MIB_WLAN_FRAG_THRESHOLD, (void *)&reserved_value)) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_RESOURCEUNAVAILABLE);
        }
        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */
        value = *requests->requestvb->val.integer;
        if (!apmib_set(MIB_WLAN_FRAG_THRESHOLD, (void *)&value)) {
            netsnmp_set_request_error(reqinfo, requests, /* some error */
                                      SNMP_ERR_GENERR);
        }
        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */
        if (0 /* XXX: error? */ ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */
        if ((!apmib_set(MIB_WLAN_FRAG_THRESHOLD, (void *)&reserved_value))) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_UNDOFAILED);
        }
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_dot11FragmentationThreshold\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dot11SSIDBroadcast(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    int             ret;
    int             value;
    static int      reserved_value;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
     	if (!apmib_get(MIB_WLAN_HIDDEN_SSID, (void *)&value)) {
    		netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
    	}
    	else {
    		if (value == 0) {
    			value = TV_TRUE;
    		} else {
    			value = TV_FALSE;
    		}
        	snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&value, sizeof(value));
        }
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        ret = netsnmp_check_vb_truthvalue(requests->requestvb);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */
        if (!apmib_get(MIB_WLAN_HIDDEN_SSID, (void *)&reserved_value)) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_RESOURCEUNAVAILABLE);
        }
        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */
        value = *requests->requestvb->val.integer; 
        if (!apmib_set(MIB_WLAN_HIDDEN_SSID, (void *)&value)) {
            netsnmp_set_request_error(reqinfo, requests, /* some error */
                                      SNMP_ERR_GENERR);
        }
        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */
        if (0 /* XXX: error? */ ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */
        if (!apmib_set(MIB_WLAN_HIDDEN_SSID, (void *)&reserved_value)) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_UNDOFAILED);
        }
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_dot11SSIDBroadcast\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dot11PreambleType(netsnmp_mib_handler *handler,
                         netsnmp_handler_registration *reginfo,
                         netsnmp_agent_request_info *reqinfo,
                         netsnmp_request_info *requests)
{
    int             ret;
    int             value;
    static int      reserved_value;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
     	if (!apmib_get(MIB_WLAN_PREAMBLE_TYPE, (void *)&value)) {
    		netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
    	}
    	else {
    		if (value == LONG_PREAMBLE) {
    			value = 1;
    		}
    		else if (value == SHORT_PREAMBLE) {
    			value = 2;
    		}
    		else {
    			netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_GENERR);
    		}
        	snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&value, sizeof(value));
        }
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_dot11PreambleType\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dot11MaxTransmitMSDULifetime(netsnmp_mib_handler *handler,
                                    netsnmp_handler_registration *reginfo,
                                    netsnmp_agent_request_info *reqinfo,
                                    netsnmp_request_info *requests)
{
    int             value;
    unsigned char   data[sizeof(value)];
    unsigned long   data_len = sizeof(value);
	oid             rtk_oid[] = {2, 1, 1, 6, 1};
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
		if (get_wlan_snmpmib("wlan0", rtk_oid, OID_LENGTH(rtk_oid), data, &data_len) == -1) {
			netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
		} else {
			if (data_len == 0) {
				netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);;
			} else {
				value = *((int *)data);
			}
    		snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&value, sizeof(value));
		}
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_dot11MaxTransmitMSDULifetime\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dot11MaxReceiveLifetime(netsnmp_mib_handler *handler,
                               netsnmp_handler_registration *reginfo,
                               netsnmp_agent_request_info *reqinfo,
                               netsnmp_request_info *requests)
{
    int             value;
    unsigned char   data[sizeof(value)];
    unsigned long   data_len = sizeof(value);
	oid             rtk_oid[] = {2, 1, 1, 7, 1};
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
		if (get_wlan_snmpmib("wlan0", rtk_oid, OID_LENGTH(rtk_oid), data, &data_len) == -1) {
			netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
		} else {
			if (data_len == 0) {
				netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);;
			} else {
				value = *((int *)data);
			}
    		snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&value, sizeof(value));
		}
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_dot11MaxReceiveLifetime\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dot11ManufacturerID(netsnmp_mib_handler *handler,
                           netsnmp_handler_registration *reginfo,
                           netsnmp_agent_request_info *reqinfo,
                           netsnmp_request_info *requests)
{
    unsigned char   data[129];
    unsigned long   data_len = sizeof(data);
	oid             rtk_oid[] = {2, 1, 1, 8, 1};
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
    	/*
		if (get_wlan_snmpmib("wlan0", rtk_oid, OID_LENGTH(rtk_oid), data, &data_len) == -1) {
			netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
		} else {
			if (data_len == 0) {
				netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
			}
    		snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *)data, (size_t)data_len);
		}
		*/
		strcpy(data, "TRENDnet");
		snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *)data, strlen(data));
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_dot11ManufacturerID\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dot11ProductID(netsnmp_mib_handler *handler,
                      netsnmp_handler_registration *reginfo,
                      netsnmp_agent_request_info *reqinfo,
                      netsnmp_request_info *requests)
{
    unsigned char   data[129];
    unsigned long   data_len = sizeof(data);
	oid             rtk_oid[] = {2, 1, 1, 9, 1};
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
    	/*
		if (get_wlan_snmpmib("wlan0", rtk_oid, OID_LENGTH(rtk_oid), data, &data_len) == -1) {
			netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
		} else {
			if (data_len == 0) {
				netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
			}
    		snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *)data, (size_t)data_len);
		}
		*/
		strcpy(data, "TRENDnet WIRELESS_AP");
		snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *)data, strlen(data));
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_dot11ProductID\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dot11TransmittedFragmentCount(netsnmp_mib_handler *handler,
                                     netsnmp_handler_registration *reginfo,
                                     netsnmp_agent_request_info *reqinfo,
                                     netsnmp_request_info *requests)
{
    unsigned int    value;
    unsigned char   data[sizeof(value)];
    unsigned long   data_len = sizeof(value);
	oid             rtk_oid[] = {2, 2, 1, 1, 1};
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
		if (get_wlan_snmpmib("wlan0", rtk_oid, OID_LENGTH(rtk_oid), data, &data_len) == -1) {
			netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
		} else {
			if (data_len == 0) {
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_GENERR);
			} else {
				value = *((unsigned int *)data);
			}
    		snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&value, sizeof(value));
		}
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_dot11TransmittedFragmentCount\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dot11MulticastTransmittedFrameCount(netsnmp_mib_handler *handler,
                                           netsnmp_handler_registration
                                           *reginfo,
                                           netsnmp_agent_request_info
                                           *reqinfo,
                                           netsnmp_request_info *requests)
{
    unsigned int    value;
    unsigned char   data[sizeof(value)];
    unsigned long   data_len = sizeof(value);
	oid             rtk_oid[] = {2, 2, 1, 2, 1};
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
		if (get_wlan_snmpmib("wlan0", rtk_oid, OID_LENGTH(rtk_oid), data, &data_len) == -1) {
			netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
		} else {
			if (data_len == 0) {
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_GENERR);
			} else {
				value = *((unsigned int *)data);
			}
    		snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&value, sizeof(value));
		}
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_dot11MulticastTransmittedFrameCount\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dot11FailedCount(netsnmp_mib_handler *handler,
                        netsnmp_handler_registration *reginfo,
                        netsnmp_agent_request_info *reqinfo,
                        netsnmp_request_info *requests)
{
    unsigned int    value;
    unsigned char   data[sizeof(value)];
    unsigned long   data_len = sizeof(value);
	oid             rtk_oid[] = {2, 2, 1, 3, 1};
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
		if (get_wlan_snmpmib("wlan0", rtk_oid, OID_LENGTH(rtk_oid), data, &data_len) == -1) {
			netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
		} else {
			if (data_len == 0) {
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_GENERR);
			} else {
				value = *((unsigned int *)data);
			}
    		snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&value, sizeof(value));
		}
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_dot11FailedCount\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dot11RetryCount(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info *reqinfo,
                       netsnmp_request_info *requests)
{
    unsigned int    value;
    unsigned char   data[sizeof(value)];
    unsigned long   data_len = sizeof(value);
	oid             rtk_oid[] = {2, 2, 1, 4, 1};
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
		if (get_wlan_snmpmib("wlan0", rtk_oid, OID_LENGTH(rtk_oid), data, &data_len) == -1) {
			netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
		} else {
			if (data_len == 0) {
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_GENERR);
			} else {
				value = *((unsigned int *)data);
			}
    		snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&value, sizeof(value));
		}
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_dot11RetryCount\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dot11MultipleRetryCount(netsnmp_mib_handler *handler,
                               netsnmp_handler_registration *reginfo,
                               netsnmp_agent_request_info *reqinfo,
                               netsnmp_request_info *requests)
{
    unsigned int    value;
    unsigned char   data[sizeof(value)];
    unsigned long   data_len = sizeof(value);
	oid             rtk_oid[] = {2, 2, 1, 5, 1};
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
		if (get_wlan_snmpmib("wlan0", rtk_oid, OID_LENGTH(rtk_oid), data, &data_len) == -1) {
			netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
		} else {
			if (data_len == 0) {
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_GENERR);
			} else {
				value = *((unsigned int *)data);
			}
    		snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&value, sizeof(value));
		}
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_dot11MultipleRetryCount\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dot11FrameDuplicateCount(netsnmp_mib_handler *handler,
                                netsnmp_handler_registration *reginfo,
                                netsnmp_agent_request_info *reqinfo,
                                netsnmp_request_info *requests)
{
    unsigned int    value;
    unsigned char   data[sizeof(value)];
    unsigned long   data_len = sizeof(value);
	oid             rtk_oid[] = {2, 2, 1, 6, 1};
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
		if (get_wlan_snmpmib("wlan0", rtk_oid, OID_LENGTH(rtk_oid), data, &data_len) == -1) {
			netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
		} else {
			if (data_len == 0) {
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_GENERR);
			} else {
				value = *((unsigned int *)data);
			}
    		snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&value, sizeof(value));
		}
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_dot11FrameDuplicateCount\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dot11RTSSuccessCount(netsnmp_mib_handler *handler,
                            netsnmp_handler_registration *reginfo,
                            netsnmp_agent_request_info *reqinfo,
                            netsnmp_request_info *requests)
{
    unsigned int    value;
    unsigned char   data[sizeof(value)];
    unsigned long   data_len = sizeof(value);
	oid             rtk_oid[] = {2, 2, 1, 7, 1};
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
		if (get_wlan_snmpmib("wlan0", rtk_oid, OID_LENGTH(rtk_oid), data, &data_len) == -1) {
			netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
		} else {
			if (data_len == 0) {
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_GENERR);
			} else {
				value = *((unsigned int *)data);
			}
    		snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&value, sizeof(value));
		}
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_dot11RTSSuccessCount\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dot11RTSFailureCount(netsnmp_mib_handler *handler,
                            netsnmp_handler_registration *reginfo,
                            netsnmp_agent_request_info *reqinfo,
                            netsnmp_request_info *requests)
{
    unsigned int    value;
    unsigned char   data[sizeof(value)];
    unsigned long   data_len = sizeof(value);
	oid             rtk_oid[] = {2, 2, 1, 8, 1};
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
		if (get_wlan_snmpmib("wlan0", rtk_oid, OID_LENGTH(rtk_oid), data, &data_len) == -1) {
			netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
		} else {
			if (data_len == 0) {
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_GENERR);
			} else {
				value = *((unsigned int *)data);
			}
    		snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&value, sizeof(value));
		}
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_dot11RTSFailureCount\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dot11ACKFailureCount(netsnmp_mib_handler *handler,
                            netsnmp_handler_registration *reginfo,
                            netsnmp_agent_request_info *reqinfo,
                            netsnmp_request_info *requests)
{
    unsigned int    value;
    unsigned char   data[sizeof(value)];
    unsigned long   data_len = sizeof(value);
	oid             rtk_oid[] = {2, 2, 1, 9, 1};
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
		if (get_wlan_snmpmib("wlan0", rtk_oid, OID_LENGTH(rtk_oid), data, &data_len) == -1) {
			netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
		} else {
			if (data_len == 0) {
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_GENERR);
			} else {
				value = *((unsigned int *)data);
			}
    		snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&value, sizeof(value));
		}
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_dot11ACKFailureCount\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dot11ReceivedFragmentCount(netsnmp_mib_handler *handler,
                                  netsnmp_handler_registration *reginfo,
                                  netsnmp_agent_request_info *reqinfo,
                                  netsnmp_request_info *requests)
{
    unsigned int    value;
    unsigned char   data[sizeof(value)];
    unsigned long   data_len = sizeof(value);
	oid             rtk_oid[] = {2, 2, 1, 10, 1};
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
		if (get_wlan_snmpmib("wlan0", rtk_oid, OID_LENGTH(rtk_oid), data, &data_len) == -1) {
			netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
		} else {
			if (data_len == 0) {
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_GENERR);
			} else {
				value = *((unsigned int *)data);
			}
    		snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&value, sizeof(value));
		}
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_dot11ReceivedFragmentCount\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dot11MulticastReceivedFrameCount(netsnmp_mib_handler *handler,
                                        netsnmp_handler_registration
                                        *reginfo,
                                        netsnmp_agent_request_info
                                        *reqinfo,
                                        netsnmp_request_info *requests)
{
    unsigned int    value;
    unsigned char   data[sizeof(value)];
    unsigned long   data_len = sizeof(value);
	oid             rtk_oid[] = {2, 2, 1, 11, 1};
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
		if (get_wlan_snmpmib("wlan0", rtk_oid, OID_LENGTH(rtk_oid), data, &data_len) == -1) {
			netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
		} else {
			if (data_len == 0) {
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_GENERR);
			} else {
				value = *((unsigned int *)data);
			}
    		snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&value, sizeof(value));
		}
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_dot11MulticastReceivedFrameCount\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dot11FCSErrorCount(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    unsigned int    value;
    unsigned char   data[sizeof(value)];
    unsigned long   data_len = sizeof(value);
	oid             rtk_oid[] = {2, 2, 1, 12, 1};
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
		if (get_wlan_snmpmib("wlan0", rtk_oid, OID_LENGTH(rtk_oid), data, &data_len) == -1) {
			netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
		} else {
			if (data_len == 0) {
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_GENERR);
			} else {
				value = *((unsigned int *)data);
			}
    		snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&value, sizeof(value));
		}
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_dot11FCSErrorCount\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dot11TransmittedFrameCount(netsnmp_mib_handler *handler,
                                  netsnmp_handler_registration *reginfo,
                                  netsnmp_agent_request_info *reqinfo,
                                  netsnmp_request_info *requests)
{
    unsigned int    value;
    unsigned char   data[sizeof(value)];
    unsigned long   data_len = sizeof(value);
	oid             rtk_oid[] = {2, 2, 1, 13, 1};
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
		if (get_wlan_snmpmib("wlan0", rtk_oid, OID_LENGTH(rtk_oid), data, &data_len) == -1) {
			netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
		} else {
			if (data_len == 0) {
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_GENERR);
			} else {
				value = *((unsigned int *)data);
			}
    		snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&value, sizeof(value));
		}
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_dot11TransmittedFrameCount\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dot11WEPUndecryptableCount(netsnmp_mib_handler *handler,
                                  netsnmp_handler_registration *reginfo,
                                  netsnmp_agent_request_info *reqinfo,
                                  netsnmp_request_info *requests)
{
    unsigned int    value;
    unsigned char   data[sizeof(value)];
    unsigned long   data_len = sizeof(value);
	oid             rtk_oid[] = {2, 2, 1, 14, 1};
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
		if (get_wlan_snmpmib("wlan0", rtk_oid, OID_LENGTH(rtk_oid), data, &data_len) == -1) {
			netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
		} else {
			if (data_len == 0) {
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_GENERR);
			} else {
				value = *((unsigned int *)data);
			}
    		snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, (u_char *)&value, sizeof(value));
		}
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_dot11WEPUndecryptableCount\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dot11manufacturerOUI(netsnmp_mib_handler *handler,
                            netsnmp_handler_registration *reginfo,
                            netsnmp_agent_request_info *reqinfo,
                            netsnmp_request_info *requests)
{
	char            value[129];
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
    	strcpy(value, "TRENDnet");
    	snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *)value, strlen(value));
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_dot11manufacturerOUI\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dot11manufacturerName(netsnmp_mib_handler *handler,
                             netsnmp_handler_registration *reginfo,
                             netsnmp_agent_request_info *reqinfo,
                             netsnmp_request_info *requests)
{
	char            value[129];
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
    	strcpy(value, "TRENDnet,Inc.");
    	snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *)value, strlen(value));
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_dot11manufacturerName\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dot11manufacturerProductName(netsnmp_mib_handler *handler,
                                    netsnmp_handler_registration *reginfo,
                                    netsnmp_agent_request_info *reqinfo,
                                    netsnmp_request_info *requests)
{
	char            value[129];
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
    	strcpy(value, "TRENDnet WIRELESS_AP");
    	snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *)value, strlen(value));
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_dot11manufacturerProductName\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dot11manufacturerProductVersion(netsnmp_mib_handler *handler,
                                       netsnmp_handler_registration
                                       *reginfo,
                                       netsnmp_agent_request_info *reqinfo,
                                       netsnmp_request_info *requests)
{
	char            value[129];
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
    	strcpy(value, "v4.02");
    	snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, (u_char *)value, strlen(value));
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_dot11manufacturerProductVersion\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dot11CurrentRegDomain(netsnmp_mib_handler *handler,
                             netsnmp_handler_registration *reginfo,
                             netsnmp_agent_request_info *reqinfo,
                             netsnmp_request_info *requests)
{
    int             value;
    unsigned char   data[sizeof(value)];
    unsigned long   data_len = sizeof(value);
	oid             rtk_oid[] = {4, 1, 1, 2, 1};
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
		if (get_wlan_snmpmib("wlan0", rtk_oid, OID_LENGTH(rtk_oid), data, &data_len) == -1) {
			netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
		} else {
			if (data_len == 0) {
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_GENERR);
			} else {
				value = *((int *)data);
				snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&value, sizeof(value));
			}    		
		}
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_dot11CurrentRegDomain\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dot11SupportedDataRatesTxValue(netsnmp_mib_handler *handler,
                                      netsnmp_handler_registration
                                      *reginfo,
                                      netsnmp_agent_request_info *reqinfo,
                                      netsnmp_request_info *requests)
{
    int             value;
    unsigned char   data[sizeof(value)];
    unsigned long   data_len = sizeof(value);
	oid             rtk_oid[] = {4, 9, 1, 2, 1};
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
		if (get_wlan_snmpmib("wlan0", rtk_oid, OID_LENGTH(rtk_oid), data, &data_len) == -1) {
			netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
		} else {
			if (data_len == 1) {
				netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
			} else {
				value = *((int *)data);
				value = 108;	// G forced to be 54M for TRENDnet
				snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&value, sizeof(value));
			}    		
		}
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_dot11SupportedDataRatesTxValue\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dot11SupportedDataRatesRxValue(netsnmp_mib_handler *handler,
                                      netsnmp_handler_registration
                                      *reginfo,
                                      netsnmp_agent_request_info *reqinfo,
                                      netsnmp_request_info *requests)
{
    int             value;
    unsigned char   data[sizeof(value)];
    unsigned long   data_len = sizeof(value);
	oid             rtk_oid[] = {4, 10, 1, 2, 1};
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
		if (get_wlan_snmpmib("wlan0", rtk_oid, OID_LENGTH(rtk_oid), data, &data_len) == -1) {
			netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
		} else {
			if (data_len == 1) {
				netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
			} else {
				value = *((int *)data);
				value = 108;	// G forced to be 54M for TRENDnet
				snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&value, sizeof(value));
			}    		
		}
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_dot11SupportedDataRatesRxValue\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dot11CurrentTxRate(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info *reqinfo,
                          netsnmp_request_info *requests)
{
    int             ret, i;
    int             value, value2;
    static int      reserved_value, reserved_value2;
    int             rate[] = {0, 2, 4, 11, 12, 18, 22, 24, 36, 48, 72, 96, 108};
    unsigned char   data[sizeof(value)];
    unsigned long   data_len = sizeof(value);
    oid             rtk_oid[] = {4, 1, 1, 4, 1};
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
     	if (!apmib_get(MIB_WLAN_FIX_RATE, (void *)&value)) {
    		netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
    		break;
    	}
     	if (!apmib_get(MIB_WLAN_RATE_ADAPTIVE_ENABLED, (void *)&value2)) {
    		netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
    		break;
    	}
    	if (value2 != 0) {
			if (get_wlan_snmpmib("wlan0", rtk_oid, OID_LENGTH(rtk_oid), data, &data_len) == -1) {
				netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
			} else {
				if (data_len == 1) {
					netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
				} else {
					value = *((int *)data);
					if (value == 0) {
						value = 108;
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&value, sizeof(value));
				}    		
			}		
    	} else {
    		i = 0;
    		if (value == 16) {
    			i = 4;	
    		} else if (value == 32) {
    			i = 5;
    		} else if (value == 8) {
    			i = 6;
    		} else {
    			for (i = 1; i <= 12; i++) {
    				if (value == (1 << (i-1))) {
    					break;
    				}
    			}
    		}
    		value = rate[i];
    		snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&value, sizeof(value));
    	}
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        ret = netsnmp_check_vb_int_range(requests->requestvb, 2, 127);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */
        if (!apmib_get(MIB_WLAN_FIX_RATE, (void *)&reserved_value) ||
            !apmib_get(MIB_WLAN_RATE_ADAPTIVE_ENABLED, (void *)&reserved_value2)) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_RESOURCEUNAVAILABLE);
        }
        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */
        value = *requests->requestvb->val.integer;
        value2 = 0;
        for (i = 1; i <= 12; i++) {
        	if (value == rate[i]) {
        		break;
        	} 
        }
        i = i - 1;
		if (i == 3) {
			value = 1 << 4;
		} else if (i == 4) {
			value = 1 << 5;
		} else if (i == 5) {
			value = 1 << 3;
		} else {
			value = 1 << (i);
		}
		if (i >= 12) {
			netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_WRONGVALUE);
		}
        if (!apmib_set(MIB_WLAN_FIX_RATE, (void *)&value) || 
            !apmib_set(MIB_WLAN_RATE_ADAPTIVE_ENABLED, (void *)&value2)) {
            netsnmp_set_request_error(reqinfo, requests, /* some error */
                                      SNMP_ERR_GENERR);
        }
        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */
        if (0 /* XXX: error? */ ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */
        if (!apmib_set(MIB_WLAN_FIX_RATE, (void *)&reserved_value) ||
            !apmib_set(MIB_WLAN_RATE_ADAPTIVE_ENABLED, (void *)&reserved_value2)) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_UNDOFAILED);
        }
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_dot11CurrentTxRate\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dot11CurrentTxAntenna(netsnmp_mib_handler *handler,
                             netsnmp_handler_registration *reginfo,
                             netsnmp_agent_request_info *reqinfo,
                             netsnmp_request_info *requests)
{
    int             value;
    unsigned char   data[sizeof(value)];
    unsigned long   data_len = sizeof(value);
	oid             rtk_oid[] = {4, 2, 1, 1, 1};
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
		if (get_wlan_snmpmib("wlan0", rtk_oid, OID_LENGTH(rtk_oid), data, &data_len) == -1) {
			netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
		} else {
			if (data_len == 0) {
				netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
			} else {
				value = *((int *)data);
				snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&value, sizeof(value));
			}    		
		}
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_dot11CurrentTxAntenna\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dot11DiversitySupport(netsnmp_mib_handler *handler,
                             netsnmp_handler_registration *reginfo,
                             netsnmp_agent_request_info *reqinfo,
                             netsnmp_request_info *requests)
{
    int             value;
    unsigned char   data[sizeof(value)];
    unsigned long   data_len = sizeof(value);
	oid             rtk_oid[] = {4, 2, 1, 2, 1};
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
		if (get_wlan_snmpmib("wlan0", rtk_oid, OID_LENGTH(rtk_oid), data, &data_len) == -1) {
			netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
		} else {
			if (data_len == 0) {
				netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
			} else {
				value = (int)*data;
				snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&value, sizeof(value));
			}    		
		}
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_dot11DiversitySupport\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dot11CurrentRxAntenna(netsnmp_mib_handler *handler,
                             netsnmp_handler_registration *reginfo,
                             netsnmp_agent_request_info *reqinfo,
                             netsnmp_request_info *requests)
{
    int             value;
    unsigned char   data[sizeof(value)];
    unsigned long   data_len = sizeof(value);
	oid             rtk_oid[] = {4, 2, 1, 3, 1};
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
		if (get_wlan_snmpmib("wlan0", rtk_oid, OID_LENGTH(rtk_oid), data, &data_len) == -1) {
			netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
		} else {
			if (data_len == 0) {
				netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
			} else {
				value = *((int *)data);
				snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&value, sizeof(value));
			}    		
		}
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_dot11CurrentRxAntenna\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dot11CurrentChannel(netsnmp_mib_handler *handler,
                           netsnmp_handler_registration *reginfo,
                           netsnmp_agent_request_info *reqinfo,
                           netsnmp_request_info *requests)
{
	int             ret;
    int             value;
    int             reserved_value;
    unsigned char   data[sizeof(value)];
    unsigned long   data_len = sizeof(value);
	oid             rtk_oid[] = {4, 5, 1, 1, 1};
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
		if (!apmib_get(MIB_WLAN_CHAN_NUM, (void *)&value)) {
			netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
		} else {
			if (value == 0) {
				/* Auto */
				if (get_wlan_snmpmib("wlan0", rtk_oid, OID_LENGTH(rtk_oid), data, &data_len) == -1) {
					netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
				} else {
					if (data_len == 0) {
						netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
					} else {
						value = *((int *)data);
					}    		
				}				
			}
			snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&value, sizeof(value));    		
		}
        break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        ret = netsnmp_check_vb_int_range(requests->requestvb, 1, 14);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */
        if (!apmib_get(MIB_WLAN_CHAN_NUM, (void *)&reserved_value)) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_RESOURCEUNAVAILABLE);
        }
        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
        /*
         * XXX: perform the value change here 
         */
        value = *requests->requestvb->val.integer; 
        if (!apmib_set(MIB_WLAN_CHAN_NUM, (void *)&value)) {
            netsnmp_set_request_error(reqinfo, requests, /* some error */
                                      SNMP_ERR_GENERR);
        }
        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */
        if (0 /* XXX: error? */ ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */
        if (!apmib_set(MIB_WLAN_CHAN_NUM, (void *)&reserved_value)) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_UNDOFAILED);
        }
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_dot11CurrentChannel\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_dot11ShortPreambleOptionImplemented(netsnmp_mib_handler *handler,
                                           netsnmp_handler_registration
                                           *reginfo,
                                           netsnmp_agent_request_info
                                           *reqinfo,
                                           netsnmp_request_info *requests)
{
    int             value;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
    	/*
     	if (!apmib_get(MIB_WLAN_WEP_DEFAULT_KEY, (void *)&value)) {
    		netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
    	}
    	else {
    		if (value == LONG_PREAMBLE) {
    			value = 2;
    		}
    		else if (value == SHORT_PREAMBLE) {
    			value = 1;
    		}
    		else {
    			// netsnmp_set_request_error(reqinfo, requests, SNMP_NOSUCHINSTANCE);
    			value = 2;
    		}
    		snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&value, sizeof(value));        	
        }
        */
        value = 1;
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, (u_char *)&value, sizeof(value));
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_dot11ShortPreambleOptionImplemented\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
