
./Output/boot.out:     file format elf32-tradbigmips

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00014000  a0000000  a0000000  00010000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .reginfo      00000018  a0014000  a0014000  00024000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA, LINK_ONCE_SAME_SIZE
  2 .rodata.str1.4 000031f8  a0014018  a0014018  00024018  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .data         00000730  a0017210  a0017210  00027210  2**4
                  CONTENTS, ALLOC, LOAD, DATA
  4 .sbss         00000064  a0017940  a0017940  00027940  2**2
                  ALLOC
  5 .bss          00045100  a00179a8  a00179a8  00027940  2**4
                  ALLOC
  6 .pdr          00001d20  00000000  00000000  00027940  2**2
                  CONTENTS, READONLY
  7 .comment      0000002b  00000000  00000000  00029660  2**0
                  CONTENTS, READONLY
  8 .gnu.attributes 00000010  00000000  00000000  0002968b  2**0
                  CONTENTS, READONLY
  9 .debug_line   00002c01  00000000  00000000  0002969b  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   0000b88b  00000000  00000000  0002c29c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 00002e49  00000000  00000000  00037b27  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_aranges 00000340  00000000  00000000  0003a970  2**3
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  00001bb0  00000000  00000000  0003acb0  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    00007409  00000000  00000000  0003c860  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_pubnames 0000170c  00000000  00000000  00043c69  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    0000392e  00000000  00000000  00045375  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_ranges 00000268  00000000  00000000  00048ca3  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

a0000000 <start>:
	 * FIXME: Use the initcode feature to get rid of unused handler
	 * variants.
	 */

#if 1
	b check_self_exist
a0000000:	10000102 	b	a000040c <check_self_exist>
	nop
a0000004:	00000000 	nop
	...

a000040c <check_self_exist>:


reset:

	/* Clear watch registers */
	mtc0	zero, CP0_WATCHLO
a000040c:	40809000 	mtc0	zero,c0_watchlo
	mtc0	zero, CP0_WATCHHI
a0000410:	40809800 	mtc0	zero,c0_watchhi

	/* WP(Watch Pending), SW0/1 should be cleared */
	mtc0	zero, CP0_CAUSE
a0000414:	40806800 	mtc0	zero,c0_cause
	

	mfc0	t0, CP0_STATUS
a0000418:	40086000 	mfc0	t0,c0_status
	or	t0, ST0_CU0 | 0x1f  
a000041c:	3c011000 	lui	at,0x1000
a0000420:	3421001f 	ori	at,at,0x1f
a0000424:	01014025 	or	t0,t0,at
	xor	t0, 0x1f 
a0000428:	3908001f 	xori	t0,t0,0x1f
	mtc0	t0, CP0_STATUS
a000042c:	40886000 	mtc0	t0,c0_status
	.set	noreorder
	sll	zero, 3				# ehb
a0000430:	000000c0 	ehb


	/* Init Timer */
	mtc0	zero, CP0_COUNT
a0000434:	40804800 	mtc0	zero,c0_count
	mtc0	zero, CP0_COMPARE
a0000438:	40805800 	mtc0	zero,c0_compare



#if 1 //wei add for 1074k core 1
        mfc0    v1, CP0_PRID, 1
a000043c:	40037801 	mfc0	v1,c0_ebase
        andi    v1, 0x3ff
a0000440:	306303ff 	andi	v1,v1,0x3ff
        beqz    v1, 1f   //ID=0 go out
a0000444:	10600014 	beqz	v1,a0000498 <loop+0x10>
 //       bnez    v1, 1f        //ID!=0 go out
        nop
a0000448:	00000000 	nop


		REG32_W(0xb8002000, '2'<<24);	  //Secondary CPU			
a000044c:	3c0e3200 	lui	t6,0x3200
a0000450:	3c0fb800 	lui	t7,0xb800
a0000454:	35ef2000 	ori	t7,t7,0x2000
a0000458:	adee0000 	sw	t6,0(t7)
a000045c:	00000000 	nop
		REG32_W(0xb8002000, '2'<<24);	  //Secondary CPU			
a0000460:	3c0e3200 	lui	t6,0x3200
a0000464:	3c0fb800 	lui	t7,0xb800
a0000468:	35ef2000 	ori	t7,t7,0x2000
a000046c:	adee0000 	sw	t6,0(t7)
a0000470:	00000000 	nop
		REG32_W(0xb8002000, '2'<<24);	  //Secondary CPU			
a0000474:	3c0e3200 	lui	t6,0x3200
a0000478:	3c0fb800 	lui	t7,0xb800
a000047c:	35ef2000 	ori	t7,t7,0x2000
a0000480:	adee0000 	sw	t6,0(t7)
a0000484:	00000000 	nop

a0000488 <loop>:
	...
loop:
		
        nop
        nop
        b loop
a0000490:	1000fffd 	b	a0000488 <loop>
        nop
a0000494:	00000000 	nop
		nop		
#else
#ifdef CONFIG_NAND_FLASH_BOOTING
		//li sp,0x80700000
		//li sp,0x80500000
		li sp,0xa0500000
a0000498:	3c1da050 	lui	sp,0xa050
	...
	nop
#endif
	nop
	nop

	jal	init_arch  	                                          
a00004a8:	0c001e97 	jal	a0007a5c <init_arch>
	nop  
a00004ac:	00000000 	nop
	nop
a00004b0:	00000000 	nop

a00004b4 <romReserved>:
	
//==========================================================
#if 1
romReserved:
        b       romReserved
a00004b4:	1000ffff 	b	a00004b4 <romReserved>
        nop
a00004b8:	00000000 	nop

a00004bc <romExcHandle>:

romExcHandle:
        b       romExcHandle
a00004bc:	1000ffff 	b	a00004bc <romExcHandle>
		nop
a00004c0:	00000000 	nop

a00004c4 <ramExcHandle>:

ramExcHandle:
		b	ramExcHandle
a00004c4:	1000ffff 	b	a00004c4 <ramExcHandle>
		nop
a00004c8:	00000000 	nop

a00004cc <flush_cache_r>:
a00004cc:	4080e802 	mtc0	zero,c0_taghi1
		sll zero,zero,1
		
	//----------------------------------------
//init_L1_dcahe:

	MTC0_SEL_OPCODE( 0, 29, 2 )   //R_C0_DTagHi
a00004d0:	00000040 	ssnop
a00004d4:	00000040 	ssnop
a00004d8:	00000040 	ssnop
a00004dc:	00000040 	ssnop
a00004e0:	4080e002 	mtc0	zero,c0_taglo1
	MTC0_SEL_OPCODE( 0, 28, 2 )
a00004e4:	00000040 	ssnop
a00004e8:	00000040 	ssnop
a00004ec:	00000040 	ssnop
a00004f0:	00000040 	ssnop

0:	
	li	a2, START_ADDR
a00004f4:	3c068000 	lui	a2,0x8000
	li  a1,_CACHELINE_SIZE
a00004f8:	24050020 	li	a1,32
	li  a3,START_ADDR+_DCACHE_SIZE-_CACHELINE_SIZE
a00004fc:	3c078000 	lui	a3,0x8000
a0000500:	34e77fe0 	ori	a3,a3,0x7fe0


	/* Loop through all lines, invalidating each of them */
1:	

	cache	DCACHE_INDEX_STORE_TAG, 0(a2)	/* clear tag */
a0000504:	bcc90000 	cache	0x9,0(a2)


	bne	a2, a3, 1b
a0000508:	14c7fffe 	bne	a2,a3,a0000504 <flush_cache_r+0x38>
	addu	a2, a1
a000050c:	00c53021 	addu	a2,a2,a1
a0000510:	4080e800 	mtc0	zero,c0_taghi


	//--------------------------------------------
//init_L1_icahe:	
	MTC0_SEL_OPCODE( 0, 29, 0 )   //R_C0_ITagHi
a0000514:	00000040 	ssnop
a0000518:	00000040 	ssnop
a000051c:	00000040 	ssnop
a0000520:	00000040 	ssnop
a0000524:	4080e000 	mtc0	zero,c0_taglo
	MTC0_SEL_OPCODE( 0, 28, 0 )
a0000528:	00000040 	ssnop
a000052c:	00000040 	ssnop
a0000530:	00000040 	ssnop
a0000534:	00000040 	ssnop

0:	
	li	a2, START_ADDR
a0000538:	3c068000 	lui	a2,0x8000
	li  a1,_CACHELINE_SIZE
a000053c:	24050020 	li	a1,32
	li  a3,START_ADDR+_ICACHE_SIZE-_CACHELINE_SIZE
a0000540:	3c078000 	lui	a3,0x8000
a0000544:	34e7ffe0 	ori	a3,a3,0xffe0


	/* Loop through all lines, invalidating each of them */
1:	

	cache	ICACHE_INDEX_STORE_TAG, 0(a2)	/* clear tag */
a0000548:	bcc80000 	cache	0x8,0(a2)


	bne	a2, a3, 1b
a000054c:	14c7fffe 	bne	a2,a3,a0000548 <flush_cache_r+0x7c>
	addu	a2, a1
a0000550:	00c53021 	addu	a2,a2,a1

a0000554 <init_L2_cache>:
	//disable L2 cache
	li t0,(1<<12)
	MTC0_SEL_OPCODE( 8,16,  2);
#else	
#define RTL98_V0 0x8198C000
	nop
a0000554:	00000000 	nop
        REG32_R(0xb8000000,t8);
a0000558:	3c0fb800 	lui	t7,0xb800
a000055c:	8df80000 	lw	t8,0(t7)
	...
        nop
	nop
//	IF_EQ(t8, RTL98_V0, lab_disSC); //jason
        nop
	nop
	li t0,(0<<12)
a0000574:	24080000 	li	t0,0
a0000578:	4080e004 	mtc0	zero,c0_taglo2
	MTC0_SEL_OPCODE( 0, 28, 4 )  //R_C0_SelL23TagLo
a000057c:	00000040 	ssnop
a0000580:	00000040 	ssnop
a0000584:	00000040 	ssnop
a0000588:	00000040 	ssnop
	...
	nop
	nop
0:
	li	a2, START_ADDR
a0000594:	3c068000 	lui	a2,0x8000
	li  a1,_CACHELINE_SIZE
a0000598:	24050020 	li	a1,32
	li  a3,START_ADDR+_SCACHE_SIZE-_CACHELINE_SIZE
a000059c:	3c078007 	lui	a3,0x8007
a00005a0:	34e7ffe0 	ori	a3,a3,0xffe0
	

	/* Loop through all lines, invalidating each of them */
1:	

	cache	SCACHE_INDEX_STORE_TAG, 0(a2)	/* clear tag */
a00005a4:	bccb0000 	cache	0xb,0(a2)

	bne	a2, a3, 1b
a00005a8:	14c7fffe 	bne	a2,a3,a00005a4 <init_L2_cache+0x50>
	addu	a2, a1
a00005ac:	00c53021 	addu	a2,a2,a1
	...
	nop
	nop
	j SC_EXIT
a00005b8:	08000177 	j	a00005dc <SC_EXIT>

a00005bc <lab_disSC>:
lab_disSC:
	//disable L2 cache
	li t0,(1<<12)
a00005bc:	24081000 	li	t0,4096
a00005c0:	40888002 	mtc0	t0,c0_config2
	MTC0_SEL_OPCODE( 8,16,  2);
a00005c4:	00000040 	ssnop
a00005c8:	00000040 	ssnop
a00005cc:	00000040 	ssnop
a00005d0:	00000040 	ssnop
	...

a00005dc <SC_EXIT>:
	nop
	nop
	
#endif
SC_EXIT:
	nop
a00005dc:	00000000 	nop
	
	j ra
a00005e0:	03e00008 	jr	ra
	nop
a00005e4:	00000000 	nop
	...

a0000600 <exception_matrix>:
	
	//copy this body to 0x80000180
		NESTED(exception_matrix, 0, sp)
#if 1

		mfc0	k1, CP0_CAUSE	
a0000600:	401b6800 	mfc0	k1,c0_cause
	...
		nop
		nop
		la	k0, (exception_handlers)
a000060c:	3c1aa002 	lui	k0,0xa002
a0000610:	275a8970 	addiu	k0,k0,-30352
	...
		nop
		nop		
		andi	k1, k1, 0x7c
a000061c:	337b007c 	andi	k1,k1,0x7c
		addu	k0, k0, k1
a0000620:	035bd021 	addu	k0,k0,k1
		lw	k0, (k0)
a0000624:	8f5a0000 	lw	k0,0(k0)
		jr	k0
a0000628:	03400008 	jr	k0
a000062c:	00000000 	nop
	...

a0000640 <IRQ_finder>:
	.text
	.set	noreorder
	.set	noat
	.align	5
	NESTED(IRQ_finder, PT_SIZE, sp)
	SAVE_ALL
a0000640:	401a6000 	mfc0	k0,c0_status
a0000644:	001ad0c0 	sll	k0,k0,0x3
a0000648:	07400003 	bltz	k0,a0000658 <IRQ_finder+0x18>
a000064c:	03a0d821 	move	k1,sp
a0000650:	3c1ba001 	lui	k1,0xa001
a0000654:	8f7b797c 	lw	k1,31100(k1)
a0000658:	03a0d021 	move	k0,sp
a000065c:	277dff50 	addiu	sp,k1,-176
a0000660:	afba008c 	sw	k0,140(sp)
a0000664:	afa30024 	sw	v1,36(sp)
a0000668:	afa00018 	sw	zero,24(sp)
a000066c:	40036000 	mfc0	v1,c0_status
a0000670:	afa20020 	sw	v0,32(sp)
a0000674:	afa300a8 	sw	v1,168(sp)
a0000678:	afa40028 	sw	a0,40(sp)
a000067c:	40036800 	mfc0	v1,c0_cause
a0000680:	afa5002c 	sw	a1,44(sp)
a0000684:	afa300ac 	sw	v1,172(sp)
a0000688:	afa60030 	sw	a2,48(sp)
a000068c:	40037000 	mfc0	v1,c0_epc
a0000690:	afa70034 	sw	a3,52(sp)
a0000694:	afa300a0 	sw	v1,160(sp)
a0000698:	afb9007c 	sw	t9,124(sp)
a000069c:	afbc0088 	sw	gp,136(sp)
a00006a0:	afbf0094 	sw	ra,148(sp)
a00006a4:	37bc1fff 	ori	gp,sp,0x1fff
a00006a8:	3b9c1fff 	xori	gp,gp,0x1fff
a00006ac:	afa1001c 	sw	at,28(sp)
a00006b0:	00001810 	mfhi	v1
a00006b4:	afa80038 	sw	t0,56(sp)
a00006b8:	afa9003c 	sw	t1,60(sp)
a00006bc:	afa3009c 	sw	v1,156(sp)
a00006c0:	00001812 	mflo	v1
a00006c4:	afaa0040 	sw	t2,64(sp)
a00006c8:	afab0044 	sw	t3,68(sp)
a00006cc:	afa30098 	sw	v1,152(sp)
a00006d0:	afac0048 	sw	t4,72(sp)
a00006d4:	afad004c 	sw	t5,76(sp)
a00006d8:	afae0050 	sw	t6,80(sp)
a00006dc:	afaf0054 	sw	t7,84(sp)
a00006e0:	afb80078 	sw	t8,120(sp)
a00006e4:	afb00058 	sw	s0,88(sp)
a00006e8:	afb1005c 	sw	s1,92(sp)
a00006ec:	afb20060 	sw	s2,96(sp)
a00006f0:	afb30064 	sw	s3,100(sp)
a00006f4:	afb40068 	sw	s4,104(sp)
a00006f8:	afb5006c 	sw	s5,108(sp)
a00006fc:	afb60070 	sw	s6,112(sp)
a0000700:	afb70074 	sw	s7,116(sp)
a0000704:	afbe0090 	sw	s8,144(sp)
	CLI
a0000708:	40086000 	mfc0	t0,c0_status
a000070c:	3c091000 	lui	t1,0x1000
a0000710:	3529001f 	ori	t1,t1,0x1f
a0000714:	01094025 	or	t0,t0,t1
a0000718:	3908001f 	xori	t0,t0,0x1f
a000071c:	40886000 	mtc0	t0,c0_status
a0000720:	000000c0 	ehb
	.set	at
	
		mfc0    t0, CP0_CAUSE       #get pending interrupts
a0000724:	40086800 	mfc0	t0,c0_cause
	...
        nop
        nop
        
        mfc0    t2, CP0_STATUS
a0000730:	400a6000 	mfc0	t2,c0_status
	...
        nop
        nop
        
        and     t0, t2              #isolate allowed ones
a000073c:	010a4024 	and	t0,t0,t2
        nop
a0000740:	00000000 	nop
        and    t2, t0, 0xfc00      #CT: just look at the Hardware INT bit 10-15
a0000744:	310afc00 	andi	t2,t0,0xfc00
        nop
a0000748:	00000000 	nop
        
        bne     t2, zero, handle_it #it shows there are pending interrupt, jump to Handler.
a000074c:	1540000c 	bnez	t2,a0000780 <handle_it>
        nop
a0000750:	00000000 	nop
        nop
a0000754:	00000000 	nop
1:        
        li      t0,( UART_THR + 0xb8000000)
a0000758:	3c08b800 	lui	t0,0xb800
a000075c:	35082000 	ori	t0,t0,0x2000
        li      t1,'m'		    #it shows m, that is not reasonable to come here.
a0000760:	2409006d 	li	t1,109
        nop
a0000764:	00000000 	nop
        sb      t1, 0(t0)
a0000768:	a1090000 	sb	t1,0(t0)
	...
     	nop
     	nop
	 		            #just hang here.
      	b	1b 
a0000774:	1000fff8 	b	a0000758 <IRQ_finder+0x118>
        nop
a0000778:	00000000 	nop
        nop
a000077c:	00000000 	nop

a0000780 <handle_it>:

handle_it:  
//see GIC
        la      t0, (GIC_BASE_ADDR+0x480)
a0000780:	3c08bbdc 	lui	t0,0xbbdc
a0000784:	35080480 	ori	t0,t0,0x480
        la      t1, (GIC_BASE_ADDR+0x400)
a0000788:	3c09bbdc 	lui	t1,0xbbdc
a000078c:	35290400 	ori	t1,t1,0x400
	
        lw      a0, 0(t0)  	    
a0000790:	8d040000 	lw	a0,0(t0)
        lw      a1, 0(t1)	    
a0000794:	8d250000 	lw	a1,0(t1)
        nop
a0000798:	00000000 	nop
        and     a0, a1		   
a000079c:	00852024 	and	a0,a0,a1
        

        la      t0, (GIC_BASE_ADDR+0x484)
a00007a0:	3c08bbdc 	lui	t0,0xbbdc
a00007a4:	35080484 	ori	t0,t0,0x484
        la      t1, (GIC_BASE_ADDR+0x404)	
a00007a8:	3c09bbdc 	lui	t1,0xbbdc
a00007ac:	35290404 	ori	t1,t1,0x404
        lw      a2, 0(t0)  	    
a00007b0:	8d060000 	lw	a2,0(t0)
        lw      a1, 0(t1)	    
a00007b4:	8d250000 	lw	a1,0(t1)
        nop        
a00007b8:	00000000 	nop
        and     a1, a2		    
a00007bc:	00a62824 	and	a1,a1,a2
        nop
        sb      t1, 0(t0)
	//----------------------------------------------------------
#endif
        
	jal irq_dispatch        #this will lead to real ISR 
a00007c0:	0c00032c 	jal	a0000cb0 <irq_dispatch>
	nop
a00007c4:	00000000 	nop
	nop
a00007c8:	00000000 	nop
        li      t1,'o'		   
        nop
        sb      t1, 0(t0)
	//----------------------------------------------------------
#endif
        move   a1,sp
a00007cc:	03a02821 	move	a1,sp
	RESTORE_ALL_AND_RET
a00007d0:	40086000 	mfc0	t0,c0_status
a00007d4:	3508001f 	ori	t0,t0,0x1f
a00007d8:	3908001f 	xori	t0,t0,0x1f
a00007dc:	40886000 	mtc0	t0,c0_status
a00007e0:	3403ff00 	li	v1,0xff00
a00007e4:	01034024 	and	t0,t0,v1
a00007e8:	8fa200a8 	lw	v0,168(sp)
a00007ec:	00031827 	nor	v1,zero,v1
a00007f0:	00431024 	and	v0,v0,v1
a00007f4:	00481025 	or	v0,v0,t0
a00007f8:	40826000 	mtc0	v0,c0_status
a00007fc:	8fbf0094 	lw	ra,148(sp)
a0000800:	8fbc0088 	lw	gp,136(sp)
a0000804:	8fb9007c 	lw	t9,124(sp)
a0000808:	8fa70034 	lw	a3,52(sp)
a000080c:	8fa60030 	lw	a2,48(sp)
a0000810:	8fa5002c 	lw	a1,44(sp)
a0000814:	8fa40028 	lw	a0,40(sp)
a0000818:	8fa30024 	lw	v1,36(sp)
a000081c:	8fa20020 	lw	v0,32(sp)
a0000820:	8fa1001c 	lw	at,28(sp)
a0000824:	8fb80098 	lw	t8,152(sp)
a0000828:	8fa80038 	lw	t0,56(sp)
a000082c:	8fa9003c 	lw	t1,60(sp)
a0000830:	03000013 	mtlo	t8
a0000834:	8fb8009c 	lw	t8,156(sp)
a0000838:	8faa0040 	lw	t2,64(sp)
a000083c:	8fab0044 	lw	t3,68(sp)
a0000840:	03000011 	mthi	t8
a0000844:	8fac0048 	lw	t4,72(sp)
a0000848:	8fad004c 	lw	t5,76(sp)
a000084c:	8fae0050 	lw	t6,80(sp)
a0000850:	8faf0054 	lw	t7,84(sp)
a0000854:	8fb80078 	lw	t8,120(sp)
a0000858:	8fb00058 	lw	s0,88(sp)
a000085c:	8fb1005c 	lw	s1,92(sp)
a0000860:	8fb20060 	lw	s2,96(sp)
a0000864:	8fb30064 	lw	s3,100(sp)
a0000868:	8fb40068 	lw	s4,104(sp)
a000086c:	8fb5006c 	lw	s5,108(sp)
a0000870:	8fb60070 	lw	s6,112(sp)
a0000874:	8fb70074 	lw	s7,116(sp)
a0000878:	8fbe0090 	lw	s8,144(sp)
a000087c:	8fba00a0 	lw	k0,160(sp)
a0000880:	8fbd008c 	lw	sp,140(sp)
a0000884:	409a7000 	mtc0	k0,c0_epc
a0000888:	42000018 	eret
	...

a00008a0 <clear_cp0_status>:
inline unsigned int					
clear_cp0_status(unsigned int clear)				
{								
	unsigned int res;					
								
	res = read_32bit_cp0_register(CP0_STATUS);		
a00008a0:	40026000 	mfc0	v0,c0_status
	res &= ~clear;						
	write_32bit_cp0_register(CP0_STATUS, res);		
a00008a4:	00042027 	nor	a0,zero,a0
a00008a8:	00442024 	and	a0,v0,a0
a00008ac:	40846000 	mtc0	a0,c0_status
a00008b0:	00000040 	ssnop
a00008b4:	00000040 	ssnop
a00008b8:	00000040 	ssnop
a00008bc:	00000040 	ssnop
a00008c0:	000000c0 	ehb
	SPECIAL_EHB();	
}								
a00008c4:	03e00008 	jr	ra
a00008c8:	00000000 	nop

a00008cc <change_cp0_status>:
inline unsigned int					
change_cp0_status(unsigned int change, unsigned int newvalue)	
{								
	unsigned int res;					
								
	res = read_32bit_cp0_register(CP0_STATUS);		
a00008cc:	40036000 	mfc0	v1,c0_status
	res &= ~change;						
a00008d0:	00041027 	nor	v0,zero,a0
a00008d4:	00621024 	and	v0,v1,v0
	res |= (newvalue & change);					
a00008d8:	00a42024 	and	a0,a1,a0
a00008dc:	00441025 	or	v0,v0,a0
	write_32bit_cp0_register(CP0_STATUS, res);		
a00008e0:	40826000 	mtc0	v0,c0_status
a00008e4:	00000040 	ssnop
a00008e8:	00000040 	ssnop
a00008ec:	00000040 	ssnop
a00008f0:	00000040 	ssnop
a00008f4:	000000c0 	ehb
	SPECIAL_EHB();							
	return res;						
}
a00008f8:	03e00008 	jr	ra
a00008fc:	00000000 	nop

a0000900 <GIC_GIMR_enable>:
//------------------------------------------------------------------------------
//============================================================================
GIC_GIMR_enable(int irq)
{
	
	if(irq<32)
a0000900:	28820020 	slti	v0,a0,32
a0000904:	10400007 	beqz	v0,a0000924 <GIC_GIMR_enable+0x24>
a0000908:	24030001 	li	v1,1
	{
		REG32(GIC_BASE_ADDR+0x380)=(1<<irq);
a000090c:	00831804 	sllv	v1,v1,a0
a0000910:	3c02bbdc 	lui	v0,0xbbdc
a0000914:	34420380 	ori	v0,v0,0x380
a0000918:	ac430000 	sw	v1,0(v0)
	{		
		REG32(GIC_BASE_ADDR+0x384)=(1<<(irq-32));		
	}

	//map2pin
	REG32(GIC_BASE_ADDR+0x500+irq*4)=0x80000000;	
a000091c:	0800024e 	j	a0000938 <GIC_GIMR_enable+0x38>
a0000920:	3c022ef7 	lui	v0,0x2ef7
	{
		REG32(GIC_BASE_ADDR+0x380)=(1<<irq);
	}
	else
	{		
		REG32(GIC_BASE_ADDR+0x384)=(1<<(irq-32));		
a0000924:	00831804 	sllv	v1,v1,a0
a0000928:	3c02bbdc 	lui	v0,0xbbdc
a000092c:	34420384 	ori	v0,v0,0x384
a0000930:	ac430000 	sw	v1,0(v0)
	}

	//map2pin
	REG32(GIC_BASE_ADDR+0x500+irq*4)=0x80000000;	
a0000934:	3c022ef7 	lui	v0,0x2ef7
a0000938:	34420140 	ori	v0,v0,0x140
a000093c:	00821021 	addu	v0,a0,v0
a0000940:	00021080 	sll	v0,v0,0x2
a0000944:	3c038000 	lui	v1,0x8000
a0000948:	ac430000 	sw	v1,0(v0)

	//map2vpe
	REG32(GIC_BASE_ADDR+0x2000+irq*0x20)=0x1;		
a000094c:	3c0205de 	lui	v0,0x5de
a0000950:	3442e100 	ori	v0,v0,0xe100
a0000954:	00822021 	addu	a0,a0,v0
a0000958:	00042140 	sll	a0,a0,0x5
a000095c:	24020001 	li	v0,1
a0000960:	ac820000 	sw	v0,0(a0)
}
a0000964:	03e00008 	jr	ra
a0000968:	00000000 	nop

a000096c <setup_IRQ>:
    struct irqaction *old, **p;
    unsigned long flags;

    p = irq_action + irq;
//    prom_printf("IRQ action=%x,%x\n",irq_action,irq);
    save_and_cli(flags);
a000096c:	40026000 	mfc0	v0,c0_status
a0000970:	34410001 	ori	at,v0,0x1
a0000974:	38210001 	xori	at,at,0x1
a0000978:	40816000 	mtc0	at,c0_status
a000097c:	000000c0 	ehb
	...
    *p = new;
a000098c:	00042080 	sll	a0,a0,0x2
a0000990:	3c03a001 	lui	v1,0xa001
a0000994:	246379b4 	addiu	v1,v1,31156
a0000998:	00642021 	addu	a0,v1,a0
a000099c:	ac850000 	sw	a1,0(a0)
    
    restore_flags(flags);
a00009a0:	40016000 	mfc0	at,c0_status
a00009a4:	30420001 	andi	v0,v0,0x1
a00009a8:	34210001 	ori	at,at,0x1
a00009ac:	38210001 	xori	at,at,0x1
a00009b0:	00411025 	or	v0,v0,at
a00009b4:	40826000 	mtc0	v0,c0_status
a00009b8:	000000c0 	ehb
	...
    
    return 0;
}
a00009c8:	03e00008 	jr	ra
a00009cc:	00001021 	move	v0,zero

a00009d0 <request_IRQ>:

#endif


int request_IRQ(unsigned long irq, struct irqaction *action, void* dev_id)
{
a00009d0:	27bdffe0 	addiu	sp,sp,-32
a00009d4:	afbf001c 	sw	ra,28(sp)
a00009d8:	afb10018 	sw	s1,24(sp)
a00009dc:	afb00014 	sw	s0,20(sp)
a00009e0:	00808821 	move	s1,a0

    int retval;
      
 //   prom_printf("IRQ No=%x,%x\n",irq,NR_IRQS);
    if (irq >= NR_IRQS)
a00009e4:	2c820040 	sltiu	v0,a0,64
a00009e8:	10400008 	beqz	v0,a0000a0c <request_IRQ+0x3c>
a00009ec:	2410ffea 	li	s0,-22
		return -EINVAL;

	action->dev_id = dev_id;
	
    retval = setup_IRQ(irq, action);
a00009f0:	0c00025b 	jal	a000096c <setup_IRQ>
a00009f4:	aca60010 	sw	a2,16(a1)
a00009f8:	00408021 	move	s0,v0
 //   prom_printf("devid & retval =%x,%x\n",dev_id,retval);
 	
	//GIMR_enable_irq(irq);
	GIC_GIMR_enable(irq);
a00009fc:	0c000240 	jal	a0000900 <GIC_GIMR_enable>
a0000a00:	02202021 	move	a0,s1
	
    if (retval)
a0000a04:	12000003 	beqz	s0,a0000a14 <request_IRQ+0x44>
a0000a08:	8fbf001c 	lw	ra,28(sp)

	    return retval;
}
a0000a0c:	02001021 	move	v0,s0
a0000a10:	8fbf001c 	lw	ra,28(sp)
a0000a14:	8fb10018 	lw	s1,24(sp)
a0000a18:	8fb00014 	lw	s0,20(sp)
a0000a1c:	03e00008 	jr	ra
a0000a20:	27bd0020 	addiu	sp,sp,32

a0000a24 <free_IRQ>:
//------------------------------------------------------------------------------

static void  GIMR_disable_irq(unsigned int irq)
{

	REG32(GIMR_REG) &= ~(1<<irq);	
a0000a24:	3c02b800 	lui	v0,0xb800
a0000a28:	34423000 	ori	v0,v0,0x3000
a0000a2c:	8c430000 	lw	v1,0(v0)
a0000a30:	24050001 	li	a1,1
a0000a34:	00852804 	sllv	a1,a1,a0
a0000a38:	00052827 	nor	a1,zero,a1
a0000a3c:	00a31824 	and	v1,a1,v1
a0000a40:	ac430000 	sw	v1,0(v0)

int	free_IRQ(unsigned long irq)
{
	GIMR_disable_irq(irq);	
	
}
a0000a44:	03e00008 	jr	ra
a0000a48:	00000000 	nop

a0000a4c <set_except_vector>:

//------------------------------------------------------------------------------
void set_except_vector(int n, void *addr)
{
	unsigned handler = (unsigned long) addr;
	exception_handlers[n] = handler;
a0000a4c:	00042080 	sll	a0,a0,0x2
a0000a50:	3c02a002 	lui	v0,0xa002
a0000a54:	24428970 	addiu	v0,v0,-30352
a0000a58:	00822021 	addu	a0,a0,v0
}
a0000a5c:	03e00008 	jr	ra
a0000a60:	ac850000 	sw	a1,0(a0)

a0000a64 <init_IRQ>:
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------


void  init_IRQ(void)
{
a0000a64:	27bdffe8 	addiu	sp,sp,-24
a0000a68:	afbf0014 	sw	ra,20(sp)
inline unsigned int					
change_cp0_status(unsigned int change, unsigned int newvalue)	
{								
	unsigned int res;					
								
	res = read_32bit_cp0_register(CP0_STATUS);		
a0000a6c:	40036000 	mfc0	v1,c0_status
	res &= ~change;						
	res |= (newvalue & change);					
	write_32bit_cp0_register(CP0_STATUS, res);		
a0000a70:	3c02ffff 	lui	v0,0xffff
a0000a74:	344200ff 	ori	v0,v0,0xff
a0000a78:	00621024 	and	v0,v1,v0
a0000a7c:	40826000 	mtc0	v0,c0_status
a0000a80:	00000040 	ssnop
a0000a84:	00000040 	ssnop
a0000a88:	00000040 	ssnop
a0000a8c:	00000040 	ssnop
a0000a90:	000000c0 	ehb
	change_cp0_status(ST0_IM, 0x00);
	

	/* Set up the external interrupt exception vector */
	/* First exception is Interrupt*/
	set_except_vector(0, IRQ_finder);
a0000a94:	00002021 	move	a0,zero
a0000a98:	3c05a000 	lui	a1,0xa000
a0000a9c:	0c000293 	jal	a0000a4c <set_except_vector>
a0000aa0:	24a50640 	addiu	a1,a1,1600
inline unsigned int					
change_cp0_status(unsigned int change, unsigned int newvalue)	
{								
	unsigned int res;					
								
	res = read_32bit_cp0_register(CP0_STATUS);		
a0000aa4:	40036000 	mfc0	v1,c0_status
	res &= ~change;						
a0000aa8:	3c02ffff 	lui	v0,0xffff
a0000aac:	344200ff 	ori	v0,v0,0xff
a0000ab0:	00621024 	and	v0,v1,v0
	res |= (newvalue & change);					
	write_32bit_cp0_register(CP0_STATUS, res);		
a0000ab4:	34427c00 	ori	v0,v0,0x7c00
a0000ab8:	40826000 	mtc0	v0,c0_status
a0000abc:	00000040 	ssnop
a0000ac0:	00000040 	ssnop
a0000ac4:	00000040 	ssnop
a0000ac8:	00000040 	ssnop
a0000acc:	000000c0 	ehb
	/* First exception is Interrupt*/
	set_except_vector(0, IRQ_finder);

	/* Enable all interrupts */
	change_cp0_status(ST0_IM, ALLINTS);
}
a0000ad0:	8fbf0014 	lw	ra,20(sp)
a0000ad4:	03e00008 	jr	ra
a0000ad8:	27bd0018 	addiu	sp,sp,24

a0000adc <init_exception>:
}

unsigned long ebase_reg = 0;
//------------------------------------------------------------------------------
void  init_exception(void)
{
a0000adc:	27bdffe0 	addiu	sp,sp,-32
a0000ae0:	afbf001c 	sw	ra,28(sp)
a0000ae4:	afb20018 	sw	s2,24(sp)
a0000ae8:	afb10014 	sw	s1,20(sp)
a0000aec:	afb00010 	sw	s0,16(sp)
inline unsigned int					
clear_cp0_status(unsigned int clear)				
{								
	unsigned int res;					
								
	res = read_32bit_cp0_register(CP0_STATUS);		
a0000af0:	40036000 	mfc0	v1,c0_status
	res &= ~clear;						
	write_32bit_cp0_register(CP0_STATUS, res);		
a0000af4:	3c02ffbf 	lui	v0,0xffbf
a0000af8:	3442ffff 	ori	v0,v0,0xffff
a0000afc:	00621024 	and	v0,v1,v0
a0000b00:	40826000 	mtc0	v0,c0_status
a0000b04:	00000040 	ssnop
a0000b08:	00000040 	ssnop
a0000b0c:	00000040 	ssnop
a0000b10:	00000040 	ssnop
a0000b14:	000000c0 	ehb
	SPECIAL_EHB();	
a0000b18:	00008021 	move	s0,zero

	unsigned long i;
	clear_cp0_status(ST0_BEV);

	for (i = 0; i <= 31; i++)
		set_except_vector(i, do_reserved);
a0000b1c:	3c11a000 	lui	s1,0xa000
a0000b20:	26310c40 	addiu	s1,s1,3136
	extern char exception_matrix;

	unsigned long i;
	clear_cp0_status(ST0_BEV);

	for (i = 0; i <= 31; i++)
a0000b24:	24120020 	li	s2,32
		set_except_vector(i, do_reserved);
a0000b28:	02002021 	move	a0,s0
a0000b2c:	0c000293 	jal	a0000a4c <set_except_vector>
a0000b30:	02202821 	move	a1,s1
	extern char exception_matrix;

	unsigned long i;
	clear_cp0_status(ST0_BEV);

	for (i = 0; i <= 31; i++)
a0000b34:	26100001 	addiu	s0,s0,1
a0000b38:	1612fffc 	bne	s0,s2,a0000b2c <init_exception+0x50>
a0000b3c:	02002021 	move	a0,s0
		set_except_vector(i, do_reserved);

#ifdef CONFIG_NAND_FLASH_BOOTING
	ebase_reg = 0xa0000000;
a0000b40:	3c03a000 	lui	v1,0xa000
a0000b44:	3c02a001 	lui	v0,0xa001
a0000b48:	ac4379b0 	sw	v1,31152(v0)
	write_c0_ebase(ebase_reg);
a0000b4c:	3c02a000 	lui	v0,0xa000
a0000b50:	40827801 	mtc0	v0,c0_ebase
    memcpy((void *)(KSEG1 + 0x180), &exception_matrix, 0x80);
a0000b54:	3c03a000 	lui	v1,0xa000
a0000b58:	24630600 	addiu	v1,v1,1536
a0000b5c:	34420180 	ori	v0,v0,0x180
a0000b60:	24680080 	addiu	t0,v1,128
a0000b64:	88670000 	lwl	a3,0(v1)
a0000b68:	98670003 	lwr	a3,3(v1)
a0000b6c:	88660004 	lwl	a2,4(v1)
a0000b70:	98660007 	lwr	a2,7(v1)
a0000b74:	88650008 	lwl	a1,8(v1)
a0000b78:	9865000b 	lwr	a1,11(v1)
a0000b7c:	8864000c 	lwl	a0,12(v1)
a0000b80:	9864000f 	lwr	a0,15(v1)
a0000b84:	a8470000 	swl	a3,0(v0)
a0000b88:	b8470003 	swr	a3,3(v0)
a0000b8c:	a8460004 	swl	a2,4(v0)
a0000b90:	b8460007 	swr	a2,7(v0)
a0000b94:	a8450008 	swl	a1,8(v0)
a0000b98:	b845000b 	swr	a1,11(v0)
a0000b9c:	a844000c 	swl	a0,12(v0)
a0000ba0:	b844000f 	swr	a0,15(v0)
a0000ba4:	24630010 	addiu	v1,v1,16
a0000ba8:	1468ffee 	bne	v1,t0,a0000b64 <init_exception+0x88>
a0000bac:	24420010 	addiu	v0,v0,16
#else
    memcpy((void *)(KSEG0 + 0x180), &exception_matrix, 0x80);
#endif
    flush_cache();
a0000bb0:	0c001eae 	jal	a0007ab8 <flush_cache>
a0000bb4:	00000000 	nop
}
a0000bb8:	8fbf001c 	lw	ra,28(sp)
a0000bbc:	8fb20018 	lw	s2,24(sp)
a0000bc0:	8fb10014 	lw	s1,20(sp)
a0000bc4:	8fb00010 	lw	s0,16(sp)
a0000bc8:	03e00008 	jr	ra
a0000bcc:	27bd0020 	addiu	sp,sp,32

a0000bd0 <initInterrupt>:

//============================================================================

// init interrupt 
void initInterrupt(void)
{
a0000bd0:	27bdffe8 	addiu	sp,sp,-24
a0000bd4:	afbf0014 	sw	ra,20(sp)
	//printf("=>init interrupt...\n");
	REG32(GIMR_REG)=0x00;/*mask all interrupt*/
a0000bd8:	3c02b800 	lui	v0,0xb800
a0000bdc:	34433000 	ori	v1,v0,0x3000
a0000be0:	ac600000 	sw	zero,0(v1)
	
		REG32(0xb8003114)=0;  //disable timer interrupt
a0000be4:	34433114 	ori	v1,v0,0x3114
a0000be8:	ac600000 	sw	zero,0(v1)
		REG32(0xb8000010)&=~(1<<11);
a0000bec:	34420010 	ori	v0,v0,0x10
a0000bf0:	8c440000 	lw	a0,0(v0)
a0000bf4:	2403f7ff 	li	v1,-2049
a0000bf8:	00831824 	and	v1,a0,v1
a0000bfc:	ac430000 	sw	v1,0(v0)
		
		REG32(0xbbdc0300)=0xFFFFFFFF;
a0000c00:	3c03bbdc 	lui	v1,0xbbdc
a0000c04:	34640300 	ori	a0,v1,0x300
a0000c08:	2402ffff 	li	v0,-1
a0000c0c:	ac820000 	sw	v0,0(a0)
		REG32(0xbbdc0304)=0xFFFFFFFF;
a0000c10:	34630304 	ori	v1,v1,0x304
	
   /*setup the BEV0,and IRQ */
	init_exception();/*Copy handler to 0x80000080*/
a0000c14:	0c0002b7 	jal	a0000adc <init_exception>
a0000c18:	ac620000 	sw	v0,0(v1)
	init_IRQ();      /*Allocate IRQfinder to Exception 0*/
a0000c1c:	0c000299 	jal	a0000a64 <init_IRQ>
a0000c20:	00000000 	nop


extern __inline__ void
__sti(void)
{
	__asm__ __volatile__(
a0000c24:	40016000 	mfc0	at,c0_status
a0000c28:	34210001 	ori	at,at,0x1
a0000c2c:	40816000 	mtc0	at,c0_status
a0000c30:	000000c0 	ehb
	sti();
}
a0000c34:	8fbf0014 	lw	ra,20(sp)
a0000c38:	03e00008 	jr	ra
a0000c3c:	27bd0018 	addiu	sp,sp,24

a0000c40 <do_reserved>:
	exception_handlers[n] = handler;
}
//------------------------------------------------------------------------------

void do_reserved(struct pt_regs *regs)
{
a0000c40:	27bdffe8 	addiu	sp,sp,-24
a0000c44:	afbf0014 	sw	ra,20(sp)
	/*fatal hard/software error*/
	int i;
	prom_printf("Undefined Exception happen.");	
a0000c48:	3c04a001 	lui	a0,0xa001
a0000c4c:	0c0023a7 	jal	a0008e9c <prom_printf>
a0000c50:	24844018 	addiu	a0,a0,16408
a0000c54:	08000315 	j	a0000c54 <do_reserved+0x14>
a0000c58:	00000000 	nop

a0000c5c <do_IRQ>:
}

//------------------------------------------------------------------------------

void do_IRQ(int irqnr)
{
a0000c5c:	27bdffe8 	addiu	sp,sp,-24
a0000c60:	afbf0014 	sw	ra,20(sp)
    struct irqaction *action;
	unsigned long i;

	//printf("Got irq %d\n", irqnr);
	
    action = *(irqnr + irq_action);
a0000c64:	00041880 	sll	v1,a0,0x2
a0000c68:	3c02a001 	lui	v0,0xa001
a0000c6c:	244279b4 	addiu	v0,v0,31156
a0000c70:	00431021 	addu	v0,v0,v1
a0000c74:	8c430000 	lw	v1,0(v0)
        	
	if (action) 
a0000c78:	10600008 	beqz	v1,a0000c9c <do_IRQ+0x40>
a0000c7c:	00802821 	move	a1,a0
    {
    	//printf("Do ISR=%x\n", action->handler);
	    action->handler(irqnr, action->dev_id, NULL);
a0000c80:	8c620000 	lw	v0,0(v1)
a0000c84:	8c650010 	lw	a1,16(v1)
a0000c88:	0040f809 	jalr	v0
a0000c8c:	00003021 	move	a2,zero
	else
	{    
		prom_printf("Fail, you got irq=%X, but not have ISR\n", irqnr);
		for(;;);
	}			
}	
a0000c90:	8fbf0014 	lw	ra,20(sp)
a0000c94:	03e00008 	jr	ra
a0000c98:	27bd0018 	addiu	sp,sp,24
    	//printf("Do ISR=%x\n", action->handler);
	    action->handler(irqnr, action->dev_id, NULL);
    }
	else
	{    
		prom_printf("Fail, you got irq=%X, but not have ISR\n", irqnr);
a0000c9c:	3c04a001 	lui	a0,0xa001
a0000ca0:	0c0023a7 	jal	a0008e9c <prom_printf>
a0000ca4:	24844034 	addiu	a0,a0,16436
a0000ca8:	0800032a 	j	a0000ca8 <do_IRQ+0x4c>
a0000cac:	00000000 	nop

a0000cb0 <irq_dispatch>:

extern  void do_IRQ(int irq);
//------------------------------------------------------------------------------

void irq_dispatch(int irq_nr, int irq_nr2)
{
a0000cb0:	27bdffd0 	addiu	sp,sp,-48
a0000cb4:	afbf002c 	sw	ra,44(sp)
a0000cb8:	afb50028 	sw	s5,40(sp)
a0000cbc:	afb40024 	sw	s4,36(sp)
a0000cc0:	afb30020 	sw	s3,32(sp)
a0000cc4:	afb2001c 	sw	s2,28(sp)
a0000cc8:	afb10018 	sw	s1,24(sp)
a0000ccc:	afb00014 	sw	s0,20(sp)
a0000cd0:	00808821 	move	s1,a0
a0000cd4:	00a09021 	move	s2,a1
a0000cd8:	00008021 	move	s0,zero
	int i,irq=0;
	//prom_printf("irq.c : irq_nr=%x  irq_nr2=%x  \n",irq_nr, irq_nr2);
	
	//Low 32bit
    for (i=0; i<=31; i++)
a0000cdc:	24130020 	li	s3,32
    {
        if (irq_nr & 0x01)
a0000ce0:	32220001 	andi	v0,s1,0x1
a0000ce4:	10400003 	beqz	v0,a0000cf4 <irq_dispatch+0x44>
a0000ce8:	00000000 	nop
		{
			//prom_printf("do irq=%x\n",irq);
			do_IRQ(irq);
a0000cec:	0c000317 	jal	a0000c5c <do_IRQ>
a0000cf0:	02002021 	move	a0,s0
{
	int i,irq=0;
	//prom_printf("irq.c : irq_nr=%x  irq_nr2=%x  \n",irq_nr, irq_nr2);
	
	//Low 32bit
    for (i=0; i<=31; i++)
a0000cf4:	26100001 	addiu	s0,s0,1
a0000cf8:	1613fff9 	bne	s0,s3,a0000ce0 <irq_dispatch+0x30>
a0000cfc:	00118843 	sra	s1,s1,0x1
			//prom_printf("do irq=%x\n",irq);
			do_IRQ(irq);

		}  
        irq++;
        irq_nr = irq_nr >> 1;
a0000d00:	24100020 	li	s0,32
	//High 32bit
    for (i=0; i<=31; i++)
    {
        if (irq_nr2 & 0x01)
		{
			if(irq==43)
a0000d04:	2413002b 	li	s3,43
   			{
    				if(REG32(0xbbdc2560)==2)   //for core 1, not process.
a0000d08:	3c14bbdc 	lui	s4,0xbbdc
a0000d0c:	36942560 	ori	s4,s4,0x2560
a0000d10:	24150002 	li	s5,2
        irq++;
        irq_nr = irq_nr >> 1;
    }

	//High 32bit
    for (i=0; i<=31; i++)
a0000d14:	2411003f 	li	s1,63
    {
        if (irq_nr2 & 0x01)
a0000d18:	32420001 	andi	v0,s2,0x1
a0000d1c:	10400008 	beqz	v0,a0000d40 <irq_dispatch+0x90>
a0000d20:	00000000 	nop
		{
			if(irq==43)
a0000d24:	16130004 	bne	s0,s3,a0000d38 <irq_dispatch+0x88>
a0000d28:	00000000 	nop
   			{
    				if(REG32(0xbbdc2560)==2)   //for core 1, not process.
a0000d2c:	8e820000 	lw	v0,0(s4)
a0000d30:	10550008 	beq	v0,s5,a0000d54 <irq_dispatch+0xa4>
a0000d34:	8fbf002c 	lw	ra,44(sp)
     				return;
   			}		
	
					//prom_printf("do irq=%x\n",irq);
			do_IRQ(irq);
a0000d38:	0c000317 	jal	a0000c5c <do_IRQ>
a0000d3c:	02002021 	move	a0,s0
        irq++;
        irq_nr = irq_nr >> 1;
    }

	//High 32bit
    for (i=0; i<=31; i++)
a0000d40:	12110003 	beq	s0,s1,a0000d50 <irq_dispatch+0xa0>
a0000d44:	26100001 	addiu	s0,s0,1
					//prom_printf("do irq=%x\n",irq);
			do_IRQ(irq);

		}  
        irq++;
        irq_nr2 = irq_nr2 >> 1;
a0000d48:	08000346 	j	a0000d18 <irq_dispatch+0x68>
a0000d4c:	00129043 	sra	s2,s2,0x1
    }
}
a0000d50:	8fbf002c 	lw	ra,44(sp)
a0000d54:	8fb50028 	lw	s5,40(sp)
a0000d58:	8fb40024 	lw	s4,36(sp)
a0000d5c:	8fb30020 	lw	s3,32(sp)
a0000d60:	8fb2001c 	lw	s2,28(sp)
a0000d64:	8fb10018 	lw	s1,24(sp)
a0000d68:	8fb00014 	lw	s0,20(sp)
a0000d6c:	03e00008 	jr	ra
a0000d70:	27bd0030 	addiu	sp,sp,48
	...

a0000d80 <errorTFTP>:
/*error in boot state machine*/	
}
//----------------------------------------------------------------------------------------
static void errorTFTP(void)
{
    if (!tftpd_is_ready)
a0000d80:	3c02a001 	lui	v0,0xa001
a0000d84:	8c427ac4 	lw	v0,31428(v0)
a0000d88:	10400002 	beqz	v0,a0000d94 <errorTFTP+0x14>
a0000d8c:	3c02a001 	lui	v0,0xa001
		dprintf("[errcode from TFTP server:] %d\n",errcode);
		dprintf("[errmsg from TFTP server:] %s\n",errmsg);
		tftp_client_recvdone = 1;
	}
#endif
bootState=BOOT_STATE0_INIT_ARP;
a0000d90:	ac407954 	sw	zero,31060(v0)
a0000d94:	03e00008 	jr	ra
a0000d98:	00000000 	nop

a0000d9c <updateARPTable>:
			//dprintf("--send rrq to TFTP server--, [filename:] %s, image_address = 0x%x\n",TEST_FILENAME,image_address);
		}
	 }
 }
#endif 
}
a0000d9c:	03e00008 	jr	ra
a0000da0:	00000000 	nop

a0000da4 <Patch_TFTP_SDR_2M>:
	#define RANG2 3
	#define RANG3  7
	#define RANG4 0xf	
	
	#define SYS_HW_STRAP   (0xb8000000 +0x08)
	unsigned int v=REG32(SYS_HW_STRAP);
a0000da4:	3c02b800 	lui	v0,0xb800
a0000da8:	34420008 	ori	v0,v0,0x8
a0000dac:	8c420000 	lw	v0,0(v0)

	unsigned char boot_sel=GET_BITVAL(v, 0, RANG3);
	unsigned char dramtype_sel=GET_BITVAL(v, 4, RANG1);

	
	if( (boot_sel==0x7) && (dramtype_sel==0) )   //ROM4, SDR type =2M
a0000db0:	30440007 	andi	a0,v0,0x7
a0000db4:	24030007 	li	v1,7
a0000db8:	14830005 	bne	a0,v1,a0000dd0 <Patch_TFTP_SDR_2M+0x2c>
a0000dbc:	7c420100 	ext	v0,v0,0x4,0x1
a0000dc0:	14400003 	bnez	v0,a0000dd0 <Patch_TFTP_SDR_2M+0x2c>
a0000dc4:	3c038018 	lui	v1,0x8018
		image_address=0x80180000;
a0000dc8:	3c02a001 	lui	v0,0xa001
a0000dcc:	ac437218 	sw	v1,29208(v0)
a0000dd0:	03e00008 	jr	ra
a0000dd4:	00000000 	nop

a0000dd8 <tftpd_entry>:
#ifdef SUPPORT_TFTP_CLIENT
void tftpd_entry(int is_client_mode)
#else
void tftpd_entry(void)
#endif
{
a0000dd8:	27bdffe8 	addiu	sp,sp,-24
a0000ddc:	afbf0014 	sw	ra,20(sp)
 int i,j;
 
#if 1 //ROM code need
		Patch_TFTP_SDR_2M();
a0000de0:	0c000369 	jal	a0000da4 <Patch_TFTP_SDR_2M>
a0000de4:	00000000 	nop
	arptable_tftp[TFTP_SERVER].ipaddr.s_addr = *ptr2;	
else
	arptable_tftp[TFTP_SERVER].ipaddr.s_addr = IPTOUL(192,168,1,97);

#else
arptable_tftp[TFTP_SERVER].ipaddr.s_addr = IPTOUL(192,168,1,6);
a0000de8:	3c02a002 	lui	v0,0xa002
a0000dec:	3c03c0a8 	lui	v1,0xc0a8
a0000df0:	34630106 	ori	v1,v1,0x106
a0000df4:	ac438bf0 	sw	v1,-29712(v0)
#endif

arptable_tftp[TFTP_CLIENT].ipaddr.s_addr = IPTOUL(192,162,1,116);
a0000df8:	24428bf0 	addiu	v0,v0,-29712
a0000dfc:	3c03c0a2 	lui	v1,0xc0a2
a0000e00:	34630174 	ori	v1,v1,0x174
a0000e04:	ac43000c 	sw	v1,12(v0)
 /*This is ETH0. we treat ETH0 as the TFTP server*/
 /*char eth0_mac[6]={0x56, 0xaa, 0xa5, 0x5a, 0x7d, 0xe8};*/
arptable_tftp[TFTP_SERVER].node[5]=eth0_mac[5];
a0000e08:	3c04a001 	lui	a0,0xa001
a0000e0c:	248374f0 	addiu	v1,a0,29936
a0000e10:	90650005 	lbu	a1,5(v1)
a0000e14:	a0450009 	sb	a1,9(v0)
arptable_tftp[TFTP_SERVER].node[4]=eth0_mac[4];
a0000e18:	90650004 	lbu	a1,4(v1)
a0000e1c:	a0450008 	sb	a1,8(v0)
arptable_tftp[TFTP_SERVER].node[3]=eth0_mac[3];
a0000e20:	90650003 	lbu	a1,3(v1)
a0000e24:	a0450007 	sb	a1,7(v0)
arptable_tftp[TFTP_SERVER].node[2]=eth0_mac[2];
a0000e28:	90650002 	lbu	a1,2(v1)
a0000e2c:	a0450006 	sb	a1,6(v0)
arptable_tftp[TFTP_SERVER].node[1]=eth0_mac[1];
a0000e30:	90630001 	lbu	v1,1(v1)
a0000e34:	a0430005 	sb	v1,5(v0)
arptable_tftp[TFTP_SERVER].node[0]=eth0_mac[0];
a0000e38:	908374f0 	lbu	v1,29936(a0)
a0000e3c:	a0430004 	sb	v1,4(v0)
//arptable_tftp[TFTP_SERVER].node[1]=0xaa;
//arptable_tftp[TFTP_SERVER].node[0]=0x56;


 /*intialize boot state*/	
 bootState=BOOT_STATE0_INIT_ARP;
a0000e40:	3c02a001 	lui	v0,0xa001
a0000e44:	ac407954 	sw	zero,31060(v0)
 /*this nic is the expected data structure to be processed.*/
 nic.packet=eth_packet;
a0000e48:	3c02a001 	lui	v0,0xa001
a0000e4c:	3c03a002 	lui	v1,0xa002
a0000e50:	24638c14 	addiu	v1,v1,-29676
a0000e54:	ac437948 	sw	v1,31048(v0)
 nic.packetlen=0;
a0000e58:	24427948 	addiu	v0,v0,31048
a0000e5c:	ac400004 	sw	zero,4(v0)

 block_expected=0;
a0000e60:	3c02a001 	lui	v0,0xa001
a0000e64:	a4407944 	sh	zero,31044(v0)
 one_tftp_lock=0;
a0000e68:	3c02a001 	lui	v0,0xa001
a0000e6c:	a0407acc 	sb	zero,31436(v0)
 it_is_EOF=0;
a0000e70:	3c02a001 	lui	v0,0xa001
a0000e74:	ac407ad0 	sw	zero,31440(v0)

//prom_printf("line=%d:		block_expected=%d\n", __LINE__,  block_expected); // for debug

 
 //image_address=FILESTART; //sc_yang
 address_to_store=image_address;
a0000e78:	3c02a001 	lui	v0,0xa001
a0000e7c:	8c437218 	lw	v1,29208(v0)
a0000e80:	3c02a001 	lui	v0,0xa001
a0000e84:	ac437940 	sw	v1,31040(v0)
 
 file_length_to_server=0;
a0000e88:	3c02a001 	lui	v0,0xa001
a0000e8c:	ac407960 	sw	zero,31072(v0)
 file_length_to_client=0;
a0000e90:	3c02a001 	lui	v0,0xa001
a0000e94:	ac407958 	sw	zero,31064(v0)
#ifdef SUPPORT_TFTP_CLIENT
 if (is_client_mode)
	 SERVER_port=69; 	
 else
#endif 	
 SERVER_port=2098;
a0000e98:	24030832 	li	v1,2098
a0000e9c:	3c02a001 	lui	v0,0xa001
a0000ea0:	a4437950 	sh	v1,31056(v0)

#ifndef CONFIG_FPGA_PLATFORM
    tftpd_is_ready = 1;
a0000ea4:	24030001 	li	v1,1
a0000ea8:	3c02a001 	lui	v0,0xa001
a0000eac:	ac437ac4 	sw	v1,31428(v0)
	tftp_client_enabled = 1;	
 }
 else	
	tftp_client_enabled = 0;
#endif
}
a0000eb0:	8fbf0014 	lw	ra,20(sp)
a0000eb4:	03e00008 	jr	ra
a0000eb8:	27bd0018 	addiu	sp,sp,24

a0000ebc <ipheader_chksum>:
            break;/*ptype=IP*/ 
    }
}
//----------------------------------------------------------------------------------------
Int16 ipheader_chksum(Int16*ip,int len)
{
a0000ebc:	00052843 	sra	a1,a1,0x1
a0000ec0:	00001021 	move	v0,zero
 Int32 sum = 0;
 len >>= 1;
 while (len--)
 {
  sum += *(ip++);
  if (sum > 0xFFFF)
a0000ec4:	3c080001 	lui	t0,0x1
  sum -= 0xFFFF;
a0000ec8:	3c07ffff 	lui	a3,0xffff
//----------------------------------------------------------------------------------------
Int16 ipheader_chksum(Int16*ip,int len)
{
 Int32 sum = 0;
 len >>= 1;
 while (len--)
a0000ecc:	080003bc 	j	a0000ef0 <ipheader_chksum+0x34>
a0000ed0:	34e70001 	ori	a3,a3,0x1
 {
  sum += *(ip++);
a0000ed4:	94830000 	lhu	v1,0(a0)
a0000ed8:	00431021 	addu	v0,v0,v1
  if (sum > 0xFFFF)
a0000edc:	0048302b 	sltu	a2,v0,t0
  sum -= 0xFFFF;
a0000ee0:	00471821 	addu	v1,v0,a3
a0000ee4:	0066100a 	movz	v0,v1,a2
{
 Int32 sum = 0;
 len >>= 1;
 while (len--)
 {
  sum += *(ip++);
a0000ee8:	24840002 	addiu	a0,a0,2
a0000eec:	24a5ffff 	addiu	a1,a1,-1
//----------------------------------------------------------------------------------------
Int16 ipheader_chksum(Int16*ip,int len)
{
 Int32 sum = 0;
 len >>= 1;
 while (len--)
a0000ef0:	14a0fff8 	bnez	a1,a0000ed4 <ipheader_chksum+0x18>
a0000ef4:	00000000 	nop
a0000ef8:	00021027 	nor	v0,zero,v0
  sum += *(ip++);
  if (sum > 0xFFFF)
  sum -= 0xFFFF;
 }                           /*Correct return 0*/
 return((~sum) & 0x0000FFFF);/*only 2 bytes*/
}
a0000efc:	03e00008 	jr	ra
a0000f00:	3042ffff 	andi	v0,v0,0xffff

a0000f04 <kick_tftpd>:
 prepare_txpkt(0,FRAME_IP,arptable_tftp[TFTP_CLIENT].node,(Int8*)&tftp_tx,(Int16)sizeof(struct iphdr)+sizeof(struct udphdr)+length+4);
}
               
//----------------------------------------------------------------------------------------
void kick_tftpd(void)
{
a0000f04:	27bdffe8 	addiu	sp,sp,-24
a0000f08:	afbf0014 	sw	ra,20(sp)
a0000f0c:	afb00010 	sw	s0,16(sp)
    BootEvent_t  kick_event=NUM_OF_BOOT_EVENTS;
      
    Int32 UDPIPETHheader = ETH_HLEN + sizeof(struct iphdr)  + sizeof(struct udphdr);		 
    
    
    if (nic.packetlen >= ETH_HLEN+sizeof(struct arprequest)) {
a0000f10:	3c02a001 	lui	v0,0xa001
a0000f14:	8c42794c 	lw	v0,31052(v0)
a0000f18:	2c43002a 	sltiu	v1,v0,42
a0000f1c:	1460008d 	bnez	v1,a0001154 <kick_tftpd+0x250>
a0000f20:	3c03a001 	lui	v1,0xa001
    	 pkttype =( (Int16)(nic.packet[12]<< 8)  |(Int16)(nic.packet[13])   );   /*This BIG byte shifts right 8*/             
a0000f24:	8c707948 	lw	s0,31048(v1)
    } 

    switch (pkttype) {
a0000f28:	8203000c 	lb	v1,12(s0)
a0000f2c:	8204000d 	lb	a0,13(s0)
a0000f30:	00031a00 	sll	v1,v1,0x8
a0000f34:	00641825 	or	v1,v1,a0
a0000f38:	3063ffff 	andi	v1,v1,0xffff
a0000f3c:	24040800 	li	a0,2048
a0000f40:	10640015 	beq	v1,a0,a0000f98 <kick_tftpd+0x94>
a0000f44:	2c42002b 	sltiu	v0,v0,43
a0000f48:	24020806 	li	v0,2054
a0000f4c:	14620081 	bne	v1,v0,a0001154 <kick_tftpd+0x250>
a0000f50:	2610000e 	addiu	s0,s0,14
			/*keep parsing, check the opcode is request or reply*/
			arppacket = (struct arprequest *)&nic.packet[ETH_HLEN];
			/*Parse the opcode, 01->req, 02 ->reply*/ 	
			arpopcode = arppacket->opcode;
						  
            switch(arpopcode) {
a0000f54:	96020006 	lhu	v0,6(s0)
a0000f58:	24030001 	li	v1,1
a0000f5c:	10430005 	beq	v0,v1,a0000f74 <kick_tftpd+0x70>
a0000f60:	24030002 	li	v1,2
a0000f64:	1443007b 	bne	v0,v1,a0001154 <kick_tftpd+0x250>
a0000f68:	24030001 	li	v1,1
                    break;
            }
            //wei del
            if (kick_event!=NUM_OF_BOOT_EVENTS) {
                jump = (void *)(*BootStateEvent[bootState][kick_event]);
                jump();
a0000f6c:	0800043d 	j	a00010f4 <kick_tftpd+0x1f0>
a0000f70:	3c02a001 	lui	v0,0xa001
			arpopcode = arppacket->opcode;
						  
            switch(arpopcode) {
                case htons(ARP_REQUEST):     														
				    // check dst ip, david+2007-12-26											
                    if (!memcmp(arppacket->tipaddr, &arptable_tftp[TFTP_SERVER].ipaddr, 4)
a0000f74:	26040018 	addiu	a0,s0,24
a0000f78:	3c05a002 	lui	a1,0xa002
a0000f7c:	24a58bf0 	addiu	a1,a1,-29712
a0000f80:	0c002051 	jal	a0008144 <memcmp>
a0000f84:	24060004 	li	a2,4
a0000f88:	10400059 	beqz	v0,a00010f0 <kick_tftpd+0x1ec>
a0000f8c:	00001821 	move	v1,zero
                    }
                }
            }
            break;/*ptype=IP*/ 
    }
}
a0000f90:	08000456 	j	a0001158 <kick_tftpd+0x254>
a0000f94:	8fbf0014 	lw	ra,20(sp)
            break;/*ptype=ARP*/

        //--------------------------------------------------------------------------	
        case htons(FRAME_IP):
            //dprintf("rx ip packet\n");	//wei add
            ipheader = (struct iphdr *)&nic.packet[ETH_HLEN];
a0000f98:	2610000e 	addiu	s0,s0,14
            // word alignment
            //Cyrus Dick
            ip_addr.ip[0] = ipheader->dest.ip[0];
a0000f9c:	92060010 	lbu	a2,16(s0)
            ip_addr.ip[1] = ipheader->dest.ip[1];
a0000fa0:	92050011 	lbu	a1,17(s0)
            ip_addr.ip[2] = ipheader->dest.ip[2];
a0000fa4:	92040012 	lbu	a0,18(s0)
            //source_ip_addr.ip[1] = ipheader->src.ip[1];
            //source_ip_addr.ip[2] = ipheader->src.ip[2];
            //source_ip_addr.ip[3] = ipheader->src.ip[3];
            //Cyrus Dick
            /*Even type is IP, but the total payload must at least UDPH+IPH*/
            if (nic.packetlen > UDPIPETHheader) {
a0000fa8:	1440006a 	bnez	v0,a0001154 <kick_tftpd+0x250>
a0000fac:	92030013 	lbu	v1,19(s0)
                /*keep parsing, check the TCP/UDP, here is meaningful*/
                if (ipheader->verhdrlen==0x45) {
a0000fb0:	82070000 	lb	a3,0(s0)
a0000fb4:	24020045 	li	v0,69
a0000fb8:	14e20067 	bne	a3,v0,a0001158 <kick_tftpd+0x254>
a0000fbc:	8fbf0014 	lw	ra,20(sp)
        case htons(FRAME_IP):
            //dprintf("rx ip packet\n");	//wei add
            ipheader = (struct iphdr *)&nic.packet[ETH_HLEN];
            // word alignment
            //Cyrus Dick
            ip_addr.ip[0] = ipheader->dest.ip[0];
a0000fc0:	00001021 	move	v0,zero
a0000fc4:	7cc2fe04 	ins	v0,a2,0x18,0x8
            ip_addr.ip[1] = ipheader->dest.ip[1];
a0000fc8:	7ca2bc04 	ins	v0,a1,0x10,0x8
            ip_addr.ip[2] = ipheader->dest.ip[2];
a0000fcc:	7c827a04 	ins	v0,a0,0x8,0x8
            ip_addr.ip[3] = ipheader->dest.ip[3];
a0000fd0:	7c623804 	ins	v0,v1,0x0,0x8
                        || ip_addr.s_addr  == arptable_tftp[HTTPD_ARPENTRY].ipaddr.s_addr 
#endif
                        ) {					

#else					
                    if (ip_addr.s_addr==arptable_tftp[TFTP_SERVER].ipaddr.s_addr 
a0000fd4:	3c03a002 	lui	v1,0xa002
a0000fd8:	8c638bf0 	lw	v1,-29712(v1)
a0000fdc:	1443005e 	bne	v0,v1,a0001158 <kick_tftpd+0x254>
a0000fe0:	02002021 	move	a0,s0
#endif
                        ) {
#endif                        
                        //if(source_ip_addr.s_addr==arptable_tftp[TFTP_CLIENT].ipaddr.s_addr)
                        //Cyrus Dick
                        if (!ipheader_chksum((Int16*)ipheader,sizeof(struct iphdr))) {
a0000fe4:	0c0003af 	jal	a0000ebc <ipheader_chksum>
a0000fe8:	24050014 	li	a1,20
a0000fec:	14400059 	bnez	v0,a0001154 <kick_tftpd+0x250>
a0000ff0:	24020011 	li	v0,17
                            if (ipheader->protocol==IP_UDP) {                                                 
a0000ff4:	82030009 	lb	v1,9(s0)
a0000ff8:	14620057 	bne	v1,v0,a0001158 <kick_tftpd+0x254>
a0000ffc:	8fbf0014 	lw	ra,20(sp)
                                }
#endif
                                /*All we care is TFTP protocol, no other  protocol*/
                                tftppacket = (struct tftp_t *)&nic.packet[ETH_HLEN];
                                tftpopcode  = tftppacket->opcode;      
                                switch (tftpopcode) {
a0001000:	3c02a001 	lui	v0,0xa001
a0001004:	8c427948 	lw	v0,31048(v0)
a0001008:	9443002a 	lhu	v1,42(v0)
a000100c:	2c630007 	sltiu	v1,v1,7
a0001010:	10600051 	beqz	v1,a0001158 <kick_tftpd+0x254>
a0001014:	00000000 	nop
a0001018:	9443002a 	lhu	v1,42(v0)
a000101c:	00031880 	sll	v1,v1,0x2
a0001020:	3c02a001 	lui	v0,0xa001
a0001024:	2442ff60 	addiu	v0,v0,-160
a0001028:	00431021 	addu	v0,v0,v1
a000102c:	8c420000 	lw	v0,0(v0)
a0001030:	00400008 	jr	v0
a0001034:	00000000 	nop
a0001038:	0800044a 	j	a0001128 <kick_tftpd+0x224>
a000103c:	24020006 	li	v0,6
                                    case htons(TFTP_RRQ):
                                        if (one_tftp_lock==0)
a0001040:	3c02a001 	lui	v0,0xa001
a0001044:	90437acc 	lbu	v1,31436(v0)
a0001048:	10600037 	beqz	v1,a0001128 <kick_tftpd+0x224>
a000104c:	24020002 	li	v0,2
                    }
                }
            }
            break;/*ptype=IP*/ 
    }
}
a0001050:	08000456 	j	a0001158 <kick_tftpd+0x254>
a0001054:	8fbf0014 	lw	ra,20(sp)
                                        if (one_tftp_lock==0)
                                            kick_event= BOOT_EVENT2_TFTP_RRQ;                 
                                        break;                     
                                    case htons(TFTP_WRQ):
#if 1
                                        if (one_tftp_lock==0) {
a0001058:	3c02a001 	lui	v0,0xa001
a000105c:	90427acc 	lbu	v0,31436(v0)
a0001060:	14400007 	bnez	v0,a0001080 <kick_tftpd+0x17c>
a0001064:	00000000 	nop
                                            kick_event = BOOT_EVENT3_TFTP_WRQ; 
                                            rx_kickofftime = get_timer_jiffies(); //wei add
a0001068:	0c0038ec 	jal	a000e3b0 <get_timer_jiffies>
a000106c:	00000000 	nop
a0001070:	3c03a001 	lui	v1,0xa001
a0001074:	ac627ac8 	sw	v0,31432(v1)
a0001078:	0800044a 	j	a0001128 <kick_tftpd+0x224>
a000107c:	24020003 	li	v0,3
                                        }
                                        else {
                                           // prom_printf("TFTP_WRQ: one_tftp_lock=%d block_expected=%d\n",one_tftp_lock, block_expected);
                                            //fix TFTP WRQ retransmit issue and add timout mechanism for second TFTP WRQ coming issue
                                            if ((block_expected == 1) || ((get_timer_jiffies() - rx_kickofftime) > 2000)) { //wait 20sec, unit is 10ms
a0001080:	3c02a001 	lui	v0,0xa001
a0001084:	94437944 	lhu	v1,31044(v0)
a0001088:	3063ffff 	andi	v1,v1,0xffff
a000108c:	24020001 	li	v0,1
a0001090:	10620009 	beq	v1,v0,a00010b8 <kick_tftpd+0x1b4>
a0001094:	00000000 	nop
a0001098:	0c0038ec 	jal	a000e3b0 <get_timer_jiffies>
a000109c:	00000000 	nop
a00010a0:	3c03a001 	lui	v1,0xa001
a00010a4:	8c637ac8 	lw	v1,31432(v1)
a00010a8:	00431823 	subu	v1,v0,v1
a00010ac:	2c6307d1 	sltiu	v1,v1,2001
a00010b0:	14600029 	bnez	v1,a0001158 <kick_tftpd+0x254>
a00010b4:	8fbf0014 	lw	ra,20(sp)
                                                kick_event = BOOT_EVENT3_TFTP_WRQ;
                                                rx_kickofftime = get_timer_jiffies();
a00010b8:	0c0038ec 	jal	a000e3b0 <get_timer_jiffies>
a00010bc:	00000000 	nop
a00010c0:	3c03a001 	lui	v1,0xa001
a00010c4:	ac627ac8 	sw	v0,31432(v1)
a00010c8:	0800044a 	j	a0001128 <kick_tftpd+0x224>
a00010cc:	24020003 	li	v0,3
#endif
                                        //setTFTP_WRQ();
                                        break;
                                    case htons(TFTP_DATA):
                                        kick_event= BOOT_EVENT4_TFTP_DATA;
                                        rx_kickofftime = get_timer_jiffies();
a00010d0:	0c0038ec 	jal	a000e3b0 <get_timer_jiffies>
a00010d4:	00000000 	nop
a00010d8:	3c03a001 	lui	v1,0xa001
a00010dc:	ac627ac8 	sw	v0,31432(v1)
                                        //	prepareACK();
                                        break;
a00010e0:	0800044a 	j	a0001128 <kick_tftpd+0x224>
a00010e4:	24020004 	li	v0,4
a00010e8:	0800044a 	j	a0001128 <kick_tftpd+0x224>
a00010ec:	24020007 	li	v0,7
                    break;
            }
            //wei del
            if (kick_event!=NUM_OF_BOOT_EVENTS) {
                jump = (void *)(*BootStateEvent[bootState][kick_event]);
                jump();
a00010f0:	3c02a001 	lui	v0,0xa001
a00010f4:	8c427954 	lw	v0,31060(v0)
a00010f8:	000210c0 	sll	v0,v0,0x3
a00010fc:	00431821 	addu	v1,v0,v1
a0001100:	00031880 	sll	v1,v1,0x2
a0001104:	3c02a001 	lui	v0,0xa001
a0001108:	2442ff7c 	addiu	v0,v0,-132
a000110c:	00621821 	addu	v1,v1,v0
a0001110:	8c620000 	lw	v0,0(v1)
a0001114:	0040f809 	jalr	v0
a0001118:	00000000 	nop
                    }
                }
            }
            break;/*ptype=IP*/ 
    }
}
a000111c:	08000456 	j	a0001158 <kick_tftpd+0x254>
a0001120:	8fbf0014 	lw	ra,20(sp)
                    break;
            }
            //wei del
            if (kick_event!=NUM_OF_BOOT_EVENTS) {
                jump = (void *)(*BootStateEvent[bootState][kick_event]);
                jump();
a0001124:	24020005 	li	v0,5
                                        break;
                                }
				
                                if (kick_event!=NUM_OF_BOOT_EVENTS) {
                                    jump = (void *)(*BootStateEvent[bootState][kick_event]);
                                    jump();
a0001128:	3c03a001 	lui	v1,0xa001
a000112c:	8c637954 	lw	v1,31060(v1)
a0001130:	000318c0 	sll	v1,v1,0x3
a0001134:	00621021 	addu	v0,v1,v0
a0001138:	00021080 	sll	v0,v0,0x2
a000113c:	3c03a001 	lui	v1,0xa001
a0001140:	2463ff7c 	addiu	v1,v1,-132
a0001144:	00431021 	addu	v0,v0,v1
a0001148:	8c420000 	lw	v0,0(v0)
a000114c:	0040f809 	jalr	v0
a0001150:	00000000 	nop
                    }
                }
            }
            break;/*ptype=IP*/ 
    }
}
a0001154:	8fbf0014 	lw	ra,20(sp)
a0001158:	8fb00010 	lw	s0,16(sp)
a000115c:	03e00008 	jr	ra
a0001160:	27bd0018 	addiu	sp,sp,24

a0001164 <errorDrop>:
#endif // SUPPORT_TFTP_CLIENT


//----------------------------------------------------------------------------------------
static void errorDrop(void)
{
a0001164:	27bdffe8 	addiu	sp,sp,-24
a0001168:	afbf0014 	sw	ra,20(sp)
    if (!tftpd_is_ready)
a000116c:	3c02a001 	lui	v0,0xa001
a0001170:	8c427ac4 	lw	v0,31428(v0)
a0001174:	10400009 	beqz	v0,a000119c <errorDrop+0x38>
a0001178:	8fbf0014 	lw	ra,20(sp)
        return;
/*no need to change boot state*/
prom_printf("Boot state error,%d,%d\n",bootState,bootEvent);
a000117c:	3c04a001 	lui	a0,0xa001
a0001180:	2484405c 	addiu	a0,a0,16476
a0001184:	3c02a001 	lui	v0,0xa001
a0001188:	8c457954 	lw	a1,31060(v0)
a000118c:	3c02a001 	lui	v0,0xa001
a0001190:	0c002325 	jal	a0008c94 <dprintf>
a0001194:	8c467964 	lw	a2,31076(v0)
//bootState=BOOT_STATE0_INIT_ARP;
/*error in boot state machine*/	
}
a0001198:	8fbf0014 	lw	ra,20(sp)
a000119c:	03e00008 	jr	ra
a00011a0:	27bd0018 	addiu	sp,sp,24

a00011a4 <autoreboot>:
	return found;
}
#endif

void autoreboot()
{
a00011a4:	27bdffe8 	addiu	sp,sp,-24
a00011a8:	afbf0014 	sw	ra,20(sp)
        extern unsigned int ComSrlCmd_EX4B(unsigned char ucChip, unsigned int uiLen);
        ComSrlCmd_EX4B(0,4);

        #endif

	jumpF = (void *)(0xbfc00000);
a00011ac:	3c03bfc0 	lui	v1,0xbfc0
a00011b0:	3c02a001 	lui	v0,0xa001
a00011b4:	ac43795c 	sw	v1,31068(v0)
__IN(unsigned short,h,w)
__IN(unsigned int,w,l)

__OUT(b,b)
__OUT(h,w)
__OUT(w,l)
a00011b8:	3c03b800 	lui	v1,0xb800
a00011bc:	00001021 	move	v0,zero
a00011c0:	ac623000 	sw	v0,12288(v1)
 * no nops at all.
 */
extern __inline__ void
__cli(void)
{
	__asm__ __volatile__(
a00011c4:	40016000 	mfc0	at,c0_status
a00011c8:	34210001 	ori	at,at,0x1
a00011cc:	38210001 	xori	at,at,0x1
a00011d0:	40816000 	mtc0	at,c0_status
a00011d4:	000000c0 	ehb
	...
	outl(0,GIMR0); // mask all interrupt	    
	cli();

	flush_cache(); 
a00011e4:	0c001eae 	jal	a0007ab8 <flush_cache>
a00011e8:	00000000 	nop
	prom_printf("\nreboot.......\n");
a00011ec:	3c04a001 	lui	a0,0xa001
a00011f0:	0c002325 	jal	a0008c94 <dprintf>
a00011f4:	24844074 	addiu	a0,a0,16500
#if defined(RTL865X) || defined(RTL8198)
	/* this is to enable 865xc watch dog reset */
	*(volatile unsigned long *)(0xB800311c)=0; 
a00011f8:	3c02b800 	lui	v0,0xb800
a00011fc:	3442311c 	ori	v0,v0,0x311c
a0001200:	ac400000 	sw	zero,0(v0)
	#ifndef CONFIG_NAND_FLASH_BOOTING
	for(;;);
	#endif
#endif
 	/* reboot */
	jumpF();	
a0001204:	3c02a001 	lui	v0,0xa001
a0001208:	8c42795c 	lw	v0,31068(v0)
a000120c:	0040f809 	jalr	v0
a0001210:	00000000 	nop
}
a0001214:	8fbf0014 	lw	ra,20(sp)
a0001218:	03e00008 	jr	ra
a000121c:	27bd0018 	addiu	sp,sp,24

a0001220 <doARPReply>:
	}
#endif
}
//----------------------------------------------------------------------------------------
static void doARPReply(void)
{
a0001220:	27bdffc0 	addiu	sp,sp,-64
a0001224:	afbf003c 	sw	ra,60(sp)
 Int8 checkIP[4];
 Int32 targetIP; 

//dprintf("execute ARP reply function\n");

 arppacket=(struct arprequest *) &(nic.packet[ETH_HLEN]);
a0001228:	3c02a001 	lui	v0,0xa001
a000122c:	8c427948 	lw	v0,31048(v0)
a0001230:	2446000e 	addiu	a2,v0,14

//memcpy(arptable_tftp[TFTP_CLIENT].ipaddr.ip, arppacket->sipaddr, sizeof(in_addr)); 
 //prom_printf("DoARPRpy 2.:update CLIENT ip address %x\n",arptable_tftp[TFTP_CLIENT].ipaddr.s_addr);
 
 memcpy(&targetIP,arppacket->tipaddr,4);
a0001234:	24420026 	addiu	v0,v0,38
a0001238:	88430000 	lwl	v1,0(v0)
a000123c:	98430003 	lwr	v1,3(v0)
a0001240:	00601021 	move	v0,v1
a0001244:	afa30034 	sw	v1,52(sp)

#ifdef SUPPORT_TFTP_CLIENT
 if ((tftp_client_enabled && (targetIP==arptable_tftp[TFTP_CLIENT].ipaddr.s_addr)) ||  	
	  (!tftp_client_enabled && (targetIP==arptable_tftp[TFTP_SERVER].ipaddr.s_addr)))
#else
 if(targetIP==arptable_tftp[TFTP_SERVER].ipaddr.s_addr)/*that is us*/
a0001248:	3c03a002 	lui	v1,0xa002
a000124c:	8c638bf0 	lw	v1,-29712(v1)
a0001250:	14620025 	bne	v1,v0,a00012e8 <doARPReply+0xc8>
a0001254:	8fbf003c 	lw	ra,60(sp)
#endif 	
 {
#if 1
    /*Fill in the arp reply payload.*/
    arpreply.hwtype = htons(1);
a0001258:	24020001 	li	v0,1
a000125c:	a7a20018 	sh	v0,24(sp)
    arpreply.protocol = htons(FRAME_IP);/*that is 0x0800*/
a0001260:	24020800 	li	v0,2048
a0001264:	a7a2001a 	sh	v0,26(sp)
    arpreply.hwlen = ETH_ALEN;
a0001268:	24020006 	li	v0,6
a000126c:	a3a2001c 	sb	v0,28(sp)
    arpreply.protolen = 4;
a0001270:	24020004 	li	v0,4
a0001274:	a3a2001d 	sb	v0,29(sp)
    arpreply.opcode = htons(ARP_REPLY);
a0001278:	24020002 	li	v0,2
a000127c:	a7a2001e 	sh	v0,30(sp)
	    memcpy(&(arpreply.sipaddr), &(arptable_tftp[TFTP_CLIENT].ipaddr), sizeof(in_addr));		
	}
	else
#endif
	{
    memcpy(&(arpreply.shwaddr), &(arptable_tftp[TFTP_SERVER].node), ETH_ALEN);
a0001280:	3c02a002 	lui	v0,0xa002
a0001284:	24438bf0 	addiu	v1,v0,-29712
a0001288:	8c640004 	lw	a0,4(v1)
a000128c:	afa40020 	sw	a0,32(sp)
a0001290:	94630008 	lhu	v1,8(v1)
a0001294:	a7a30024 	sh	v1,36(sp)
    memcpy(&(arpreply.sipaddr), &(arptable_tftp[TFTP_SERVER].ipaddr), sizeof(in_addr));
a0001298:	8c428bf0 	lw	v0,-29712(v0)
a000129c:	aba20026 	swl	v0,38(sp)
a00012a0:	bba20029 	swr	v0,41(sp)
	}		
    memcpy(&(arpreply.thwaddr), arppacket->shwaddr, ETH_ALEN);
a00012a4:	94c40008 	lhu	a0,8(a2)
a00012a8:	94c3000a 	lhu	v1,10(a2)
a00012ac:	94c2000c 	lhu	v0,12(a2)
a00012b0:	a7a4002a 	sh	a0,42(sp)
a00012b4:	a7a3002c 	sh	v1,44(sp)
a00012b8:	a7a2002e 	sh	v0,46(sp)
    memcpy(&(arpreply.tipaddr), arppacket->sipaddr, sizeof(in_addr));
a00012bc:	88c2000e 	lwl	v0,14(a2)
a00012c0:	98c20011 	lwr	v0,17(a2)
a00012c4:	afa20030 	sw	v0,48(sp)

    prepare_txpkt(0,FRAME_ARP,arppacket->shwaddr,(Int8*)&arpreply,(Int16)sizeof(arpreply));
a00012c8:	2402001c 	li	v0,28
a00012cc:	afa20010 	sw	v0,16(sp)
a00012d0:	00002021 	move	a0,zero
a00012d4:	24050806 	li	a1,2054
a00012d8:	24c60008 	addiu	a2,a2,8
a00012dc:	0c000880 	jal	a0002200 <prepare_txpkt>
a00012e0:	27a70018 	addiu	a3,sp,24
    memcpy(&(arpreply.tipaddr), &(arptable_tftp[TFTP_CLIENT].ipaddr), sizeof(in_addr));

    prepare_txpkt(0,FRAME_ARP,arptable_tftp[TFTP_CLIENT].node,(Int8*)&arpreply,(Int16)sizeof(arpreply));
#endif
   } 
}
a00012e4:	8fbf003c 	lw	ra,60(sp)
a00012e8:	03e00008 	jr	ra
a00012ec:	27bd0040 	addiu	sp,sp,64

a00012f0 <tftpd_send_data>:
#endif  
 prepare_txpkt(0,FRAME_IP,arptable_tftp[TFTP_CLIENT].node,(Int8*)&tftp_tx,(Int16)sizeof(struct iphdr)+sizeof(struct udphdr)+4);
}
//----------------------------------------------------------------------------------------
void tftpd_send_data(char* filename, Int16 block_number)
{
a00012f0:	27bdfa20 	addiu	sp,sp,-1504
a00012f4:	afbf05dc 	sw	ra,1500(sp)
a00012f8:	afb205d8 	sw	s2,1496(sp)
a00012fc:	afb105d4 	sw	s1,1492(sp)
a0001300:	afb005d0 	sw	s0,1488(sp)
a0001304:	30b0ffff 	andi	s0,a1,0xffff
 Int32* data; 
 int length;


 /********************************************/  
   data=(Int32 *)(image_address+ 512*(block_number-1));
a0001308:	02002821 	move	a1,s0
a000130c:	3c02a001 	lui	v0,0xa001
   //prom_printf("send data start at %x\n",data);
 if (512* block_number==(file_length_to_client+512))
a0001310:	00102240 	sll	a0,s0,0x9
a0001314:	3c03a001 	lui	v1,0xa001
a0001318:	8c637958 	lw	v1,31064(v1)
a000131c:	24660200 	addiu	a2,v1,512
a0001320:	14860006 	bne	a0,a2,a000133c <tftpd_send_data+0x4c>
a0001324:	8c427218 	lw	v0,29208(v0)
    {
    /*it is over that means a length=0 data is required*/
    length=0;
    //prom_printf("TFTP RRQ last NULL data to send\n");
    it_is_EOF=1;
a0001328:	24040001 	li	a0,1
a000132c:	3c03a001 	lui	v1,0xa001
a0001330:	ac647ad0 	sw	a0,31440(v1)
a0001334:	080004d8 	j	a0001360 <tftpd_send_data+0x70>
a0001338:	00008821 	move	s1,zero
    }
 else if( 512* block_number > file_length_to_client)
a000133c:	0064202b 	sltu	a0,v1,a0
a0001340:	10800007 	beqz	a0,a0001360 <tftpd_send_data+0x70>
a0001344:	24110200 	li	s1,512
    { 
     length=file_length_to_client-512*(block_number-1);
a0001348:	24040001 	li	a0,1
a000134c:	00908823 	subu	s1,a0,s0
a0001350:	00118a40 	sll	s1,s1,0x9
a0001354:	02238821 	addu	s1,s1,v1
     //prom_printf("TFTP RRQ last data to send\n");
     it_is_EOF=1;
a0001358:	3c03a001 	lui	v1,0xa001
a000135c:	ac647ad0 	sw	a0,31440(v1)
 else
    length=512;
 
 /********************************************/
 /*generate the TFTP body*/
 tftp_tx.opcode=htons(TFTP_DATA);
a0001360:	24030003 	li	v1,3
a0001364:	a7a30034 	sh	v1,52(sp)
 memcpy(tftp_tx.u.data.download,(Int8*)data,length);
a0001368:	24a5ffff 	addiu	a1,a1,-1
a000136c:	00052a40 	sll	a1,a1,0x9
a0001370:	27a40038 	addiu	a0,sp,56
a0001374:	00a22821 	addu	a1,a1,v0
a0001378:	0c002046 	jal	a0008118 <memcpy>
a000137c:	02203021 	move	a2,s1
 tftp_tx.u.data.block=htons(block_number);
a0001380:	a7b00036 	sh	s0,54(sp)
 
 ip = (struct iphdr *)&tftp_tx;
 udp = (struct udphdr *)((Int8*)&tftp_tx + sizeof(struct iphdr));
 
 /*generate the IP header*/
 ip->verhdrlen = 0x45;
a0001384:	24020045 	li	v0,69
a0001388:	a3a20018 	sb	v0,24(sp)
 ip->service = 0;
a000138c:	a3a00019 	sb	zero,25(sp)
 ip->len = htons(32+length);
a0001390:	3231ffff 	andi	s1,s1,0xffff
a0001394:	26300020 	addiu	s0,s1,32
a0001398:	3210ffff 	andi	s0,s0,0xffff
a000139c:	a7b0001a 	sh	s0,26(sp)
 ip->ident = 0;
a00013a0:	a7a0001c 	sh	zero,28(sp)
 ip->frags = 0;
a00013a4:	a7a0001e 	sh	zero,30(sp)
 ip->ttl = 60;
a00013a8:	2402003c 	li	v0,60
a00013ac:	a3a20020 	sb	v0,32(sp)
 ip->protocol = IP_UDP;
a00013b0:	24020011 	li	v0,17
a00013b4:	a3a20021 	sb	v0,33(sp)
 ip->chksum = 0;
a00013b8:	a7a00022 	sh	zero,34(sp)
 ip->src.s_addr = arptable_tftp[TFTP_SERVER].ipaddr.s_addr;
a00013bc:	3c02a002 	lui	v0,0xa002
a00013c0:	8c438bf0 	lw	v1,-29712(v0)
a00013c4:	afa30024 	sw	v1,36(sp)
 ip->dest.s_addr = arptable_tftp[TFTP_CLIENT].ipaddr.s_addr;
a00013c8:	24428bf0 	addiu	v0,v0,-29712
a00013cc:	8c42000c 	lw	v0,12(v0)
a00013d0:	afa20028 	sw	v0,40(sp)
 ip->chksum = ipheader_chksum((Int16 *)&tftp_tx, sizeof(struct iphdr));
a00013d4:	27b20018 	addiu	s2,sp,24
a00013d8:	02402021 	move	a0,s2
a00013dc:	0c0003af 	jal	a0000ebc <ipheader_chksum>
a00013e0:	24050014 	li	a1,20
a00013e4:	a7a20022 	sh	v0,34(sp)
 /*generate the UDP header*/
 udp->src  = htons(SERVER_port);
a00013e8:	3c02a001 	lui	v0,0xa001
a00013ec:	94427950 	lhu	v0,31056(v0)
a00013f0:	a7a2002c 	sh	v0,44(sp)
 udp->dest = htons(CLIENT_port);
a00013f4:	3c02a001 	lui	v0,0xa001
a00013f8:	94427952 	lhu	v0,31058(v0)
a00013fc:	a7a2002e 	sh	v0,46(sp)
 udp->len  = htons(length+4+8);
a0001400:	2631000c 	addiu	s1,s1,12
a0001404:	a7b10030 	sh	s1,48(sp)
 udp->chksum = 0;
 
 /*use twiddle here*/
 twiddle();
a0001408:	0c00225d 	jal	a0008974 <twiddle>
a000140c:	a7a00032 	sh	zero,50(sp)
 //prom_printf(" -> ");
 
 prepare_txpkt(0,FRAME_IP,arptable_tftp[TFTP_CLIENT].node,(Int8*)&tftp_tx,(Int16)sizeof(struct iphdr)+sizeof(struct udphdr)+length+4);
a0001410:	afb00010 	sw	s0,16(sp)
a0001414:	00002021 	move	a0,zero
a0001418:	24050800 	li	a1,2048
a000141c:	3c06a002 	lui	a2,0xa002
a0001420:	24c68c00 	addiu	a2,a2,-29696
a0001424:	0c000880 	jal	a0002200 <prepare_txpkt>
a0001428:	02403821 	move	a3,s2
}
a000142c:	8fbf05dc 	lw	ra,1500(sp)
a0001430:	8fb205d8 	lw	s2,1496(sp)
a0001434:	8fb105d4 	lw	s1,1492(sp)
a0001438:	8fb005d0 	lw	s0,1488(sp)
a000143c:	03e00008 	jr	ra
a0001440:	27bd05e0 	addiu	sp,sp,1504

a0001444 <prepareDATA>:

}
//----------------------------------------------------------------------------------------
/*Why we prepare DATA, because we receive the ACK*/
static void prepareDATA(void)
{
a0001444:	27bdffe8 	addiu	sp,sp,-24
a0001448:	afbf0014 	sw	ra,20(sp)
 struct tftp_t *tftppacket;
 Int16 tftpopcode;
 Int32 tftpdata_length;
 Int16 block_received=0;

    if (!tftpd_is_ready)
a000144c:	3c02a001 	lui	v0,0xa001
a0001450:	8c427ac4 	lw	v0,31428(v0)
a0001454:	10400043 	beqz	v0,a0001564 <prepareDATA+0x120>
a0001458:	3c02a001 	lui	v0,0xa001
        return;
 udpheader = (struct udphdr *)&nic.packet[ETH_HLEN+ sizeof(struct iphdr)];
a000145c:	8c427948 	lw	v0,31048(v0)
a0001460:	24430022 	addiu	v1,v0,34
 if(udpheader->dest==htons(SERVER_port))
a0001464:	94650002 	lhu	a1,2(v1)
a0001468:	3c04a001 	lui	a0,0xa001
a000146c:	94847950 	lhu	a0,31056(a0)
a0001470:	14a4003d 	bne	a1,a0,a0001568 <prepareDATA+0x124>
a0001474:	8fbf0014 	lw	ra,20(sp)
   {
    /*memorize CLIENT port*/
    CLIENT_port=  ntohs(udpheader->src); 
a0001478:	94640000 	lhu	a0,0(v1)
a000147c:	3c03a001 	lui	v1,0xa001
a0001480:	a4647952 	sh	a0,31058(v1)
    tftppacket = (struct tftp_t *)&nic.packet[ETH_HLEN];
    /*no need to check opcode, this is a ACK packet*/     
    /*parse the TFTP ACK number*/	
    block_received=tftppacket->u.ack.block;
    if(block_received != (block_expected))
a0001484:	3c03a001 	lui	v1,0xa001
a0001488:	94637944 	lhu	v1,31044(v1)
a000148c:	3063ffff 	andi	v1,v1,0xffff
    /*memorize CLIENT port*/
    CLIENT_port=  ntohs(udpheader->src); 
    tftppacket = (struct tftp_t *)&nic.packet[ETH_HLEN];
    /*no need to check opcode, this is a ACK packet*/     
    /*parse the TFTP ACK number*/	
    block_received=tftppacket->u.ack.block;
a0001490:	9442002c 	lhu	v0,44(v0)
a0001494:	1043000c 	beq	v0,v1,a00014c8 <prepareDATA+0x84>
a0001498:	3c02a001 	lui	v0,0xa001
    if(block_received != (block_expected))
    {
     //prom_printf("line=%d: block_received=%d, block_expected=%d\n", __LINE__,  block_received,  block_expected); // for debug
     prom_printf("\n**TFTP #\n");
a000149c:	3c04a001 	lui	a0,0xa001
a00014a0:	0c002325 	jal	a0008c94 <dprintf>
a00014a4:	24844084 	addiu	a0,a0,16516
     tftpd_send_data(filename,block_expected);
a00014a8:	3c02a001 	lui	v0,0xa001
a00014ac:	94457944 	lhu	a1,31044(v0)
a00014b0:	3c04a002 	lui	a0,0xa002
a00014b4:	248489f0 	addiu	a0,a0,-30224
a00014b8:	0c0004bc 	jal	a00012f0 <tftpd_send_data>
a00014bc:	30a5ffff 	andi	a1,a1,0xffff
   }
//else 
//   prom_printf("\n**TFTP port number error\n");   
  

}                               
a00014c0:	0800055a 	j	a0001568 <prepareDATA+0x124>
a00014c4:	8fbf0014 	lw	ra,20(sp)
     prom_printf("\n**TFTP #\n");
     tftpd_send_data(filename,block_expected);
    }
    else 
     {      
      block_expected=block_expected+1;      
a00014c8:	94437944 	lhu	v1,31044(v0)
a00014cc:	24630001 	addiu	v1,v1,1
a00014d0:	3063ffff 	andi	v1,v1,0xffff
a00014d4:	a4437944 	sh	v1,31044(v0)
      if(!(it_is_EOF))
a00014d8:	3c02a001 	lui	v0,0xa001
a00014dc:	8c427ad0 	lw	v0,31440(v0)
a00014e0:	14400009 	bnez	v0,a0001508 <prepareDATA+0xc4>
a00014e4:	3c02a001 	lui	v0,0xa001
          tftpd_send_data(filename,block_expected);     
a00014e8:	3c02a001 	lui	v0,0xa001
a00014ec:	94457944 	lhu	a1,31044(v0)
a00014f0:	3c04a002 	lui	a0,0xa002
a00014f4:	248489f0 	addiu	a0,a0,-30224
a00014f8:	0c0004bc 	jal	a00012f0 <tftpd_send_data>
a00014fc:	30a5ffff 	andi	a1,a1,0xffff
   }
//else 
//   prom_printf("\n**TFTP port number error\n");   
  

}                               
a0001500:	0800055a 	j	a0001568 <prepareDATA+0x124>
a0001504:	8fbf0014 	lw	ra,20(sp)
      if(!(it_is_EOF))
          tftpd_send_data(filename,block_expected);     
      else 
         {
         /*After we receive the last ACK then we can go on.*/	
          bootState=BOOT_STATE0_INIT_ARP;  
a0001508:	ac407954 	sw	zero,31060(v0)
          one_tftp_lock=0; 
a000150c:	3c02a001 	lui	v0,0xa001
a0001510:	a0407acc 	sb	zero,31436(v0)
          //prom_printf("\n**TFTP Client Upload Success! File Size = %X Bytes\n",file_length_to_server);                        
          prom_printf("\n*TFTP Client Download Success! File Size = %X Bytes\n",file_length_to_client);          
a0001514:	3c04a001 	lui	a0,0xa001
a0001518:	24844090 	addiu	a0,a0,16528
a000151c:	3c02a001 	lui	v0,0xa001
a0001520:	0c002325 	jal	a0008c94 <dprintf>
a0001524:	8c457958 	lw	a1,31064(v0)
          prom_printf( ".Success!\n%s", "<RealTek>" );         
a0001528:	3c04a001 	lui	a0,0xa001
a000152c:	248440c8 	addiu	a0,a0,16584
a0001530:	3c05a001 	lui	a1,0xa001
a0001534:	0c002325 	jal	a0008c94 <dprintf>
a0001538:	24a540d8 	addiu	a1,a1,16600
          nic.packet = eth_packet;
a000153c:	3c02a001 	lui	v0,0xa001
a0001540:	3c03a002 	lui	v1,0xa002
a0001544:	24638c14 	addiu	v1,v1,-29676
a0001548:	ac437948 	sw	v1,31048(v0)
          nic.packetlen = 0;        
a000154c:	24427948 	addiu	v0,v0,31048
a0001550:	ac400004 	sw	zero,4(v0)
          block_expected =0;       
a0001554:	3c02a001 	lui	v0,0xa001
a0001558:	a4407944 	sh	zero,31044(v0)
//prom_printf("line=%d:		block_expected=%d\n", __LINE__,  block_expected); // for debug
          
          it_is_EOF=0;
a000155c:	3c02a001 	lui	v0,0xa001
a0001560:	ac407ad0 	sw	zero,31440(v0)
   }
//else 
//   prom_printf("\n**TFTP port number error\n");   
  

}                               
a0001564:	8fbf0014 	lw	ra,20(sp)
a0001568:	03e00008 	jr	ra
a000156c:	27bd0018 	addiu	sp,sp,24

a0001570 <setTFTP_RRQ>:
 }
#endif 
}
//----------------------------------------------------------------------------------------
static void setTFTP_RRQ(void)
{
a0001570:	27bdffe0 	addiu	sp,sp,-32
a0001574:	afbf001c 	sw	ra,28(sp)
a0001578:	afb10018 	sw	s1,24(sp)
a000157c:	afb00014 	sw	s0,20(sp)
 struct tftp_t *tftppacket;
 
 Int16 tftpopcode;
 int find_zero;

    if (!tftpd_is_ready)
a0001580:	3c02a001 	lui	v0,0xa001
a0001584:	8c427ac4 	lw	v0,31428(v0)
a0001588:	10400055 	beqz	v0,a00016e0 <setTFTP_RRQ+0x170>
a000158c:	3c02a001 	lui	v0,0xa001
        return;
 udpheader = (struct udphdr *)&nic.packet[ETH_HLEN+ sizeof(struct iphdr)];
a0001590:	8c507948 	lw	s0,31048(v0)
a0001594:	26100022 	addiu	s0,s0,34
 if( udpheader->dest==htons(TFTP_PORT) )
a0001598:	96030002 	lhu	v1,2(s0)
a000159c:	24020045 	li	v0,69
a00015a0:	14620050 	bne	v1,v0,a00016e4 <setTFTP_RRQ+0x174>
a00015a4:	8fbf001c 	lw	ra,28(sp)
   {
   	
    prom_printf("\nFile Start: %x,length=%x\n",image_address,file_length_to_client);
a00015a8:	3c04a001 	lui	a0,0xa001
a00015ac:	248440e4 	addiu	a0,a0,16612
a00015b0:	3c02a001 	lui	v0,0xa001
a00015b4:	8c457218 	lw	a1,29208(v0)
a00015b8:	3c02a001 	lui	v0,0xa001
a00015bc:	0c002325 	jal	a0008c94 <dprintf>
a00015c0:	8c467958 	lw	a2,31064(v0)
                    nic.packet[ETH_HLEN+14]&0xff, nic.packet[ETH_HLEN+15]&0xff
                    );
    }
    */
    /*memorize CLIENT IP address*/
    memcpy(&(arptable_tftp[TFTP_CLIENT].ipaddr.s_addr),(Int8*)&nic.packet[ETH_HLEN+12],4);
a00015c4:	3c02a001 	lui	v0,0xa001
a00015c8:	8c457948 	lw	a1,31048(v0)
a00015cc:	24a2001a 	addiu	v0,a1,26
a00015d0:	88430000 	lwl	v1,0(v0)
a00015d4:	98430003 	lwr	v1,3(v0)
a00015d8:	3c02a002 	lui	v0,0xa002
a00015dc:	ac438bfc 	sw	v1,-29700(v0)

    /*memorize CLIENT mac address*/
    memcpy(arptable_tftp[TFTP_CLIENT].node,(Int8*)&(nic.packet[ETH_ALEN]),ETH_ALEN);
a00015e0:	3c03a002 	lui	v1,0xa002
a00015e4:	24a20006 	addiu	v0,a1,6
a00015e8:	88440000 	lwl	a0,0(v0)
a00015ec:	98440003 	lwr	a0,3(v0)
a00015f0:	ac648c00 	sw	a0,-29696(v1)
a00015f4:	24638c00 	addiu	v1,v1,-29696
a00015f8:	90440004 	lbu	a0,4(v0)
a00015fc:	a0640004 	sb	a0,4(v1)
a0001600:	90420005 	lbu	v0,5(v0)
a0001604:	a0620005 	sb	v0,5(v1)

    /*memorize CLIENT port*/
    CLIENT_port=  ntohs(udpheader->src); 
a0001608:	96030000 	lhu	v1,0(s0)
a000160c:	3c02a001 	lui	v0,0xa001
a0001610:	a4437952 	sh	v1,31058(v0)
    tftppacket = (struct tftp_t *)&nic.packet[ETH_HLEN];
    tftpopcode = tftppacket->opcode;      
    
    
    for(find_zero=0;find_zero<TFTP_DEFAULTSIZE_PACKET;find_zero++)
        if( *( (Int8*)(tftppacket->u.rrq)+find_zero ) ==0 )
a0001614:	24a5002c 	addiu	a1,a1,44
a0001618:	90a20000 	lbu	v0,0(a1)
a000161c:	24100001 	li	s0,1
a0001620:	14400003 	bnez	v0,a0001630 <setTFTP_RRQ+0xc0>
a0001624:	24030200 	li	v1,512
a0001628:	08000593 	j	a000164c <setTFTP_RRQ+0xdc>
a000162c:	00008021 	move	s0,zero
a0001630:	00b01021 	addu	v0,a1,s0
a0001634:	90420000 	lbu	v0,0(v0)
a0001638:	10400005 	beqz	v0,a0001650 <setTFTP_RRQ+0xe0>
a000163c:	3c11a002 	lui	s1,0xa002
    CLIENT_port=  ntohs(udpheader->src); 
    tftppacket = (struct tftp_t *)&nic.packet[ETH_HLEN];
    tftpopcode = tftppacket->opcode;      
    
    
    for(find_zero=0;find_zero<TFTP_DEFAULTSIZE_PACKET;find_zero++)
a0001640:	26100001 	addiu	s0,s0,1
a0001644:	1603fffb 	bne	s0,v1,a0001634 <setTFTP_RRQ+0xc4>
a0001648:	00b01021 	addu	v0,a1,s0
        if( *( (Int8*)(tftppacket->u.rrq)+find_zero ) ==0 )
           break;
    
    memcpy(filename,tftppacket->u.rrq,find_zero);
a000164c:	3c11a002 	lui	s1,0xa002
a0001650:	263189f0 	addiu	s1,s1,-30224
a0001654:	02202021 	move	a0,s1
a0001658:	0c002046 	jal	a0008118 <memcpy>
a000165c:	02003021 	move	a2,s0
    filename[find_zero]='\0';
a0001660:	02118021 	addu	s0,s0,s1
a0001664:	a2000000 	sb	zero,0(s0)
             nic.packet[ETH_ALEN+2]&0xff, nic.packet[ETH_ALEN+3]&0xff,
             nic.packet[ETH_ALEN+4]&0xff, nic.packet[ETH_ALEN+5]&0xff
             );
    }
    */
    memcpy(arptable_tftp[TFTP_CLIENT].node,(Int8*)&(nic.packet[ETH_ALEN]), ETH_ALEN); 
a0001668:	3c03a002 	lui	v1,0xa002
a000166c:	3c02a001 	lui	v0,0xa001
a0001670:	8c427948 	lw	v0,31048(v0)
a0001674:	24420006 	addiu	v0,v0,6
a0001678:	88440000 	lwl	a0,0(v0)
a000167c:	98440003 	lwr	a0,3(v0)
a0001680:	ac648c00 	sw	a0,-29696(v1)
a0001684:	24638c00 	addiu	v1,v1,-29696
a0001688:	90440004 	lbu	a0,4(v0)
a000168c:	a0640004 	sb	a0,4(v1)
a0001690:	90420005 	lbu	v0,5(v0)
a0001694:	a0620005 	sb	v0,5(v1)
   
    prom_printf("\n**TFTP GET File %s,Size %X Byte\n",filename,file_length_to_client);                
a0001698:	3c04a001 	lui	a0,0xa001
a000169c:	24844100 	addiu	a0,a0,16640
a00016a0:	02202821 	move	a1,s1
a00016a4:	3c02a001 	lui	v0,0xa001
a00016a8:	0c002325 	jal	a0008c94 <dprintf>
a00016ac:	8c467958 	lw	a2,31064(v0)
    /*Initialziation of RRQ file*/   
    //image_address=FILESTART; //sc_yang
    /*now we can use fiile_length_to_client, if we have meet WRQ*/
    one_tftp_lock=1;
a00016b0:	24030001 	li	v1,1
a00016b4:	3c02a001 	lui	v0,0xa001
a00016b8:	a0437acc 	sb	v1,31436(v0)
    /*we should send a data block numbered 1, waiting for number 1 ACK.*/
    tftpd_send_data(filename,0x0001);
a00016bc:	02202021 	move	a0,s1
a00016c0:	0c0004bc 	jal	a00012f0 <tftpd_send_data>
a00016c4:	24050001 	li	a1,1
    block_expected=1;
a00016c8:	24030001 	li	v1,1
a00016cc:	3c02a001 	lui	v0,0xa001
a00016d0:	a4437944 	sh	v1,31044(v0)
//prom_printf("line=%d:		block_expected=%d\n", __LINE__,  block_expected); // for debug
		
    /*now change state to RRQ*/
    bootState=BOOT_STATE1_TFTP_CLIENT_RRQ; 
a00016d4:	24030001 	li	v1,1
a00016d8:	3c02a001 	lui	v0,0xa001
a00016dc:	ac437954 	sw	v1,31060(v0)
   }
#else
    prom_printf("\ntftp read request is not supported\n");              
#endif
}
a00016e0:	8fbf001c 	lw	ra,28(sp)
a00016e4:	8fb10018 	lw	s1,24(sp)
a00016e8:	8fb00014 	lw	s0,20(sp)
a00016ec:	03e00008 	jr	ra
a00016f0:	27bd0020 	addiu	sp,sp,32

a00016f4 <tftpd_send_ack>:
	tftp_client_enabled = 0;
#endif
}
//----------------------------------------------------------------------------------------
void tftpd_send_ack(Int16 number)
{
a00016f4:	27bdfa28 	addiu	sp,sp,-1496
a00016f8:	afbf05d4 	sw	ra,1492(sp)
a00016fc:	afb005d0 	sw	s0,1488(sp)
 /*UDP target port: CLIENT_port*/
 struct iphdr *ip;
 struct udphdr *udp;
 struct tftp_t tftp_tx;
 /*generate the TFTP body*/
 tftp_tx.opcode=htons(TFTP_ACK);
a0001700:	24020004 	li	v0,4
a0001704:	a7a20034 	sh	v0,52(sp)
 tftp_tx.u.ack.block=htons(number);
a0001708:	a7a40036 	sh	a0,54(sp)
 
 ip = (struct iphdr *)&tftp_tx;
 udp = (struct udphdr *)((Int8*)&tftp_tx + sizeof(struct iphdr));
 
 /*IP header*/
 ip->verhdrlen = 0x45;
a000170c:	24020045 	li	v0,69
a0001710:	a3a20018 	sb	v0,24(sp)
 ip->service = 0;
a0001714:	a3a00019 	sb	zero,25(sp)
 ip->len = htons(32);
a0001718:	24020020 	li	v0,32
a000171c:	a7a2001a 	sh	v0,26(sp)
 ip->ident = 0;
a0001720:	a7a0001c 	sh	zero,28(sp)
 ip->frags = 0;
a0001724:	a7a0001e 	sh	zero,30(sp)
 ip->ttl = 60;
a0001728:	2402003c 	li	v0,60
a000172c:	a3a20020 	sb	v0,32(sp)
 ip->protocol = IP_UDP;
a0001730:	24020011 	li	v0,17
a0001734:	a3a20021 	sb	v0,33(sp)
 ip->chksum = 0;
a0001738:	a7a00022 	sh	zero,34(sp)
	 ip->dest.s_addr = arptable_tftp[TFTP_SERVER].ipaddr.s_addr; 	
 }
 else
#endif
 {
 ip->src.s_addr = arptable_tftp[TFTP_SERVER].ipaddr.s_addr;
a000173c:	3c02a002 	lui	v0,0xa002
a0001740:	8c438bf0 	lw	v1,-29712(v0)
a0001744:	afa30024 	sw	v1,36(sp)
 ip->dest.s_addr = arptable_tftp[TFTP_CLIENT].ipaddr.s_addr;
a0001748:	24428bf0 	addiu	v0,v0,-29712
a000174c:	8c42000c 	lw	v0,12(v0)
a0001750:	afa20028 	sw	v0,40(sp)
 }
 ip->chksum = ipheader_chksum((Int16 *)&tftp_tx, sizeof(struct iphdr));
a0001754:	27b00018 	addiu	s0,sp,24
a0001758:	02002021 	move	a0,s0
a000175c:	0c0003af 	jal	a0000ebc <ipheader_chksum>
a0001760:	24050014 	li	a1,20
a0001764:	a7a20022 	sh	v0,34(sp)
	 udp->dest = htons(SERVER_port); 	
 }
 else
#endif  
 {
 udp->src  = htons(SERVER_port);
a0001768:	3c02a001 	lui	v0,0xa001
a000176c:	94427950 	lhu	v0,31056(v0)
a0001770:	a7a2002c 	sh	v0,44(sp)
 udp->dest = htons(CLIENT_port);
a0001774:	3c02a001 	lui	v0,0xa001
a0001778:	94427952 	lhu	v0,31058(v0)
a000177c:	a7a2002e 	sh	v0,46(sp)
 }
 udp->len  = htons(32 - sizeof(struct iphdr));/*TFTP IP packet is 32 bytes.*/
a0001780:	2402000c 	li	v0,12
a0001784:	a7a20030 	sh	v0,48(sp)
 udp->chksum = 0;
a0001788:	a7a00032 	sh	zero,50(sp)
#ifdef SUPPORT_TFTP_CLIENT
 if (tftp_client_enabled)
	 prepare_txpkt(0,FRAME_IP,arptable_tftp[TFTP_SERVER].node,(Int8*)&tftp_tx,(Int16)sizeof(struct iphdr)+sizeof(struct udphdr)+4); 
 else
#endif  
 prepare_txpkt(0,FRAME_IP,arptable_tftp[TFTP_CLIENT].node,(Int8*)&tftp_tx,(Int16)sizeof(struct iphdr)+sizeof(struct udphdr)+4);
a000178c:	24020020 	li	v0,32
a0001790:	afa20010 	sw	v0,16(sp)
a0001794:	00002021 	move	a0,zero
a0001798:	24050800 	li	a1,2048
a000179c:	3c06a002 	lui	a2,0xa002
a00017a0:	24c68c00 	addiu	a2,a2,-29696
a00017a4:	0c000880 	jal	a0002200 <prepare_txpkt>
a00017a8:	02003821 	move	a3,s0
}
a00017ac:	8fbf05d4 	lw	ra,1492(sp)
a00017b0:	8fb005d0 	lw	s0,1488(sp)
a00017b4:	03e00008 	jr	ra
a00017b8:	27bd05d8 	addiu	sp,sp,1496

a00017bc <setTFTP_WRQ>:
/*DEBUG*/
//int upload_start=0;
/*DEBUG*/
//----------------------------------------------------------------------------------------
static void setTFTP_WRQ(void)
{
a00017bc:	27bdffe8 	addiu	sp,sp,-24
a00017c0:	afbf0014 	sw	ra,20(sp)
a00017c4:	afb00010 	sw	s0,16(sp)
 struct udphdr *udpheader;
 
 struct tftp_t *tftppacket;
 Int16 tftpopcode;

    if (!tftpd_is_ready)
a00017c8:	3c02a001 	lui	v0,0xa001
a00017cc:	8c427ac4 	lw	v0,31428(v0)
a00017d0:	10400045 	beqz	v0,a00018e8 <setTFTP_WRQ+0x12c>
a00017d4:	3c02a001 	lui	v0,0xa001
        return;

//dprintf("Receive TFTP WRQ\n");
  
 udpheader = (struct udphdr *)&nic.packet[ETH_HLEN+ sizeof(struct iphdr)];
a00017d8:	8c507948 	lw	s0,31048(v0)
a00017dc:	26020022 	addiu	v0,s0,34
 if( udpheader->dest==htons(TFTP_PORT) )
a00017e0:	94440002 	lhu	a0,2(v0)
a00017e4:	24030045 	li	v1,69
a00017e8:	14830040 	bne	a0,v1,a00018ec <setTFTP_WRQ+0x130>
a00017ec:	8fbf0014 	lw	ra,20(sp)
   {
     /*memorize CLIENT port*/
    CLIENT_port=  ntohs(udpheader->src); 
a00017f0:	94430000 	lhu	v1,0(v0)
a00017f4:	3c02a001 	lui	v0,0xa001
a00017f8:	a4437952 	sh	v1,31058(v0)
    tftppacket = (struct tftp_t *)&nic.packet[ETH_HLEN];
    
    /*memorize CLIENT mac address*/
    memcpy(arptable_tftp[TFTP_CLIENT].node,(Int8*)&(nic.packet[ETH_ALEN]),ETH_ALEN);
a00017fc:	3c03a002 	lui	v1,0xa002
a0001800:	26020006 	addiu	v0,s0,6
a0001804:	88440000 	lwl	a0,0(v0)
a0001808:	98440003 	lwr	a0,3(v0)
a000180c:	ac648c00 	sw	a0,-29696(v1)
a0001810:	24638c00 	addiu	v1,v1,-29696
a0001814:	90440004 	lbu	a0,4(v0)
a0001818:	a0640004 	sb	a0,4(v1)
a000181c:	90420005 	lbu	v0,5(v0)
a0001820:	a0620005 	sb	v0,5(v1)
    /*memorize CLIENT IP address*/
    memcpy(&(arptable_tftp[TFTP_CLIENT].ipaddr.s_addr),(Int8*)&nic.packet[ETH_HLEN+12],4);
a0001824:	3c02a001 	lui	v0,0xa001
a0001828:	8c427948 	lw	v0,31048(v0)
a000182c:	2442001a 	addiu	v0,v0,26
a0001830:	88430000 	lwl	v1,0(v0)
a0001834:	98430003 	lwr	v1,3(v0)
a0001838:	3c02a002 	lui	v0,0xa002
a000183c:	ac438bfc 	sw	v1,-29700(v0)
    /*here we can parse the file name if required.*/
    prom_printf("\n**TFTP Client Upload, File Name: %s\n",tftppacket->u.wrq);   
a0001840:	2610002c 	addiu	s0,s0,44
a0001844:	3c04a001 	lui	a0,0xa001
a0001848:	24844124 	addiu	a0,a0,16676
a000184c:	0c002325 	jal	a0008c94 <dprintf>
a0001850:	02002821 	move	a1,s0
    /*initializaiton of writing file.*/


//#if 0
//    if(!strcmp(tftppacket->u.wrq,TEST_FILENAME))
    if(strstr(tftppacket->u.wrq,TEST_FILENAME))
a0001854:	02002021 	move	a0,s0
a0001858:	3c05a001 	lui	a1,0xa001
a000185c:	0c002067 	jal	a000819c <strstr>
a0001860:	24a5414c 	addiu	a1,a1,16716
a0001864:	10400004 	beqz	v0,a0001878 <setTFTP_WRQ+0xbc>
a0001868:	24030001 	li	v1,1
    {
       jump_to_test=1;
a000186c:	3c02a001 	lui	v0,0xa001
a0001870:	0800062a 	j	a00018a8 <setTFTP_WRQ+0xec>
a0001874:	ac437ac0 	sw	v1,31424(v0)
       //image_address=TESTSTART;
    }
    else if(!strcmp(tftppacket->u.wrq,BOOT_FILENAME))
a0001878:	02002021 	move	a0,s0
a000187c:	3c05a001 	lui	a1,0xa001
a0001880:	0c002015 	jal	a0008054 <strcmp>
a0001884:	24a54154 	addiu	a1,a1,16724
a0001888:	14400008 	bnez	v0,a00018ac <setTFTP_WRQ+0xf0>
a000188c:	3c02a001 	lui	v0,0xa001
    {
       jump_to_test=1;
a0001890:	24030001 	li	v1,1
a0001894:	3c02a001 	lui	v0,0xa001
a0001898:	ac437ac0 	sw	v1,31424(v0)
       image_address=BOOTSTART;
a000189c:	3c038000 	lui	v1,0x8000
a00018a0:	3c02a001 	lui	v0,0xa001
a00018a4:	ac437218 	sw	v1,29208(v0)
#endif
//#endif  
#if defined(CONFIG_TFTP_COMMAND)
	memset(image_address,0,MAX_CMD_LEN);
#endif
    address_to_store=image_address;
a00018a8:	3c02a001 	lui	v0,0xa001
a00018ac:	8c437218 	lw	v1,29208(v0)
a00018b0:	3c02a001 	lui	v0,0xa001
a00018b4:	ac437940 	sw	v1,31040(v0)
    file_length_to_server=0;  
a00018b8:	3c02a001 	lui	v0,0xa001
a00018bc:	ac407960 	sw	zero,31072(v0)
    /*now send one ACK out, to identify this.*/
    tftpd_send_ack(0x0000);/*Block number 0*/
a00018c0:	0c0005bd 	jal	a00016f4 <tftpd_send_ack>
a00018c4:	00002021 	move	a0,zero
    block_expected=1;/*later client will send an Data number 1*/
a00018c8:	24020001 	li	v0,1
a00018cc:	3c03a001 	lui	v1,0xa001
a00018d0:	a4627944 	sh	v0,31044(v1)
    //prom_printf("line=%d:		block_expected=%d\n", __LINE__,  block_expected); // for debug
		
	//now lock the tftp..till upload finished
	one_tftp_lock=1;
a00018d4:	3c03a001 	lui	v1,0xa001
a00018d8:	a0627acc 	sb	v0,31436(v1)
    /*Change state to WRQ state.*/
    bootState=BOOT_STATE2_TFTP_CLIENT_WRQ;
a00018dc:	24030002 	li	v1,2
a00018e0:	3c02a001 	lui	v0,0xa001
a00018e4:	ac437954 	sw	v1,31060(v0)
   }
}
a00018e8:	8fbf0014 	lw	ra,20(sp)
a00018ec:	8fb00010 	lw	s0,16(sp)
a00018f0:	03e00008 	jr	ra
a00018f4:	27bd0018 	addiu	sp,sp,24

a00018f8 <checkAutoFlashing>:
}
#endif

#if ! (defined(CONFIG_NFBI) || defined(CONFIG_NONE_FLASH))
void checkAutoFlashing(unsigned long startAddr, int len)
{
a00018f8:	27bdff78 	addiu	sp,sp,-136
a00018fc:	afbf0084 	sw	ra,132(sp)
a0001900:	afbe0080 	sw	s8,128(sp)
a0001904:	afb7007c 	sw	s7,124(sp)
a0001908:	afb60078 	sw	s6,120(sp)
a000190c:	afb50074 	sw	s5,116(sp)
a0001910:	afb40070 	sw	s4,112(sp)
a0001914:	afb3006c 	sw	s3,108(sp)
a0001918:	afb20068 	sw	s2,104(sp)
a000191c:	afb10064 	sw	s1,100(sp)
a0001920:	afb00060 	sw	s0,96(sp)
a0001924:	afa40088 	sw	a0,136(sp)
a0001928:	afa5008c 	sw	a1,140(sp)
a000192c:	afa0003c 	sw	zero,60(sp)
a0001930:	afa00044 	sw	zero,68(sp)
a0001934:	afa00038 	sw	zero,56(sp)
				prom_printf("%s imgage checksum error at %X!\n"
				, Header.signature, startAddr+head_offset);
				return ;
			}
		}
		prom_printf("checksum Ok !\n");
a0001938:	3c02a001 	lui	v0,0xa001
a000193c:	244241bc 	addiu	v0,v0,16828
a0001940:	afa20048 	sw	v0,72(sp)
		   	    prom_printf("it's special wrt image need add 4 byte to burnlen =%8x!\n",burnLen);
			    burnLen += 4;
			}
		}
		
		prom_printf("burn Addr =0x%x! srcAddr=0x%x len =0x%x \n", Header.burnAddr, srcAddr, burnLen);
a0001944:	3c02a001 	lui	v0,0xa001
a0001948:	24424208 	addiu	v0,v0,16904
a000194c:	afa2004c 	sw	v0,76(sp)
				 int block_count=0;
				 //printf("original src_len %d dest 0x%x\n\r",src_len, dest);
				 //debug cl
				//block_count = (len+(block_size-1))/block_size;
	    		//len = block_count*block_size;
				block_count = (burnLen+(block_size-1))/block_size;
a0001950:	3c14a001 	lui	s4,0xa001
					unsigned int start_block=0;
					unsigned int addr=0, page=0;
					unsigned char *tmp_oob;


					tmp_oob = (unsigned char*)malloc((sizeof(char)*ppb*oob_size));
a0001954:	3c15a001 	lui	s5,0xa001
}
FINISH_GO:
	
#endif
		if(trueorfalse)
			prom_printf("\nFlash Write Successed!\n%s", "<RealTek>");
a0001958:	3c02a001 	lui	v0,0xa001
a000195c:	244242a4 	addiu	v0,v0,17060
a0001960:	afa20050 	sw	v0,80(sp)
a0001964:	3c02a001 	lui	v0,0xa001
a0001968:	244240d8 	addiu	v0,v0,16600
a000196c:	afa20054 	sw	v0,84(sp)
								start_page = ((Header.burnAddr+burn_offset)/page_size)-ppb;
							}					
							
							#ifdef CONFIG_RTK_NAND_BBT											
							                    //dprintf("[%s]:%d\n",__func__,__LINE__);
												start_block = ((Header.burnAddr+burn_offset) >> block_shift);
a0001970:	3c17a002 	lui	s7,0xa002
										if(nand_erase_nand(addr, block_size)){
											printf("%s: erase blockv:%x pagev:%x fail!\n",__FUNCTION__, i, page);
											break;
										}
										if(nand_write_ecc_ob(addr, block_size, srcAddr+offset, tmp_oob)){
												printf("%s: nand_write_ecc addrv :%x error\n",__FUNCTION__, addr);
a0001974:	3c02a001 	lui	v0,0xa001
a0001978:	24424280 	addiu	v0,v0,17024
a000197c:	afa2005c 	sw	v0,92(sp)
a0001980:	3c02a001 	lui	v0,0xa001
a0001984:	2442ffdc 	addiu	v0,v0,-36
a0001988:	afa20058 	sw	v0,88(sp)
#endif		
	while( (head_offset + sizeof(IMG_HEADER_T)) <  len){
		sum=0; sum1=0;
		memcpy(&Header, ((char *)startAddr + head_offset), sizeof(IMG_HEADER_T));
		
		if (!skip_check_signature) {
a000198c:	3c02a001 	lui	v0,0xa001
a0001990:	2442721c 	addiu	v0,v0,29212
#endif

#ifdef CONFIG_RTL_FLASH_DUAL_IMAGE_ENABLE	
	check_dualbank_setting(0); //must do check image to get current boot_bank.......
#endif		
	while( (head_offset + sizeof(IMG_HEADER_T)) <  len){
a0001994:	080007b8 	j	a0001ee0 <checkAutoFlashing+0x5e8>
a0001998:	afa20040 	sw	v0,64(sp)
		sum=0; sum1=0;
		memcpy(&Header, ((char *)startAddr + head_offset), sizeof(IMG_HEADER_T));
a000199c:	8fa30088 	lw	v1,136(sp)
a00019a0:	00438021 	addu	s0,v0,v1
a00019a4:	8a050000 	lwl	a1,0(s0)
a00019a8:	9a050003 	lwr	a1,3(s0)
a00019ac:	8a040004 	lwl	a0,4(s0)
a00019b0:	9a040007 	lwr	a0,7(s0)
a00019b4:	8a030008 	lwl	v1,8(s0)
a00019b8:	9a03000b 	lwr	v1,11(s0)
a00019bc:	8a02000c 	lwl	v0,12(s0)
a00019c0:	9a02000f 	lwr	v0,15(s0)
a00019c4:	afa50010 	sw	a1,16(sp)
a00019c8:	afa40014 	sw	a0,20(sp)
a00019cc:	afa30018 	sw	v1,24(sp)
a00019d0:	afa2001c 	sw	v0,28(sp)
		
		if (!skip_check_signature) {
a00019d4:	8fa4003c 	lw	a0,60(sp)
a00019d8:	14800034 	bnez	a0,a0001aac <checkAutoFlashing+0x1b4>
a00019dc:	27a40010 	addiu	a0,sp,16
a00019e0:	8fb10040 	lw	s1,64(sp)
a00019e4:	00009021 	move	s2,zero
			for(i=0 ;i < MAX_SIG_TBL ; i++) {
			
				if(!memcmp(Header.signature, (char *)sign_tbl[i].signature, sign_tbl[i].sig_len))
a00019e8:	27be0010 	addiu	s8,sp,16
	while( (head_offset + sizeof(IMG_HEADER_T)) <  len){
		sum=0; sum1=0;
		memcpy(&Header, ((char *)startAddr + head_offset), sizeof(IMG_HEADER_T));
		
		if (!skip_check_signature) {
			for(i=0 ;i < MAX_SIG_TBL ; i++) {
a00019ec:	24160007 	li	s6,7
			
				if(!memcmp(Header.signature, (char *)sign_tbl[i].signature, sign_tbl[i].sig_len))
a00019f0:	03c02021 	move	a0,s8
a00019f4:	8e250000 	lw	a1,0(s1)
a00019f8:	0c002051 	jal	a0008144 <memcmp>
a00019fc:	8e260008 	lw	a2,8(s1)
a0001a00:	10400006 	beqz	v0,a0001a1c <checkAutoFlashing+0x124>
a0001a04:	24020007 	li	v0,7
	while( (head_offset + sizeof(IMG_HEADER_T)) <  len){
		sum=0; sum1=0;
		memcpy(&Header, ((char *)startAddr + head_offset), sizeof(IMG_HEADER_T));
		
		if (!skip_check_signature) {
			for(i=0 ;i < MAX_SIG_TBL ; i++) {
a0001a08:	26520001 	addiu	s2,s2,1
a0001a0c:	1656fff8 	bne	s2,s6,a00019f0 <checkAutoFlashing+0xf8>
a0001a10:	26310018 	addiu	s1,s1,24
					break;			
				
		
			}
			if(i == MAX_SIG_TBL){
				head_offset += Header.len + sizeof(IMG_HEADER_T);
a0001a14:	0800068a 	j	a0001a28 <checkAutoFlashing+0x130>
a0001a18:	8fb3001c 	lw	s3,28(sp)
				if(!memcmp(Header.signature, (char *)sign_tbl[i].signature, sign_tbl[i].sig_len))
					break;			
				
		
			}
			if(i == MAX_SIG_TBL){
a0001a1c:	16420006 	bne	s2,v0,a0001a38 <checkAutoFlashing+0x140>
a0001a20:	00121040 	sll	v0,s2,0x1
				head_offset += Header.len + sizeof(IMG_HEADER_T);
a0001a24:	8fb3001c 	lw	s3,28(sp)
a0001a28:	26730010 	addiu	s3,s3,16
a0001a2c:	8fa20038 	lw	v0,56(sp)
				continue ;
a0001a30:	080007b7 	j	a0001edc <checkAutoFlashing+0x5e4>
a0001a34:	02629821 	addu	s3,s3,v0
			}			
			skip_header = sign_tbl[i].skip ;
a0001a38:	00521021 	addu	v0,v0,s2
a0001a3c:	24420001 	addiu	v0,v0,1
a0001a40:	000210c0 	sll	v0,v0,0x3
a0001a44:	8fa30040 	lw	v1,64(sp)
a0001a48:	00621021 	addu	v0,v1,v0
a0001a4c:	8c420004 	lw	v0,4(v0)
a0001a50:	10400004 	beqz	v0,a0001a64 <checkAutoFlashing+0x16c>
a0001a54:	00000000 	nop
			if(skip_header){
				srcAddr = startAddr + head_offset + sizeof(IMG_HEADER_T);
a0001a58:	261e0010 	addiu	s8,s0,16
					burnLen = Header.len; // +checksum
a0001a5c:	0800069c 	j	a0001a70 <checkAutoFlashing+0x178>
a0001a60:	8fb1001c 	lw	s1,28(sp)
			}else{
				srcAddr = startAddr + head_offset ;
				burnLen = Header.len + sizeof(IMG_HEADER_T) ;
a0001a64:	8fb1001c 	lw	s1,28(sp)
a0001a68:	26310010 	addiu	s1,s1,16
a0001a6c:	0200f021 	move	s8,s0
			}	
			reboot |= sign_tbl[i].reboot;
a0001a70:	001210c0 	sll	v0,s2,0x3
a0001a74:	00129140 	sll	s2,s2,0x5
a0001a78:	02429023 	subu	s2,s2,v0
a0001a7c:	8fa40040 	lw	a0,64(sp)
a0001a80:	00929021 	addu	s2,a0,s2
a0001a84:	8e420014 	lw	v0,20(s2)
a0001a88:	8fa30044 	lw	v1,68(sp)
a0001a8c:	00621825 	or	v1,v1,v0
a0001a90:	afa30044 	sw	v1,68(sp)
			prom_printf("\n%s upgrade.\n", sign_tbl[i].comment);
a0001a94:	3c04a001 	lui	a0,0xa001
a0001a98:	24844160 	addiu	a0,a0,16736
a0001a9c:	0c002325 	jal	a0008c94 <dprintf>
a0001aa0:	8e450004 	lw	a1,4(s2)

#ifdef CONFIG_NAND_FLASH_BOOTING
		//add by cl for NAND DMA ALIGED,in case linux.bin or rootfs.bin start address in fw.bin not 4Byte aligned.
		//now 0x80a00000 just tmp for dma write.
		#define DRAM_BURN_TMP_ADDR        0xa0a00000 //this address will also use in boot read image from nand.
		if(srcAddr%4 != 0)
a0001aa4:	080006be 	j	a0001af8 <checkAutoFlashing+0x200>
a0001aa8:	33c20003 	andi	v0,s8,0x3
			}	
			reboot |= sign_tbl[i].reboot;
			prom_printf("\n%s upgrade.\n", sign_tbl[i].comment);
		}
		else {
			if(!memcmp(Header.signature, BOOT_SIGNATURE, SIG_LEN))
a0001aac:	3c05a001 	lui	a1,0xa001
a0001ab0:	24a54170 	addiu	a1,a1,16752
a0001ab4:	0c002051 	jal	a0008144 <memcmp>
a0001ab8:	24060004 	li	a2,4
a0001abc:	10400008 	beqz	v0,a0001ae0 <checkAutoFlashing+0x1e8>
a0001ac0:	261e0010 	addiu	s8,s0,16
				skip_header = 1;
			else {
				unsigned char *pRoot =((unsigned char *)startAddr) + head_offset + sizeof(IMG_HEADER_T);
				if (!memcmp(pRoot, SQSH_SIGNATURE, SIG_LEN))
a0001ac4:	26040010 	addiu	a0,s0,16
a0001ac8:	3c05a001 	lui	a1,0xa001
a0001acc:	24a54178 	addiu	a1,a1,16760
a0001ad0:	0c002051 	jal	a0008144 <memcmp>
a0001ad4:	24060004 	li	a2,4
					skip_header = 1;
				else				
					skip_header = 0;
			}				
			if(skip_header){
a0001ad8:	14400003 	bnez	v0,a0001ae8 <checkAutoFlashing+0x1f0>
a0001adc:	261e0010 	addiu	s8,s0,16
				srcAddr = startAddr + head_offset + sizeof(IMG_HEADER_T);
				burnLen = Header.len ; // +checksum
a0001ae0:	080006bd 	j	a0001af4 <checkAutoFlashing+0x1fc>
a0001ae4:	8fb1001c 	lw	s1,28(sp)

			}else{
				srcAddr = startAddr + head_offset ;
				burnLen = Header.len + sizeof(IMG_HEADER_T) ;
a0001ae8:	8fb1001c 	lw	s1,28(sp)
a0001aec:	26310010 	addiu	s1,s1,16
a0001af0:	0200f021 	move	s8,s0

#ifdef CONFIG_NAND_FLASH_BOOTING
		//add by cl for NAND DMA ALIGED,in case linux.bin or rootfs.bin start address in fw.bin not 4Byte aligned.
		//now 0x80a00000 just tmp for dma write.
		#define DRAM_BURN_TMP_ADDR        0xa0a00000 //this address will also use in boot read image from nand.
		if(srcAddr%4 != 0)
a0001af4:	33c20003 	andi	v0,s8,0x3
a0001af8:	10400007 	beqz	v0,a0001b18 <checkAutoFlashing+0x220>
a0001afc:	8fa4003c 	lw	a0,60(sp)
		{
		    //dprintf("[%s]:%d address not aligned,now use aligned address for NAND DMA\n",__func__,__LINE__);
		    memcpy((void *)DRAM_BURN_TMP_ADDR,(void*)srcAddr,burnLen); 
a0001b00:	3c04a0a0 	lui	a0,0xa0a0
a0001b04:	03c02821 	move	a1,s8
a0001b08:	0c002046 	jal	a0008118 <memcpy>
a0001b0c:	02203021 	move	a2,s1
a0001b10:	3c1ea0a0 	lui	s8,0xa0a0
		    srcAddr = DRAM_BURN_TMP_ADDR;
		}
#endif

		if(skip_check_signature || 
a0001b14:	8fa4003c 	lw	a0,60(sp)
a0001b18:	1480000c 	bnez	a0,a0001b4c <checkAutoFlashing+0x254>
a0001b1c:	27a40010 	addiu	a0,sp,16
			memcmp(Header.signature, WEB_SIGNATURE, 3)){
a0001b20:	3c05a001 	lui	a1,0xa001
a0001b24:	24a54180 	addiu	a1,a1,16768
a0001b28:	0c002051 	jal	a0008144 <memcmp>
a0001b2c:	24060003 	li	a2,3
		    memcpy((void *)DRAM_BURN_TMP_ADDR,(void*)srcAddr,burnLen); 
		    srcAddr = DRAM_BURN_TMP_ADDR;
		}
#endif

		if(skip_check_signature || 
a0001b30:	14400006 	bnez	v0,a0001b4c <checkAutoFlashing+0x254>
a0001b34:	27a40010 	addiu	a0,sp,16
				continue;		
			}						
		}else
		{  //web page use different checksum algorimth

			for (i=0; i< Header.len; i++)
a0001b38:	8fa6001c 	lw	a2,28(sp)
a0001b3c:	14c0004f 	bnez	a2,a0001c7c <checkAutoFlashing+0x384>
a0001b40:	00002021 	move	a0,zero
a0001b44:	08000731 	j	a0001cc4 <checkAutoFlashing+0x3cc>
a0001b48:	00000000 	nop
#endif

		if(skip_check_signature || 
			memcmp(Header.signature, WEB_SIGNATURE, 3)){
			//calculate checksum
			if(!memcmp(Header.signature, ALL1_SIGNATURE, SIG_LEN) ||
a0001b4c:	3c05a001 	lui	a1,0xa001
a0001b50:	24a54188 	addiu	a1,a1,16776
a0001b54:	0c002051 	jal	a0008144 <memcmp>
a0001b58:	24060004 	li	a2,4
a0001b5c:	14400007 	bnez	v0,a0001b7c <checkAutoFlashing+0x284>
a0001b60:	27a40010 	addiu	a0,sp,16
					!memcmp(Header.signature, ALL2_SIGNATURE, SIG_LEN)) {										
				for (i=0; i< Header.len+sizeof(IMG_HEADER_T); i+=2) {
a0001b64:	8fa6001c 	lw	a2,28(sp)
a0001b68:	24c60010 	addiu	a2,a2,16
a0001b6c:	14c0000b 	bnez	a2,a0001b9c <checkAutoFlashing+0x2a4>
a0001b70:	00001821 	move	v1,zero
			if ( sum ) {
				prom_printf("%s imgage checksum error at %X!\n"
				, Header.signature, startAddr+head_offset);
				return ;
			}
			if(!memcmp(Header.signature, ALL1_SIGNATURE, SIG_LEN)){
a0001b74:	08000711 	j	a0001c44 <checkAutoFlashing+0x34c>
a0001b78:	27a40010 	addiu	a0,sp,16

		if(skip_check_signature || 
			memcmp(Header.signature, WEB_SIGNATURE, 3)){
			//calculate checksum
			if(!memcmp(Header.signature, ALL1_SIGNATURE, SIG_LEN) ||
					!memcmp(Header.signature, ALL2_SIGNATURE, SIG_LEN)) {										
a0001b7c:	3c05a001 	lui	a1,0xa001
a0001b80:	24a54190 	addiu	a1,a1,16784
a0001b84:	0c002051 	jal	a0008144 <memcmp>
a0001b88:	24060004 	li	a2,4
#endif

		if(skip_check_signature || 
			memcmp(Header.signature, WEB_SIGNATURE, 3)){
			//calculate checksum
			if(!memcmp(Header.signature, ALL1_SIGNATURE, SIG_LEN) ||
a0001b8c:	1040fff6 	beqz	v0,a0001b68 <checkAutoFlashing+0x270>
a0001b90:	8fa6001c 	lw	a2,28(sp)
				}				
			}	
				else 
				{
					unsigned char x=0,y=0;
					unsigned short temp=0;
a0001b94:	080006f3 	j	a0001bcc <checkAutoFlashing+0x2d4>
a0001b98:	a7a00020 	sh	zero,32(sp)
#endif

		if(skip_check_signature || 
			memcmp(Header.signature, WEB_SIGNATURE, 3)){
			//calculate checksum
			if(!memcmp(Header.signature, ALL1_SIGNATURE, SIG_LEN) ||
a0001b9c:	00002021 	move	a0,zero
a0001ba0:	00001021 	move	v0,zero
					!memcmp(Header.signature, ALL2_SIGNATURE, SIG_LEN)) {										
				for (i=0; i< Header.len+sizeof(IMG_HEADER_T); i+=2) {
					sum += *((unsigned short *)(startAddr+ head_offset + i));
a0001ba4:	00902021 	addu	a0,a0,s0
a0001ba8:	94840000 	lhu	a0,0(a0)
a0001bac:	00641821 	addu	v1,v1,a0
a0001bb0:	3063ffff 	andi	v1,v1,0xffff
		if(skip_check_signature || 
			memcmp(Header.signature, WEB_SIGNATURE, 3)){
			//calculate checksum
			if(!memcmp(Header.signature, ALL1_SIGNATURE, SIG_LEN) ||
					!memcmp(Header.signature, ALL2_SIGNATURE, SIG_LEN)) {										
				for (i=0; i< Header.len+sizeof(IMG_HEADER_T); i+=2) {
a0001bb4:	24420002 	addiu	v0,v0,2
a0001bb8:	0046282b 	sltu	a1,v0,a2
a0001bbc:	14a0fff9 	bnez	a1,a0001ba4 <checkAutoFlashing+0x2ac>
a0001bc0:	00402021 	move	a0,v0
a0001bc4:	08000707 	j	a0001c1c <checkAutoFlashing+0x324>
a0001bc8:	00000000 	nop
				else 
				{
					unsigned char x=0,y=0;
					unsigned short temp=0;
					
					for (i=0; i< Header.len; i+=2) 
a0001bcc:	8fa2001c 	lw	v0,28(sp)
a0001bd0:	1040001b 	beqz	v0,a0001c40 <checkAutoFlashing+0x348>
a0001bd4:	00002021 	move	a0,zero
a0001bd8:	00001821 	move	v1,zero
a0001bdc:	00001021 	move	v0,zero
					{
						
#if  defined(RTL8198)																		
#if 1				
						//sum +=*((unsigned short *)(startAddr+ head_offset + sizeof(IMG_HEADER_T) + i));
						memcpy(&temp, (startAddr+ head_offset + sizeof(IMG_HEADER_T) + i), 2); // for alignment issue
a0001be0:	27a50020 	addiu	a1,sp,32
a0001be4:	26070010 	addiu	a3,s0,16
a0001be8:	00e42021 	addu	a0,a3,a0
a0001bec:	90860000 	lbu	a2,0(a0)
a0001bf0:	a0a60000 	sb	a2,0(a1)
a0001bf4:	90840001 	lbu	a0,1(a0)
a0001bf8:	a0a40001 	sb	a0,1(a1)
						sum+=temp;
a0001bfc:	97a40020 	lhu	a0,32(sp)
a0001c00:	00641821 	addu	v1,v1,a0
a0001c04:	3063ffff 	andi	v1,v1,0xffff
				else 
				{
					unsigned char x=0,y=0;
					unsigned short temp=0;
					
					for (i=0; i< Header.len; i+=2) 
a0001c08:	24420002 	addiu	v0,v0,2
a0001c0c:	8fa6001c 	lw	a2,28(sp)
a0001c10:	0046302b 	sltu	a2,v0,a2
a0001c14:	14c0fff4 	bnez	a2,a0001be8 <checkAutoFlashing+0x2f0>
a0001c18:	00402021 	move	a0,v0
#else
				sum += *((unsigned short *)(startAddr+ head_offset + sizeof(IMG_HEADER_T) + i));
#endif	// defined(RTL8198)
				}
			}
			if ( sum ) {
a0001c1c:	10600009 	beqz	v1,a0001c44 <checkAutoFlashing+0x34c>
a0001c20:	27a40010 	addiu	a0,sp,16
				prom_printf("%s imgage checksum error at %X!\n"
a0001c24:	3c04a001 	lui	a0,0xa001
a0001c28:	24844198 	addiu	a0,a0,16792
a0001c2c:	27a50010 	addiu	a1,sp,16
a0001c30:	0c002325 	jal	a0008c94 <dprintf>
a0001c34:	02003021 	move	a2,s0
				, Header.signature, startAddr+head_offset);
				return ;
a0001c38:	080007c4 	j	a0001f10 <checkAutoFlashing+0x618>
a0001c3c:	8fbf0084 	lw	ra,132(sp)
			}
			if(!memcmp(Header.signature, ALL1_SIGNATURE, SIG_LEN)){
a0001c40:	27a40010 	addiu	a0,sp,16
a0001c44:	3c05a001 	lui	a1,0xa001
a0001c48:	24a54188 	addiu	a1,a1,16776
a0001c4c:	0c002051 	jal	a0008144 <memcmp>
a0001c50:	24060004 	li	a2,4
a0001c54:	104000a1 	beqz	v0,a0001edc <checkAutoFlashing+0x5e4>
a0001c58:	27a40010 	addiu	a0,sp,16
				head_offset += sizeof(IMG_HEADER_T);
				continue;		
			}		
			if(!memcmp(Header.signature, ALL2_SIGNATURE, SIG_LEN)){
a0001c5c:	3c05a001 	lui	a1,0xa001
a0001c60:	24a54190 	addiu	a1,a1,16784
a0001c64:	0c002051 	jal	a0008144 <memcmp>
a0001c68:	24060004 	li	a2,4
a0001c6c:	1040009a 	beqz	v0,a0001ed8 <checkAutoFlashing+0x5e0>
a0001c70:	24030001 	li	v1,1
a0001c74:	08000731 	j	a0001cc4 <checkAutoFlashing+0x3cc>
a0001c78:	00000000 	nop
a0001c7c:	00001821 	move	v1,zero
a0001c80:	00001021 	move	v0,zero
			}						
		}else
		{  //web page use different checksum algorimth

			for (i=0; i< Header.len; i++)
			       sum1 += *((unsigned char *)(startAddr+ head_offset + sizeof(IMG_HEADER_T) + i));
a0001c84:	00902021 	addu	a0,a0,s0
a0001c88:	90840010 	lbu	a0,16(a0)
a0001c8c:	00641821 	addu	v1,v1,a0
a0001c90:	306300ff 	andi	v1,v1,0xff
				continue;		
			}						
		}else
		{  //web page use different checksum algorimth

			for (i=0; i< Header.len; i++)
a0001c94:	24420001 	addiu	v0,v0,1
a0001c98:	0046282b 	sltu	a1,v0,a2
a0001c9c:	14a0fff9 	bnez	a1,a0001c84 <checkAutoFlashing+0x38c>
a0001ca0:	00402021 	move	a0,v0
			       sum1 += *((unsigned char *)(startAddr+ head_offset + sizeof(IMG_HEADER_T) + i));
			if ( sum1 ) {
a0001ca4:	10600007 	beqz	v1,a0001cc4 <checkAutoFlashing+0x3cc>
a0001ca8:	3c04a001 	lui	a0,0xa001
				prom_printf("%s imgage checksum error at %X!\n"
a0001cac:	24844198 	addiu	a0,a0,16792
a0001cb0:	27a50010 	addiu	a1,sp,16
a0001cb4:	0c002325 	jal	a0008c94 <dprintf>
a0001cb8:	02003021 	move	a2,s0
				, Header.signature, startAddr+head_offset);
				return ;
a0001cbc:	080007c4 	j	a0001f10 <checkAutoFlashing+0x618>
a0001cc0:	8fbf0084 	lw	ra,132(sp)
			}
		}
		prom_printf("checksum Ok !\n");
a0001cc4:	0c002325 	jal	a0008c94 <dprintf>
a0001cc8:	8fa40048 	lw	a0,72(sp)
		
		if( (burnLen % 0x1000) == 0) //mean 4k alignemnt
a0001ccc:	32220fff 	andi	v0,s1,0xfff
a0001cd0:	1440000c 	bnez	v0,a0001d04 <checkAutoFlashing+0x40c>
a0001cd4:	8fa30088 	lw	v1,136(sp)
		{
			if( (*((unsigned int *)(startAddr+burnLen))) == 0xdeadc0de ) //wrt jffs2 endof mark
a0001cd8:	02231021 	addu	v0,s1,v1
a0001cdc:	8c430000 	lw	v1,0(v0)
a0001ce0:	3c02dead 	lui	v0,0xdead
a0001ce4:	3442c0de 	ori	v0,v0,0xc0de
a0001ce8:	14620006 	bne	v1,v0,a0001d04 <checkAutoFlashing+0x40c>
a0001cec:	00000000 	nop

		 	    prom_printf("dual image burn_offset =0x%x \n", burn_offset); //mark_boot
			    //update bootinfo 
			    rtk_update_bootbank(next_bank);  //if bank is bank1 not bank0 ,then need add offset	
#endif		
		   	    prom_printf("it's special wrt image need add 4 byte to burnlen =%8x!\n",burnLen);
a0001cf0:	3c04a001 	lui	a0,0xa001
a0001cf4:	248441cc 	addiu	a0,a0,16844
a0001cf8:	0c002325 	jal	a0008c94 <dprintf>
a0001cfc:	02202821 	move	a1,s1
			    burnLen += 4;
a0001d00:	26310004 	addiu	s1,s1,4
			}
		}
		
		prom_printf("burn Addr =0x%x! srcAddr=0x%x len =0x%x \n", Header.burnAddr, srcAddr, burnLen);
a0001d04:	8fa4004c 	lw	a0,76(sp)
a0001d08:	8fa50018 	lw	a1,24(sp)
a0001d0c:	03c03021 	move	a2,s8
a0001d10:	0c002325 	jal	a0008c94 <dprintf>
a0001d14:	02203821 	move	a3,s1
				 int block_count=0;
				 //printf("original src_len %d dest 0x%x\n\r",src_len, dest);
				 //debug cl
				//block_count = (len+(block_size-1))/block_size;
	    		//len = block_count*block_size;
				block_count = (burnLen+(block_size-1))/block_size;
a0001d18:	8e907524 	lw	s0,29988(s4)
					unsigned int start_block=0;
					unsigned int addr=0, page=0;
					unsigned char *tmp_oob;


					tmp_oob = (unsigned char*)malloc((sizeof(char)*ppb*oob_size));
a0001d1c:	3c02a001 	lui	v0,0xa001
a0001d20:	8c447548 	lw	a0,30024(v0)
a0001d24:	8ea2754c 	lw	v0,30028(s5)
a0001d28:	0c001f55 	jal	a0007d54 <malloc>
a0001d2c:	70822002 	mul	a0,a0,v0
					if(!tmp_oob){
a0001d30:	14400006 	bnez	v0,a0001d4c <checkAutoFlashing+0x454>
a0001d34:	afa20028 	sw	v0,40(sp)
						printf("can't alloc memory for tmp_oob buf!!!\n\r");
a0001d38:	3c04a001 	lui	a0,0xa001
a0001d3c:	0c002325 	jal	a0008c94 <dprintf>
a0001d40:	24844234 	addiu	a0,a0,16948
						return -1;
a0001d44:	080007c4 	j	a0001f10 <checkAutoFlashing+0x618>
a0001d48:	8fbf0084 	lw	ra,132(sp)
				 int block_count=0;
				 //printf("original src_len %d dest 0x%x\n\r",src_len, dest);
				 //debug cl
				//block_count = (len+(block_size-1))/block_size;
	    		//len = block_count*block_size;
				block_count = (burnLen+(block_size-1))/block_size;
a0001d4c:	2602ffff 	addiu	v0,s0,-1
a0001d50:	00518821 	addu	s1,v0,s1
a0001d54:	0230001b 	divu	zero,s1,s0
a0001d58:	020001f4 	teq	s0,zero,0x7
a0001d5c:	00008812 	mflo	s1
					if(!tmp_oob){
						printf("can't alloc memory for tmp_oob buf!!!\n\r");
						return -1;
					}
						//printf("(sizeof(char)*ppb*oob_size) %d!!!\n\r", (sizeof(char)*ppb*oob_size));
					memset(tmp_oob,0xff,(sizeof(char)*ppb*oob_size));
a0001d60:	3c02a001 	lui	v0,0xa001
a0001d64:	8c467548 	lw	a2,30024(v0)
a0001d68:	8ea2754c 	lw	v0,30028(s5)
a0001d6c:	8fa40028 	lw	a0,40(sp)
a0001d70:	240500ff 	li	a1,255
a0001d74:	0c00203d 	jal	a00080f4 <memset>
a0001d78:	70c23002 	mul	a2,a2,v0
					rtk_scan_v2r_bbt();
a0001d7c:	0c0017c5 	jal	a0005f14 <rtk_scan_v2r_bbt>
a0001d80:	00000000 	nop
					rtk_nand_scan_bbt();
a0001d84:	0c0015e8 	jal	a00057a0 <rtk_nand_scan_bbt>
a0001d88:	00000000 	nop
										start_block = (IMG_BACKUP_ADDR >> block_shift);
					#endif
						offset = 0;
					}else{
							//printf("Header.burnAddr:%x burn_offset:%x\n\r",Header.burnAddr,burn_offset);
							if((Header.burnAddr+burn_offset)==0){
a0001d8c:	8fa20018 	lw	v0,24(sp)
a0001d90:	14400007 	bnez	v0,a0001db0 <checkAutoFlashing+0x4b8>
a0001d94:	8ee28870 	lw	v0,-30608(s7)
									//continue;
									//while(1); //debug cl
									//debug boot.bin
									//Header.burnAddr = 0x100440;
									//burn_offset = 0;
									if (rtk_write_ecc_page(Header.burnAddr+burn_offset, srcAddr, burnLen))
a0001d98:	00002021 	move	a0,zero
a0001d9c:	03c02821 	move	a1,s8
a0001da0:	0c0014a4 	jal	a0005290 <rtk_write_ecc_page>
a0001da4:	72303002 	mul	a2,s1,s0
a0001da8:	1440003d 	bnez	v0,a0001ea0 <checkAutoFlashing+0x5a8>
a0001dac:	8ee28870 	lw	v0,-30608(s7)
								start_page = ((Header.burnAddr+burn_offset)/page_size)-ppb;
							}					
							
							#ifdef CONFIG_RTK_NAND_BBT											
							                    //dprintf("[%s]:%d\n",__func__,__LINE__);
												start_block = ((Header.burnAddr+burn_offset) >> block_shift);
a0001db0:	8fb00018 	lw	s0,24(sp)
a0001db4:	00508006 	srlv	s0,s0,v0
												//debug cl
												//continue;
												//while(1);
									
									//printf("start blockv:%x start_page:%x block_count:%x\n\r",start_block,start_page,block_count);
									for(i=start_block;i<block_count+start_block;i++){ //caculate how many block.
a0001db8:	02308821 	addu	s1,s1,s0
a0001dbc:	afb1002c 	sw	s1,44(sp)
a0001dc0:	0211102b 	sltu	v0,s0,s1
a0001dc4:	10400034 	beqz	v0,a0001e98 <checkAutoFlashing+0x5a0>
a0001dc8:	0000b021 	move	s6,zero
										if(nand_write_ecc_ob(addr, block_size, srcAddr+offset, tmp_oob)){
												printf("%s: nand_write_ecc addrv :%x error\n",__FUNCTION__, addr);
												break;
										}	
										offset += block_size;//shift buffer ptr one block each time.
										if(i==(block_count+start_block-1)){
a0001dcc:	2622ffff 	addiu	v0,s1,-1
a0001dd0:	afa20034 	sw	v0,52(sp)
a0001dd4:	afbe0030 	sw	s8,48(sp)
a0001dd8:	02c0f021 	move	s8,s6
a0001ddc:	02008821 	move	s1,s0
a0001de0:	02009821 	move	s3,s0
									
									//printf("start blockv:%x start_page:%x block_count:%x\n\r",start_block,start_page,block_count);
									for(i=start_block;i<block_count+start_block;i++){ //caculate how many block.
										//real_addr = (bbt_v2r[i].block_r << block_shift);
										//real_page = bbt_v2r[i].block_r * ppb;
										addr = (i << block_shift);
a0001de4:	8ef28870 	lw	s2,-30608(s7)
a0001de8:	02519004 	sllv	s2,s1,s2
										page = i * ppb;
a0001dec:	8eb0754c 	lw	s0,30028(s5)
a0001df0:	72708002 	mul	s0,s3,s0
										//printf("addrv:%x pagev:%x block_count:%x i:%d\n\r",addr, page,block_count,i);
								 
										//if(rtk_erase_block(real_page))
										if(nand_erase_nand(addr, block_size)){
a0001df4:	02402021 	move	a0,s2
a0001df8:	0c001d2e 	jal	a00074b8 <nand_erase_nand>
a0001dfc:	8e857524 	lw	a1,29988(s4)
a0001e00:	1040000b 	beqz	v0,a0001e30 <checkAutoFlashing+0x538>
a0001e04:	02402021 	move	a0,s2
a0001e08:	02009021 	move	s2,s0
a0001e0c:	03c0b021 	move	s6,s8
											printf("%s: erase blockv:%x pagev:%x fail!\n",__FUNCTION__, i, page);
a0001e10:	3c04a001 	lui	a0,0xa001
a0001e14:	2484425c 	addiu	a0,a0,16988
a0001e18:	8fa50058 	lw	a1,88(sp)
a0001e1c:	02203021 	move	a2,s1
a0001e20:	0c002325 	jal	a0008c94 <dprintf>
a0001e24:	02403821 	move	a3,s2
											break;
a0001e28:	080007a6 	j	a0001e98 <checkAutoFlashing+0x5a0>
a0001e2c:	00000000 	nop
										}
										if(nand_write_ecc_ob(addr, block_size, srcAddr+offset, tmp_oob)){
a0001e30:	8e857524 	lw	a1,29988(s4)
a0001e34:	8fa20030 	lw	v0,48(sp)
a0001e38:	02c23021 	addu	a2,s6,v0
a0001e3c:	0c001a4e 	jal	a0006938 <nand_write_ecc_ob>
a0001e40:	8fa70028 	lw	a3,40(sp)
a0001e44:	10400008 	beqz	v0,a0001e68 <checkAutoFlashing+0x570>
a0001e48:	8e837524 	lw	v1,29988(s4)
a0001e4c:	03c0b021 	move	s6,s8
												printf("%s: nand_write_ecc addrv :%x error\n",__FUNCTION__, addr);
a0001e50:	8fa4005c 	lw	a0,92(sp)
a0001e54:	8fa50058 	lw	a1,88(sp)
a0001e58:	0c002325 	jal	a0008c94 <dprintf>
a0001e5c:	02403021 	move	a2,s2
												break;
a0001e60:	080007a6 	j	a0001e98 <checkAutoFlashing+0x5a0>
a0001e64:	00000000 	nop
										}	
										offset += block_size;//shift buffer ptr one block each time.
										if(i==(block_count+start_block-1)){
a0001e68:	8fa40034 	lw	a0,52(sp)
a0001e6c:	02649826 	xor	s3,s3,a0
a0001e70:	24020001 	li	v0,1
a0001e74:	0053f00a 	movz	s8,v0,s3
												//debug cl
												//continue;
												//while(1);
									
									//printf("start blockv:%x start_page:%x block_count:%x\n\r",start_block,start_page,block_count);
									for(i=start_block;i<block_count+start_block;i++){ //caculate how many block.
a0001e78:	26310001 	addiu	s1,s1,1
a0001e7c:	8fa4002c 	lw	a0,44(sp)
a0001e80:	0224102b 	sltu	v0,s1,a0
a0001e84:	10400003 	beqz	v0,a0001e94 <checkAutoFlashing+0x59c>
a0001e88:	02209821 	move	s3,s1
										}
										if(nand_write_ecc_ob(addr, block_size, srcAddr+offset, tmp_oob)){
												printf("%s: nand_write_ecc addrv :%x error\n",__FUNCTION__, addr);
												break;
										}	
										offset += block_size;//shift buffer ptr one block each time.
a0001e8c:	08000779 	j	a0001de4 <checkAutoFlashing+0x4ec>
a0001e90:	02c3b021 	addu	s6,s6,v1
a0001e94:	03c0b021 	move	s6,s8

}
FINISH_GO:
	
#endif
		if(trueorfalse)
a0001e98:	12c00009 	beqz	s6,a0001ec0 <checkAutoFlashing+0x5c8>
a0001e9c:	3c04a001 	lui	a0,0xa001
			prom_printf("\nFlash Write Successed!\n%s", "<RealTek>");
a0001ea0:	8fa40050 	lw	a0,80(sp)
a0001ea4:	0c002325 	jal	a0008c94 <dprintf>
a0001ea8:	8fa50054 	lw	a1,84(sp)
		else{
			prom_printf("\nFlash Write Failed!\n%s", "<RealTek>");
			return ;
		}

		head_offset += Header.len + sizeof(IMG_HEADER_T);
a0001eac:	8fb3001c 	lw	s3,28(sp)
a0001eb0:	26730010 	addiu	s3,s3,16
a0001eb4:	8fa20038 	lw	v0,56(sp)
a0001eb8:	080007b7 	j	a0001edc <checkAutoFlashing+0x5e4>
a0001ebc:	02629821 	addu	s3,s3,v0
	
#endif
		if(trueorfalse)
			prom_printf("\nFlash Write Successed!\n%s", "<RealTek>");
		else{
			prom_printf("\nFlash Write Failed!\n%s", "<RealTek>");
a0001ec0:	248442c0 	addiu	a0,a0,17088
a0001ec4:	3c05a001 	lui	a1,0xa001
a0001ec8:	0c002325 	jal	a0008c94 <dprintf>
a0001ecc:	24a540d8 	addiu	a1,a1,16600
			return ;
a0001ed0:	080007c4 	j	a0001f10 <checkAutoFlashing+0x618>
a0001ed4:	8fbf0084 	lw	ra,132(sp)
a0001ed8:	afa3003c 	sw	v1,60(sp)
a0001edc:	afb30038 	sw	s3,56(sp)
#endif

#ifdef CONFIG_RTL_FLASH_DUAL_IMAGE_ENABLE	
	check_dualbank_setting(0); //must do check image to get current boot_bank.......
#endif		
	while( (head_offset + sizeof(IMG_HEADER_T)) <  len){
a0001ee0:	8fa40038 	lw	a0,56(sp)
a0001ee4:	24930010 	addiu	s3,a0,16
a0001ee8:	8fa3008c 	lw	v1,140(sp)
a0001eec:	0263102b 	sltu	v0,s3,v1
a0001ef0:	1440feaa 	bnez	v0,a000199c <checkAutoFlashing+0xa4>
a0001ef4:	8fa20038 	lw	v0,56(sp)
			return ;
		}

		head_offset += Header.len + sizeof(IMG_HEADER_T);
	} //while
	if(reboot){
a0001ef8:	8fa40044 	lw	a0,68(sp)
a0001efc:	10800004 	beqz	a0,a0001f10 <checkAutoFlashing+0x618>
a0001f00:	8fbf0084 	lw	ra,132(sp)
	    	autoreboot();
a0001f04:	0c000469 	jal	a00011a4 <autoreboot>
a0001f08:	00000000 	nop
	}
		
}
a0001f0c:	8fbf0084 	lw	ra,132(sp)
a0001f10:	8fbe0080 	lw	s8,128(sp)
a0001f14:	8fb7007c 	lw	s7,124(sp)
a0001f18:	8fb60078 	lw	s6,120(sp)
a0001f1c:	8fb50074 	lw	s5,116(sp)
a0001f20:	8fb40070 	lw	s4,112(sp)
a0001f24:	8fb3006c 	lw	s3,108(sp)
a0001f28:	8fb20068 	lw	s2,104(sp)
a0001f2c:	8fb10064 	lw	s1,100(sp)
a0001f30:	8fb00060 	lw	s0,96(sp)
a0001f34:	03e00008 	jr	ra
a0001f38:	27bd0088 	addiu	sp,sp,136

a0001f3c <prepareACK>:
	}
    return NULL;
}
#endif
static void prepareACK(void)
{
a0001f3c:	27bdffd8 	addiu	sp,sp,-40
a0001f40:	afbf0024 	sw	ra,36(sp)
a0001f44:	afb10020 	sw	s1,32(sp)
a0001f48:	afb0001c 	sw	s0,28(sp)
 struct udphdr *udpheader;
 struct tftp_t *tftppacket;
 Int16 tftpopcode;
 Int32 tftpdata_length;
 volatile Int16 block_received=0;
a0001f4c:	a7a00010 	sh	zero,16(sp)
    IMG_HEADER_T header;
    int ret;
    extern int check_system_image(unsigned long addr, IMG_HEADER_Tp pHeader);
#endif

    if (!tftpd_is_ready)
a0001f50:	3c02a001 	lui	v0,0xa001
a0001f54:	8c427ac4 	lw	v0,31428(v0)
a0001f58:	104000a2 	beqz	v0,a00021e4 <prepareACK+0x2a8>
a0001f5c:	3c02a001 	lui	v0,0xa001
        return;

	//dprintf("Receive TFTP Data\n");
 
 udpheader = (struct udphdr *)&nic.packet[ETH_HLEN+ sizeof(struct iphdr)];
a0001f60:	8c427948 	lw	v0,31048(v0)
a0001f64:	24420022 	addiu	v0,v0,34
#ifdef SUPPORT_TFTP_CLIENT
 if((tftp_client_enabled && (udpheader->dest==htons(CLIENT_port))) || 	
	 (!tftp_client_enabled && (udpheader->dest==htons(SERVER_port))))
#else	
 if(udpheader->dest==htons(SERVER_port))
a0001f68:	94440002 	lhu	a0,2(v0)
a0001f6c:	3c03a001 	lui	v1,0xa001
a0001f70:	94637950 	lhu	v1,31056(v1)
a0001f74:	1483009c 	bne	a0,v1,a00021e8 <prepareACK+0x2ac>
a0001f78:	8fbf0024 	lw	ra,36(sp)
   	if (tftp_client_enabled)
		SERVER_port = ntohs(udpheader->src); 
	else
#endif		
          /*memorize CLIENT port*/
          CLIENT_port=  ntohs(udpheader->src); 
a0001f7c:	94440000 	lhu	a0,0(v0)
a0001f80:	3c03a001 	lui	v1,0xa001
a0001f84:	a4647952 	sh	a0,31058(v1)
    tftppacket = (struct tftp_t *)&nic.packet[ETH_HLEN];
a0001f88:	3c03a001 	lui	v1,0xa001
a0001f8c:	8c657948 	lw	a1,31048(v1)
a0001f90:	24a5000e 	addiu	a1,a1,14
    /*no need to check opcode, this is a Data packet*/     
    /*parse the TFTP block number*/	
    block_received=tftppacket->u.data.block;
a0001f94:	94a3001e 	lhu	v1,30(a1)
a0001f98:	a7a30010 	sh	v1,16(sp)
//prom_printf("line=%d:		block_received=%d\n", __LINE__,  block_received); // for debug
    
    if(block_received != (block_expected))
a0001f9c:	97a40010 	lhu	a0,16(sp)
a0001fa0:	3084ffff 	andi	a0,a0,0xffff
a0001fa4:	3c03a001 	lui	v1,0xa001
a0001fa8:	94637944 	lhu	v1,31044(v1)
a0001fac:	3063ffff 	andi	v1,v1,0xffff
a0001fb0:	1083000b 	beq	a0,v1,a0001fe0 <prepareACK+0xa4>
a0001fb4:	3c10a001 	lui	s0,0xa001
    {
     //prom_printf("line=%d: block_received=%d, block_expected=%d\n", __LINE__,  block_received,  block_expected); // for debug
     prom_printf("TFTP #\n");
a0001fb8:	3c04a001 	lui	a0,0xa001
a0001fbc:	0c002325 	jal	a0008c94 <dprintf>
a0001fc0:	248442d8 	addiu	a0,a0,17112
     /*restore the block number*/
     tftpd_send_ack(block_expected-1);    
a0001fc4:	3c02a001 	lui	v0,0xa001
a0001fc8:	94447944 	lhu	a0,31044(v0)
a0001fcc:	2484ffff 	addiu	a0,a0,-1
a0001fd0:	0c0005bd 	jal	a00016f4 <tftpd_send_ack>
a0001fd4:	3084ffff 	andi	a0,a0,0xffff
     }
   }
//else 
//   prom_printf("\n**TFTP port number error");   

}
a0001fd8:	0800087a 	j	a00021e8 <prepareACK+0x2ac>
a0001fdc:	8fbf0024 	lw	ra,36(sp)
     tftpd_send_ack(block_expected-1);    
    }
    else 
     {      
          
      tftpdata_length=ntohs(udpheader->len)-4-sizeof(struct udphdr);
a0001fe0:	94510004 	lhu	s1,4(v0)
a0001fe4:	2631fff4 	addiu	s1,s1,-12
      /*put the image into memory address*/
      memcpy((void *)address_to_store, tftppacket->u.data.download, tftpdata_length);
a0001fe8:	8e047940 	lw	a0,31040(s0)
a0001fec:	24a50020 	addiu	a1,a1,32
a0001ff0:	0c002046 	jal	a0008118 <memcpy>
a0001ff4:	02203021 	move	a2,s1
	//flush_cache_range(address_to_store,tftpdata_length);
	// ddump(address_to_store, tftpdata_length);
      //prom_printf("a %x. l %x\n",address_to_store,tftpdata_length);
      
      address_to_store=address_to_store+tftpdata_length;
a0001ff8:	8e027940 	lw	v0,31040(s0)
a0001ffc:	02221021 	addu	v0,s1,v0
a0002000:	ae027940 	sw	v0,31040(s0)
      /*use this to count the image bytes*/
      file_length_to_server=file_length_to_server+tftpdata_length;
a0002004:	3c02a001 	lui	v0,0xa001
a0002008:	8c437960 	lw	v1,31072(v0)
a000200c:	02231821 	addu	v1,s1,v1
      /*this is for receiving one packet*/
      //prom_printf("%x.\n",address_to_store);
      twiddle();
a0002010:	0c00225d 	jal	a0008974 <twiddle>
a0002014:	ac437960 	sw	v1,31072(v0)
      //prom_printf(" <- ");
      //prom_printf("%x. %x. %x\n",block_expected,address_to_store,tftpdata_length);
      
      tftpd_send_ack(block_expected);               
a0002018:	3c10a001 	lui	s0,0xa001
a000201c:	96047944 	lhu	a0,31044(s0)
a0002020:	0c0005bd 	jal	a00016f4 <tftpd_send_ack>
a0002024:	3084ffff 	andi	a0,a0,0xffff
      block_expected=block_expected+1;
a0002028:	96027944 	lhu	v0,31044(s0)
a000202c:	24420001 	addiu	v0,v0,1
a0002030:	3042ffff 	andi	v0,v0,0xffff
a0002034:	a6027944 	sh	v0,31044(s0)
//prom_printf("line=%d:		block_expected=%d\n", __LINE__,  block_expected); // for debug
      
      /*remember to check if it is the last packet*/      
      if(tftpdata_length < TFTP_DEFAULTSIZE_PACKET)
a0002038:	2e310200 	sltiu	s1,s1,512
a000203c:	1220006a 	beqz	s1,a00021e8 <prepareACK+0x2ac>
a0002040:	8fbf0024 	lw	ra,36(sp)
        {
         prom_printf("\n**TFTP Client Upload File Size = %X Bytes at %X\n",file_length_to_server,image_address);          
a0002044:	3c11a001 	lui	s1,0xa001
a0002048:	3c10a001 	lui	s0,0xa001
a000204c:	3c04a001 	lui	a0,0xa001
a0002050:	248442e0 	addiu	a0,a0,17120
a0002054:	8e257960 	lw	a1,31072(s1)
a0002058:	0c002325 	jal	a0008c94 <dprintf>
a000205c:	8e067218 	lw	a2,29208(s0)
         /*change the boot state back to orignal, and some variables also*/
         nic.packet = eth_packet;
a0002060:	3c02a001 	lui	v0,0xa001
a0002064:	3c03a002 	lui	v1,0xa002
a0002068:	24638c14 	addiu	v1,v1,-29676
a000206c:	ac437948 	sw	v1,31048(v0)
         nic.packetlen = 0;        
a0002070:	24427948 	addiu	v0,v0,31048
a0002074:	ac400004 	sw	zero,4(v0)
         block_expected =0;   
a0002078:	3c02a001 	lui	v0,0xa001
a000207c:	a4407944 	sh	zero,31044(v0)
//prom_printf("line=%d:		block_expected=%d\n", __LINE__,  block_expected); // for debug
				 
         /*reset the file position*/
         //image_address=FILESTART;
         address_to_store=image_address;
a0002080:	8e037218 	lw	v1,29208(s0)
a0002084:	3c02a001 	lui	v0,0xa001
a0002088:	ac437940 	sw	v1,31040(v0)
         file_length_to_client=file_length_to_server;
a000208c:	8e237960 	lw	v1,31072(s1)
a0002090:	3c02a001 	lui	v0,0xa001
a0002094:	ac437958 	sw	v1,31064(v0)
         /*file_length_to_server can not be reset,only when another WRQ */
         /*and export to file_length_to_client for our SDRAM direct RRQ*/
         it_is_EOF=0;
a0002098:	3c02a001 	lui	v0,0xa001
a000209c:	ac407ad0 	sw	zero,31440(v0)
#if defined(SUPPORT_TFTP_CLIENT)
		if(tftp_from_command)
		    tftp_client_recvdone = 1;
#endif
         bootState=BOOT_STATE0_INIT_ARP;
a00020a0:	3c02a001 	lui	v0,0xa001
a00020a4:	ac407954 	sw	zero,31060(v0)
         /*Cyrus Tsai*/
         one_tftp_lock=0; 
a00020a8:	3c02a001 	lui	v0,0xa001
a00020ac:	a0407acc 	sb	zero,31436(v0)
         SERVER_port++;
a00020b0:	3c02a001 	lui	v0,0xa001
a00020b4:	94437950 	lhu	v1,31056(v0)
a00020b8:	24630001 	addiu	v1,v1,1
a00020bc:	a4437950 	sh	v1,31056(v0)
#if defined(SUPPORT_TFTP_CLIENT)
     if(tftp_from_command)
		prom_printf( "\nSuccess!\n");
	 else
#endif
		prom_printf( "\nSuccess!\n%s", "<RealTek>" );
a00020c0:	3c04a001 	lui	a0,0xa001
a00020c4:	24844314 	addiu	a0,a0,17172
a00020c8:	3c05a001 	lui	a1,0xa001
a00020cc:	0c002325 	jal	a0008c94 <dprintf>
a00020d0:	24a540d8 	addiu	a1,a1,16600
		
		jump_to_test = 1;  //wei add
	}
#endif  //CONFIG_NFBI

         if(jump_to_test==1)
a00020d4:	3c02a001 	lui	v0,0xa001
a00020d8:	8c437ac0 	lw	v1,31424(v0)
a00020dc:	24020001 	li	v0,1
a00020e0:	14620038 	bne	v1,v0,a00021c4 <prepareACK+0x288>
a00020e4:	3c02a001 	lui	v0,0xa001
           {
            jump_to_test=0;
a00020e8:	3c02a001 	lui	v0,0xa001
a00020ec:	ac407ac0 	sw	zero,31424(v0)
	    /*we should clear all irq mask.*/
	    //jumpF = (void *)(TESTSTART); //sc_yang
	 REG32(0xb8000010)=REG32(0xb8000010) &(~(1<<11)); //disable switch IRQ
a00020f0:	3c02b800 	lui	v0,0xb800
a00020f4:	34420010 	ori	v0,v0,0x10
a00020f8:	8c440000 	lw	a0,0(v0)
a00020fc:	2403f7ff 	li	v1,-2049
a0002100:	00831824 	and	v1,a0,v1
a0002104:	ac430000 	sw	v1,0(v0)
		image_address &= ~0x20000000;
a0002108:	8e047218 	lw	a0,29208(s0)
a000210c:	3c02dfff 	lui	v0,0xdfff
a0002110:	3442ffff 	ori	v0,v0,0xffff
a0002114:	00821024 	and	v0,a0,v0
a0002118:	ae027218 	sw	v0,29208(s0)
	    jumpF = (void *)(image_address);
a000211c:	3c03a001 	lui	v1,0xa001
a0002120:	ac62795c 	sw	v0,31068(v1)
a0002124:	3c03b800 	lui	v1,0xb800
a0002128:	00001021 	move	v0,zero
a000212c:	ac623000 	sw	v0,12288(v1)
a0002130:	40016000 	mfc0	at,c0_status
a0002134:	34210001 	ori	at,at,0x1
a0002138:	38210001 	xori	at,at,0x1
a000213c:	40816000 	mtc0	at,c0_status
a0002140:	000000c0 	ehb
	...
	    /*we should clear all irq mask.*/
	    
		outl(0,GIMR0); // mask all interrupt	    
	   cli();
		REG32(0xb8003114)=0;  //disable timer interrupt
a0002150:	3c02b800 	lui	v0,0xb800
a0002154:	34433114 	ori	v1,v0,0x3114
a0002158:	ac600000 	sw	zero,0(v1)
		REG32(0xb8000010)&=~(1<<11);
a000215c:	34420010 	ori	v0,v0,0x10
a0002160:	8c440000 	lw	a0,0(v0)
a0002164:	2403f7ff 	li	v1,-2049
a0002168:	00831824 	and	v1,a0,v1
a000216c:	ac430000 	sw	v1,0(v0)
		
		REG32(0xbbdc0300)=0xFFFFFFFF;
a0002170:	3c03bbdc 	lui	v1,0xbbdc
a0002174:	34640300 	ori	a0,v1,0x300
a0002178:	2402ffff 	li	v0,-1
a000217c:	ac820000 	sw	v0,0(a0)
		REG32(0xbbdc0304)=0xFFFFFFFF;
a0002180:	34630304 	ori	v1,v1,0x304
a0002184:	ac620000 	sw	v0,0(v1)
		dprintf("Jump to 0x%x\n", image_address);
a0002188:	3c04a001 	lui	a0,0xa001
a000218c:	24844324 	addiu	a0,a0,17188
a0002190:	3c02a001 	lui	v0,0xa001
a0002194:	0c002325 	jal	a0008c94 <dprintf>
a0002198:	8c457218 	lw	a1,29208(v0)
		flush_cache();
a000219c:	0c001eae 	jal	a0007ab8 <flush_cache>
a00021a0:	00000000 	nop
		invalidate_cache();
a00021a4:	0c001eac 	jal	a0007ab0 <invalidate_cache>
a00021a8:	00000000 	nop
	    jumpF();	
a00021ac:	3c02a001 	lui	v0,0xa001
a00021b0:	8c42795c 	lw	v0,31068(v0)
a00021b4:	0040f809 	jalr	v0
a00021b8:	00000000 	nop
     }
   }
//else 
//   prom_printf("\n**TFTP port number error");   

}
a00021bc:	0800087a 	j	a00021e8 <prepareACK+0x2ac>
a00021c0:	8fbf0024 	lw	ra,36(sp)
		flush_cache();
		invalidate_cache();
	    jumpF();	
           }
#if !(defined( CONFIG_NFBI) || defined(CONFIG_NONE_FLASH))
	   else if(autoBurn)
a00021c4:	8c4272c4 	lw	v0,29380(v0)
a00021c8:	10400007 	beqz	v0,a00021e8 <prepareACK+0x2ac>
a00021cc:	8fbf0024 	lw	ra,36(sp)
	   {
	   	checkAutoFlashing(image_address, file_length_to_server);
a00021d0:	3c02a001 	lui	v0,0xa001
a00021d4:	8c447218 	lw	a0,29208(v0)
a00021d8:	3c02a001 	lui	v0,0xa001
a00021dc:	0c00063e 	jal	a00018f8 <checkAutoFlashing>
a00021e0:	8c457960 	lw	a1,31072(v0)
     }
   }
//else 
//   prom_printf("\n**TFTP port number error");   

}
a00021e4:	8fbf0024 	lw	ra,36(sp)
a00021e8:	8fb10020 	lw	s1,32(sp)
a00021ec:	8fb0001c 	lw	s0,28(sp)
a00021f0:	03e00008 	jr	ra
a00021f4:	27bd0028 	addiu	sp,sp,40
	...

a0002200 <prepare_txpkt>:
}

//----------------------------------------------------------------------------------------
/*Just a start address, and the data length*/
void prepare_txpkt(int etherport, Int16 type, Int8* destaddr, Int8* data, Int16 len) 
{
a0002200:	27bdffd8 	addiu	sp,sp,-40
a0002204:	afbf0024 	sw	ra,36(sp)
a0002208:	afb10020 	sw	s1,32(sp)
a000220c:	afb0001c 	sw	s0,28(sp)
a0002210:	30a5ffff 	andi	a1,a1,0xffff
a0002214:	97b1003a 	lhu	s1,58(sp)
	char *tx_buffer=&ETH0_tx_buf[0][0];
a0002218:	3c10a001 	lui	s0,0xa001
a000221c:	26107aec 	addiu	s0,s0,31468
 	Int16 nstype;	
	int Length=len;
	
	memcpy(tx_buffer,destaddr,6);
a0002220:	88c20000 	lwl	v0,0(a2)
a0002224:	98c20003 	lwr	v0,3(a2)
a0002228:	aa020000 	swl	v0,0(s0)
a000222c:	ba020003 	swr	v0,3(s0)
a0002230:	90c20004 	lbu	v0,4(a2)
a0002234:	a2020004 	sb	v0,4(s0)
a0002238:	90c20005 	lbu	v0,5(a2)
a000223c:	a2020005 	sb	v0,5(s0)

	/*Source Address*/
	memcpy(tx_buffer+6,eth0_mac,6);
a0002240:	26020006 	addiu	v0,s0,6
a0002244:	3c03a001 	lui	v1,0xa001
a0002248:	8c6474f0 	lw	a0,29936(v1)
a000224c:	a8440000 	swl	a0,0(v0)
a0002250:	b8440003 	swr	a0,3(v0)
a0002254:	246374f0 	addiu	v1,v1,29936
a0002258:	90640004 	lbu	a0,4(v1)
a000225c:	a0440004 	sb	a0,4(v0)
a0002260:	90630005 	lbu	v1,5(v1)
a0002264:	a0430005 	sb	v1,5(v0)

	/*Payload type*/
	nstype = htons(type);
a0002268:	a7a50010 	sh	a1,16(sp)
	memcpy(tx_buffer + 12,(Int8*)&nstype,2);
a000226c:	2602000c 	addiu	v0,s0,12
a0002270:	00051a02 	srl	v1,a1,0x8
a0002274:	a0430000 	sb	v1,0(v0)
a0002278:	a0450001 	sb	a1,1(v0)

	/*Payload */
	memcpy(tx_buffer + 14,(Int8*)data,Length);
a000227c:	2604000e 	addiu	a0,s0,14
a0002280:	00e02821 	move	a1,a3
a0002284:	0c002046 	jal	a0008118 <memcpy>
a0002288:	02203021 	move	a2,s1
	Length += 14;

//	printf("tx pkt\n");
	swNic_send(tx_buffer,Length);
a000228c:	02002021 	move	a0,s0
a0002290:	0c000d2c 	jal	a00034b0 <swNic_send>
a0002294:	2625000e 	addiu	a1,s1,14
}
a0002298:	8fbf0024 	lw	ra,36(sp)
a000229c:	8fb10020 	lw	s1,32(sp)
a00022a0:	8fb0001c 	lw	s0,28(sp)
a00022a4:	03e00008 	jr	ra
a00022a8:	27bd0028 	addiu	sp,sp,40

a00022ac <eth_startup>:
}

#endif
//----------------------------------------------------------------------------------------
void eth_startup(int etherport)
{
a00022ac:	27bdff90 	addiu	sp,sp,-112
a00022b0:	afbf006c 	sw	ra,108(sp)
#ifdef CONFIG_HTTP_SERVER
	getmacandip(eth0_mac_httpd,eth0_ip_httpd);
#endif
#endif

	if (swCore_init()) {  	
a00022b4:	0c000adc 	jal	a0002b70 <swCore_init>
a00022b8:	00000000 	nop
a00022bc:	10400006 	beqz	v0,a00022d8 <eth_startup+0x2c>
a00022c0:	24020004 	li	v0,4
		dprintf("\nSwitch core initialization failed!\n");        
a00022c4:	3c04a001 	lui	a0,0xa001
a00022c8:	0c002325 	jal	a0008c94 <dprintf>
a00022cc:	248443c0 	addiu	a0,a0,17344
		return;
a00022d0:	080008ff 	j	a00023fc <eth_startup+0x150>
a00022d4:	8fbf006c 	lw	ra,108(sp)
	}

    	//avoid download bin checksum error
	uint32 rx[6] = {4, 0, 0, 0, 0, 0};
a00022d8:	afa20010 	sw	v0,16(sp)
a00022dc:	afa00014 	sw	zero,20(sp)
a00022e0:	afa00018 	sw	zero,24(sp)
a00022e4:	afa0001c 	sw	zero,28(sp)
a00022e8:	afa00020 	sw	zero,32(sp)
a00022ec:	afa00024 	sw	zero,36(sp)
#if defined(CONFIG_RTL8196D) || defined(CONFIG_RTL8196E)||defined(CONFIG_RTL8881A)
        uint32 tx[4] = {4, 2, 2, 2};
a00022f0:	afa20028 	sw	v0,40(sp)
a00022f4:	24020002 	li	v0,2
a00022f8:	afa2002c 	sw	v0,44(sp)
a00022fc:	afa20030 	sw	v0,48(sp)
a0002300:	afa20034 	sw	v0,52(sp)
#else
        uint32 tx[2] = {4, 2};
#endif

	/* Initialize NIC module */
	if (swNic_init(rx, 4, tx, MBUF_LEN)) {
a0002304:	27a40010 	addiu	a0,sp,16
a0002308:	24050004 	li	a1,4
a000230c:	27a60028 	addiu	a2,sp,40
a0002310:	0c000b85 	jal	a0002e14 <swNic_init>
a0002314:	24070800 	li	a3,2048
a0002318:	10400006 	beqz	v0,a0002334 <eth_startup+0x88>
a000231c:	27a50044 	addiu	a1,sp,68
		dprintf("\nSwitch nic initialization failed!\n");            
a0002320:	3c04a001 	lui	a0,0xa001
a0002324:	0c002325 	jal	a0008c94 <dprintf>
a0002328:	248443e8 	addiu	a0,a0,17384
		return;
a000232c:	080008ff 	j	a00023fc <eth_startup+0x150>
a0002330:	8fbf006c 	lw	ra,108(sp)
	rtl_netif_param_t np;
	rtl_acl_param_t ap;

	/* Create Netif */
#if !(defined(CONFIG_RTL_LAN_WAN_ISOLATION) || defined(CONFIG_RTL_ALL_PORT_ISOLATION))
	bzero((void *) &np, sizeof(rtl_netif_param_t));
a0002334:	aca00004 	sw	zero,4(a1)
	np.vid = 8;
a0002338:	24020008 	li	v0,8
a000233c:	a7a2004e 	sh	v0,78(sp)
	np.valid = 1;
a0002340:	24020001 	li	v0,1
	np.enableRoute = 0;
a0002344:	00021f80 	sll	v1,v0,0x1e
a0002348:	7c03ffc4 	ins	v1,zero,0x1f,0x1
a000234c:	afa30064 	sw	v1,100(sp)
	np.inAclEnd = 0;
a0002350:	afa00054 	sw	zero,84(sp)
	np.inAclStart = 0;
a0002354:	afa00050 	sw	zero,80(sp)
	np.outAclEnd = 0;
a0002358:	afa0005c 	sw	zero,92(sp)
	np.outAclStart = 0;
a000235c:	afa00058 	sw	zero,88(sp)
	memcpy(&np.gMac, &eth0_mac[0], 6);
a0002360:	3c03a001 	lui	v1,0xa001
a0002364:	8c6474f0 	lw	a0,29936(v1)
a0002368:	aca40000 	sw	a0,0(a1)
a000236c:	246374f0 	addiu	v1,v1,29936
a0002370:	94630004 	lhu	v1,4(v1)
a0002374:	a4a30004 	sh	v1,4(a1)

	np.macAddrNumber = 1;
a0002378:	a7a2004c 	sh	v0,76(sp)
	np.mtu = 1500;
a000237c:	240205dc 	li	v0,1500
a0002380:	afa20060 	sw	v0,96(sp)
	ret = swCore_netifCreate(0, &np);
a0002384:	0c000eef 	jal	a0003bbc <swCore_netifCreate>
a0002388:	00002021 	move	a0,zero
	if (ret != 0) {
a000238c:	10400007 	beqz	v0,a00023ac <eth_startup+0x100>
a0002390:	27a50038 	addiu	a1,sp,56
		printf( "Creating intif fails:%d\n", ret );
a0002394:	3c04a001 	lui	a0,0xa001
a0002398:	2484440c 	addiu	a0,a0,17420
a000239c:	0c002325 	jal	a0008c94 <dprintf>
a00023a0:	00402821 	move	a1,v0
		return;
a00023a4:	080008ff 	j	a00023fc <eth_startup+0x150>
a00023a8:	8fbf006c 	lw	ra,108(sp)
	}

	/* Create vlan */
	bzero((void *) &vp, sizeof(rtl_vlan_param_t));
a00023ac:	aca00008 	sw	zero,8(a1)
	vp.egressUntag = ALL_PORT_MASK;
a00023b0:	2402003f 	li	v0,63
a00023b4:	afa2003c 	sw	v0,60(sp)
	vp.memberPort = ALL_PORT_MASK;
a00023b8:	afa20038 	sw	v0,56(sp)
	ret = swCore_vlanCreate(8, &vp);
a00023bc:	0c000eb2 	jal	a0003ac8 <vlanTable_create>
a00023c0:	24040008 	li	a0,8
	if (ret != 0) {       
a00023c4:	10400007 	beqz	v0,a00023e4 <eth_startup+0x138>
a00023c8:	24040019 	li	a0,25
		printf( "Creating vlan fails:%d\n", ret );
a00023cc:	3c04a001 	lui	a0,0xa001
a00023d0:	24844428 	addiu	a0,a0,17448
a00023d4:	0c002325 	jal	a0008c94 <dprintf>
a00023d8:	00402821 	move	a1,v0
       return;
a00023dc:	080008ff 	j	a00023fc <eth_startup+0x150>
a00023e0:	8fbf006c 	lw	ra,108(sp)
    /* Set interrupt routing register */

#if !defined(CONFIG_RTL8198C)
	REG32(IRR1_REG) |= (3<<28); 
#endif	
 	request_IRQ(ETH0_IRQ, &irq_eth15,&(ETH[0]));
a00023e4:	3c05a001 	lui	a1,0xa001
a00023e8:	24a574f8 	addiu	a1,a1,29944
a00023ec:	3c06a002 	lui	a2,0xa002
a00023f0:	0c000274 	jal	a00009d0 <request_IRQ>
a00023f4:	24c6876c 	addiu	a2,a2,-30868
}
a00023f8:	8fbf006c 	lw	ra,108(sp)
a00023fc:	03e00008 	jr	ra
a0002400:	27bd0070 	addiu	sp,sp,112

a0002404 <eth_interrupt>:
static struct eth_private ETH[2];
static struct irqaction irq_eth15 = {eth_interrupt, 0, 15,"eth0", NULL, NULL};  
//--------------------------------------------------------------------------------------------

void eth_interrupt(int irq, void *dev_id, struct pt_regs *regs)
{
a0002404:	27bdffe0 	addiu	sp,sp,-32
a0002408:	afbf001c 	sw	ra,28(sp)
a000240c:	afb10018 	sw	s1,24(sp)
a0002410:	afb00014 	sw	s0,20(sp)
#ifdef CONFIG_NIC_LOOPBACK
	int i=0;
#endif
	int status=*(volatile Int32*)(0xb801002c);
a0002414:	3c02b801 	lui	v0,0xb801
a0002418:	3442002c 	ori	v0,v0,0x2c
a000241c:	8c430000 	lw	v1,0(v0)
	*(volatile Int32*)(0xb801002c)=status;
a0002420:	ac430000 	sw	v1,0(v0)
  	if (swNic_receive((void **)&nic.packet, &nic.packetlen)== 0) 
 		kick_tftpd();  	
*/
//		printf("rx intterupt...\n");

	nic.packetlen=0;
a0002424:	3c02a001 	lui	v0,0xa001
a0002428:	ac40794c 	sw	zero,31052(v0)
	while(swNic_receive((void **)&nic.packet, &nic.packetlen)== 0) 
a000242c:	3c10a001 	lui	s0,0xa001
a0002430:	26107948 	addiu	s0,s0,31048
a0002434:	08000914 	j	a0002450 <eth_interrupt+0x4c>
a0002438:	2451794c 	addiu	s1,v0,31052
				swNic_txDone();
		}
		else 
#endif		
		{
			swNic_txDone();
a000243c:	0c000b6a 	jal	a0002da8 <swNic_txDone>
a0002440:	00000000 	nop
			kick_tftpd();  	
a0002444:	0c0003c1 	jal	a0000f04 <kick_tftpd>
a0002448:	00000000 	nop
			nic.packetlen=0;
a000244c:	ae000004 	sw	zero,4(s0)
 		kick_tftpd();  	
*/
//		printf("rx intterupt...\n");

	nic.packetlen=0;
	while(swNic_receive((void **)&nic.packet, &nic.packetlen)== 0) 
a0002450:	02002021 	move	a0,s0
a0002454:	0c000d8b 	jal	a000362c <swNic_receive>
a0002458:	02202821 	move	a1,s1
a000245c:	1040fff7 	beqz	v0,a000243c <eth_interrupt+0x38>
a0002460:	00000000 	nop
			kick_tftpd();  	
			nic.packetlen=0;
		}
	}

	swNic_txDone();
a0002464:	0c000b6a 	jal	a0002da8 <swNic_txDone>
a0002468:	00000000 	nop
}
a000246c:	8fbf001c 	lw	ra,28(sp)
a0002470:	8fb10018 	lw	s1,24(sp)
a0002474:	8fb00014 	lw	s0,20(sp)
a0002478:	03e00008 	jr	ra
a000247c:	27bd0020 	addiu	sp,sp,32

a0002480 <rtl8651_filterDbIndex>:
	#endif

	return SUCCESS;
}

uint32 rtl8651_filterDbIndex(ether_addr_t * macAddr,uint16 fid) {
a0002480:	30a5ffff 	andi	a1,a1,0xffff
a0002484:	90830001 	lbu	v1,1(a0)
a0002488:	90820000 	lbu	v0,0(a0)
a000248c:	00621026 	xor	v0,v1,v0
a0002490:	90830002 	lbu	v1,2(a0)
a0002494:	00431026 	xor	v0,v0,v1
a0002498:	90830003 	lbu	v1,3(a0)
a000249c:	00431026 	xor	v0,v0,v1
a00024a0:	90830004 	lbu	v1,4(a0)
a00024a4:	00431026 	xor	v0,v0,v1
a00024a8:	90830005 	lbu	v1,5(a0)
a00024ac:	3c04a001 	lui	a0,0xa001
a00024b0:	2484fff0 	addiu	a0,a0,-16
a00024b4:	00a42821 	addu	a1,a1,a0
a00024b8:	00431026 	xor	v0,v0,v1
a00024bc:	90a30000 	lbu	v1,0(a1)
a00024c0:	00431026 	xor	v0,v0,v1
    return ( macAddr->octet[0] ^ macAddr->octet[1] ^
                    macAddr->octet[2] ^ macAddr->octet[3] ^
                    macAddr->octet[4] ^ macAddr->octet[5] ^fidHashTable[fid]) & 0xFF;
}
a00024c4:	03e00008 	jr	ra
a00024c8:	304200ff 	andi	v0,v0,0xff

a00024cc <rtl8651_getAsicEthernetPHYReg>:

int32 rtl8651_getAsicEthernetPHYReg(uint32 phyId, uint32 regId, uint32 *rData)
{
	uint32 status;
	
	WRITE_MEM32( MDCIOCR, COMMAND_READ | ( phyId << PHYADD_OFFSET ) | ( regId << REGADD_OFFSET ) );
a00024cc:	00052c00 	sll	a1,a1,0x10
a00024d0:	00042600 	sll	a0,a0,0x18
a00024d4:	00a42825 	or	a1,a1,a0
a00024d8:	3c02bb80 	lui	v0,0xbb80
a00024dc:	34424004 	ori	v0,v0,0x4004
a00024e0:	ac450000 	sw	a1,0(v0)
#else
#if defined(CONFIG_RTL8198) && !defined(CONFIG_RTL8198C)
	REG32(GIMR_REG) = REG32(GIMR_REG) | (0x1<<8);    //add by jiawenjian
	delay_ms(10);   //wei add, for 8196C_test chip patch. mdio data read will delay 1 mdc clock.
#endif
	do { status = READ_MEM32( MDCIOSR ); } while ( ( status & STATUS ) != 0 );
a00024e4:	3c03bb80 	lui	v1,0xbb80
a00024e8:	34634008 	ori	v1,v1,0x4008
a00024ec:	8c620000 	lw	v0,0(v1)
a00024f0:	0440fffe 	bltz	v0,a00024ec <rtl8651_getAsicEthernetPHYReg+0x20>
a00024f4:	3042ffff 	andi	v0,v0,0xffff
#endif

	status &= 0xffff;
	*rData = status;
a00024f8:	acc20000 	sw	v0,0(a2)

	return SUCCESS;
}
a00024fc:	03e00008 	jr	ra
a0002500:	00001021 	move	v0,zero

a0002504 <rtl8651_setAsicEthernetPHYReg>:
    //dprintf("\nSet enable_10M_power_saving01!\n");
    rtl8651_getAsicEthernetPHYReg( phyid, regnum, &tmp );*/

int32 rtl8651_setAsicEthernetPHYReg(uint32 phyId, uint32 regId, uint32 wData)
{
	WRITE_MEM32( MDCIOCR, COMMAND_WRITE | ( phyId << PHYADD_OFFSET ) | ( regId << REGADD_OFFSET ) | wData );
a0002504:	00042600 	sll	a0,a0,0x18
a0002508:	3c028000 	lui	v0,0x8000
a000250c:	00822025 	or	a0,a0,v0
a0002510:	00052c00 	sll	a1,a1,0x10
a0002514:	00852025 	or	a0,a0,a1
a0002518:	00862025 	or	a0,a0,a2
a000251c:	3c02bb80 	lui	v0,0xbb80
a0002520:	34424004 	ori	v0,v0,0x4004
a0002524:	ac440000 	sw	a0,0(v0)

#ifdef RTL865X_TEST
#else
	while( ( READ_MEM32( MDCIOSR ) & STATUS ) != 0 );		/* wait until command complete */
a0002528:	3c03bb80 	lui	v1,0xbb80
a000252c:	34634008 	ori	v1,v1,0x4008
a0002530:	8c620000 	lw	v0,0(v1)
a0002534:	0440fffe 	bltz	v0,a0002530 <rtl8651_setAsicEthernetPHYReg+0x2c>
a0002538:	00001021 	move	v0,zero
#endif

	return SUCCESS;
}
a000253c:	03e00008 	jr	ra
a0002540:	00000000 	nop

a0002544 <rtl8651_restartAsicEthernetPHYNway>:

int32 rtl8651_restartAsicEthernetPHYNway(uint32 port, uint32 phyid)
{
a0002544:	27bdffe0 	addiu	sp,sp,-32
a0002548:	afbf001c 	sw	ra,28(sp)
a000254c:	afb00018 	sw	s0,24(sp)
a0002550:	00a08021 	move	s0,a1
	uint32 statCtrlReg0;

	/* read current PHY reg 0 */
	rtl8651_getAsicEthernetPHYReg( phyid, 0, &statCtrlReg0 );
a0002554:	00a02021 	move	a0,a1
a0002558:	00002821 	move	a1,zero
a000255c:	0c000933 	jal	a00024cc <rtl8651_getAsicEthernetPHYReg>
a0002560:	27a60010 	addiu	a2,sp,16

	/* enable 'restart Nway' bit */
	statCtrlReg0 |= RESTART_AUTONEGO;
a0002564:	8fa60010 	lw	a2,16(sp)
a0002568:	34c60200 	ori	a2,a2,0x200
a000256c:	afa60010 	sw	a2,16(sp)

	/* write PHY reg 0 */
	rtl8651_setAsicEthernetPHYReg( phyid, 0, statCtrlReg0 );
a0002570:	02002021 	move	a0,s0
a0002574:	0c000941 	jal	a0002504 <rtl8651_setAsicEthernetPHYReg>
a0002578:	00002821 	move	a1,zero

	return SUCCESS;
}
a000257c:	00001021 	move	v0,zero
a0002580:	8fbf001c 	lw	ra,28(sp)
a0002584:	8fb00018 	lw	s0,24(sp)
a0002588:	03e00008 	jr	ra
a000258c:	27bd0020 	addiu	sp,sp,32

a0002590 <rtl8651_setAsicFlowControlRegister>:
	return SUCCESS;
}
#endif

int32 rtl8651_setAsicFlowControlRegister(uint32 port, uint32 enable, uint32 phyid)
{
a0002590:	27bdffd8 	addiu	sp,sp,-40
a0002594:	afbf0024 	sw	ra,36(sp)
a0002598:	afb20020 	sw	s2,32(sp)
a000259c:	afb1001c 	sw	s1,28(sp)
a00025a0:	afb00018 	sw	s0,24(sp)
a00025a4:	00808021 	move	s0,a0
a00025a8:	00a09021 	move	s2,a1
a00025ac:	00c08821 	move	s1,a2
	uint32 statCtrlReg4;

	/* Read */
	rtl8651_getAsicEthernetPHYReg( phyid, 4, &statCtrlReg4 );
a00025b0:	00c02021 	move	a0,a2
a00025b4:	24050004 	li	a1,4
a00025b8:	0c000933 	jal	a00024cc <rtl8651_getAsicEthernetPHYReg>
a00025bc:	27a60010 	addiu	a2,sp,16

	if ( enable && ( statCtrlReg4 & CAPABLE_PAUSE ) == 0 )
a00025c0:	12400006 	beqz	s2,a00025dc <rtl8651_setAsicFlowControlRegister+0x4c>
a00025c4:	8fa20010 	lw	v0,16(sp)
a00025c8:	30430400 	andi	v1,v0,0x400
a00025cc:	1460000f 	bnez	v1,a000260c <rtl8651_setAsicFlowControlRegister+0x7c>
a00025d0:	34420400 	ori	v0,v0,0x400
a00025d4:	0800097c 	j	a00025f0 <rtl8651_setAsicFlowControlRegister+0x60>
a00025d8:	afa20010 	sw	v0,16(sp)
	{
		statCtrlReg4 |= CAPABLE_PAUSE;		
	}
	else if ( enable == 0 && ( statCtrlReg4 & CAPABLE_PAUSE ) )
a00025dc:	30430400 	andi	v1,v0,0x400
a00025e0:	1060000a 	beqz	v1,a000260c <rtl8651_setAsicFlowControlRegister+0x7c>
a00025e4:	2403fbff 	li	v1,-1025
	{
		statCtrlReg4 &= ~CAPABLE_PAUSE;
a00025e8:	00431024 	and	v0,v0,v1
a00025ec:	afa20010 	sw	v0,16(sp)
	}
	else
		return SUCCESS;	/* The configuration does not change. Do nothing. */

	rtl8651_setAsicEthernetPHYReg( phyid, 4, statCtrlReg4 );
a00025f0:	02202021 	move	a0,s1
a00025f4:	24050004 	li	a1,4
a00025f8:	0c000941 	jal	a0002504 <rtl8651_setAsicEthernetPHYReg>
a00025fc:	8fa60010 	lw	a2,16(sp)
	
	/* restart N-way. */
	rtl8651_restartAsicEthernetPHYNway(port, phyid);
a0002600:	02002021 	move	a0,s0
a0002604:	0c000951 	jal	a0002544 <rtl8651_restartAsicEthernetPHYNway>
a0002608:	02202821 	move	a1,s1

	return SUCCESS;
}
a000260c:	00001021 	move	v0,zero
a0002610:	8fbf0024 	lw	ra,36(sp)
a0002614:	8fb20020 	lw	s2,32(sp)
a0002618:	8fb1001c 	lw	s1,28(sp)
a000261c:	8fb00018 	lw	s0,24(sp)
a0002620:	03e00008 	jr	ra
a0002624:	27bd0028 	addiu	sp,sp,40

a0002628 <Set_GPHYWB>:

//====================================================================

#if defined(CONFIG_RTL8196D) || defined(CONFIG_RTL8196E) || defined(CONFIG_RTL8198C)
void Set_GPHYWB(unsigned int phyid, unsigned int page, unsigned int reg, unsigned int mask, unsigned int val)
{
a0002628:	27bdffc8 	addiu	sp,sp,-56
a000262c:	afbf0034 	sw	ra,52(sp)
a0002630:	afb60030 	sw	s6,48(sp)
a0002634:	afb5002c 	sw	s5,44(sp)
a0002638:	afb40028 	sw	s4,40(sp)
a000263c:	afb30024 	sw	s3,36(sp)
a0002640:	afb20020 	sw	s2,32(sp)
a0002644:	afb1001c 	sw	s1,28(sp)
a0002648:	afb00018 	sw	s0,24(sp)
a000264c:	00a0a021 	move	s4,a1
a0002650:	00c09021 	move	s2,a2
a0002654:	00e08821 	move	s1,a3
a0002658:	8fb50048 	lw	s5,72(sp)

	unsigned int data=0;
	unsigned int wphyid=0;	//start
	unsigned int wphyid_end=1;   //end
	if(phyid==999)
a000265c:	240203e7 	li	v0,999
a0002660:	14820004 	bne	a0,v0,a0002674 <Set_GPHYWB+0x4c>
a0002664:	afa00010 	sw	zero,16(sp)
a0002668:	24130005 	li	s3,5
a000266c:	080009a1 	j	a0002684 <Set_GPHYWB+0x5c>
a0002670:	00008021 	move	s0,zero
	{	wphyid=0;
		wphyid_end=5;    //total phyid=0~4
	}
	else
	{	wphyid=phyid;
		wphyid_end=phyid+1;
a0002674:	24930001 	addiu	s3,a0,1
	}

	for(; wphyid<wphyid_end; wphyid++)
a0002678:	0093102b 	sltu	v0,a0,s3
a000267c:	10400017 	beqz	v0,a00026dc <Set_GPHYWB+0xb4>
a0002680:	00808021 	move	s0,a0
		//change page 
			rtl8651_setAsicEthernetPHYReg( wphyid, 31, page  );
		
		if(mask!=0)
		{
			rtl8651_getAsicEthernetPHYReg( wphyid, reg, &data);
a0002684:	27b60010 	addiu	s6,sp,16
	}

	for(; wphyid<wphyid_end; wphyid++)
	{
		//change page 
			rtl8651_setAsicEthernetPHYReg( wphyid, 31, page  );
a0002688:	02002021 	move	a0,s0
a000268c:	2405001f 	li	a1,31
a0002690:	0c000941 	jal	a0002504 <rtl8651_setAsicEthernetPHYReg>
a0002694:	02803021 	move	a2,s4
		
		if(mask!=0)
a0002698:	12200008 	beqz	s1,a00026bc <Set_GPHYWB+0x94>
a000269c:	02002021 	move	a0,s0
		{
			rtl8651_getAsicEthernetPHYReg( wphyid, reg, &data);
a00026a0:	02402821 	move	a1,s2
a00026a4:	0c000933 	jal	a00024cc <rtl8651_getAsicEthernetPHYReg>
a00026a8:	02c03021 	move	a2,s6
			data=data&mask;
a00026ac:	8fa20010 	lw	v0,16(sp)
a00026b0:	00511024 	and	v0,v0,s1
a00026b4:	afa20010 	sw	v0,16(sp)
		}
		rtl8651_setAsicEthernetPHYReg( wphyid, reg, data|val  );
a00026b8:	02002021 	move	a0,s0
a00026bc:	02402821 	move	a1,s2
a00026c0:	8fa60010 	lw	a2,16(sp)
a00026c4:	0c000941 	jal	a0002504 <rtl8651_setAsicEthernetPHYReg>
a00026c8:	02a63025 	or	a2,s5,a2
	else
	{	wphyid=phyid;
		wphyid_end=phyid+1;
	}

	for(; wphyid<wphyid_end; wphyid++)
a00026cc:	26100001 	addiu	s0,s0,1
a00026d0:	0213102b 	sltu	v0,s0,s3
a00026d4:	1440ffed 	bnez	v0,a000268c <Set_GPHYWB+0x64>
a00026d8:	02002021 	move	a0,s0
			rtl8651_setAsicEthernetPHYReg( wphyid, 31, 0  );
		}
		*/
#endif		
	}
}
a00026dc:	8fbf0034 	lw	ra,52(sp)
a00026e0:	8fb60030 	lw	s6,48(sp)
a00026e4:	8fb5002c 	lw	s5,44(sp)
a00026e8:	8fb40028 	lw	s4,40(sp)
a00026ec:	8fb30024 	lw	s3,36(sp)
a00026f0:	8fb20020 	lw	s2,32(sp)
a00026f4:	8fb1001c 	lw	s1,28(sp)
a00026f8:	8fb00018 	lw	s0,24(sp)
a00026fc:	03e00008 	jr	ra
a0002700:	27bd0038 	addiu	sp,sp,56

a0002704 <Get_P0_RxDelay>:
	#define RANG3  7
	#define RANG4 0xf	
	
	#define SYS_HW_STRAP   (0xb8000000 +0x08)
	
	unsigned int v=REG32(SYS_HW_STRAP);
a0002704:	3c02b800 	lui	v0,0xb800
a0002708:	34420008 	ori	v0,v0,0x8
a000270c:	8c420000 	lw	v0,0(v0)
	unsigned int val=GET_BITVAL(v, 26, RANG3);
	return val;

}
a0002710:	03e00008 	jr	ra
a0002714:	7c421680 	ext	v0,v0,0x1a,0x3

a0002718 <Get_P0_TxDelay>:
	#define RANG3  7
	#define RANG4 0xf	
	
	#define SYS_HW_STRAP   (0xb8000000 +0x08)
	
	unsigned int v=REG32(SYS_HW_STRAP);
a0002718:	3c02b800 	lui	v0,0xb800
a000271c:	34420008 	ori	v0,v0,0x8
a0002720:	8c420000 	lw	v0,0(v0)
	unsigned int val=GET_BITVAL(v, 29, RANG1);
	return val;

}
a0002724:	03e00008 	jr	ra
a0002728:	7c420740 	ext	v0,v0,0x1d,0x1

a000272c <set_phy_pwr_save>:



#define BIT(x)     (1 << (x))
void set_phy_pwr_save(int val)
{
a000272c:	27bdffc8 	addiu	sp,sp,-56
a0002730:	afbf0034 	sw	ra,52(sp)
a0002734:	afb60030 	sw	s6,48(sp)
a0002738:	afb5002c 	sw	s5,44(sp)
a000273c:	afb40028 	sw	s4,40(sp)
a0002740:	afb30024 	sw	s3,36(sp)
a0002744:	afb20020 	sw	s2,32(sp)
a0002748:	afb1001c 	sw	s1,28(sp)
a000274c:	afb00018 	sw	s0,24(sp)
a0002750:	00809021 	move	s2,a0
a0002754:	00008021 	move	s0,zero
	int i;
	uint32 reg_val;
	
	for(i=0; i<5; i++)
	{
		rtl8651_getAsicEthernetPHYReg( i, 24, &reg_val);
a0002758:	27b50010 	addiu	s5,sp,16

		if (val == 1)
a000275c:	24130001 	li	s3,1
			rtl8651_setAsicEthernetPHYReg( i, 24, (reg_val | BIT(15)) );
		else 
			rtl8651_setAsicEthernetPHYReg( i, 24, (reg_val & (~BIT(15))) );
a0002760:	3c16ffff 	lui	s6,0xffff
a0002764:	36d67fff 	ori	s6,s6,0x7fff
void set_phy_pwr_save(int val)
{
	int i;
	uint32 reg_val;
	
	for(i=0; i<5; i++)
a0002768:	24140005 	li	s4,5
	{
		rtl8651_getAsicEthernetPHYReg( i, 24, &reg_val);
a000276c:	02002021 	move	a0,s0
a0002770:	24050018 	li	a1,24
a0002774:	0c000933 	jal	a00024cc <rtl8651_getAsicEthernetPHYReg>
a0002778:	02a03021 	move	a2,s5

		if (val == 1)
a000277c:	16530007 	bne	s2,s3,a000279c <set_phy_pwr_save+0x70>
a0002780:	02002021 	move	a0,s0
			rtl8651_setAsicEthernetPHYReg( i, 24, (reg_val | BIT(15)) );
a0002784:	24050018 	li	a1,24
a0002788:	8fa60010 	lw	a2,16(sp)
a000278c:	0c000941 	jal	a0002504 <rtl8651_setAsicEthernetPHYReg>
a0002790:	34c68000 	ori	a2,a2,0x8000
void set_phy_pwr_save(int val)
{
	int i;
	uint32 reg_val;
	
	for(i=0; i<5; i++)
a0002794:	080009ec 	j	a00027b0 <set_phy_pwr_save+0x84>
a0002798:	26100001 	addiu	s0,s0,1
		rtl8651_getAsicEthernetPHYReg( i, 24, &reg_val);

		if (val == 1)
			rtl8651_setAsicEthernetPHYReg( i, 24, (reg_val | BIT(15)) );
		else 
			rtl8651_setAsicEthernetPHYReg( i, 24, (reg_val & (~BIT(15))) );
a000279c:	24050018 	li	a1,24
a00027a0:	8fa60010 	lw	a2,16(sp)
a00027a4:	0c000941 	jal	a0002504 <rtl8651_setAsicEthernetPHYReg>
a00027a8:	00d63024 	and	a2,a2,s6
void set_phy_pwr_save(int val)
{
	int i;
	uint32 reg_val;
	
	for(i=0; i<5; i++)
a00027ac:	26100001 	addiu	s0,s0,1
a00027b0:	1614ffef 	bne	s0,s4,a0002770 <set_phy_pwr_save+0x44>
a00027b4:	02002021 	move	a0,s0
		else 
			rtl8651_setAsicEthernetPHYReg( i, 24, (reg_val & (~BIT(15))) );
		
//		rtl8651_restartAsicEthernetPHYNway(i+1, i);							
			}
}
a00027b8:	8fbf0034 	lw	ra,52(sp)
a00027bc:	8fb60030 	lw	s6,48(sp)
a00027c0:	8fb5002c 	lw	s5,44(sp)
a00027c4:	8fb40028 	lw	s4,40(sp)
a00027c8:	8fb30024 	lw	s3,36(sp)
a00027cc:	8fb20020 	lw	s2,32(sp)
a00027d0:	8fb1001c 	lw	s1,28(sp)
a00027d4:	8fb00018 	lw	s0,24(sp)
a00027d8:	03e00008 	jr	ra
a00027dc:	27bd0038 	addiu	sp,sp,56

a00027e0 <_rtl8651_clearSpecifiedAsicTable>:
#endif
#endif

//------------------------------------------------------------------------
static void _rtl8651_clearSpecifiedAsicTable(uint32 type, uint32 count) 
{
a00027e0:	27bdffb8 	addiu	sp,sp,-72
a00027e4:	afbf0044 	sw	ra,68(sp)
a00027e8:	afb30040 	sw	s3,64(sp)
a00027ec:	afb2003c 	sw	s2,60(sp)
a00027f0:	afb10038 	sw	s1,56(sp)
a00027f4:	afb00034 	sw	s0,52(sp)
a00027f8:	00809821 	move	s3,a0
a00027fc:	00a09021 	move	s2,a1
	struct { uint32 _content[8]; } entry;
	uint32 idx;
	
	bzero(&entry, sizeof(entry));
a0002800:	afa00010 	sw	zero,16(sp)
a0002804:	afa00014 	sw	zero,20(sp)
a0002808:	afa00018 	sw	zero,24(sp)
a000280c:	afa0001c 	sw	zero,28(sp)
a0002810:	afa00020 	sw	zero,32(sp)
a0002814:	afa00024 	sw	zero,36(sp)
a0002818:	afa00028 	sw	zero,40(sp)
	for (idx=0; idx<count; idx++)// Write into hardware
a000281c:	10a0000b 	beqz	a1,a000284c <_rtl8651_clearSpecifiedAsicTable+0x6c>
a0002820:	afa0002c 	sw	zero,44(sp)
a0002824:	00008021 	move	s0,zero
		swTable_addEntry(type, idx, &entry);
a0002828:	27b10010 	addiu	s1,sp,16
a000282c:	02602021 	move	a0,s3
a0002830:	02002821 	move	a1,s0
a0002834:	0c000e4a 	jal	a0003928 <swTable_addEntry>
a0002838:	02203021 	move	a2,s1
{
	struct { uint32 _content[8]; } entry;
	uint32 idx;
	
	bzero(&entry, sizeof(entry));
	for (idx=0; idx<count; idx++)// Write into hardware
a000283c:	26100001 	addiu	s0,s0,1
a0002840:	0212102b 	sltu	v0,s0,s2
a0002844:	1440fffa 	bnez	v0,a0002830 <_rtl8651_clearSpecifiedAsicTable+0x50>
a0002848:	02602021 	move	a0,s3
		swTable_addEntry(type, idx, &entry);
}
a000284c:	8fbf0044 	lw	ra,68(sp)
a0002850:	8fb30040 	lw	s3,64(sp)
a0002854:	8fb2003c 	lw	s2,60(sp)
a0002858:	8fb10038 	lw	s1,56(sp)
a000285c:	8fb00034 	lw	s0,52(sp)
a0002860:	03e00008 	jr	ra
a0002864:	27bd0048 	addiu	sp,sp,72

a0002868 <rtl8651_setAsicL2Table>:
                    macAddr->octet[2] ^ macAddr->octet[3] ^
                    macAddr->octet[4] ^ macAddr->octet[5] ^fidHashTable[fid]) & 0xFF;
}

static int32 rtl8651_setAsicL2Table(ether_addr_t	*mac, uint32 column)
{
a0002868:	27bdffc0 	addiu	sp,sp,-64
a000286c:	afbf003c 	sw	ra,60(sp)
a0002870:	afb20038 	sw	s2,56(sp)
a0002874:	afb10034 	sw	s1,52(sp)
a0002878:	afb00030 	sw	s0,48(sp)
a000287c:	00809021 	move	s2,a0
a0002880:	00a08821 	move	s1,a1
	rtl865xc_tblAsic_l2Table_t entry;
	uint32	row;

	row = rtl8651_filterDbIndex(mac, 0);
a0002884:	0c000920 	jal	a0002480 <rtl8651_filterDbIndex>
a0002888:	00002821 	move	a1,zero
a000288c:	00408021 	move	s0,v0
	if((row >= RTL8651_L2TBL_ROW) || (column >= RTL8651_L2TBL_COLUMN))
a0002890:	2c420100 	sltiu	v0,v0,256
a0002894:	1040005c 	beqz	v0,a0002a08 <rtl8651_setAsicL2Table+0x1a0>
a0002898:	2402ffff 	li	v0,-1
a000289c:	2e220004 	sltiu	v0,s1,4
a00028a0:	10400059 	beqz	v0,a0002a08 <rtl8651_setAsicL2Table+0x1a0>
a00028a4:	2402ffff 	li	v0,-1
		return FAILED;
	if(mac->octet[5] != ((row^(fidHashTable[0])^ mac->octet[0] ^ mac->octet[1] ^ mac->octet[2] ^ mac->octet[3] ^ mac->octet[4] ) & 0xff))
a00028a8:	92430005 	lbu	v1,5(s2)
a00028ac:	92440001 	lbu	a0,1(s2)
a00028b0:	92420000 	lbu	v0,0(s2)
a00028b4:	00822026 	xor	a0,a0,v0
a00028b8:	92420002 	lbu	v0,2(s2)
a00028bc:	00822026 	xor	a0,a0,v0
a00028c0:	92420003 	lbu	v0,3(s2)
a00028c4:	00822026 	xor	a0,a0,v0
a00028c8:	92420004 	lbu	v0,4(s2)
a00028cc:	00821026 	xor	v0,a0,v0
a00028d0:	00501026 	xor	v0,v0,s0
a00028d4:	304200ff 	andi	v0,v0,0xff
a00028d8:	1462004b 	bne	v1,v0,a0002a08 <rtl8651_setAsicL2Table+0x1a0>
a00028dc:	2402ffff 	li	v0,-1
		return FAILED;

	memset(&entry, 0,sizeof(entry));
a00028e0:	27a40010 	addiu	a0,sp,16
a00028e4:	00002821 	move	a1,zero
a00028e8:	0c00203d 	jal	a00080f4 <memset>
a00028ec:	24060020 	li	a2,32
	entry.mac47_40 = mac->octet[0];
a00028f0:	92420000 	lbu	v0,0(s2)
a00028f4:	a3a20017 	sb	v0,23(sp)
	entry.mac39_24 = (mac->octet[1] << 8) | mac->octet[2];
a00028f8:	92420001 	lbu	v0,1(s2)
a00028fc:	92430002 	lbu	v1,2(s2)
a0002900:	00021200 	sll	v0,v0,0x8
a0002904:	00431025 	or	v0,v0,v1
a0002908:	a7a20010 	sh	v0,16(sp)
	entry.mac23_8 = (mac->octet[3] << 8) | mac->octet[4];
a000290c:	92460003 	lbu	a2,3(s2)
a0002910:	92450004 	lbu	a1,4(s2)
static int32 _rtl8651_forceAddAsicEntry(uint32 tableType, uint32 eidx, void *entryContent_P) {

	#ifdef RTL865XC_ASIC_WRITE_PROTECTION
	if (RTL865X_TLU_BUG_FIXED)	/* No need to stop HW table lookup process */
	{	/* No need to stop HW table lookup process */
		WRITE_MEM32(SWTCR0,EN_STOP_TLU|READ_MEM32(SWTCR0));
a0002914:	3c02bb80 	lui	v0,0xbb80
a0002918:	34424418 	ori	v0,v0,0x4418
a000291c:	8c440000 	lw	a0,0(v0)
a0002920:	3c030004 	lui	v1,0x4
a0002924:	00831825 	or	v1,a0,v1
a0002928:	ac430000 	sw	v1,0(v0)
		while ( (READ_MEM32(SWTCR0) & STOP_TLU_READY)==0);
a000292c:	00402021 	move	a0,v0
a0002930:	3c030008 	lui	v1,0x8
a0002934:	8c820000 	lw	v0,0(a0)
a0002938:	00431024 	and	v0,v0,v1
a000293c:	1040fffd 	beqz	v0,a0002934 <rtl8651_setAsicL2Table+0xcc>
a0002940:	00000000 	nop

static void _rtl8651_asicTableAccessForward(uint32 tableType, uint32 eidx, void *entryContent_P) {
	ASSERT_CSP(entryContent_P);


	while ( (READ_MEM32(SWTACR) & ACTION_MASK) != ACTION_DONE );//Wait for command done
a0002944:	3c03bb80 	lui	v1,0xbb80
a0002948:	34634d00 	ori	v1,v1,0x4d00
a000294c:	8c620000 	lw	v0,0(v1)
a0002950:	30420001 	andi	v0,v0,0x1
a0002954:	1440fffd 	bnez	v0,a000294c <rtl8651_setAsicL2Table+0xe4>
a0002958:	00061200 	sll	v0,a2,0x8
		return FAILED;

	memset(&entry, 0,sizeof(entry));
	entry.mac47_40 = mac->octet[0];
	entry.mac39_24 = (mac->octet[1] << 8) | mac->octet[2];
	entry.mac23_8 = (mac->octet[3] << 8) | mac->octet[4];
a000295c:	00a21025 	or	v0,a1,v0
a0002960:	a7a20012 	sh	v0,18(sp)

//	entry.extMemberPort = 0;   
	entry.memberPort = 7;
a0002964:	8fa30014 	lw	v1,20(sp)
a0002968:	24020007 	li	v0,7
a000296c:	7c436a04 	ins	v1,v0,0x8,0x6
	entry.toCPU = 1;
a0002970:	24020001 	li	v0,1
a0002974:	7c438c44 	ins	v1,v0,0x11,0x1
	entry.isStatic = 1;
a0002978:	7c439484 	ins	v1,v0,0x12,0x1
//	entry.nxtHostFlag = 1;

	/* RTL865xC: modification of age from ( 2 -> 3 -> 1 -> 0 ) to ( 3 -> 2 -> 1 -> 0 ). modification of granularity 100 sec to 150 sec. */
	entry.agingTime = 0x03;
a000297c:	24040003 	li	a0,3
a0002980:	7c83a4c4 	ins	v1,a0,0x13,0x2
	
//	entry.srcBlock = 0;
	entry.fid=0;
a0002984:	7c03c5c4 	ins	v1,zero,0x17,0x2
	entry.auth=1;
a0002988:	7c43ce44 	ins	v1,v0,0x19,0x1
a000298c:	afa30014 	sw	v1,20(sp)
	{
		register uint32 index;

		for( index = 0; index < _rtl8651_asicTableSize[tableType]; index++ )
		{
			WRITE_MEM32(TCR0+(index<<2), *((uint32 *)entryContent_P + index));
a0002990:	27a30010 	addiu	v1,sp,16
a0002994:	8c650000 	lw	a1,0(v1)
a0002998:	3c02bb80 	lui	v0,0xbb80
a000299c:	34444d20 	ori	a0,v0,0x4d20
a00029a0:	ac850000 	sw	a1,0(a0)
a00029a4:	8c640004 	lw	a0,4(v1)
a00029a8:	34434d24 	ori	v1,v0,0x4d24
a00029ac:	ac640000 	sw	a0,0(v1)
	WRITE_MEM32(TCR4, *((uint32 *)entryContent_P + 4));
	WRITE_MEM32(TCR5, *((uint32 *)entryContent_P + 5));
	WRITE_MEM32(TCR6, *((uint32 *)entryContent_P + 6));
	WRITE_MEM32(TCR7, *((uint32 *)entryContent_P + 7));
#endif	
	WRITE_MEM32(SWTAA, ((uint32) rtl8651_asicTableAccessAddrBase(tableType) + eidx * RTL8651_ASICTABLE_ENTRY_LENGTH));//Fill address
a00029b0:	00102080 	sll	a0,s0,0x2
a00029b4:	00912025 	or	a0,a0,s1
a00029b8:	00042140 	sll	a0,a0,0x5
a00029bc:	3c03bb00 	lui	v1,0xbb00
a00029c0:	00832021 	addu	a0,a0,v1
a00029c4:	34434d08 	ori	v1,v0,0x4d08
a00029c8:	ac640000 	sw	a0,0(v1)
	}
	#endif

	_rtl8651_asicTableAccessForward(tableType, eidx, entryContent_P);

 	WRITE_MEM32(SWTACR, ACTION_START | CMD_FORCE);//Activate add command
a00029cc:	34424d00 	ori	v0,v0,0x4d00
a00029d0:	24030009 	li	v1,9
a00029d4:	ac430000 	sw	v1,0(v0)
	while ( (READ_MEM32(SWTACR) & ACTION_MASK) != ACTION_DONE );//Wait for command done
a00029d8:	00401821 	move	v1,v0
a00029dc:	8c620000 	lw	v0,0(v1)
a00029e0:	30420001 	andi	v0,v0,0x1
a00029e4:	1440fffd 	bnez	v0,a00029dc <rtl8651_setAsicL2Table+0x174>
a00029e8:	3c02bb80 	lui	v0,0xbb80

	#ifdef RTL865XC_ASIC_WRITE_PROTECTION
	if (RTL865X_TLU_BUG_FIXED)	/* No need to stop HW table lookup process */
	{
		WRITE_MEM32(SWTCR0,~EN_STOP_TLU&READ_MEM32(SWTCR0));
a00029ec:	34424418 	ori	v0,v0,0x4418
a00029f0:	8c440000 	lw	a0,0(v0)
a00029f4:	3c03fffb 	lui	v1,0xfffb
a00029f8:	3463ffff 	ori	v1,v1,0xffff
a00029fc:	00831824 	and	v1,a0,v1
a0002a00:	ac430000 	sw	v1,0(v0)
a0002a04:	00001021 	move	v0,zero
//	entry.srcBlock = 0;
	entry.fid=0;
	entry.auth=1;

	return _rtl8651_forceAddAsicEntry(TYPE_L2_SWITCH_TABLE, row<<2 | column, &entry);
}
a0002a08:	8fbf003c 	lw	ra,60(sp)
a0002a0c:	8fb20038 	lw	s2,56(sp)
a0002a10:	8fb10034 	lw	s1,52(sp)
a0002a14:	8fb00030 	lw	s0,48(sp)
a0002a18:	03e00008 	jr	ra
a0002a1c:	27bd0040 	addiu	sp,sp,64

a0002a20 <Get_P0_MiiMode>:
#define MACTYPE_MII_PHY 1
#define MACTYPE_RGMII 2
#define MACTYPE_GMII 3

unsigned int Get_P0_MiiMode()
{
a0002a20:	27bdffd8 	addiu	sp,sp,-40
a0002a24:	afbf0024 	sw	ra,36(sp)
a0002a28:	afb00020 	sw	s0,32(sp)
		const unsigned char *miimodename[]={ "MII-MAC", "MII-PHY", "RGMII", "GMII-MAC" };
a0002a2c:	3c02a001 	lui	v0,0xa001
a0002a30:	244245c4 	addiu	v0,v0,17860
a0002a34:	afa20010 	sw	v0,16(sp)
a0002a38:	3c02a001 	lui	v0,0xa001
a0002a3c:	244245cc 	addiu	v0,v0,17868
a0002a40:	afa20014 	sw	v0,20(sp)
a0002a44:	3c02a001 	lui	v0,0xa001
a0002a48:	244245d4 	addiu	v0,v0,17876
a0002a4c:	afa20018 	sw	v0,24(sp)
a0002a50:	3c02a001 	lui	v0,0xa001
a0002a54:	244245dc 	addiu	v0,v0,17884
a0002a58:	afa2001c 	sw	v0,28(sp)
	#define RANG3  7
	#define RANG4 0xf	
	
	#define SYS_HW_STRAP   (0xb8000000 +0x08)
	
	unsigned int v=REG32(SYS_HW_STRAP);
a0002a5c:	3c02b800 	lui	v0,0xb800
a0002a60:	34420008 	ori	v0,v0,0x8
a0002a64:	8c500000 	lw	s0,0(v0)
	unsigned int mode=GET_BITVAL(v, 30, RANG2);
a0002a68:	00108782 	srl	s0,s0,0x1e

	printf("P0miimode=%02x, %s\n", mode, miimodename[mode] );
a0002a6c:	00101080 	sll	v0,s0,0x2
a0002a70:	03a21021 	addu	v0,sp,v0
a0002a74:	3c04a001 	lui	a0,0xa001
a0002a78:	248445e8 	addiu	a0,a0,17896
a0002a7c:	02002821 	move	a1,s0
a0002a80:	0c002325 	jal	a0008c94 <dprintf>
a0002a84:	8c460010 	lw	a2,16(v0)


	if(mode==0)		return MACTYPE_MII_MAC;
a0002a88:	12000008 	beqz	s0,a0002aac <Get_P0_MiiMode+0x8c>
a0002a8c:	00001021 	move	v0,zero
	else if(mode==1)	return MACTYPE_MII_PHY;
a0002a90:	24030001 	li	v1,1
a0002a94:	12030005 	beq	s0,v1,a0002aac <Get_P0_MiiMode+0x8c>
a0002a98:	24020001 	li	v0,1
	else if(mode==2) return MACTYPE_RGMII;
a0002a9c:	3a100002 	xori	s0,s0,0x2
a0002aa0:	24030003 	li	v1,3
a0002aa4:	24020002 	li	v0,2
a0002aa8:	0070100b 	movn	v0,v1,s0
	else				return MACTYPE_GMII;

	
}
a0002aac:	8fbf0024 	lw	ra,36(sp)
a0002ab0:	8fb00020 	lw	s0,32(sp)
a0002ab4:	03e00008 	jr	ra
a0002ab8:	27bd0028 	addiu	sp,sp,40

a0002abc <Get_P0_PhyMode>:
//====================================================================
#if defined(CONFIG_RTL8196D) || defined(CONFIG_RTL8196E)||defined(CONFIG_RTL8881A)
#define PHYTYPE_EMB 0
#define PHYTYPE_EXT 1
unsigned int Get_P0_PhyMode()
{
a0002abc:	27bdffe8 	addiu	sp,sp,-24
a0002ac0:	afbf0014 	sw	ra,20(sp)
a0002ac4:	afb00010 	sw	s0,16(sp)
	#define RANG3  7
	#define RANG4 0xf	
	
	#define SYS_HW_STRAP   (0xb8000000 +0x08)
	
	unsigned int v=REG32(SYS_HW_STRAP);
a0002ac8:	3c02b800 	lui	v0,0xb800
a0002acc:	34420008 	ori	v0,v0,0x8
a0002ad0:	8c420000 	lw	v0,0(v0)
	unsigned int mode=GET_BITVAL(v, 6, RANG1) *2 + GET_BITVAL(v, 7, RANG1);
a0002ad4:	7c500180 	ext	s0,v0,0x6,0x1
a0002ad8:	00108040 	sll	s0,s0,0x1
a0002adc:	7c4201c0 	ext	v0,v0,0x7,0x1
a0002ae0:	02028021 	addu	s0,s0,v0
	
	printf("P0phymode=%02x, %s phy\n", mode,   (mode==2) ? "external" : "embedded"  );
a0002ae4:	24020002 	li	v0,2
a0002ae8:	12020003 	beq	s0,v0,a0002af8 <Get_P0_PhyMode+0x3c>
a0002aec:	3c06a001 	lui	a2,0xa001
a0002af0:	08000ac0 	j	a0002b00 <Get_P0_PhyMode+0x44>
a0002af4:	24c645fc 	addiu	a2,a2,17916
a0002af8:	3c06a001 	lui	a2,0xa001
a0002afc:	24c64608 	addiu	a2,a2,17928
a0002b00:	3c04a001 	lui	a0,0xa001
a0002b04:	24844614 	addiu	a0,a0,17940
a0002b08:	0c002325 	jal	a0008c94 <dprintf>
a0002b0c:	02002821 	move	a1,s0
a0002b10:	3a020002 	xori	v0,s0,0x2
	
	if(mode==2)	return PHYTYPE_EXT;
	else 		return PHYTYPE_EMB;

	
}
a0002b14:	2c420001 	sltiu	v0,v0,1
a0002b18:	8fbf0014 	lw	ra,20(sp)
a0002b1c:	8fb00010 	lw	s0,16(sp)
a0002b20:	03e00008 	jr	ra
a0002b24:	27bd0018 	addiu	sp,sp,24

a0002b28 <FullAndSemiReset>:
	for (idx=0; idx<count; idx++)// Write into hardware
		swTable_addEntry(type, idx, &entry);
}

void FullAndSemiReset( void )
{
a0002b28:	27bdffe8 	addiu	sp,sp,-24
a0002b2c:	afbf0014 	sw	ra,20(sp)
a0002b30:	afb00010 	sw	s0,16(sp)

	/* FIXME: Currently workable for FPGA, may need further modification for real chip */
// CONFIG_RTL8198C
//	REG32(0xb8000010)|=(1<<27);  //protect bit=1
	
	REG32(0xb8000010)&= ~(1<<11);  //active_swcore=0
a0002b34:	3c10b800 	lui	s0,0xb800
a0002b38:	36100010 	ori	s0,s0,0x10
a0002b3c:	8e030000 	lw	v1,0(s0)
a0002b40:	2402f7ff 	li	v0,-2049
a0002b44:	00621024 	and	v0,v1,v0
a0002b48:	ae020000 	sw	v0,0(s0)

	__delay(5000);
a0002b4c:	0c0038dc 	jal	a000e370 <__delay>
a0002b50:	24041388 	li	a0,5000
	
	REG32(0xb8000010)|= (1<<11);  //active_swcore=1
a0002b54:	8e020000 	lw	v0,0(s0)
a0002b58:	34420800 	ori	v0,v0,0x800
a0002b5c:	ae020000 	sw	v0,0(s0)
#endif




}
a0002b60:	8fbf0014 	lw	ra,20(sp)
a0002b64:	8fb00010 	lw	s0,16(sp)
a0002b68:	03e00008 	jr	ra
a0002b6c:	27bd0018 	addiu	sp,sp,24

a0002b70 <swCore_init>:
		REG32(PCRP0+i*4) &= ~(EnForceMode);
}
#endif

int32 swCore_init()
{
a0002b70:	27bdffe0 	addiu	sp,sp,-32
a0002b74:	afbf001c 	sw	ra,28(sp)
a0002b78:	afb10018 	sw	s1,24(sp)
a0002b7c:	afb00014 	sw	s0,20(sp)
		#define REG32_ANDOR(x,y,z)   (REG32(x)=(REG32(x)& (y))|(z))

	int port;

	/* Full reset and semreset */
	FullAndSemiReset();
a0002b80:	0c000aca 	jal	a0002b28 <FullAndSemiReset>
a0002b84:	3c10bb80 	lui	s0,0xbb80
	}
#endif		

	/* rtl8651_clearAsicAllTable */
#if defined(CONFIG_RTL8196D) || defined(CONFIG_RTL8196E) ||defined(CONFIG_RTL8881A)
	REG32(MEMCR) = 0;
a0002b88:	36024234 	ori	v0,s0,0x4234
a0002b8c:	ac400000 	sw	zero,0(v0)
	REG32(MEMCR) = 0x7f;
a0002b90:	2403007f 	li	v1,127
a0002b94:	ac430000 	sw	v1,0(v0)
	_rtl8651_clearSpecifiedAsicTable(TYPE_MULTICAST_TABLE, RTL8651_IPMULTICASTTBL_SIZE);
a0002b98:	24040003 	li	a0,3
a0002b9c:	0c0009f8 	jal	a00027e0 <_rtl8651_clearSpecifiedAsicTable>
a0002ba0:	24050040 	li	a1,64
	_rtl8651_clearSpecifiedAsicTable(TYPE_NETINTERFACE_TABLE, RTL865XC_NETINTERFACE_NUMBER);
a0002ba4:	24040004 	li	a0,4
a0002ba8:	0c0009f8 	jal	a00027e0 <_rtl8651_clearSpecifiedAsicTable>
a0002bac:	24050008 	li	a1,8

#else  //8198, not NFBI
		//anson add
		//REG32(0xbb804300)= 0x00055500;

		REG32(PCRP0) &= (0xFFFFFFFF-(0x00000000|MacSwReset));
a0002bb0:	36034104 	ori	v1,s0,0x4104
a0002bb4:	8c640000 	lw	a0,0(v1)
a0002bb8:	2402fff7 	li	v0,-9
a0002bbc:	00822024 	and	a0,a0,v0
a0002bc0:	ac640000 	sw	a0,0(v1)
                REG32(PCRP1) &= (0xFFFFFFFF-(0x00000000|MacSwReset));
a0002bc4:	36074108 	ori	a3,s0,0x4108
a0002bc8:	8ce40000 	lw	a0,0(a3)
a0002bcc:	00822024 	and	a0,a0,v0
a0002bd0:	ace40000 	sw	a0,0(a3)
                REG32(PCRP2) &= (0xFFFFFFFF-(0x00000000|MacSwReset));
a0002bd4:	3606410c 	ori	a2,s0,0x410c
a0002bd8:	8cc40000 	lw	a0,0(a2)
a0002bdc:	00822024 	and	a0,a0,v0
a0002be0:	acc40000 	sw	a0,0(a2)
                REG32(PCRP3) &= (0xFFFFFFFF-(0x00000000|MacSwReset));
a0002be4:	36054110 	ori	a1,s0,0x4110
a0002be8:	8ca40000 	lw	a0,0(a1)
a0002bec:	00822024 	and	a0,a0,v0
a0002bf0:	aca40000 	sw	a0,0(a1)
                REG32(PCRP4) &= (0xFFFFFFFF-(0x00000000|MacSwReset));
a0002bf4:	36044114 	ori	a0,s0,0x4114
a0002bf8:	8c880000 	lw	t0,0(a0)
a0002bfc:	01021024 	and	v0,t0,v0
a0002c00:	ac820000 	sw	v0,0(a0)

//		REG32(PCRP0) = REG32(PCRP0) | (0 << ExtPHYID_OFFSET) | AcptMaxLen_16K | EnablePHYIf | MacSwReset;   //move to below

		REG32(PCRP1) = REG32(PCRP1) | (1 << ExtPHYID_OFFSET) |  EnablePHYIf | MacSwReset;
a0002c04:	8ce80000 	lw	t0,0(a3)
a0002c08:	3c020400 	lui	v0,0x400
a0002c0c:	34420009 	ori	v0,v0,0x9
a0002c10:	01021025 	or	v0,t0,v0
a0002c14:	ace20000 	sw	v0,0(a3)
		REG32(PCRP2) = REG32(PCRP2) | (2 << ExtPHYID_OFFSET) |  EnablePHYIf | MacSwReset;
a0002c18:	8cc70000 	lw	a3,0(a2)
a0002c1c:	3c020800 	lui	v0,0x800
a0002c20:	34420009 	ori	v0,v0,0x9
a0002c24:	00e21025 	or	v0,a3,v0
a0002c28:	acc20000 	sw	v0,0(a2)
		REG32(PCRP3) = REG32(PCRP3) | (3 << ExtPHYID_OFFSET) |  EnablePHYIf | MacSwReset;
a0002c2c:	8ca60000 	lw	a2,0(a1)
a0002c30:	3c020c00 	lui	v0,0xc00
a0002c34:	34420009 	ori	v0,v0,0x9
a0002c38:	00c21025 	or	v0,a2,v0
a0002c3c:	aca20000 	sw	v0,0(a1)
		REG32(PCRP4) = REG32(PCRP4) | (4 << ExtPHYID_OFFSET) |  EnablePHYIf | MacSwReset;
a0002c40:	8c850000 	lw	a1,0(a0)
a0002c44:	3c021000 	lui	v0,0x1000
a0002c48:	34420009 	ori	v0,v0,0x9
a0002c4c:	00a21025 	or	v0,a1,v0
a0002c50:	ac820000 	sw	v0,0(a0)
			PHYID= 0x10	: 0x011	:	0x01
		*/
		REG32_ANDOR(0xbb804050, ~(0x1f<<0), 0x11<<0); 
		REG32(PCRP0) |=  (0<< ExtPHYID_OFFSET) |  EnablePHYIf | MacSwReset;	//emabedded
#else
		REG32(PCRP0) |=  (0 << ExtPHYID_OFFSET) | EnablePHYIf | MacSwReset;	//emabedded
a0002c54:	8c620000 	lw	v0,0(v1)
a0002c58:	34420009 	ori	v0,v0,0x9
a0002c5c:	ac620000 	sw	v0,0(v1)
	
#endif


	/* Set PVID of all ports to 8 */
	REG32(PVCR0) = (0x8 << 16) | 0x8;
a0002c60:	36034a08 	ori	v1,s0,0x4a08
a0002c64:	3c020008 	lui	v0,0x8
a0002c68:	34420008 	ori	v0,v0,0x8
a0002c6c:	ac620000 	sw	v0,0(v1)
	REG32(PVCR1) = (0x8 << 16) | 0x8;
a0002c70:	36034a0c 	ori	v1,s0,0x4a0c
a0002c74:	ac620000 	sw	v0,0(v1)
	REG32(PVCR2) = (0x8 << 16) | 0x8;
a0002c78:	36034a10 	ori	v1,s0,0x4a10
a0002c7c:	ac620000 	sw	v0,0(v1)
	REG32(PVCR3) = (0x8 << 16) | 0x8;
a0002c80:	36034a14 	ori	v1,s0,0x4a14
a0002c84:	ac620000 	sw	v0,0(v1)

	
	/* Enable L2 lookup engine and spanning tree functionality */
	// REG32(MSCR) = EN_L2 | EN_L3 | EN_L4 | EN_IN_ACL;
	REG32(MSCR) = EN_L2;
a0002c88:	36024410 	ori	v0,s0,0x4410
a0002c8c:	24030001 	li	v1,1
a0002c90:	ac430000 	sw	v1,0(v0)
	REG32(QNUMCR) = P0QNum_1 | P1QNum_1 | P2QNum_1 | P3QNum_1 | P4QNum_1;
a0002c94:	36024754 	ori	v0,s0,0x4754
a0002c98:	24031249 	li	v1,4681
a0002c9c:	ac430000 	sw	v1,0(v0)

	/* Start normal TX and RX */
	REG32(SIRR) |= TRXRDY;
a0002ca0:	36024204 	ori	v0,s0,0x4204
a0002ca4:	8c430000 	lw	v1,0(v0)
a0002ca8:	34630001 	ori	v1,v1,0x1
a0002cac:	ac430000 	sw	v1,0(v0)

#define PINMUX   0xb8000040
#define PINMUX2 0xb8000044

#if defined(CONFIG_RTL8198C)
	REG32(PINMUX) &= ~((3<<8) | (3<<10) | (3<<3) | (1<<15) );  //let P0 to mii mode
a0002cb0:	3c02b800 	lui	v0,0xb800
a0002cb4:	34430040 	ori	v1,v0,0x40
a0002cb8:	8c650000 	lw	a1,0(v1)
a0002cbc:	3c04ffff 	lui	a0,0xffff
a0002cc0:	348470e7 	ori	a0,a0,0x70e7
a0002cc4:	00a42024 	and	a0,a1,a0
a0002cc8:	ac640000 	sw	a0,0(v1)
	REG32(PINMUX2) &= ~((3<<0) | (3<<3) | (3<<6) | (3<<9) | (3<<12) | (7<<15) );  //S0-S3, P0-P1
a0002ccc:	34430044 	ori	v1,v0,0x44
a0002cd0:	8c650000 	lw	a1,0(v1)
a0002cd4:	3c04fffc 	lui	a0,0xfffc
a0002cd8:	34844924 	ori	a0,a0,0x4924
a0002cdc:	00a42024 	and	a0,a1,a0
a0002ce0:	ac640000 	sw	a0,0(v1)

	#ifdef CONFIG_USING_JTAG
	REG32(PIN_MUX_SEL3) = (REG32(PIN_MUX_SEL3) & ~ (0x7FFF));  //LED0~LED4
	#else
	REG32(PIN_MUX_SEL3) = (REG32(PIN_MUX_SEL3) & ~ (0x7FFF)) | ((1<<0) | (1<<3) | (1<<6) | (1<<9) | (1<<12));  //LED0~LED4
a0002ce4:	34420108 	ori	v0,v0,0x108
a0002ce8:	8c440000 	lw	a0,0(v0)
a0002cec:	24038000 	li	v1,-32768
a0002cf0:	00831824 	and	v1,a0,v1
a0002cf4:	34631249 	ori	v1,v1,0x1249
a0002cf8:	ac430000 	sw	v1,0(v0)
	#endif

	REG32(LEDCR0) = (REG32(LEDCR0) & ~ LEDTOPOLOGY_MASK) |LEDMODE_DIRECT;
a0002cfc:	36024300 	ori	v0,s0,0x4300
a0002d00:	8c440000 	lw	a0,0(v0)
a0002d04:	3c03ffcf 	lui	v1,0xffcf
a0002d08:	3463ffff 	ori	v1,v1,0xffff
a0002d0c:	00831824 	and	v1,a0,v1
a0002d10:	3c040020 	lui	a0,0x20
a0002d14:	00641825 	or	v1,v1,a0
a0002d18:	ac430000 	sw	v1,0(v0)
	REG32(DIRECTLCR) = (REG32(DIRECTLCR) & ~ LEDONSCALEP0_MASK) |(7<<LEDONSCALEP0_OFFSET);
a0002d1c:	36104314 	ori	s0,s0,0x4314
a0002d20:	8e030000 	lw	v1,0(s0)
a0002d24:	3c020007 	lui	v0,0x7
a0002d28:	00621025 	or	v0,v1,v0
a0002d2c:	ae020000 	sw	v0,0(s0)
a0002d30:	00008021 	move	s0,zero
	REG32(LEDCR)  = (2<<20) | (0<<18) | (0<<16) | (0<<14) | (0<<12) | (0<<10) | (0<<8);  //P0-P5
#endif

	
	/*PHY FlowControl. Default enable*/
	for(port=0;port<MAX_PORT_NUMBER;port++)
a0002d34:	24110006 	li	s1,6
		if(port ==0)
					rtl8651_restartAsicEthernetPHYNway(port+1, 0x11);
		else
			
#endif
		rtl8651_restartAsicEthernetPHYNway(port+1, port);
a0002d38:	26100001 	addiu	s0,s0,1
a0002d3c:	02002021 	move	a0,s0
a0002d40:	0c000951 	jal	a0002544 <rtl8651_restartAsicEthernetPHYNway>
a0002d44:	2605ffff 	addiu	a1,s0,-1
	REG32(LEDCR)  = (2<<20) | (0<<18) | (0<<16) | (0<<14) | (0<<12) | (0<<10) | (0<<8);  //P0-P5
#endif

	
	/*PHY FlowControl. Default enable*/
	for(port=0;port<MAX_PORT_NUMBER;port++)
a0002d48:	1611fffc 	bne	s0,s1,a0002d3c <swCore_init+0x1cc>
a0002d4c:	26100001 	addiu	s0,s0,1
#if ! (defined( CONFIG_NFBI) || defined(CONFIG_NONE_FLASH))

	{		
		extern char eth0_mac[6];
		extern char eth0_mac_httpd[6];
		rtl8651_setAsicL2Table((ether_addr_t*)(&eth0_mac), 0);
a0002d50:	3c04a001 	lui	a0,0xa001
a0002d54:	248474f0 	addiu	a0,a0,29936
a0002d58:	0c000a1a 	jal	a0002868 <rtl8651_setAsicL2Table>
a0002d5c:	00002821 	move	a1,zero
		rtl8651_setAsicL2Table((ether_addr_t*)(&eth0_mac_httpd), 1);
a0002d60:	3c04a001 	lui	a0,0xa001
a0002d64:	24847ae0 	addiu	a0,a0,31456
a0002d68:	0c000a1a 	jal	a0002868 <rtl8651_setAsicL2Table>
a0002d6c:	24050001 	li	a1,1
	}
#endif

	REG32(FFCR) = EN_UNUNICAST_TOCPU | EN_UNMCAST_TOCPU; // rx broadcast and unicast packet
a0002d70:	24030003 	li	v1,3
a0002d74:	3c02bb80 	lui	v0,0xbb80
a0002d78:	34424428 	ori	v0,v0,0x4428
a0002d7c:	ac430000 	sw	v1,0(v0)
	return 0;
}
a0002d80:	00001021 	move	v0,zero
a0002d84:	8fbf001c 	lw	ra,28(sp)
a0002d88:	8fb10018 	lw	s1,24(sp)
a0002d8c:	8fb00014 	lw	s0,20(sp)
a0002d90:	03e00008 	jr	ra
a0002d94:	27bd0020 	addiu	sp,sp,32
	...

a0002da0 <swNic_intHandler>:
*       intPending      Pending interrupt sources.
*                                                                         
*   OUTPUTS                                                               
*       None
*************************************************************************/
void swNic_intHandler(uint32 intPending) {return;}
a0002da0:	03e00008 	jr	ra
a0002da4:	00000000 	nop

a0002da8 <swNic_txDone>:

void swNic_txDone(void)
{
	struct pktHdr * pPkthdr;
	
	while (txPktDoneDescIndex != currTxPkthdrDescIndex) {		
a0002da8:	3c02a002 	lui	v0,0xa002
a0002dac:	8c468860 	lw	a2,-30624(v0)
	    if ( (*(volatile uint32 *)&txPkthdrRing[0][txPktDoneDescIndex] 
a0002db0:	3c02a002 	lui	v0,0xa002
a0002db4:	8c488834 	lw	t0,-30668(v0)
                    & DESC_OWNED_BIT) == DESC_RISC_OWNED ) {										
	    
		    pPkthdr = (struct pktHdr *) ((int32) txPkthdrRing[0][txPktDoneDescIndex] 
                                                & ~(DESC_OWNED_BIT | DESC_WRAP));

			if (++txPktDoneDescIndex == txPkthdrRingCnt[0])
a0002db8:	3c02a002 	lui	v0,0xa002
a0002dbc:	8c478844 	lw	a3,-30652(v0)
a0002dc0:	3c02a002 	lui	v0,0xa002
a0002dc4:	8c428864 	lw	v0,-30620(v0)

void swNic_txDone(void)
{
	struct pktHdr * pPkthdr;
	
	while (txPktDoneDescIndex != currTxPkthdrDescIndex) {		
a0002dc8:	08000b7e 	j	a0002df8 <swNic_txDone+0x50>
a0002dcc:	00004821 	move	t1,zero
	    if ( (*(volatile uint32 *)&txPkthdrRing[0][txPktDoneDescIndex] 
a0002dd0:	8c640000 	lw	a0,0(v1)
a0002dd4:	30840001 	andi	a0,a0,0x1
a0002dd8:	10800004 	beqz	a0,a0002dec <swNic_txDone+0x44>
a0002ddc:	24420001 	addiu	v0,v0,1
a0002de0:	3c02a002 	lui	v0,0xa002
a0002de4:	03e00008 	jr	ra
a0002de8:	ac458864 	sw	a1,-30620(v0)
                    & DESC_OWNED_BIT) == DESC_RISC_OWNED ) {										
	    
		    pPkthdr = (struct pktHdr *) ((int32) txPkthdrRing[0][txPktDoneDescIndex] 
                                                & ~(DESC_OWNED_BIT | DESC_WRAP));

			if (++txPktDoneDescIndex == txPkthdrRingCnt[0])
a0002dec:	14e20004 	bne	a3,v0,a0002e00 <swNic_txDone+0x58>
a0002df0:	24630004 	addiu	v1,v1,4
a0002df4:	01201021 	move	v0,t1
a0002df8:	00021880 	sll	v1,v0,0x2
a0002dfc:	01031821 	addu	v1,t0,v1

void swNic_txDone(void)
{
	struct pktHdr * pPkthdr;
	
	while (txPktDoneDescIndex != currTxPkthdrDescIndex) {		
a0002e00:	14c2fff3 	bne	a2,v0,a0002dd0 <swNic_txDone+0x28>
a0002e04:	00402821 	move	a1,v0
a0002e08:	3c02a002 	lui	v0,0xa002
a0002e0c:	03e00008 	jr	ra
a0002e10:	ac458864 	sw	a1,-30620(v0)

a0002e14 <swNic_init>:

int32 swNic_init(uint32 userNeedRxPkthdrRingCnt[RTL865X_SWNIC_RXRING_MAX_PKTDESC],
                 uint32 userNeedRxMbufRingCnt,
                 uint32 userNeedTxPkthdrRingCnt[RTL865X_SWNIC_TXRING_MAX_PKTDESC],
                 uint32 clusterSize)
{
a0002e14:	27bdffc0 	addiu	sp,sp,-64
a0002e18:	afbf003c 	sw	ra,60(sp)
a0002e1c:	afbe0038 	sw	s8,56(sp)
a0002e20:	afb70034 	sw	s7,52(sp)
a0002e24:	afb60030 	sw	s6,48(sp)
a0002e28:	afb5002c 	sw	s5,44(sp)
a0002e2c:	afb40028 	sw	s4,40(sp)
a0002e30:	afb30024 	sw	s3,36(sp)
a0002e34:	afb20020 	sw	s2,32(sp)
a0002e38:	afb1001c 	sw	s1,28(sp)
a0002e3c:	afb00018 	sw	s0,24(sp)
a0002e40:	00809021 	move	s2,a0
a0002e44:	00a0b821 	move	s7,a1
a0002e48:	00c0b021 	move	s6,a2
    uint8 * pClusterList;
    struct pktHdr * pPkthdr;
    struct mBuf * pMbuf;

    /* Cluster size is always 2048 */
    size_of_cluster = 2048;
a0002e4c:	24030800 	li	v1,2048
a0002e50:	3c02a002 	lui	v0,0xa002
a0002e54:	ac438854 	sw	v1,-30636(v0)
a0002e58:	3c15a002 	lui	s5,0xa002
a0002e5c:	26b5881c 	addiu	s5,s5,-30692
a0002e60:	02a08821 	move	s1,s5
a0002e64:	00008021 	move	s0,zero
a0002e68:	0000a021 	move	s4,zero
    for (i = 0; i < RTL865X_SWNIC_RXRING_MAX_PKTDESC; i++) {
		rxPkthdrRingCnt[i] = userNeedRxPkthdrRingCnt[i];
		if (rxPkthdrRingCnt[i] == 0)
			continue;

		rxPkthdrRing[i] = (uint32 *) UNCACHED_MALLOC(rxPkthdrRingCnt[i] * sizeof(uint32));
a0002e6c:	3c1ea000 	lui	s8,0xa000
a0002e70:	3c02a002 	lui	v0,0xa002
a0002e74:	24428804 	addiu	v0,v0,-30716
a0002e78:	afa20010 	sw	v0,16(sp)
		ASSERT_CSP( (uint32) rxPkthdrRing[i] & 0x0fffffff );
a0002e7c:	3c020fff 	lui	v0,0xfff
a0002e80:	3442ffff 	ori	v0,v0,0xffff
a0002e84:	afa20014 	sw	v0,20(sp)

    /* Cluster size is always 2048 */
    size_of_cluster = 2048;

    /* Allocate Rx descriptors of rings */
    for (i = 0; i < RTL865X_SWNIC_RXRING_MAX_PKTDESC; i++) {
a0002e88:	24130018 	li	s3,24
		rxPkthdrRingCnt[i] = userNeedRxPkthdrRingCnt[i];
a0002e8c:	02501021 	addu	v0,s2,s0
a0002e90:	8c440000 	lw	a0,0(v0)
		if (rxPkthdrRingCnt[i] == 0)
a0002e94:	10800015 	beqz	a0,a0002eec <swNic_init+0xd8>
a0002e98:	ae240000 	sw	a0,0(s1)
			continue;

		rxPkthdrRing[i] = (uint32 *) UNCACHED_MALLOC(rxPkthdrRingCnt[i] * sizeof(uint32));
a0002e9c:	0c001f55 	jal	a0007d54 <malloc>
a0002ea0:	00042080 	sll	a0,a0,0x2
a0002ea4:	005e2025 	or	a0,v0,s8
a0002ea8:	8fa30010 	lw	v1,16(sp)
a0002eac:	00701021 	addu	v0,v1,s0
a0002eb0:	ac440000 	sw	a0,0(v0)
		ASSERT_CSP( (uint32) rxPkthdrRing[i] & 0x0fffffff );
a0002eb4:	8fa30014 	lw	v1,20(sp)
a0002eb8:	00831024 	and	v0,a0,v1
a0002ebc:	14400006 	bnez	v0,a0002ed8 <swNic_init+0xc4>
a0002ec0:	00002821 	move	a1,zero
a0002ec4:	3c04a001 	lui	a0,0xa001
a0002ec8:	0c002325 	jal	a0008c94 <dprintf>
a0002ecc:	2484462c 	addiu	a0,a0,17964
a0002ed0:	08000bb4 	j	a0002ed0 <swNic_init+0xbc>
a0002ed4:	00000000 	nop
		memset(rxPkthdrRing[i],0,rxPkthdrRingCnt[i] * sizeof(uint32));
a0002ed8:	8e260000 	lw	a2,0(s1)
a0002edc:	0c00203d 	jal	a00080f4 <memset>
a0002ee0:	00063080 	sll	a2,a2,0x2
		totalRxPkthdrRingCnt += rxPkthdrRingCnt[i];
a0002ee4:	8e220000 	lw	v0,0(s1)
a0002ee8:	0282a021 	addu	s4,s4,v0
a0002eec:	26100004 	addiu	s0,s0,4

    /* Cluster size is always 2048 */
    size_of_cluster = 2048;

    /* Allocate Rx descriptors of rings */
    for (i = 0; i < RTL865X_SWNIC_RXRING_MAX_PKTDESC; i++) {
a0002ef0:	1613ffe6 	bne	s0,s3,a0002e8c <swNic_init+0x78>
a0002ef4:	26310004 	addiu	s1,s1,4
		ASSERT_CSP( (uint32) rxPkthdrRing[i] & 0x0fffffff );
		memset(rxPkthdrRing[i],0,rxPkthdrRingCnt[i] * sizeof(uint32));
		totalRxPkthdrRingCnt += rxPkthdrRingCnt[i];
    }
	
	if (totalRxPkthdrRingCnt == 0)
a0002ef8:	12800160 	beqz	s4,a000347c <swNic_init+0x668>
a0002efc:	3c13a002 	lui	s3,0xa002
a0002f00:	26738844 	addiu	s3,s3,-30652
a0002f04:	02608021 	move	s0,s3
a0002f08:	00008821 	move	s1,zero
a0002f0c:	00009021 	move	s2,zero
		txPkthdrRingCnt[i] = userNeedTxPkthdrRingCnt[i];

		if (txPkthdrRingCnt[i] == 0)
			continue;

		txPkthdrRing[i] = (uint32 *) UNCACHED_MALLOC(txPkthdrRingCnt[i] * sizeof(uint32));
a0002f10:	3c02a002 	lui	v0,0xa002
a0002f14:	24428834 	addiu	v0,v0,-30668
a0002f18:	afa20010 	sw	v0,16(sp)
		
		ASSERT_CSP( (uint32) txPkthdrRing[i] & 0x0fffffff );
a0002f1c:	3c020fff 	lui	v0,0xfff
a0002f20:	3442ffff 	ori	v0,v0,0xffff
a0002f24:	afa20014 	sw	v0,20(sp)
	
	if (totalRxPkthdrRingCnt == 0)
		return EINVAL;

    /* Allocate Tx descriptors of rings */
    for (i = 0; i < RTL865X_SWNIC_TXRING_MAX_PKTDESC; i++) {
a0002f28:	241e0010 	li	s8,16
		txPkthdrRingCnt[i] = userNeedTxPkthdrRingCnt[i];
a0002f2c:	02d11021 	addu	v0,s6,s1
a0002f30:	8c440000 	lw	a0,0(v0)

		if (txPkthdrRingCnt[i] == 0)
a0002f34:	10800016 	beqz	a0,a0002f90 <swNic_init+0x17c>
a0002f38:	ae040000 	sw	a0,0(s0)
			continue;

		txPkthdrRing[i] = (uint32 *) UNCACHED_MALLOC(txPkthdrRingCnt[i] * sizeof(uint32));
a0002f3c:	0c001f55 	jal	a0007d54 <malloc>
a0002f40:	00042080 	sll	a0,a0,0x2
a0002f44:	3c03a000 	lui	v1,0xa000
a0002f48:	00432025 	or	a0,v0,v1
a0002f4c:	8fa30010 	lw	v1,16(sp)
a0002f50:	00711021 	addu	v0,v1,s1
a0002f54:	ac440000 	sw	a0,0(v0)
		
		ASSERT_CSP( (uint32) txPkthdrRing[i] & 0x0fffffff );
a0002f58:	8fa30014 	lw	v1,20(sp)
a0002f5c:	00831024 	and	v0,a0,v1
a0002f60:	14400006 	bnez	v0,a0002f7c <swNic_init+0x168>
a0002f64:	00002821 	move	a1,zero
a0002f68:	3c04a001 	lui	a0,0xa001
a0002f6c:	0c002325 	jal	a0008c94 <dprintf>
a0002f70:	2484462c 	addiu	a0,a0,17964
a0002f74:	08000bdd 	j	a0002f74 <swNic_init+0x160>
a0002f78:	00000000 	nop
		memset(txPkthdrRing[i],0,(txPkthdrRingCnt[i] * sizeof(uint32)));
a0002f7c:	8e060000 	lw	a2,0(s0)
a0002f80:	0c00203d 	jal	a00080f4 <memset>
a0002f84:	00063080 	sll	a2,a2,0x2
		totalTxPkthdrRingCnt += txPkthdrRingCnt[i];
a0002f88:	8e020000 	lw	v0,0(s0)
a0002f8c:	02429021 	addu	s2,s2,v0
a0002f90:	26310004 	addiu	s1,s1,4
	
	if (totalRxPkthdrRingCnt == 0)
		return EINVAL;

    /* Allocate Tx descriptors of rings */
    for (i = 0; i < RTL865X_SWNIC_TXRING_MAX_PKTDESC; i++) {
a0002f94:	163effe5 	bne	s1,s8,a0002f2c <swNic_init+0x118>
a0002f98:	26100004 	addiu	s0,s0,4
		ASSERT_CSP( (uint32) txPkthdrRing[i] & 0x0fffffff );
		memset(txPkthdrRing[i],0,(txPkthdrRingCnt[i] * sizeof(uint32)));
		totalTxPkthdrRingCnt += txPkthdrRingCnt[i];
    }

	if (totalTxPkthdrRingCnt == 0)
a0002f9c:	12400137 	beqz	s2,a000347c <swNic_init+0x668>
a0002fa0:	3c02a001 	lui	v0,0xa001
		return EINVAL;

    /* Allocate MBuf descriptors of rings */
	rxMbufRingCnt = userNeedRxMbufRingCnt;

	if (userNeedRxMbufRingCnt == 0)
a0002fa4:	12e00135 	beqz	s7,a000347c <swNic_init+0x668>
a0002fa8:	ac577968 	sw	s7,31080(v0)
		return EINVAL;

	rxMbufRing = (uint32 *) UNCACHED_MALLOC(userNeedRxMbufRingCnt * sizeof(uint32));
a0002fac:	0017b880 	sll	s7,s7,0x2
a0002fb0:	0c001f55 	jal	a0007d54 <malloc>
a0002fb4:	02e02021 	move	a0,s7
a0002fb8:	3c03a000 	lui	v1,0xa000
a0002fbc:	00432025 	or	a0,v0,v1
a0002fc0:	3c02a002 	lui	v0,0xa002
a0002fc4:	ac448800 	sw	a0,-30720(v0)
    ASSERT_CSP( (uint32) rxMbufRing & 0x0fffffff );
a0002fc8:	3c020fff 	lui	v0,0xfff
a0002fcc:	3442ffff 	ori	v0,v0,0xffff
a0002fd0:	00821024 	and	v0,a0,v0
a0002fd4:	14400006 	bnez	v0,a0002ff0 <swNic_init+0x1dc>
a0002fd8:	00002821 	move	a1,zero
a0002fdc:	3c04a001 	lui	a0,0xa001
a0002fe0:	0c002325 	jal	a0008c94 <dprintf>
a0002fe4:	2484462c 	addiu	a0,a0,17964
a0002fe8:	08000bfa 	j	a0002fe8 <swNic_init+0x1d4>
a0002fec:	00000000 	nop
	memset(rxMbufRing,0,userNeedRxMbufRingCnt * sizeof(uint32));
a0002ff0:	0c00203d 	jal	a00080f4 <memset>
a0002ff4:	02e03021 	move	a2,s7
    /* Allocate pkthdr */
    pPkthdrList = (struct pktHdr *) UNCACHED_MALLOC(
a0002ff8:	0254a021 	addu	s4,s2,s4
a0002ffc:	001410c0 	sll	v0,s4,0x3
a0003000:	0014a140 	sll	s4,s4,0x5
a0003004:	02828823 	subu	s1,s4,v0
a0003008:	0c001f55 	jal	a0007d54 <malloc>
a000300c:	02202021 	move	a0,s1
a0003010:	3c10a000 	lui	s0,0xa000
a0003014:	00508025 	or	s0,v0,s0
                    (totalRxPkthdrRingCnt + totalTxPkthdrRingCnt) * sizeof(struct pktHdr));
    ASSERT_CSP( (uint32) pPkthdrList & 0x0fffffff );
a0003018:	3c020fff 	lui	v0,0xfff
a000301c:	3442ffff 	ori	v0,v0,0xffff
a0003020:	02021024 	and	v0,s0,v0
a0003024:	14400006 	bnez	v0,a0003040 <swNic_init+0x22c>
a0003028:	00002821 	move	a1,zero
a000302c:	3c04a001 	lui	a0,0xa001
a0003030:	0c002325 	jal	a0008c94 <dprintf>
a0003034:	2484462c 	addiu	a0,a0,17964
a0003038:	08000c0e 	j	a0003038 <swNic_init+0x224>
a000303c:	00000000 	nop
   memset(pPkthdrList,0, (totalRxPkthdrRingCnt + totalTxPkthdrRingCnt) * sizeof(struct pktHdr));                 
a0003040:	02002021 	move	a0,s0
a0003044:	0c00203d 	jal	a00080f4 <memset>
a0003048:	02203021 	move	a2,s1
    /* Allocate mbufs */
    pMbufList = (struct mBuf *) UNCACHED_MALLOC(
a000304c:	3c02a001 	lui	v0,0xa001
a0003050:	8c427968 	lw	v0,31080(v0)
a0003054:	02421021 	addu	v0,s2,v0
a0003058:	000218c0 	sll	v1,v0,0x3
a000305c:	00021140 	sll	v0,v0,0x5
a0003060:	0c001f55 	jal	a0007d54 <malloc>
a0003064:	00432023 	subu	a0,v0,v1
a0003068:	3c11a000 	lui	s1,0xa000
a000306c:	00518825 	or	s1,v0,s1
                    (rxMbufRingCnt + totalTxPkthdrRingCnt) * sizeof(struct mBuf));
    ASSERT_CSP( (uint32) pMbufList & 0x0fffffff );
a0003070:	3c020fff 	lui	v0,0xfff
a0003074:	3442ffff 	ori	v0,v0,0xffff
a0003078:	02221024 	and	v0,s1,v0
a000307c:	14400006 	bnez	v0,a0003098 <swNic_init+0x284>
a0003080:	3c14a001 	lui	s4,0xa001
a0003084:	3c04a001 	lui	a0,0xa001
a0003088:	0c002325 	jal	a0008c94 <dprintf>
a000308c:	2484462c 	addiu	a0,a0,17964
a0003090:	08000c24 	j	a0003090 <swNic_init+0x27c>
a0003094:	00000000 	nop
    memset(pMbufList,0,((rxMbufRingCnt + totalTxPkthdrRingCnt) * sizeof(struct mBuf)));                
a0003098:	8e867968 	lw	a2,31080(s4)
a000309c:	02463021 	addu	a2,s2,a2
a00030a0:	000610c0 	sll	v0,a2,0x3
a00030a4:	00063140 	sll	a2,a2,0x5
a00030a8:	02202021 	move	a0,s1
a00030ac:	00002821 	move	a1,zero
a00030b0:	0c00203d 	jal	a00080f4 <memset>
a00030b4:	00c23023 	subu	a2,a2,v0
    /* Allocate clusters */
    pClusterList = (uint8 *) UNCACHED_MALLOC(rxMbufRingCnt * size_of_cluster + 8 - 1+2*rxMbufRingCnt);
a00030b8:	3c02a002 	lui	v0,0xa002
a00030bc:	8c448854 	lw	a0,-30636(v0)
a00030c0:	24840002 	addiu	a0,a0,2
a00030c4:	8e827968 	lw	v0,31080(s4)
a00030c8:	70822002 	mul	a0,a0,v0
a00030cc:	0c001f55 	jal	a0007d54 <malloc>
a00030d0:	24840007 	addiu	a0,a0,7
a00030d4:	3c12a000 	lui	s2,0xa000
a00030d8:	00529025 	or	s2,v0,s2
    ASSERT_CSP( (uint32) pClusterList & 0x0fffffff );
a00030dc:	3c020fff 	lui	v0,0xfff
a00030e0:	3442ffff 	ori	v0,v0,0xffff
a00030e4:	02421024 	and	v0,s2,v0
a00030e8:	14400006 	bnez	v0,a0003104 <swNic_init+0x2f0>
a00030ec:	3c02a002 	lui	v0,0xa002
a00030f0:	3c04a001 	lui	a0,0xa001
a00030f4:	0c002325 	jal	a0008c94 <dprintf>
a00030f8:	2484462c 	addiu	a0,a0,17964
a00030fc:	08000c3f 	j	a00030fc <swNic_init+0x2e8>
a0003100:	00000000 	nop
    memset(pClusterList,0,(rxMbufRingCnt * size_of_cluster + 8 - 1+2*rxMbufRingCnt));
a0003104:	8c468854 	lw	a2,-30636(v0)
a0003108:	24c60002 	addiu	a2,a2,2
a000310c:	3c02a001 	lui	v0,0xa001
a0003110:	8c427968 	lw	v0,31080(v0)
a0003114:	70c23002 	mul	a2,a2,v0
a0003118:	02402021 	move	a0,s2
a000311c:	00002821 	move	a1,zero
a0003120:	0c00203d 	jal	a00080f4 <memset>
a0003124:	24c60007 	addiu	a2,a2,7
    pClusterList = (uint8*)(((uint32) pClusterList + 8 - 1) & ~(8 - 1));

    /* Initialize interrupt statistics counter */
    rxPktCounter = txPktCounter = 0;
a0003128:	3c02a002 	lui	v0,0xa002
a000312c:	ac40886c 	sw	zero,-30612(v0)
a0003130:	3c02a002 	lui	v0,0xa002
a0003134:	ac408868 	sw	zero,-30616(v0)

    /* Initialize index of Tx pkthdr descriptor */
    currTxPkthdrDescIndex = 0;
a0003138:	3c02a002 	lui	v0,0xa002
a000313c:	ac408860 	sw	zero,-30624(v0)
    txPktDoneDescIndex=0;
a0003140:	3c02a002 	lui	v0,0xa002
a0003144:	ac408864 	sw	zero,-30620(v0)
a0003148:	3c04a002 	lui	a0,0xa002
a000314c:	24848834 	addiu	a0,a0,-30668
*                                                                         
*   OUTPUTS                                                               
*       Status.
*************************************************************************/

int32 swNic_init(uint32 userNeedRxPkthdrRingCnt[RTL865X_SWNIC_RXRING_MAX_PKTDESC],
a0003150:	3c0aa002 	lui	t2,0xa002
a0003154:	254a8844 	addiu	t2,t2,-30652
    /* Initialize index of Tx pkthdr descriptor */
    currTxPkthdrDescIndex = 0;
    txPktDoneDescIndex=0;

    /* Initialize Tx packet header descriptors */
    for (i = 0; i < RTL865X_SWNIC_TXRING_MAX_PKTDESC; i++)
a0003158:	00004821 	move	t1,zero
         bzero((void *) pPkthdr, sizeof(struct pktHdr));
         bzero((void *) pMbuf, sizeof(struct mBuf));

			pPkthdr->ph_mbuf = pMbuf;
			pPkthdr->ph_len = 0;
			pPkthdr->ph_flags = PKTHDR_USED | PKT_OUTGOING;
a000315c:	24088800 	li	t0,-30720
			pPkthdr->ph_type = PKTHDR_ETHERNET;
			pPkthdr->ph_portlist = 0;

			pMbuf->m_next = NULL;
			pMbuf->m_pkthdr = pPkthdr;
			pMbuf->m_flags = MBUF_USED | MBUF_EXT | MBUF_PKTHDR | MBUF_EOR;
a0003160:	08000c8a 	j	a0003228 <swNic_init+0x414>
a0003164:	2407009c 	li	a3,156
	{
		for (j = 0; j < txPkthdrRingCnt[i]; j++)
		{
			/* Dequeue pkthdr and mbuf */
			pPkthdr = pPkthdrList++;
			pMbuf = pMbufList++;
a0003168:	26230018 	addiu	v1,s1,24

         bzero((void *) pPkthdr, sizeof(struct pktHdr));
a000316c:	ae000000 	sw	zero,0(s0)
a0003170:	ae000004 	sw	zero,4(s0)
a0003174:	ae000008 	sw	zero,8(s0)
a0003178:	ae00000c 	sw	zero,12(s0)
a000317c:	ae000010 	sw	zero,16(s0)
a0003180:	ae000014 	sw	zero,20(s0)
         bzero((void *) pMbuf, sizeof(struct mBuf));
a0003184:	ae200000 	sw	zero,0(s1)
a0003188:	ae200004 	sw	zero,4(s1)
a000318c:	ae200008 	sw	zero,8(s1)
a0003190:	ae20000c 	sw	zero,12(s1)
a0003194:	ae200010 	sw	zero,16(s1)
a0003198:	ae200014 	sw	zero,20(s1)

			pPkthdr->ph_mbuf = pMbuf;
a000319c:	ac510000 	sw	s1,0(v0)
			pPkthdr->ph_len = 0;
a00031a0:	a4400004 	sh	zero,4(v0)
			pPkthdr->ph_flags = PKTHDR_USED | PKT_OUTGOING;
a00031a4:	a448000c 	sh	t0,12(v0)
			pPkthdr->ph_type = PKTHDR_ETHERNET;
a00031a8:	8e060008 	lw	a2,8(s0)
a00031ac:	7c06ff44 	ins	a2,zero,0x1d,0x3
a00031b0:	ae060008 	sw	a2,8(s0)
			pPkthdr->ph_portlist = 0;
a00031b4:	a040000f 	sb	zero,15(v0)

			pMbuf->m_next = NULL;
a00031b8:	ac60ffe8 	sw	zero,-24(v1)
			pMbuf->m_pkthdr = pPkthdr;
a00031bc:	ac70ffec 	sw	s0,-20(v1)
			pMbuf->m_flags = MBUF_USED | MBUF_EXT | MBUF_PKTHDR | MBUF_EOR;
a00031c0:	a467fff2 	sh	a3,-14(v1)
			pMbuf->m_data = NULL;
a00031c4:	ac60fff4 	sw	zero,-12(v1)
			pMbuf->m_extbuf = NULL;
a00031c8:	ac60fff8 	sw	zero,-8(v1)
			pMbuf->m_extsize = 0;
a00031cc:	a460fffc 	sh	zero,-4(v1)

			txPkthdrRing[i][j] = (int32) pPkthdr | DESC_RISC_OWNED;
a00031d0:	8c8b0000 	lw	t3,0(a0)
a00031d4:	00053080 	sll	a2,a1,0x2
a00031d8:	01663021 	addu	a2,t3,a2
a00031dc:	acc20000 	sw	v0,0(a2)
    txPktDoneDescIndex=0;

    /* Initialize Tx packet header descriptors */
    for (i = 0; i < RTL865X_SWNIC_TXRING_MAX_PKTDESC; i++)
	{
		for (j = 0; j < txPkthdrRingCnt[i]; j++)
a00031e0:	24a50001 	addiu	a1,a1,1
a00031e4:	24420018 	addiu	v0,v0,24
a00031e8:	00608821 	move	s1,v1
a00031ec:	8e630000 	lw	v1,0(s3)
a00031f0:	00a3302b 	sltu	a2,a1,v1
a00031f4:	14c0ffdc 	bnez	a2,a0003168 <swNic_init+0x354>
a00031f8:	00408021 	move	s0,v0
			txPkthdrRing[i][j] = (int32) pPkthdr | DESC_RISC_OWNED;

		}

		/* Set wrap bit of the last descriptor */
        if (txPkthdrRingCnt[i] != 0)
a00031fc:	10600007 	beqz	v1,a000321c <swNic_init+0x408>
a0003200:	2463ffff 	addiu	v1,v1,-1
{
            txPkthdrRing[i][txPkthdrRingCnt[i] - 1] |= DESC_WRAP;
a0003204:	00031880 	sll	v1,v1,0x2
a0003208:	8c820000 	lw	v0,0(a0)
a000320c:	00431021 	addu	v0,v0,v1
a0003210:	8c430000 	lw	v1,0(v0)
a0003214:	34630002 	ori	v1,v1,0x2
a0003218:	ac430000 	sw	v1,0(v0)
a000321c:	24840004 	addiu	a0,a0,4
    /* Initialize index of Tx pkthdr descriptor */
    currTxPkthdrDescIndex = 0;
    txPktDoneDescIndex=0;

    /* Initialize Tx packet header descriptors */
    for (i = 0; i < RTL865X_SWNIC_TXRING_MAX_PKTDESC; i++)
a0003220:	108a0004 	beq	a0,t2,a0003234 <swNic_init+0x420>
a0003224:	26730004 	addiu	s3,s3,4
a0003228:	02001021 	move	v0,s0
a000322c:	08000c7b 	j	a00031ec <swNic_init+0x3d8>
a0003230:	01202821 	move	a1,t1
    memset(pMbufList,0,((rxMbufRingCnt + totalTxPkthdrRingCnt) * sizeof(struct mBuf)));                
    /* Allocate clusters */
    pClusterList = (uint8 *) UNCACHED_MALLOC(rxMbufRingCnt * size_of_cluster + 8 - 1+2*rxMbufRingCnt);
    ASSERT_CSP( (uint32) pClusterList & 0x0fffffff );
    memset(pClusterList,0,(rxMbufRingCnt * size_of_cluster + 8 - 1+2*rxMbufRingCnt));
    pClusterList = (uint8*)(((uint32) pClusterList + 8 - 1) & ~(8 - 1));
a0003234:	26520007 	addiu	s2,s2,7
a0003238:	2402fff8 	li	v0,-8
a000323c:	02429024 	and	s2,s2,v0
}

	}

    /* Fill Tx packet header FDP */
    REG32(CPUTPDCR0) = (uint32) txPkthdrRing[0];
a0003240:	3c03a002 	lui	v1,0xa002
a0003244:	8c658834 	lw	a1,-30668(v1)
a0003248:	3c02b801 	lui	v0,0xb801
a000324c:	34440020 	ori	a0,v0,0x20
a0003250:	ac850000 	sw	a1,0(a0)
    REG32(CPUTPDCR1) = (uint32) txPkthdrRing[1];
a0003254:	24638834 	addiu	v1,v1,-30668
a0003258:	8c650004 	lw	a1,4(v1)
a000325c:	34440024 	ori	a0,v0,0x24
a0003260:	ac850000 	sw	a1,0(a0)
#if defined(CONFIG_RTL8196D) || defined(CONFIG_RTL8196E)||defined(CONFIG_RTL8881A)
    REG32(CPUTPDCR2) = (uint32) txPkthdrRing[2];
a0003264:	8c650008 	lw	a1,8(v1)
a0003268:	34440060 	ori	a0,v0,0x60
a000326c:	ac850000 	sw	a1,0(a0)
    REG32(CPUTPDCR3) = (uint32) txPkthdrRing[3];
a0003270:	8c63000c 	lw	v1,12(v1)
a0003274:	34420064 	ori	v0,v0,0x64
a0003278:	ac430000 	sw	v1,0(v0)
#endif

    /* Initialize index of current Rx pkthdr descriptor */
    currRxPkthdrDescIndex = 0;
a000327c:	3c02a002 	lui	v0,0xa002
a0003280:	ac408858 	sw	zero,-30632(v0)

    /* Initialize index of current Rx Mbuf descriptor */
    currRxMbufDescIndex = 0;
a0003284:	3c02a002 	lui	v0,0xa002
a0003288:	ac40885c 	sw	zero,-30628(v0)
a000328c:	3c04a002 	lui	a0,0xa002
a0003290:	24848804 	addiu	a0,a0,-30716
*                                                                         
*   OUTPUTS                                                               
*       Status.
*************************************************************************/

int32 swNic_init(uint32 userNeedRxPkthdrRingCnt[RTL865X_SWNIC_RXRING_MAX_PKTDESC],
a0003294:	3c0ea002 	lui	t6,0xa002
a0003298:	25ce881c 	addiu	t6,t6,-30692
a000329c:	00003021 	move	a2,zero
    currRxMbufDescIndex = 0;

    /* Initialize Rx packet header descriptors */
	k = 0;

    for (i = 0; i < RTL865X_SWNIC_RXRING_MAX_PKTDESC; i++)
a00032a0:	00006821 	move	t5,zero
         bzero((void *) pMbuf, sizeof(struct mBuf));

			/* Setup pkthdr and mbuf */
			pPkthdr->ph_mbuf = pMbuf;
			pPkthdr->ph_len = 0;
			pPkthdr->ph_flags = PKTHDR_USED | PKT_INCOMING;
a00032a4:	240c9000 	li	t4,-28672
			pPkthdr->ph_type = PKTHDR_ETHERNET;
			pPkthdr->ph_portlist = 0;
			pMbuf->m_next = NULL;
			pMbuf->m_pkthdr = pPkthdr;
			pMbuf->m_len = 0;
			pMbuf->m_flags = MBUF_USED | MBUF_EXT | MBUF_PKTHDR | MBUF_EOR;
a00032a8:	240b009c 	li	t3,156
			pMbuf->m_data = NULL;
			pMbuf->m_extsize = size_of_cluster;
a00032ac:	3c09a002 	lui	t1,0xa002
			pMbuf->m_data = pMbuf->m_extbuf = (pClusterList+2);
			pClusterList += size_of_cluster;
			
			/* Setup descriptors */
			rxPkthdrRing[i][j] = (int32) pPkthdr | DESC_SWCORE_OWNED;
			rxMbufRing[k++] = (int32) pMbuf | DESC_SWCORE_OWNED;
a00032b0:	08000cec 	j	a00033b0 <swNic_init+0x59c>
a00032b4:	3c0aa002 	lui	t2,0xa002
		{
			/* Dequeue pkthdr and mbuf */
			pPkthdr = pPkthdrList++;
			pMbuf = pMbufList++;

         bzero((void *) pPkthdr, sizeof(struct pktHdr));
a00032b8:	ae000000 	sw	zero,0(s0)
a00032bc:	ae000004 	sw	zero,4(s0)
a00032c0:	ae000008 	sw	zero,8(s0)
a00032c4:	ae00000c 	sw	zero,12(s0)
a00032c8:	ae000010 	sw	zero,16(s0)
a00032cc:	ae000014 	sw	zero,20(s0)
         bzero((void *) pMbuf, sizeof(struct mBuf));
a00032d0:	ae200000 	sw	zero,0(s1)
a00032d4:	ae200004 	sw	zero,4(s1)
a00032d8:	ae200008 	sw	zero,8(s1)
a00032dc:	ae20000c 	sw	zero,12(s1)
a00032e0:	ae200010 	sw	zero,16(s1)
a00032e4:	ae200014 	sw	zero,20(s1)

			/* Setup pkthdr and mbuf */
			pPkthdr->ph_mbuf = pMbuf;
a00032e8:	ac710000 	sw	s1,0(v1)
			pPkthdr->ph_len = 0;
a00032ec:	a4600004 	sh	zero,4(v1)
			pPkthdr->ph_flags = PKTHDR_USED | PKT_INCOMING;
a00032f0:	a46c000c 	sh	t4,12(v1)
			pPkthdr->ph_type = PKTHDR_ETHERNET;
a00032f4:	8e080008 	lw	t0,8(s0)
a00032f8:	7c08ff44 	ins	t0,zero,0x1d,0x3
a00032fc:	ae080008 	sw	t0,8(s0)
			pPkthdr->ph_portlist = 0;
a0003300:	a060000f 	sb	zero,15(v1)
			pMbuf->m_next = NULL;
a0003304:	ac400000 	sw	zero,0(v0)
			pMbuf->m_pkthdr = pPkthdr;
a0003308:	ac500004 	sw	s0,4(v0)
			pMbuf->m_len = 0;
a000330c:	a4400008 	sh	zero,8(v0)
			pMbuf->m_flags = MBUF_USED | MBUF_EXT | MBUF_PKTHDR | MBUF_EOR;
a0003310:	a44b000a 	sh	t3,10(v0)
			pMbuf->m_data = NULL;
a0003314:	ac40000c 	sw	zero,12(v0)
			pMbuf->m_extsize = size_of_cluster;
a0003318:	8d288854 	lw	t0,-30636(t1)
a000331c:	a4480014 	sh	t0,20(v0)
			/*offset 2 bytes for 4 bytes align of ip packet*/
			pMbuf->m_data = pMbuf->m_extbuf = (pClusterList+2);
a0003320:	26480002 	addiu	t0,s2,2
a0003324:	ac480010 	sw	t0,16(v0)
a0003328:	ac48000c 	sw	t0,12(v0)
			pClusterList += size_of_cluster;
a000332c:	8d288854 	lw	t0,-30636(t1)
a0003330:	02489021 	addu	s2,s2,t0
			
			/* Setup descriptors */
			rxPkthdrRing[i][j] = (int32) pPkthdr | DESC_SWCORE_OWNED;
a0003334:	8c8f0000 	lw	t7,0(a0)
a0003338:	00054080 	sll	t0,a1,0x2
a000333c:	01e84021 	addu	t0,t7,t0
a0003340:	346f0001 	ori	t7,v1,0x1
a0003344:	ad0f0000 	sw	t7,0(t0)
			rxMbufRing[k++] = (int32) pMbuf | DESC_SWCORE_OWNED;
a0003348:	8d488800 	lw	t0,-30720(t2)
a000334c:	01074021 	addu	t0,t0,a3
a0003350:	344f0001 	ori	t7,v0,0x1
a0003354:	ad0f0000 	sw	t7,0(t0)
    /* Initialize Rx packet header descriptors */
	k = 0;

    for (i = 0; i < RTL865X_SWNIC_RXRING_MAX_PKTDESC; i++)
	{
		for (j = 0; j < rxPkthdrRingCnt[i]; j++)
a0003358:	24a50001 	addiu	a1,a1,1
a000335c:	24630018 	addiu	v1,v1,24
a0003360:	24420018 	addiu	v0,v0,24
a0003364:	24e70004 	addiu	a3,a3,4
a0003368:	00408821 	move	s1,v0
a000336c:	00608021 	move	s0,v1
a0003370:	8ea80000 	lw	t0,0(s5)
a0003374:	00a8c02b 	sltu	t8,a1,t0
a0003378:	1700ffcf 	bnez	t8,a00032b8 <swNic_init+0x4a4>
a000337c:	00a67821 	addu	t7,a1,a2
			rxPkthdrRing[i][j] = (int32) pPkthdr | DESC_SWCORE_OWNED;
			rxMbufRing[k++] = (int32) pMbuf | DESC_SWCORE_OWNED;
		}

		/* Set wrap bit of the last descriptor */
        if (rxPkthdrRingCnt[i] != 0)
a0003380:	11000007 	beqz	t0,a00033a0 <swNic_init+0x58c>
a0003384:	2508ffff 	addiu	t0,t0,-1
		    rxPkthdrRing[i][rxPkthdrRingCnt[i] - 1] |= DESC_WRAP;
a0003388:	00084080 	sll	t0,t0,0x2
a000338c:	8c820000 	lw	v0,0(a0)
a0003390:	00481021 	addu	v0,v0,t0
a0003394:	8c430000 	lw	v1,0(v0)
a0003398:	34630002 	ori	v1,v1,0x2
a000339c:	ac430000 	sw	v1,0(v0)
a00033a0:	24840004 	addiu	a0,a0,4
    currRxMbufDescIndex = 0;

    /* Initialize Rx packet header descriptors */
	k = 0;

    for (i = 0; i < RTL865X_SWNIC_RXRING_MAX_PKTDESC; i++)
a00033a4:	108e0007 	beq	a0,t6,a00033c4 <swNic_init+0x5b0>
a00033a8:	26b50004 	addiu	s5,s5,4
a00033ac:	01e03021 	move	a2,t7
a00033b0:	02001821 	move	v1,s0
a00033b4:	02201021 	move	v0,s1
a00033b8:	00063880 	sll	a3,a2,0x2
a00033bc:	08000cda 	j	a0003368 <swNic_init+0x554>
a00033c0:	01a02821 	move	a1,t5
		/* Set wrap bit of the last descriptor */
        if (rxPkthdrRingCnt[i] != 0)
		    rxPkthdrRing[i][rxPkthdrRingCnt[i] - 1] |= DESC_WRAP;
	}

	rxMbufRing[rxMbufRingCnt - 1] |= DESC_WRAP;
a00033c4:	3c04a002 	lui	a0,0xa002
a00033c8:	3c02a001 	lui	v0,0xa001
a00033cc:	8c427968 	lw	v0,31080(v0)
a00033d0:	2442ffff 	addiu	v0,v0,-1
a00033d4:	00021080 	sll	v0,v0,0x2
a00033d8:	8c838800 	lw	v1,-30720(a0)
a00033dc:	00621021 	addu	v0,v1,v0
a00033e0:	8c430000 	lw	v1,0(v0)
a00033e4:	34630002 	ori	v1,v1,0x2
a00033e8:	ac430000 	sw	v1,0(v0)

    /* Fill Rx packet header FDP */
    REG32(CPURPDCR0) = (uint32) rxPkthdrRing[0];
a00033ec:	3c03a002 	lui	v1,0xa002
a00033f0:	8c668804 	lw	a2,-30716(v1)
a00033f4:	3c02b801 	lui	v0,0xb801
a00033f8:	34450004 	ori	a1,v0,0x4
a00033fc:	aca60000 	sw	a2,0(a1)
    REG32(CPURPDCR1) = (uint32) rxPkthdrRing[1];
a0003400:	24638804 	addiu	v1,v1,-30716
a0003404:	8c660004 	lw	a2,4(v1)
a0003408:	34450008 	ori	a1,v0,0x8
a000340c:	aca60000 	sw	a2,0(a1)
    REG32(CPURPDCR2) = (uint32) rxPkthdrRing[2];
a0003410:	8c660008 	lw	a2,8(v1)
a0003414:	3445000c 	ori	a1,v0,0xc
a0003418:	aca60000 	sw	a2,0(a1)
    REG32(CPURPDCR3) = (uint32) rxPkthdrRing[3];
a000341c:	8c66000c 	lw	a2,12(v1)
a0003420:	34450010 	ori	a1,v0,0x10
a0003424:	aca60000 	sw	a2,0(a1)
    REG32(CPURPDCR4) = (uint32) rxPkthdrRing[4];
a0003428:	8c660010 	lw	a2,16(v1)
a000342c:	34450014 	ori	a1,v0,0x14
a0003430:	aca60000 	sw	a2,0(a1)
    REG32(CPURPDCR5) = (uint32) rxPkthdrRing[5];
a0003434:	8c650014 	lw	a1,20(v1)
a0003438:	34430018 	ori	v1,v0,0x18
a000343c:	ac650000 	sw	a1,0(v1)

    REG32(CPURMDCR0) = (uint32) rxMbufRing;
a0003440:	8c848800 	lw	a0,-30720(a0)
a0003444:	3443001c 	ori	v1,v0,0x1c
a0003448:	ac640000 	sw	a0,0(v1)
	//dprintf("eth0 CPUIIMR status=%x\r\n", *(volatile unsigned int*)(0xb8010028));   //ISR	
	
    /* Enable Rx & Tx. Config bus burst size and mbuf size. */
    //REG32(CPUICR) = TXCMD | RXCMD | BUSBURST_256WORDS | icr_mbufsize;
    //REG32(CPUICR) = TXCMD | RXCMD | BUSBURST_32WORDS | MBUF_2048BYTES;	//8651c
	REG32(CPUICR) = TXCMD | RXCMD | BUSBURST_32WORDS | MBUF_2048BYTES; //wei test irq
a000344c:	3c03c400 	lui	v1,0xc400
a0003450:	ac430000 	sw	v1,0(v0)

	REG32(CPUIIMR) = RX_DONE_IE_ALL | TX_DONE_IE_ALL; 
a0003454:	34420028 	ori	v0,v0,0x28
a0003458:	240307f8 	li	v1,2040
a000345c:	ac430000 	sw	v1,0(v0)


	REG32(MDCIOCR)=0x96181441;      // enable Giga port 8211B LED
a0003460:	3c039618 	lui	v1,0x9618
a0003464:	34631441 	ori	v1,v1,0x1441
a0003468:	3c02bb80 	lui	v0,0xbb80
a000346c:	34424004 	ori	v0,v0,0x4004
a0003470:	ac430000 	sw	v1,0(v0)
	//dprintf("eth0 CPUIIMR status=%x\r\n", *(volatile unsigned int*)(0xb8010028));   //ISR
	
    return SUCCESS;
a0003474:	08000d20 	j	a0003480 <swNic_init+0x66c>
a0003478:	00001021 	move	v0,zero
a000347c:	24020016 	li	v0,22
}
a0003480:	8fbf003c 	lw	ra,60(sp)
a0003484:	8fbe0038 	lw	s8,56(sp)
a0003488:	8fb70034 	lw	s7,52(sp)
a000348c:	8fb60030 	lw	s6,48(sp)
a0003490:	8fb5002c 	lw	s5,44(sp)
a0003494:	8fb40028 	lw	s4,40(sp)
a0003498:	8fb30024 	lw	s3,36(sp)
a000349c:	8fb20020 	lw	s2,32(sp)
a00034a0:	8fb1001c 	lw	s1,28(sp)
a00034a4:	8fb00018 	lw	s0,24(sp)
a00034a8:	03e00008 	jr	ra
a00034ac:	27bd0040 	addiu	sp,sp,64

a00034b0 <swNic_send>:
*                                                                         
*   OUTPUTS                                                               
*       None
*************************************************************************/
int32 swNic_send(void * output, uint32 len)
{
a00034b0:	27bdffe0 	addiu	sp,sp,-32
a00034b4:	afbf001c 	sw	ra,28(sp)
a00034b8:	afb20018 	sw	s2,24(sp)
a00034bc:	afb10014 	sw	s1,20(sp)
a00034c0:	afb00010 	sw	s0,16(sp)
a00034c4:	00801021 	move	v0,a0
    struct pktHdr * pPkthdr;
    //uint8 pktbuf[2048];
    uint8* pktbuf_alligned;

	int next_index;
	if ((currTxPkthdrDescIndex+1) == txPkthdrRingCnt[0])
a00034c8:	3c03a002 	lui	v1,0xa002
a00034cc:	8c708860 	lw	s0,-30624(v1)
a00034d0:	26100001 	addiu	s0,s0,1
a00034d4:	3c03a002 	lui	v1,0xa002
a00034d8:	8c638844 	lw	v1,-30652(v1)
a00034dc:	02031826 	xor	v1,s0,v1
a00034e0:	0003800a 	movz	s0,zero,v1
		next_index = 0;
	else
		next_index = currTxPkthdrDescIndex+1;
	if (next_index == txPktDoneDescIndex) {
a00034e4:	3c03a002 	lui	v1,0xa002
a00034e8:	8c638864 	lw	v1,-30620(v1)
a00034ec:	16030006 	bne	s0,v1,a0003508 <swNic_send+0x58>
a00034f0:	00a08821 	move	s1,a1
		dprintf("Tx Desc full!\n");
a00034f4:	3c04a001 	lui	a0,0xa001
a00034f8:	0c002325 	jal	a0008c94 <dprintf>
a00034fc:	24844644 	addiu	a0,a0,17988
		return -1;
a0003500:	08000d85 	j	a0003614 <swNic_send+0x164>
a0003504:	2402ffff 	li	v0,-1
	}		

#ifdef _FAST_TX
	pktbuf_alligned = (uint8 *)output;
#else
	pktbuf_alligned = (uint8 *) (( (uint32) pktbuf & 0xfffffffc) | 0xa0000000);
a0003508:	3c035fff 	lui	v1,0x5fff
a000350c:	3463fffc 	ori	v1,v1,0xfffc
a0003510:	3c12a002 	lui	s2,0xa002
a0003514:	26529204 	addiu	s2,s2,-28156
a0003518:	02439024 	and	s2,s2,v1
a000351c:	3c03a000 	lui	v1,0xa000
a0003520:	02439025 	or	s2,s2,v1
    /* Copy Packet Content */
    memcpy(pktbuf_alligned, output, len);
a0003524:	02402021 	move	a0,s2
a0003528:	00402821 	move	a1,v0
a000352c:	0c002046 	jal	a0008118 <memcpy>
a0003530:	02203021 	move	a2,s1
			ddump(output, 32);
//		else
//			ddump(output, len);
	}
#endif
    ASSERT_CSP( ((int32) txPkthdrRing[0][currTxPkthdrDescIndex] & DESC_OWNED_BIT) == DESC_RISC_OWNED );
a0003534:	3c02a002 	lui	v0,0xa002
a0003538:	8c438860 	lw	v1,-30624(v0)
a000353c:	00031880 	sll	v1,v1,0x2
a0003540:	3c02a002 	lui	v0,0xa002
a0003544:	8c428834 	lw	v0,-30668(v0)
a0003548:	00431021 	addu	v0,v0,v1
a000354c:	8c420000 	lw	v0,0(v0)
a0003550:	30440001 	andi	a0,v0,0x1
a0003554:	10800005 	beqz	a0,a000356c <swNic_send+0xbc>
a0003558:	3c04a001 	lui	a0,0xa001
a000355c:	0c002325 	jal	a0008c94 <dprintf>
a0003560:	2484462c 	addiu	a0,a0,17964
a0003564:	08000d59 	j	a0003564 <swNic_send+0xb4>
a0003568:	00000000 	nop

    /* Fetch packet header from Tx ring */
    pPkthdr = (struct pktHdr *) ((int32) txPkthdrRing[0][currTxPkthdrDescIndex] 
a000356c:	2404fffc 	li	a0,-4
a0003570:	00441024 	and	v0,v0,a0
                                                & ~(DESC_OWNED_BIT | DESC_WRAP));

    /* Pad small packets and add CRC */
    if ( len < 60 )
a0003574:	2e24003c 	sltiu	a0,s1,60
a0003578:	10800004 	beqz	a0,a000358c <swNic_send+0xdc>
a000357c:	26310004 	addiu	s1,s1,4
        pPkthdr->ph_len = 64;
a0003580:	24040040 	li	a0,64
a0003584:	08000d64 	j	a0003590 <swNic_send+0xe0>
a0003588:	a4440004 	sh	a0,4(v0)
    else
        pPkthdr->ph_len = len + 4;
a000358c:	a4510004 	sh	s1,4(v0)
    pPkthdr->ph_mbuf->m_len       = pPkthdr->ph_len;
a0003590:	8c440000 	lw	a0,0(v0)
a0003594:	94450004 	lhu	a1,4(v0)
a0003598:	a4850008 	sh	a1,8(a0)
    pPkthdr->ph_mbuf->m_extsize = pPkthdr->ph_len;
a000359c:	8c440000 	lw	a0,0(v0)
a00035a0:	94450004 	lhu	a1,4(v0)
a00035a4:	a4850014 	sh	a1,20(a0)

    /* Set cluster pointer to buffer */
    pPkthdr->ph_mbuf->m_data    = pktbuf_alligned;
a00035a8:	8c440000 	lw	a0,0(v0)
a00035ac:	ac92000c 	sw	s2,12(a0)
    pPkthdr->ph_mbuf->m_extbuf = pktbuf_alligned;
a00035b0:	8c440000 	lw	a0,0(v0)
a00035b4:	ac920010 	sw	s2,16(a0)
#if defined(CONFIG_RTL8196D) || defined(CONFIG_RTL8196E)||defined(CONFIG_RTL8881A)
    pPkthdr->ph_ptpPkt = 0;
a00035b8:	8c440014 	lw	a0,20(v0)
a00035bc:	7c04c604 	ins	a0,zero,0x18,0x1
a00035c0:	ac440014 	sw	a0,20(v0)
#endif

    /* Set destination port */
#if defined(CONFIG_RTL8198)
    pPkthdr->ph_portlist = ALL_PORT_MASK;
a00035c4:	2404003f 	li	a0,63
a00035c8:	a044000f 	sb	a0,15(v0)
        {
                pPkthdr->ph_portlist = AP_MODE_PORT_MASK;//Port 4 Only for AP Mode
        }
#endif		
    /* Give descriptor to switch core */
    txPkthdrRing[0][currTxPkthdrDescIndex] |= DESC_SWCORE_OWNED;
a00035cc:	3c02a002 	lui	v0,0xa002
a00035d0:	8c428834 	lw	v0,-30668(v0)
a00035d4:	00431021 	addu	v0,v0,v1
a00035d8:	8c430000 	lw	v1,0(v0)
a00035dc:	34630001 	ori	v1,v1,0x1
a00035e0:	ac430000 	sw	v1,0(v0)

    /* Set TXFD bit to start send */
    REG32(CPUICR) |= TXFD;
a00035e4:	3c02b801 	lui	v0,0xb801
a00035e8:	8c440000 	lw	a0,0(v0)
a00035ec:	3c030080 	lui	v1,0x80
a00035f0:	00831825 	or	v1,a0,v1
a00035f4:	ac430000 	sw	v1,0(v0)
    txPktCounter++;
a00035f8:	3c02a002 	lui	v0,0xa002
a00035fc:	8c43886c 	lw	v1,-30612(v0)
a0003600:	24630001 	addiu	v1,v1,1
a0003604:	ac43886c 	sw	v1,-30612(v0)

	currTxPkthdrDescIndex = next_index;
a0003608:	3c02a002 	lui	v0,0xa002
a000360c:	ac508860 	sw	s0,-30624(v0)
a0003610:	00001021 	move	v0,zero
    return 0;
}
a0003614:	8fbf001c 	lw	ra,28(sp)
a0003618:	8fb20018 	lw	s2,24(sp)
a000361c:	8fb10014 	lw	s1,20(sp)
a0003620:	8fb00010 	lw	s0,16(sp)
a0003624:	03e00008 	jr	ra
a0003628:	27bd0020 	addiu	sp,sp,32

a000362c <swNic_receive>:
*                                                                         
*   OUTPUTS                                                               
*       None
*************************************************************************/
int32 swNic_receive(void** input, uint32* pLen)
{
a000362c:	27bdffd8 	addiu	sp,sp,-40
a0003630:	afbf0024 	sw	ra,36(sp)
a0003634:	afb30020 	sw	s3,32(sp)
a0003638:	afb2001c 	sw	s2,28(sp)
a000363c:	afb10018 	sw	s1,24(sp)
a0003640:	afb00014 	sw	s0,20(sp)
a0003644:	00808021 	move	s0,a0
a0003648:	00a08821 	move	s1,a1
    static int32 firstTime = 1;
    char	*data;
    int	ret=-1;

    /* Check OWN bit of descriptors */
    if ( (rxPkthdrRing[0][currRxPkthdrDescIndex] & DESC_OWNED_BIT) == DESC_RISC_OWNED )
a000364c:	3c02a002 	lui	v0,0xa002
a0003650:	8c428858 	lw	v0,-30632(v0)
a0003654:	3c03a002 	lui	v1,0xa002
a0003658:	8c638804 	lw	v1,-30716(v1)
a000365c:	00021080 	sll	v0,v0,0x2
a0003660:	00621021 	addu	v0,v1,v0
a0003664:	8c420000 	lw	v0,0(v0)
a0003668:	30440001 	andi	a0,v0,0x1
a000366c:	14800069 	bnez	a0,a0003814 <swNic_receive+0x1e8>
a0003670:	2403ffff 	li	v1,-1
    {
        //ASSERT_ISR(currRxPkthdrDescIndex < rxPkthdrRingCnt[0]);
        
        /* Fetch pkthdr */
        pPkthdr = (struct pktHdr *) (rxPkthdrRing[0][currRxPkthdrDescIndex] & 
a0003674:	2413fffc 	li	s3,-4
a0003678:	00539824 	and	s3,v0,s3
        //ASSERT_ISR(pPkthdr->ph_len); /* Not allow zero packet length */
        //ASSERT_ISR(pPkthdr->ph_len >= 64);
        //ASSERT_ISR(pPkthdr->ph_len <= 1522);

        /* Increment counter */
        rxPktCounter++;
a000367c:	3c02a002 	lui	v0,0xa002
a0003680:	8c438868 	lw	v1,-30616(v0)
a0003684:	24630001 	addiu	v1,v1,1
a0003688:	ac438868 	sw	v1,-30616(v0)

	data = pPkthdr->ph_mbuf->m_data;
a000368c:	8e620000 	lw	v0,0(s3)
a0003690:	8c52000c 	lw	s2,12(v0)
 		extern char eth0_mac[6]; 
	if ( (data[0]&0x1)||!memcmp(data, eth0_mac, 6) )

#else
		extern char eth0_mac[6];
		if ( (data[0]&0x1)||!memcmp(data, eth0_mac, 6) )
a0003694:	92420000 	lbu	v0,0(s2)
a0003698:	30420001 	andi	v0,v0,0x1
a000369c:	14400007 	bnez	v0,a00036bc <swNic_receive+0x90>
a00036a0:	02402021 	move	a0,s2
a00036a4:	3c05a001 	lui	a1,0xa001
a00036a8:	24a574f0 	addiu	a1,a1,29936
a00036ac:	0c002051 	jal	a0008144 <memcmp>
a00036b0:	24060006 	li	a2,6
a00036b4:	1440000e 	bnez	v0,a00036f0 <swNic_receive+0xc4>
a00036b8:	2403ffff 	li	v1,-1
#endif
		{

		
        /* Output packet */
		        *input = data;
a00036bc:	ae120000 	sw	s2,0(s0)
        *pLen = pPkthdr->ph_len - 4;
a00036c0:	96660004 	lhu	a2,4(s3)
a00036c4:	24c6fffc 	addiu	a2,a2,-4
a00036c8:	ae260000 	sw	a2,0(s1)
			ret = 0;


#if 1 //joey patch for inic
	   // for iNic & 8306 board, the received packet will has VLAN tag
	   if (*(unsigned short *)&(data[12]) == 0x8100)
a00036cc:	9644000c 	lhu	a0,12(s2)
a00036d0:	34028100 	li	v0,0x8100
a00036d4:	14820006 	bne	a0,v0,a00036f0 <swNic_receive+0xc4>
a00036d8:	00001821 	move	v1,zero
	   {
		    memcpy(&(data[12]), &(data[16]), *pLen - 16);
a00036dc:	2644000c 	addiu	a0,s2,12
a00036e0:	26450010 	addiu	a1,s2,16
a00036e4:	0c002046 	jal	a0008118 <memcpy>
a00036e8:	24c6fff0 	addiu	a2,a2,-16
a00036ec:	00001821 	move	v1,zero
			ddump(*input, 64);
//		else
//			ddump(*input, *pLen);
	}
#endif
        if ( !firstTime )
a00036f0:	3c02a001 	lui	v0,0xa001
a00036f4:	8c427510 	lw	v0,29968(v0)
a00036f8:	14400024 	bnez	v0,a000378c <swNic_receive+0x160>
a00036fc:	3c02a001 	lui	v0,0xa001
        {
            /* Calculate previous pkthdr and mbuf index */
            pkthdr_index = currRxPkthdrDescIndex;
a0003700:	3c02a002 	lui	v0,0xa002
a0003704:	8c448858 	lw	a0,-30632(v0)
            if ( --pkthdr_index < 0 )
a0003708:	2484ffff 	addiu	a0,a0,-1
a000370c:	04810005 	bgez	a0,a0003724 <swNic_receive+0xf8>
a0003710:	00042080 	sll	a0,a0,0x2
                pkthdr_index = rxPkthdrRingCnt[0] - 1;
a0003714:	3c02a002 	lui	v0,0xa002
a0003718:	8c44881c 	lw	a0,-30692(v0)
a000371c:	2484ffff 	addiu	a0,a0,-1
#if defined(CONFIG_RTL8196D) || defined(CONFIG_RTL8196E)||defined(CONFIG_RTL8881A)
            // for rx descriptor runout
            pPkthdr = (struct pktHdr *) (rxPkthdrRing[0][pkthdr_index] & ~(DESC_OWNED_BIT | DESC_WRAP));
a0003720:	00042080 	sll	a0,a0,0x2
a0003724:	3c02a002 	lui	v0,0xa002
a0003728:	8c428804 	lw	v0,-30716(v0)
a000372c:	00442021 	addu	a0,v0,a0
a0003730:	8c850000 	lw	a1,0(a0)
            mbuf_index = ((uint32)(pPkthdr->ph_mbuf) - (rxMbufRing[0] & ~(DESC_OWNED_BIT | DESC_WRAP))) /
a0003734:	2406fffc 	li	a2,-4
a0003738:	00a63824 	and	a3,a1,a2
a000373c:	3c02a002 	lui	v0,0xa002
a0003740:	8c488800 	lw	t0,-30720(v0)
a0003744:	8d080000 	lw	t0,0(t0)
a0003748:	01063024 	and	a2,t0,a2
a000374c:	8ce70000 	lw	a3,0(a3)
a0003750:	00e63023 	subu	a2,a3,a2
a0003754:	3c07aaaa 	lui	a3,0xaaaa
a0003758:	34e7aaab 	ori	a3,a3,0xaaab
a000375c:	00c70019 	multu	a2,a3
a0003760:	00003010 	mfhi	a2
a0003764:	00063102 	srl	a2,a2,0x4
            if ( --mbuf_index < 0 )
                mbuf_index = rxPkthdrRingCnt[0] - 1;
#endif
        
            /* Reset OWN bit */
            rxPkthdrRing[0][pkthdr_index] |= DESC_SWCORE_OWNED;
a0003768:	34a50001 	ori	a1,a1,0x1
a000376c:	ac850000 	sw	a1,0(a0)
            rxMbufRing[mbuf_index] |= DESC_SWCORE_OWNED;
a0003770:	00063080 	sll	a2,a2,0x2
a0003774:	8c428800 	lw	v0,-30720(v0)
a0003778:	00463021 	addu	a2,v0,a2
a000377c:	8cc20000 	lw	v0,0(a2)
a0003780:	34420001 	ori	v0,v0,0x1
a0003784:	08000de4 	j	a0003790 <swNic_receive+0x164>
a0003788:	acc20000 	sw	v0,0(a2)
        }
        else
            firstTime = 0;
a000378c:	ac407510 	sw	zero,29968(v0)
        
        /* Increment index */
        if ( ++currRxPkthdrDescIndex == rxPkthdrRingCnt[0] )
a0003790:	3c04a002 	lui	a0,0xa002
a0003794:	8c828858 	lw	v0,-30632(a0)
a0003798:	24420001 	addiu	v0,v0,1
a000379c:	ac828858 	sw	v0,-30632(a0)
a00037a0:	3c04a002 	lui	a0,0xa002
a00037a4:	8c84881c 	lw	a0,-30692(a0)
a00037a8:	14440003 	bne	v0,a0,a00037b8 <swNic_receive+0x18c>
a00037ac:	3c04a002 	lui	a0,0xa002
            currRxPkthdrDescIndex = 0;
a00037b0:	3c02a002 	lui	v0,0xa002
a00037b4:	ac408858 	sw	zero,-30632(v0)
        if ( ++currRxMbufDescIndex == rxMbufRingCnt )
a00037b8:	8c82885c 	lw	v0,-30628(a0)
a00037bc:	24420001 	addiu	v0,v0,1
a00037c0:	ac82885c 	sw	v0,-30628(a0)
a00037c4:	3c04a001 	lui	a0,0xa001
a00037c8:	8c847968 	lw	a0,31080(a0)
a00037cc:	14440004 	bne	v0,a0,a00037e0 <swNic_receive+0x1b4>
a00037d0:	3c02b801 	lui	v0,0xb801
            currRxMbufDescIndex = 0;
a00037d4:	3c02a002 	lui	v0,0xa002
a00037d8:	ac40885c 	sw	zero,-30628(v0)

        if ( REG32(CPUIISR) & PKTHDR_DESC_RUNOUT_IP_ALL )
a00037dc:	3c02b801 	lui	v0,0xb801
a00037e0:	3442002c 	ori	v0,v0,0x2c
a00037e4:	8c440000 	lw	a0,0(v0)
a00037e8:	3c02007e 	lui	v0,0x7e
a00037ec:	00821024 	and	v0,a0,v0
a00037f0:	10400008 	beqz	v0,a0003814 <swNic_receive+0x1e8>
a00037f4:	3c04b801 	lui	a0,0xb801
        {
            /* Enable and clear interrupt for continue reception */
            REG32(CPUIIMR) |= PKTHDR_DESC_RUNOUT_IE_ALL;
a00037f8:	34850028 	ori	a1,a0,0x28
a00037fc:	8ca60000 	lw	a2,0(a1)
a0003800:	3c02007e 	lui	v0,0x7e
a0003804:	00c23025 	or	a2,a2,v0
a0003808:	aca60000 	sw	a2,0(a1)
            REG32(CPUIISR) = PKTHDR_DESC_RUNOUT_IP_ALL;
a000380c:	3484002c 	ori	a0,a0,0x2c
a0003810:	ac820000 	sw	v0,0(a0)
        }
        return ret;
    }
    else
        return -1;
}
a0003814:	00601021 	move	v0,v1
a0003818:	8fbf0024 	lw	ra,36(sp)
a000381c:	8fb30020 	lw	s3,32(sp)
a0003820:	8fb2001c 	lw	s2,28(sp)
a0003824:	8fb10018 	lw	s1,24(sp)
a0003828:	8fb00014 	lw	s0,20(sp)
a000382c:	03e00008 	jr	ra
a0003830:	27bd0028 	addiu	sp,sp,40
	...

a0003840 <swTable_readEntry>:



#ifdef CONFIG_RTL865XC
int32 swTable_readEntry(uint32 tableType, uint32 eidx, void *entryContent_P)
{
a0003840:	27bdffe8 	addiu	sp,sp,-24
a0003844:	afbf0014 	sw	ra,20(sp)
    uint32 *    entryAddr;

    REG32(SWTCR0) = REG32(SWTCR0) | EN_STOP_TLU;
a0003848:	3c02bb80 	lui	v0,0xbb80
a000384c:	34424418 	ori	v0,v0,0x4418
a0003850:	8c470000 	lw	a3,0(v0)
a0003854:	3c030004 	lui	v1,0x4
a0003858:	00e31825 	or	v1,a3,v1
a000385c:	ac430000 	sw	v1,0(v0)
    while ((REG32(SWTCR0) & STOP_TLU_READY) == 0);
a0003860:	00403821 	move	a3,v0
a0003864:	3c030008 	lui	v1,0x8
a0003868:	8ce20000 	lw	v0,0(a3)
a000386c:	00431024 	and	v0,v0,v1
a0003870:	1040fffd 	beqz	v0,a0003868 <swTable_readEntry+0x28>
a0003874:	00000000 	nop

    ASSERT_CSP(entryContent_P);
a0003878:	14c00006 	bnez	a2,a0003894 <swTable_readEntry+0x54>
a000387c:	3402bb00 	li	v0,0xbb00
a0003880:	3c04a001 	lui	a0,0xa001
a0003884:	0c002325 	jal	a0008c94 <dprintf>
a0003888:	2484462c 	addiu	a0,a0,17964
a000388c:	08000e23 	j	a000388c <swTable_readEntry+0x4c>
a0003890:	00000000 	nop
    
    entryAddr = (uint32 *) (table_access_addr_base(tableType) + eidx * TABLE_ENTRY_DISTANCE);
a0003894:	00822021 	addu	a0,a0,v0
a0003898:	000422c0 	sll	a0,a0,0xb
a000389c:	00852821 	addu	a1,a0,a1
a00038a0:	00052940 	sll	a1,a1,0x5
    
    /* Wait for command ready */
    while ( (REG32(SWTACR) & ACTION_MASK) != ACTION_DONE );
a00038a4:	3c03bb80 	lui	v1,0xbb80
a00038a8:	34634d00 	ori	v1,v1,0x4d00
a00038ac:	8c620000 	lw	v0,0(v1)
a00038b0:	30420001 	andi	v0,v0,0x1
a00038b4:	1440fffd 	bnez	v0,a00038ac <swTable_readEntry+0x6c>
a00038b8:	00000000 	nop
    
    /* Read registers according to entry width of each table */
    *((uint32 *)entryContent_P + 7) = *(entryAddr + 7);
a00038bc:	8ca2001c 	lw	v0,28(a1)
a00038c0:	acc2001c 	sw	v0,28(a2)
    *((uint32 *)entryContent_P + 6) = *(entryAddr + 6);
a00038c4:	8ca20018 	lw	v0,24(a1)
a00038c8:	acc20018 	sw	v0,24(a2)
    *((uint32 *)entryContent_P + 5) = *(entryAddr + 5);
a00038cc:	8ca20014 	lw	v0,20(a1)
a00038d0:	acc20014 	sw	v0,20(a2)
    *((uint32 *)entryContent_P + 4) = *(entryAddr + 4);
a00038d4:	8ca20010 	lw	v0,16(a1)
a00038d8:	acc20010 	sw	v0,16(a2)
    *((uint32 *)entryContent_P + 3) = *(entryAddr + 3);
a00038dc:	8ca2000c 	lw	v0,12(a1)
a00038e0:	acc2000c 	sw	v0,12(a2)
    *((uint32 *)entryContent_P + 2) = *(entryAddr + 2);
a00038e4:	8ca20008 	lw	v0,8(a1)
a00038e8:	acc20008 	sw	v0,8(a2)
    *((uint32 *)entryContent_P + 1) = *(entryAddr + 1);
a00038ec:	8ca20004 	lw	v0,4(a1)
a00038f0:	acc20004 	sw	v0,4(a2)
    *((uint32 *)entryContent_P + 0) = *(entryAddr + 0);
a00038f4:	8ca20000 	lw	v0,0(a1)
a00038f8:	acc20000 	sw	v0,0(a2)

    REG32(SWTCR0) = REG32(SWTCR0) & ~EN_STOP_TLU;
a00038fc:	3c02bb80 	lui	v0,0xbb80
a0003900:	34424418 	ori	v0,v0,0x4418
a0003904:	8c440000 	lw	a0,0(v0)
a0003908:	3c03fffb 	lui	v1,0xfffb
a000390c:	3463ffff 	ori	v1,v1,0xffff
a0003910:	00831824 	and	v1,a0,v1
a0003914:	ac430000 	sw	v1,0(v0)

    return 0;
}
a0003918:	00001021 	move	v0,zero
a000391c:	8fbf0014 	lw	ra,20(sp)
a0003920:	03e00008 	jr	ra
a0003924:	27bd0018 	addiu	sp,sp,24

a0003928 <swTable_addEntry>:
 */
RTL_STATIC_INLINE void tableAccessForeword(uint32, uint32, void *);

#ifdef CONFIG_RTL865XC
int32 swTable_addEntry(uint32 tableType, uint32 eidx, void *entryContent_P)
{
a0003928:	27bdffe8 	addiu	sp,sp,-24
a000392c:	afbf0014 	sw	ra,20(sp)
    REG32(SWTCR0) = REG32(SWTCR0) | EN_STOP_TLU;
a0003930:	3c02bb80 	lui	v0,0xbb80
a0003934:	34424418 	ori	v0,v0,0x4418
a0003938:	8c470000 	lw	a3,0(v0)
a000393c:	3c030004 	lui	v1,0x4
a0003940:	00e31825 	or	v1,a3,v1
a0003944:	ac430000 	sw	v1,0(v0)
    while ((REG32(SWTCR0) & STOP_TLU_READY) == 0);
a0003948:	00403821 	move	a3,v0
a000394c:	3c030008 	lui	v1,0x8
a0003950:	8ce20000 	lw	v0,0(a3)
a0003954:	00431024 	and	v0,v0,v1
a0003958:	1040fffd 	beqz	v0,a0003950 <swTable_addEntry+0x28>
a000395c:	00000000 	nop


//RTL_STATIC_INLINE void tableAccessForeword(uint32 tableType, uint32 eidx,     void *entryContent_P)
void tableAccessForeword(uint32 tableType, uint32 eidx,     void *entryContent_P)
{
    ASSERT_CSP(entryContent_P);
a0003960:	14c00006 	bnez	a2,a000397c <swTable_addEntry+0x54>
a0003964:	3c03bb80 	lui	v1,0xbb80
a0003968:	3c04a001 	lui	a0,0xa001
a000396c:	0c002325 	jal	a0008c94 <dprintf>
a0003970:	2484462c 	addiu	a0,a0,17964
a0003974:	08000e5d 	j	a0003974 <swTable_addEntry+0x4c>
a0003978:	00000000 	nop

    /* Wait for command done */
    while ( (REG32(SWTACR) & ACTION_MASK) != ACTION_DONE );
a000397c:	34634d00 	ori	v1,v1,0x4d00
a0003980:	8c620000 	lw	v0,0(v1)
a0003984:	30420001 	andi	v0,v0,0x1
a0003988:	1440fffd 	bnez	v0,a0003980 <swTable_addEntry+0x58>
a000398c:	3c02bb80 	lui	v0,0xbb80
    
    /* Write registers according to entry width of each table */
    REG32(TCR7) = *((uint32 *)entryContent_P + 7);
a0003990:	8cc7001c 	lw	a3,28(a2)
a0003994:	34434d3c 	ori	v1,v0,0x4d3c
a0003998:	ac670000 	sw	a3,0(v1)
    REG32(TCR6) = *((uint32 *)entryContent_P + 6);
a000399c:	8cc70018 	lw	a3,24(a2)
a00039a0:	34434d38 	ori	v1,v0,0x4d38
a00039a4:	ac670000 	sw	a3,0(v1)
    REG32(TCR5) = *((uint32 *)entryContent_P + 5);
a00039a8:	8cc70014 	lw	a3,20(a2)
a00039ac:	34434d34 	ori	v1,v0,0x4d34
a00039b0:	ac670000 	sw	a3,0(v1)
    REG32(TCR4) = *((uint32 *)entryContent_P + 4);
a00039b4:	8cc70010 	lw	a3,16(a2)
a00039b8:	34434d30 	ori	v1,v0,0x4d30
a00039bc:	ac670000 	sw	a3,0(v1)
    REG32(TCR3) = *((uint32 *)entryContent_P + 3);
a00039c0:	8cc7000c 	lw	a3,12(a2)
a00039c4:	34434d2c 	ori	v1,v0,0x4d2c
a00039c8:	ac670000 	sw	a3,0(v1)
    REG32(TCR2) = *((uint32 *)entryContent_P + 2);
a00039cc:	8cc70008 	lw	a3,8(a2)
a00039d0:	34434d28 	ori	v1,v0,0x4d28
a00039d4:	ac670000 	sw	a3,0(v1)
    REG32(TCR1) = *((uint32 *)entryContent_P + 1);
a00039d8:	8cc70004 	lw	a3,4(a2)
a00039dc:	34434d24 	ori	v1,v0,0x4d24
a00039e0:	ac670000 	sw	a3,0(v1)
    REG32(TCR0) = *(uint32 *)entryContent_P;
a00039e4:	8cc60000 	lw	a2,0(a2)
a00039e8:	34434d20 	ori	v1,v0,0x4d20
a00039ec:	ac660000 	sw	a2,0(v1)
    
    /* Fill address */
    REG32(SWTAA) = table_access_addr_base(tableType) + eidx * TABLE_ENTRY_DISTANCE;
a00039f0:	3403bb00 	li	v1,0xbb00
a00039f4:	00832021 	addu	a0,a0,v1
a00039f8:	000422c0 	sll	a0,a0,0xb
a00039fc:	00852821 	addu	a1,a0,a1
a0003a00:	00052940 	sll	a1,a1,0x5
a0003a04:	34434d08 	ori	v1,v0,0x4d08
a0003a08:	ac650000 	sw	a1,0(v1)
    while ((REG32(SWTCR0) & STOP_TLU_READY) == 0);

    tableAccessForeword(tableType, eidx, entryContent_P);
        
    /* Activate add command */
    REG32(SWTACR) = ACTION_START | CMD_ADD;
a0003a0c:	34424d00 	ori	v0,v0,0x4d00
a0003a10:	24030003 	li	v1,3
a0003a14:	ac430000 	sw	v1,0(v0)
    
    /* Wait for command done */
    while ( (REG32(SWTACR) & ACTION_MASK) != ACTION_DONE );
a0003a18:	00401821 	move	v1,v0
a0003a1c:	8c620000 	lw	v0,0(v1)
a0003a20:	30420001 	andi	v0,v0,0x1
a0003a24:	1440fffd 	bnez	v0,a0003a1c <swTable_addEntry+0xf4>
a0003a28:	3c02bb80 	lui	v0,0xbb80

    REG32(SWTCR0) = REG32(SWTCR0) & ~EN_STOP_TLU;
a0003a2c:	34434418 	ori	v1,v0,0x4418
a0003a30:	8c650000 	lw	a1,0(v1)
a0003a34:	3c04fffb 	lui	a0,0xfffb
a0003a38:	3484ffff 	ori	a0,a0,0xffff
a0003a3c:	00a42024 	and	a0,a1,a0
a0003a40:	ac640000 	sw	a0,0(v1)

    /* Check status */
    if ( (REG32(SWTASR) & TABSTS_MASK) != TABSTS_SUCCESS )
a0003a44:	34424d04 	ori	v0,v0,0x4d04
a0003a48:	8c430000 	lw	v1,0(v0)
a0003a4c:	30630001 	andi	v1,v1,0x1
        return ECOLLISION;
    else
        return 0;
}
a0003a50:	24020058 	li	v0,88
a0003a54:	0003100a 	movz	v0,zero,v1
a0003a58:	8fbf0014 	lw	ra,20(sp)
a0003a5c:	03e00008 	jr	ra
a0003a60:	27bd0018 	addiu	sp,sp,24
	...

a0003a70 <lx4180_ReadStatus>:
extern int32 swTable_readEntry(uint32 tableType, uint32 eidx, void *entryContent_P);

#include <asm/mipsregs.h>
//wei add
int lx4180_ReadStatus()
{
a0003a70:	27bdfff8 	addiu	sp,sp,-8
   volatile unsigned int reg;
	reg= read_32bit_cp0_register(CP0_STATUS);
a0003a74:	40026000 	mfc0	v0,c0_status
a0003a78:	afa20000 	sw	v0,0(sp)
	...
	__asm__ volatile("nop");	// david
   	__asm__ volatile("nop");   
	return reg;
a0003a84:	8fa20000 	lw	v0,0(sp)

}
a0003a88:	03e00008 	jr	ra
a0003a8c:	27bd0008 	addiu	sp,sp,8

a0003a90 <lx4180_WriteStatus>:
void lx4180_WriteStatus(int s)
{
a0003a90:	27bdfff8 	addiu	sp,sp,-8
   volatile unsigned int reg=s;
a0003a94:	afa40000 	sw	a0,0(sp)
	write_32bit_cp0_register(CP0_STATUS, reg);
a0003a98:	8fa20000 	lw	v0,0(sp)
a0003a9c:	40826000 	mtc0	v0,c0_status
a0003aa0:	00000040 	ssnop
a0003aa4:	00000040 	ssnop
a0003aa8:	00000040 	ssnop
a0003aac:	00000040 	ssnop
	...
	__asm__ volatile("nop");	// david
   	__asm__ volatile("nop");   
	return ;

}
a0003ab8:	03e00008 	jr	ra
a0003abc:	27bd0008 	addiu	sp,sp,8

a0003ac0 <vlanTable_setStpStatusOfAllPorts>:


int32 vlanTable_setStpStatusOfAllPorts(uint32 vid, uint32 STPStatus)
{

}
a0003ac0:	03e00008 	jr	ra
a0003ac4:	00000000 	nop

a0003ac8 <vlanTable_create>:




int32 vlanTable_create(uint32 vid, rtl_vlan_param_t * param)
{
a0003ac8:	27bdffc0 	addiu	sp,sp,-64
a0003acc:	afbf003c 	sw	ra,60(sp)
a0003ad0:	afb20038 	sw	s2,56(sp)
a0003ad4:	afb10034 	sw	s1,52(sp)
a0003ad8:	afb00030 	sw	s0,48(sp)
a0003adc:	00809021 	move	s2,a0
    vlan_table_t    entryContent;
    uint32	temp,temp2;
    
    ASSERT_CSP(param);
a0003ae0:	14a00006 	bnez	a1,a0003afc <vlanTable_create+0x34>
a0003ae4:	00a08021 	move	s0,a1
a0003ae8:	3c04a001 	lui	a0,0xa001
a0003aec:	0c002325 	jal	a0008c94 <dprintf>
a0003af0:	2484462c 	addiu	a0,a0,17964
a0003af4:	08000ebd 	j	a0003af4 <vlanTable_create+0x2c>
a0003af8:	00000000 	nop
    
    // disable interrupt
    // I don't know the reason but if you want to use "-O" flag, must disalbe interrupt before swTable_readEntry();
    temp = lx4180_ReadStatus();
a0003afc:	0c000e9c 	jal	a0003a70 <lx4180_ReadStatus>
a0003b00:	00000000 	nop
    if (0!=temp&0x1) {
a0003b04:	1040000c 	beqz	v0,a0003b38 <vlanTable_create+0x70>
a0003b08:	00408821 	move	s1,v0
	    temp2 = temp&0xfffffffe;
	    lx4180_WriteStatus(temp2);
a0003b0c:	2402fffe 	li	v0,-2
a0003b10:	0c000ea4 	jal	a0003a90 <lx4180_WriteStatus>
a0003b14:	02222024 	and	a0,s1,v0
    }
    
    swTable_readEntry(TYPE_VLAN_TABLE, vid, &entryContent);
a0003b18:	24040006 	li	a0,6
a0003b1c:	02402821 	move	a1,s2
a0003b20:	0c000e10 	jal	a0003840 <swTable_readEntry>
a0003b24:	27a60010 	addiu	a2,sp,16
    
    // restore status register
    if (0!=temp&0x1) {
	    lx4180_WriteStatus(temp);
a0003b28:	0c000ea4 	jal	a0003a90 <lx4180_WriteStatus>
a0003b2c:	02202021 	move	a0,s1
    }

    bzero( (void *) &entryContent, sizeof(entryContent) );
a0003b30:	08000ed3 	j	a0003b4c <vlanTable_create+0x84>
a0003b34:	27b10010 	addiu	s1,sp,16
    if (0!=temp&0x1) {
	    temp2 = temp&0xfffffffe;
	    lx4180_WriteStatus(temp2);
    }
    
    swTable_readEntry(TYPE_VLAN_TABLE, vid, &entryContent);
a0003b38:	24040006 	li	a0,6
a0003b3c:	02402821 	move	a1,s2
a0003b40:	0c000e10 	jal	a0003840 <swTable_readEntry>
a0003b44:	27a60010 	addiu	a2,sp,16
    // restore status register
    if (0!=temp&0x1) {
	    lx4180_WriteStatus(temp);
    }

    bzero( (void *) &entryContent, sizeof(entryContent) );
a0003b48:	27b10010 	addiu	s1,sp,16
a0003b4c:	02202021 	move	a0,s1
a0003b50:	00002821 	move	a1,zero
a0003b54:	0c00203d 	jal	a00080f4 <memset>
a0003b58:	24060020 	li	a2,32
    entryContent.memberPort = param->memberPort & ALL_PORT_MASK;
a0003b5c:	92020003 	lbu	v0,3(s0)
    entryContent.egressUntag = param->egressUntag;
a0003b60:	8e030004 	lw	v1,4(s0)
a0003b64:	3042003f 	andi	v0,v0,0x3f
a0003b68:	7c627244 	ins	v0,v1,0x9,0x6
    entryContent.fid = param->fid;
a0003b6c:	8e030008 	lw	v1,8(s0)
a0003b70:	7c630f80 	ext	v1,v1,0x1e,0x2
a0003b74:	7c629c84 	ins	v0,v1,0x12,0x2
a0003b78:	afa20010 	sw	v0,16(sp)
#if (defined(CONFIG_RTL8196D) || defined(CONFIG_RTL8196E)||defined(CONFIG_RTL8881A)) && !defined(CONFIG_RTL8198C)
    entryContent.vid = vid;
#endif

    /* Write into hardware */
    if ( swTable_addEntry(TYPE_VLAN_TABLE, vid, &entryContent) == 0 )
a0003b7c:	24040006 	li	a0,6
a0003b80:	02402821 	move	a1,s2
a0003b84:	0c000e4a 	jal	a0003928 <swTable_addEntry>
a0003b88:	02203021 	move	a2,s1
a0003b8c:	14400006 	bnez	v0,a0003ba8 <vlanTable_create+0xe0>
a0003b90:	8fbf003c 	lw	ra,60(sp)
        return 0;
    else
        /* There might be something wrong */
        ASSERT_CSP( 0 );
}
a0003b94:	8fb20038 	lw	s2,56(sp)
a0003b98:	8fb10034 	lw	s1,52(sp)
a0003b9c:	8fb00030 	lw	s0,48(sp)
a0003ba0:	03e00008 	jr	ra
a0003ba4:	27bd0040 	addiu	sp,sp,64
    /* Write into hardware */
    if ( swTable_addEntry(TYPE_VLAN_TABLE, vid, &entryContent) == 0 )
        return 0;
    else
        /* There might be something wrong */
        ASSERT_CSP( 0 );
a0003ba8:	3c04a001 	lui	a0,0xa001
a0003bac:	0c002325 	jal	a0008c94 <dprintf>
a0003bb0:	2484462c 	addiu	a0,a0,17964
a0003bb4:	08000eed 	j	a0003bb4 <vlanTable_create+0xec>
a0003bb8:	00000000 	nop

a0003bbc <swCore_netifCreate>:
        ASSERT_CSP( 0 );
}
#endif

int32 swCore_netifCreate(uint32 idx, rtl_netif_param_t * param)
{
a0003bbc:	27bdffc0 	addiu	sp,sp,-64
a0003bc0:	afbf003c 	sw	ra,60(sp)
a0003bc4:	afb20038 	sw	s2,56(sp)
a0003bc8:	afb10034 	sw	s1,52(sp)
a0003bcc:	afb00030 	sw	s0,48(sp)
a0003bd0:	00809021 	move	s2,a0
    netif_table_t    entryContent;
    uint32	temp,temp2;
    
    ASSERT_CSP(param);
a0003bd4:	14a00006 	bnez	a1,a0003bf0 <swCore_netifCreate+0x34>
a0003bd8:	00a08021 	move	s0,a1
a0003bdc:	3c04a001 	lui	a0,0xa001
a0003be0:	0c002325 	jal	a0008c94 <dprintf>
a0003be4:	2484462c 	addiu	a0,a0,17964
a0003be8:	08000efa 	j	a0003be8 <swCore_netifCreate+0x2c>
a0003bec:	00000000 	nop
    
    // disable interrupt
    // I don't know the reason but if you want to use "-O" flag, must disalbe interrupt before swTable_readEntry();
    temp = lx4180_ReadStatus();
a0003bf0:	0c000e9c 	jal	a0003a70 <lx4180_ReadStatus>
a0003bf4:	00000000 	nop
    if (0!=temp&0x1) {
a0003bf8:	1040000c 	beqz	v0,a0003c2c <swCore_netifCreate+0x70>
a0003bfc:	00408821 	move	s1,v0
	    temp2 = temp&0xfffffffe;
	    lx4180_WriteStatus(temp2);
a0003c00:	2402fffe 	li	v0,-2
a0003c04:	0c000ea4 	jal	a0003a90 <lx4180_WriteStatus>
a0003c08:	02222024 	and	a0,s1,v0
    }

    swTable_readEntry(TYPE_NETINTERFACE_TABLE, idx, &entryContent);
a0003c0c:	24040004 	li	a0,4
a0003c10:	02402821 	move	a1,s2
a0003c14:	0c000e10 	jal	a0003840 <swTable_readEntry>
a0003c18:	27a60010 	addiu	a2,sp,16

    // restore status register
    if (0!=temp&0x1) {
	    lx4180_WriteStatus(temp);
a0003c1c:	0c000ea4 	jal	a0003a90 <lx4180_WriteStatus>
a0003c20:	02202021 	move	a0,s1
    }
    
    if ( entryContent.valid )
a0003c24:	08000f10 	j	a0003c40 <swCore_netifCreate+0x84>
a0003c28:	8fa20010 	lw	v0,16(sp)
    if (0!=temp&0x1) {
	    temp2 = temp&0xfffffffe;
	    lx4180_WriteStatus(temp2);
    }

    swTable_readEntry(TYPE_NETINTERFACE_TABLE, idx, &entryContent);
a0003c2c:	24040004 	li	a0,4
a0003c30:	02402821 	move	a1,s2
a0003c34:	0c000e10 	jal	a0003840 <swTable_readEntry>
a0003c38:	27a60010 	addiu	a2,sp,16
    // restore status register
    if (0!=temp&0x1) {
	    lx4180_WriteStatus(temp);
    }
    
    if ( entryContent.valid )
a0003c3c:	8fa20010 	lw	v0,16(sp)
a0003c40:	30420001 	andi	v0,v0,0x1
a0003c44:	14400066 	bnez	v0,a0003de0 <swCore_netifCreate+0x224>
a0003c48:	24030011 	li	v1,17
    {
       return EEXIST;
    }

    bzero( (void *) &entryContent, sizeof(entryContent) );
a0003c4c:	27a40010 	addiu	a0,sp,16
a0003c50:	00002821 	move	a1,zero
a0003c54:	0c00203d 	jal	a00080f4 <memset>
a0003c58:	24060020 	li	a2,32
    entryContent.valid = param->valid;
a0003c5c:	8e030020 	lw	v1,32(s0)
a0003c60:	7c620780 	ext	v0,v1,0x1e,0x1
a0003c64:	8fa40010 	lw	a0,16(sp)
a0003c68:	7c440004 	ins	a0,v0,0x0,0x1
    entryContent.vid = param->vid;
a0003c6c:	9602000a 	lhu	v0,10(s0)
a0003c70:	7c446044 	ins	a0,v0,0x1,0xc

    entryContent.mac47_19 = ((param->gMac.mac47_32 << 13) | (param->gMac.mac31_16 >> 3)) & 0x1FFFFFFF;
a0003c74:	96050002 	lhu	a1,2(s0)
a0003c78:	000530c2 	srl	a2,a1,0x3
a0003c7c:	96020000 	lhu	v0,0(s0)
a0003c80:	00021340 	sll	v0,v0,0xd
a0003c84:	00c23025 	or	a2,a2,v0
a0003c88:	8fa20014 	lw	v0,20(sp)
a0003c8c:	7cc2e004 	ins	v0,a2,0x0,0x1d
    entryContent.mac18_0 = ((param->gMac.mac31_16 << 16) | param->gMac.mac15_0) & 0x7FFFF;
a0003c90:	00052c00 	sll	a1,a1,0x10
a0003c94:	96060004 	lhu	a2,4(s0)
a0003c98:	00a62825 	or	a1,a1,a2
a0003c9c:	3c060007 	lui	a2,0x7
a0003ca0:	34c6ffff 	ori	a2,a2,0xffff
a0003ca4:	00a62824 	and	a1,a1,a2
a0003ca8:	7ca4fb44 	ins	a0,a1,0xd,0x13
a0003cac:	afa40010 	sw	a0,16(sp)

#if defined(CONFIG_RTL8198C)
	entryContent.inACLStartH = (param->inAclStart >>1)&0x7f;
a0003cb0:	8e05000c 	lw	a1,12(s0)
a0003cb4:	7ca63040 	ext	a2,a1,0x1,0x7
a0003cb8:	8fa40018 	lw	a0,24(sp)
a0003cbc:	7cc43004 	ins	a0,a2,0x0,0x7
	entryContent.inACLStartL = param->inAclStart&0x1;
a0003cc0:	7ca2ffc4 	ins	v0,a1,0x1f,0x1
	entryContent.inACLEnd    = param->inAclEnd;
a0003cc4:	8e050010 	lw	a1,16(s0)
a0003cc8:	7ca471c4 	ins	a0,a1,0x7,0x8
	entryContent.outACLStart = param->outAclStart;
a0003ccc:	8e050014 	lw	a1,20(s0)
a0003cd0:	7ca4b3c4 	ins	a0,a1,0xf,0x8
	entryContent.outACLEnd   = param->outAclEnd;
a0003cd4:	8e050018 	lw	a1,24(s0)
a0003cd8:	7ca4f5c4 	ins	a0,a1,0x17,0x8
a0003cdc:	afa40018 	sw	a0,24(sp)
	entryContent.enHWRouteV6 = 0;
a0003ce0:	7c02f784 	ins	v0,zero,0x1e,0x1
	entryContent.enHWRoute   = param->enableRoute;
a0003ce4:	7c6307c0 	ext	v1,v1,0x1f,0x1
a0003ce8:	7c62ef44 	ins	v0,v1,0x1d,0x1
a0003cec:	afa20014 	sw	v0,20(sp)
	switch(param->macAddrNumber) {
a0003cf0:	96020008 	lhu	v0,8(s0)
a0003cf4:	2c420009 	sltiu	v0,v0,9
a0003cf8:	10400039 	beqz	v0,a0003de0 <swCore_netifCreate+0x224>
a0003cfc:	24030011 	li	v1,17
a0003d00:	96030008 	lhu	v1,8(s0)
a0003d04:	00031880 	sll	v1,v1,0x2
a0003d08:	3c02a001 	lui	v0,0xa001
a0003d0c:	24420000 	addiu	v0,v0,0
a0003d10:	00431021 	addu	v0,v0,v1
a0003d14:	8c420000 	lw	v0,0(v0)
a0003d18:	00400008 	jr	v0
a0003d1c:	00000000 	nop
		case 0:
		case 1:
		    entryContent.macMaskL = 1;
a0003d20:	8fa20018 	lw	v0,24(sp)
a0003d24:	24030001 	li	v1,1
a0003d28:	7c62ffc4 	ins	v0,v1,0x1f,0x1
a0003d2c:	afa20018 	sw	v0,24(sp)
		    entryContent.macMaskH = 3;
a0003d30:	8fa2001c 	lw	v0,28(sp)
a0003d34:	24030003 	li	v1,3
a0003d38:	7c620804 	ins	v0,v1,0x0,0x2
		break;
a0003d3c:	08000f67 	j	a0003d9c <swCore_netifCreate+0x1e0>
a0003d40:	afa2001c 	sw	v0,28(sp)
		case 2:
		    entryContent.macMaskL = 0;
a0003d44:	8fa20018 	lw	v0,24(sp)
a0003d48:	7c02ffc4 	ins	v0,zero,0x1f,0x1
a0003d4c:	afa20018 	sw	v0,24(sp)
		    entryContent.macMaskH = 3;
a0003d50:	8fa2001c 	lw	v0,28(sp)
a0003d54:	24030003 	li	v1,3
a0003d58:	7c620804 	ins	v0,v1,0x0,0x2
		break;
a0003d5c:	08000f67 	j	a0003d9c <swCore_netifCreate+0x1e0>
a0003d60:	afa2001c 	sw	v0,28(sp)
		case 4:
		    entryContent.macMaskL = 0;
a0003d64:	8fa20018 	lw	v0,24(sp)
a0003d68:	7c02ffc4 	ins	v0,zero,0x1f,0x1
a0003d6c:	afa20018 	sw	v0,24(sp)
		    entryContent.macMaskH = 2;
a0003d70:	8fa2001c 	lw	v0,28(sp)
a0003d74:	24030002 	li	v1,2
a0003d78:	7c620804 	ins	v0,v1,0x0,0x2
		break;
a0003d7c:	08000f67 	j	a0003d9c <swCore_netifCreate+0x1e0>
a0003d80:	afa2001c 	sw	v0,28(sp)
		case 8:
		    entryContent.macMaskL = 0;
a0003d84:	8fa20018 	lw	v0,24(sp)
a0003d88:	7c02ffc4 	ins	v0,zero,0x1f,0x1
a0003d8c:	afa20018 	sw	v0,24(sp)
		    entryContent.macMaskH = 0;
a0003d90:	8fa2001c 	lw	v0,28(sp)
a0003d94:	7c020804 	ins	v0,zero,0x0,0x2
a0003d98:	afa2001c 	sw	v0,28(sp)
			break;
		default:
		    return EEXIST;//Not permitted macNumber value
	}

	entryContent.mtu   = param->mtu;
a0003d9c:	8e03001c 	lw	v1,28(s0)
a0003da0:	8fa2001c 	lw	v0,28(sp)
a0003da4:	7c628084 	ins	v0,v1,0x2,0xf
	entryContent.mtuv6 = param->mtu;
a0003da8:	7c62fc44 	ins	v0,v1,0x11,0xf
a0003dac:	afa2001c 	sw	v0,28(sp)
    entryContent.mtuH = param->mtu >> 3;
    entryContent.mtuL = param->mtu & 0x7;
#endif

    /* Write into hardware */
    if ( swTable_addEntry(TYPE_NETINTERFACE_TABLE, idx, &entryContent) == 0 )
a0003db0:	24040004 	li	a0,4
a0003db4:	02402821 	move	a1,s2
a0003db8:	0c000e4a 	jal	a0003928 <swTable_addEntry>
a0003dbc:	27a60010 	addiu	a2,sp,16
a0003dc0:	10400007 	beqz	v0,a0003de0 <swCore_netifCreate+0x224>
a0003dc4:	00001821 	move	v1,zero
        return 0;
    else
        /* There might be something wrong */
        ASSERT_CSP( 0 );
a0003dc8:	3c04a001 	lui	a0,0xa001
a0003dcc:	0c002325 	jal	a0008c94 <dprintf>
a0003dd0:	2484462c 	addiu	a0,a0,17964
a0003dd4:	08000f75 	j	a0003dd4 <swCore_netifCreate+0x218>
a0003dd8:	00000000 	nop
a0003ddc:	24030011 	li	v1,17
}
a0003de0:	00601021 	move	v0,v1
a0003de4:	8fbf003c 	lw	ra,60(sp)
a0003de8:	8fb20038 	lw	s2,56(sp)
a0003dec:	8fb10034 	lw	s1,52(sp)
a0003df0:	8fb00030 	lw	s0,48(sp)
a0003df4:	03e00008 	jr	ra
a0003df8:	27bd0040 	addiu	sp,sp,64
a0003dfc:	00000000 	nop

a0003e00 <check_ready_nand>:
void 
check_ready_nand (void ) 
{
  while (1)
    {
      if ((rtk_readl (NACR) & 0x80000000) == 0x80000000)
a0003e00:	3c04b801 	lui	a0,0xb801
a0003e04:	3482a004 	ori	v0,a0,0xa004
a0003e08:	8c430000 	lw	v1,0(v0)
a0003e0c:	0461fffe 	bgez	v1,a0003e08 <check_ready_nand+0x8>
a0003e10:	00000000 	nop
        break;
    }
}
a0003e14:	03e00008 	jr	ra
a0003e18:	00000000 	nop

a0003e1c <rtk_nand_read_id>:

int 
rtk_nand_read_id () 
{
a0003e1c:	27bdffe0 	addiu	sp,sp,-32
a0003e20:	afbf001c 	sw	ra,28(sp)
a0003e24:	afb20018 	sw	s2,24(sp)
a0003e28:	afb10014 	sw	s1,20(sp)
a0003e2c:	afb00010 	sw	s0,16(sp)
  int i;
  int id_chain;
  
    //unsigned char id[5];
    check_ready_nand ();
a0003e30:	0c000f80 	jal	a0003e00 <check_ready_nand>
a0003e34:	3c10b801 	lui	s0,0xb801
  
    //rtk_writel( (rtk_readl(NACR) |ECC_enable|RBO|WBO), NACR);
    rtk_writel ((rtk_readl (NACR) | ECC_enable), NACR);
a0003e38:	3603a004 	ori	v1,s0,0xa004
a0003e3c:	8c640000 	lw	a0,0(v1)
a0003e40:	3c024000 	lui	v0,0x4000
a0003e44:	00822025 	or	a0,a0,v0
a0003e48:	ac640000 	sw	a0,0(v1)
  rtk_writel (0x0, NACMR);
a0003e4c:	3611a008 	ori	s1,s0,0xa008
a0003e50:	ae200000 	sw	zero,0(s1)
  rtk_writel ((CECS0 | CMD_READ_ID), NACMR);   //read ID command
a0003e54:	34420090 	ori	v0,v0,0x90
a0003e58:	ae220000 	sw	v0,0(s1)
  check_ready_nand ();
a0003e5c:	0c000f80 	jal	a0003e00 <check_ready_nand>
a0003e60:	3612a00c 	ori	s2,s0,0xa00c
  rtk_writel (0x0, NAADR);
a0003e64:	ae400000 	sw	zero,0(s2)
  rtk_writel ((0x0 | AD2EN | AD1EN | AD0EN), NAADR);   //dummy address cycle
a0003e68:	3c020700 	lui	v0,0x700
a0003e6c:	ae420000 	sw	v0,0(s2)
  check_ready_nand ();
a0003e70:	0c000f80 	jal	a0003e00 <check_ready_nand>
a0003e74:	3610a014 	ori	s0,s0,0xa014
  id_chain = rtk_readl (NADR);
a0003e78:	8e020000 	lw	v0,0(s0)
  id[2] = (id_chain >> 16) & 0xff;
  id[3] = (id_chain >> 24) & 0xff;
  id[4] = id_chain & 0xff;
  
#else   /*  */
    rtk_writel (0x0, NACMR);
a0003e7c:	ae200000 	sw	zero,0(s1)
  rtk_writel (0x0, NAADR);
a0003e80:	ae400000 	sw	zero,0(s2)
  return id_chain;
  
#endif  /*  */
}
a0003e84:	8fbf001c 	lw	ra,28(sp)
a0003e88:	8fb20018 	lw	s2,24(sp)
a0003e8c:	8fb10014 	lw	s1,20(sp)
a0003e90:	8fb00010 	lw	s0,16(sp)
a0003e94:	03e00008 	jr	ra
a0003e98:	27bd0020 	addiu	sp,sp,32

a0003e9c <shift_value>:
unsigned int shift_value(unsigned int x)
{
	int r = 1;

        if (!x)
a0003e9c:	10800018 	beqz	a0,a0003f00 <shift_value+0x64>
a0003ea0:	00001021 	move	v0,zero
                return 0;
        if (!(x & 0xffff)) {
a0003ea4:	3083ffff 	andi	v1,a0,0xffff
a0003ea8:	14600003 	bnez	v1,a0003eb8 <shift_value+0x1c>
a0003eac:	24020001 	li	v0,1
                x >>= 16;
a0003eb0:	00042402 	srl	a0,a0,0x10
a0003eb4:	24020011 	li	v0,17
                r += 16;
        }
        if (!(x & 0xff)) {
a0003eb8:	308300ff 	andi	v1,a0,0xff
a0003ebc:	14600004 	bnez	v1,a0003ed0 <shift_value+0x34>
a0003ec0:	3083000f 	andi	v1,a0,0xf
                x >>= 8;
a0003ec4:	00042202 	srl	a0,a0,0x8
                r += 8;
a0003ec8:	24420008 	addiu	v0,v0,8
        }
        if (!(x & 0xf)) {
a0003ecc:	3083000f 	andi	v1,a0,0xf
a0003ed0:	14600004 	bnez	v1,a0003ee4 <shift_value+0x48>
a0003ed4:	30830003 	andi	v1,a0,0x3
                x >>= 4;
a0003ed8:	00042102 	srl	a0,a0,0x4
                r += 4;
a0003edc:	24420004 	addiu	v0,v0,4
        }
        if (!(x & 3)) {
a0003ee0:	30830003 	andi	v1,a0,0x3
a0003ee4:	14600003 	bnez	v1,a0003ef4 <shift_value+0x58>
a0003ee8:	00000000 	nop
                x >>= 2;
a0003eec:	00042082 	srl	a0,a0,0x2
                r += 2;
a0003ef0:	24420002 	addiu	v0,v0,2
        }
        if (!(x & 1)) {
a0003ef4:	30840001 	andi	a0,a0,0x1
                x >>= 1;
                r += 1;
a0003ef8:	2c840001 	sltiu	a0,a0,1
        }
        return r;
a0003efc:	00441021 	addu	v0,v0,a0
}
a0003f00:	03e00008 	jr	ra
a0003f04:	00000000 	nop

a0003f08 <rtk_nand_strapin_setting>:

  /*Enable NAND Flash IP clock */
#define REG32(reg)  (*(volatile unsigned int *)(reg))
  //REG32(clk_manage_REG) |= 1 << 28;

REG32(clk_manage_REG) |= ((1 << 28)| (3<<12)| (7<<18));
a0003f08:	3c02b800 	lui	v0,0xb800
a0003f0c:	34430010 	ori	v1,v0,0x10
a0003f10:	8c650000 	lw	a1,0(v1)
a0003f14:	3c04101c 	lui	a0,0x101c
a0003f18:	34843000 	ori	a0,a0,0x3000
a0003f1c:	00a42025 	or	a0,a1,a0
a0003f20:	ac640000 	sw	a0,0(v1)

#define PINMUX_SEL_1 0xb8000100
#define PINMUX_SEL_2 0xb8000104
#define PINMUX_SEL_3 0xb8000108

  REG32 (PINMUX_SEL_1) |=((1<<26)  | (1<<24)  );  //set MFCS1# to NAND CS0#
a0003f24:	34430100 	ori	v1,v0,0x100
a0003f28:	8c650000 	lw	a1,0(v1)
a0003f2c:	3c040500 	lui	a0,0x500
a0003f30:	00a42025 	or	a0,a1,a0
a0003f34:	ac640000 	sw	a0,0(v1)
  //REG32 (PINMUX_SEL_2) |=((1<<23) | (1<<25) );  //set UART0_CTS # to NAND MD[7] ,  UART0_RTS to NF_CE1#
  REG32 (PINMUX_SEL_2) |=((1<<23)  );  //set UART0_CTS # to NAND MD[7]
a0003f38:	34430104 	ori	v1,v0,0x104
a0003f3c:	8c650000 	lw	a1,0(v1)
a0003f40:	3c040080 	lui	a0,0x80
a0003f44:	00a42025 	or	a0,a1,a0
a0003f48:	ac640000 	sw	a0,0(v1)
  REG32 (PINMUX_SEL_3) |=((1<<15) | (1<<18) | (1<<21) | (1<<24) | (1<<27)  | (1<<30) );  //set Port0 RGMII I/F to NAND
a0003f4c:	34430108 	ori	v1,v0,0x108
a0003f50:	8c650000 	lw	a1,0(v1)
a0003f54:	3c044924 	lui	a0,0x4924
a0003f58:	34848000 	ori	a0,a0,0x8000
a0003f5c:	00a42025 	or	a0,a1,a0
a0003f60:	ac640000 	sw	a0,0(v1)
#define AC_4cycles  (1<<26)
#define AC_3cycles (0<<26)

#define ECC_12T (1<<31)

REG32 (HW_Strap_REG) &= ~(0xf <<26);
a0003f64:	34420008 	ori	v0,v0,0x8
a0003f68:	8c440000 	lw	a0,0(v0)
a0003f6c:	3c03c3ff 	lui	v1,0xc3ff
a0003f70:	3463ffff 	ori	v1,v1,0xffff
a0003f74:	00831824 	and	v1,a0,v1
a0003f78:	ac430000 	sw	v1,0(v0)
#ifdef CONFIG_NAND_Flash_Large_Page_256MBto1GB_5cycles 
REG32 (HW_Strap_REG) |=( RC_Pages2KB |AC_5cycles ); 
#endif

#ifdef CONFIG_NAND_Flash_Large_Page_128MB_4cycles 
REG32 (HW_Strap_REG) |=( RC_Pages2KB |AC_4cycles ); 
a0003f7c:	8c440000 	lw	a0,0(v0)
a0003f80:	3c031400 	lui	v1,0x1400
a0003f84:	00831825 	or	v1,a0,v1
a0003f88:	ac430000 	sw	v1,0(v0)
 // printf("\nTurn on Bus TimeOut Arbiter\n");

  //REG32(LX_control_REG) |= (1 << 15);
  //dprintf("\nPINMUX_REG_8196D_97D(%x)=0x%x \n",PINMUX_REG_8196D_97D,REG32(PINMUX_REG_8196D_97D));
#endif /*  */
}
a0003f8c:	03e00008 	jr	ra
a0003f90:	00000000 	nop

a0003f94 <isBadBlock>:
                  initial_bad_block_table[bbt_loop],
                  initial_bad_block_table[bbt_loop] * ppb * (page_size +
                                                              oob_size));
  prom_printf ("\n###################################\n");
  free (nand_verify_buf);
}
a0003f94:	03e00008 	jr	ra
a0003f98:	2402ffff 	li	v0,-1

a0003f9c <rtk_PIO_write_word>:
#endif   


//debug cl
int rtk_PIO_write_word(unsigned long flash_address, unsigned char *image_addr, unsigned int image_size)
{
a0003f9c:	27bdffb8 	addiu	sp,sp,-72
a0003fa0:	afbf0044 	sw	ra,68(sp)
a0003fa4:	afb60040 	sw	s6,64(sp)
a0003fa8:	afb5003c 	sw	s5,60(sp)
a0003fac:	afb40038 	sw	s4,56(sp)
a0003fb0:	afb30034 	sw	s3,52(sp)
a0003fb4:	afb20030 	sw	s2,48(sp)
a0003fb8:	afb1002c 	sw	s1,44(sp)
a0003fbc:	afb00028 	sw	s0,40(sp)
a0003fc0:	00808021 	move	s0,a0
a0003fc4:	00a09021 	move	s2,a1
  //debug cl
  //dprintf("[%s]:%d for boot safe debug return directly\n",__func__,__LINE__);
  //return FAIL;
  flush_cache();
a0003fc8:	0c001eae 	jal	a0007ab8 <flush_cache>
a0003fcc:	00c0b021 	move	s6,a2
 

  if ((flash_address % (page_size + oob_size)) != 0) {
a0003fd0:	3c02a001 	lui	v0,0xa001
a0003fd4:	8c457544 	lw	a1,30020(v0)
a0003fd8:	3c02a001 	lui	v0,0xa001
a0003fdc:	8c467548 	lw	a2,30024(v0)
a0003fe0:	00c5a821 	addu	s5,a2,a1
a0003fe4:	0215001b 	divu	zero,s0,s5
a0003fe8:	02a001f4 	teq	s5,zero,0x7
a0003fec:	00001010 	mfhi	v0
a0003ff0:	10400006 	beqz	v0,a000400c <rtk_PIO_write_word+0x70>
a0003ff4:	3c11b801 	lui	s1,0xb801
    dprintf("\n\rflash_address must be page(0x%x+0x%x Bytes) aligned!\n",
a0003ff8:	3c04a001 	lui	a0,0xa001
a0003ffc:	0c002325 	jal	a0008c94 <dprintf>
a0004000:	24844654 	addiu	a0,a0,18004
            page_size, oob_size);
    return;
a0004004:	0800103f 	j	a00040fc <rtk_PIO_write_word+0x160>
a0004008:	8fbf0044 	lw	ra,68(sp)

  //pre-allocat
  //int* ptr_PIO_WRITE_NADR= malloc (0x4);
  int *ptr_PIO_WRITE_NADR = image_addr;

  int page_PIO_num = flash_address / (page_size + oob_size);
a000400c:	0215001b 	divu	zero,s0,s5
a0004010:	02a001f4 	teq	s5,zero,0x7
a0004014:	0000a812 	mflo	s5
  int i, j;


  /*PIO write step-0. */
#if 1
  rtk_writel(0x0, NACMR);       //Clear NACMR, set CECS0=0, CE_CMD = 0x00
a0004018:	3630a008 	ori	s0,s1,0xa008
a000401c:	ae000000 	sw	zero,0(s0)
  rtk_writel(0x0, NAADR);
a0004020:	3634a00c 	ori	s4,s1,0xa00c
a0004024:	ae800000 	sw	zero,0(s4)
  rtk_writel((CECS0 | CMD_RESET), NACMR);       //Reset for break PIO successively read 4Byte data from NADR      
a0004028:	3c134000 	lui	s3,0x4000
a000402c:	366200ff 	ori	v0,s3,0xff
a0004030:	ae020000 	sw	v0,0(s0)
#endif



  /*PIO write step-1. */
  check_ready_nand();
a0004034:	0c000f80 	jal	a0003e00 <check_ready_nand>
a0004038:	3631a004 	ori	s1,s1,0xa004

  //rtk_writel ((rtk_readl (NACR) & ~(ECC_enable)), NACR); //disable ECC function
  rtk_writel((rtk_readl(NACR) | (ECC_enable)), NACR);   //enable ECC function
a000403c:	8e220000 	lw	v0,0(s1)
a0004040:	00531025 	or	v0,v0,s3
a0004044:	ae220000 	sw	v0,0(s1)


  check_ready_nand();
a0004048:	0c000f80 	jal	a0003e00 <check_ready_nand>
a000404c:	00000000 	nop

  /*PIO write step-2. */
  rtk_writel(0x0, NACMR);
a0004050:	ae000000 	sw	zero,0(s0)
  rtk_writel((CECS0 | CMD_PG_WRITE_C1), NACMR); //JSW:0x80 is sequential data input command for 1st cycle.
a0004054:	36730080 	ori	s3,s3,0x80
a0004058:	ae130000 	sw	s3,0(s0)
  rtk_writel(NAADR_REG_value, NAADR);
  check_ready_nand();
  //dprintf (" c1-NAADR_REG_value=0x%x\n", NAADR_REG_value);
#endif
#ifdef CONFIG_NAND_Flash_Large_Page_128MB_4cycles
  addr_cycle[0] = addr_cycle[1] = 0;    //Basic PIO read is "Page"
a000405c:	afa00014 	sw	zero,20(sp)
a0004060:	afa00010 	sw	zero,16(sp)

  for (page_shift = 0; page_shift < 2; page_shift++) {
    addr_cycle[page_shift + 2] = (page_PIO_num >> (8 * page_shift)) & 0xff;
a0004064:	32a200ff 	andi	v0,s5,0xff
a0004068:	afa20018 	sw	v0,24(sp)
a000406c:	7eb03a00 	ext	s0,s5,0x8,0x8
a0004070:	afb0001c 	sw	s0,28(sp)
  }

  NAADR_REG_value =
      enNextAD | AD2EN | AD1EN | AD0EN | (addr_cycle[2] << CE_ADDR2);
  rtk_writel(NAADR_REG_value, NAADR);
a0004074:	00021400 	sll	v0,v0,0x10
a0004078:	3c030f00 	lui	v1,0xf00
a000407c:	00431025 	or	v0,v0,v1
a0004080:	ae820000 	sw	v0,0(s4)
  check_ready_nand();
a0004084:	0c000f80 	jal	a0003e00 <check_ready_nand>
a0004088:	00000000 	nop
  // dprintf ("c0-NAADR_REG_value=0x%x\n", NAADR_REG_value);

  NAADR_REG_value = (~enNextAD) & AD0EN | (addr_cycle[3] << CE_ADDR0);
  rtk_writel(NAADR_REG_value, NAADR);
a000408c:	3c020100 	lui	v0,0x100
a0004090:	02028025 	or	s0,s0,v0
a0004094:	ae900000 	sw	s0,0(s4)
  check_ready_nand();
a0004098:	0c000f80 	jal	a0003e00 <check_ready_nand>
a000409c:	00168882 	srl	s1,s6,0x2


  /*PIO write step-4. */
#if 1
  /*before setting CES0 to 1 (step.6) , user can successively read NADR for the continue next 4 bytes */
  for (i = 0; i < ((image_size) / 4); i++) {
a00040a0:	1220000d 	beqz	s1,a00040d8 <rtk_PIO_write_word+0x13c>
a00040a4:	00001021 	move	v0,zero
a00040a8:	00008021 	move	s0,zero
      dprintf("\nNADTSAR(0x%x): 0x%X\n ", NADTSAR, rtk_readl(NADTSAR));
    }
#endif //show NECN message

#endif //end of show NECN message
    rtk_readl(NADR) = *(ptr_PIO_WRITE_NADR + i);
a00040ac:	3c13b801 	lui	s3,0xb801
a00040b0:	3673a014 	ori	s3,s3,0xa014
a00040b4:	00021080 	sll	v0,v0,0x2
a00040b8:	02421021 	addu	v0,s2,v0
a00040bc:	8c420000 	lw	v0,0(v0)
a00040c0:	ae620000 	sw	v0,0(s3)

    check_ready_nand();
a00040c4:	0c000f80 	jal	a0003e00 <check_ready_nand>
a00040c8:	26100001 	addiu	s0,s0,1


  /*PIO write step-4. */
#if 1
  /*before setting CES0 to 1 (step.6) , user can successively read NADR for the continue next 4 bytes */
  for (i = 0; i < ((image_size) / 4); i++) {
a00040cc:	0211182b 	sltu	v1,s0,s1
a00040d0:	1460fff8 	bnez	v1,a00040b4 <rtk_PIO_write_word+0x118>
a00040d4:	02001021 	move	v0,s0

  }
#endif

  /*PIO write step-5. */
  rtk_writel((CECS0 | CMD_PG_WRITE_C2), NACMR); //JSW:0x10 is page program command for 2 cycle.
a00040d8:	3c10b801 	lui	s0,0xb801
a00040dc:	3610a008 	ori	s0,s0,0xa008
a00040e0:	3c024000 	lui	v0,0x4000
a00040e4:	34420010 	ori	v0,v0,0x10
a00040e8:	ae020000 	sw	v0,0(s0)
  check_ready_nand();
a00040ec:	0c000f80 	jal	a0003e00 <check_ready_nand>
a00040f0:	00000000 	nop
  //dprintf("ptr_PIO_WRITE_NADR=0x%x\n", ptr_PIO_WRITE_NADR);

  // free(ptr_PIO_WRITE_NADR);

  /*PIO write step-6. */
  rtk_writel(0x0, NACMR);       //Not select NAND CS0
a00040f4:	ae000000 	sw	zero,0(s0)


}
a00040f8:	8fbf0044 	lw	ra,68(sp)
a00040fc:	8fb60040 	lw	s6,64(sp)
a0004100:	8fb5003c 	lw	s5,60(sp)
a0004104:	8fb40038 	lw	s4,56(sp)
a0004108:	8fb30034 	lw	s3,52(sp)
a000410c:	8fb20030 	lw	s2,48(sp)
a0004110:	8fb1002c 	lw	s1,44(sp)
a0004114:	8fb00028 	lw	s0,40(sp)
a0004118:	03e00008 	jr	ra
a000411c:	27bd0048 	addiu	sp,sp,72

a0004120 <rtk_erase_block_a>:




int  rtk_erase_block_a (int page)
{
a0004120:	27bdffc0 	addiu	sp,sp,-64
a0004124:	afbf003c 	sw	ra,60(sp)
a0004128:	afb40038 	sw	s4,56(sp)
a000412c:	afb30034 	sw	s3,52(sp)
a0004130:	afb20030 	sw	s2,48(sp)
a0004134:	afb1002c 	sw	s1,44(sp)
a0004138:	afb00028 	sw	s0,40(sp)
    //debug cl for safe not write in 0,1 block that is for boot.
    //printf("[%s:] %d \n",__func__,__LINE__);
	if(page < 128||page > chip_size/page_size - 1)
a000413c:	28820080 	slti	v0,a0,128
a0004140:	1440000c 	bnez	v0,a0004174 <rtk_erase_block_a+0x54>
a0004144:	00808021 	move	s0,a0
a0004148:	3c02a002 	lui	v0,0xa002
a000414c:	8c438880 	lw	v1,-30592(v0)
a0004150:	3c02a001 	lui	v0,0xa001
a0004154:	8c427544 	lw	v0,30020(v0)
a0004158:	0062001b 	divu	zero,v1,v0
a000415c:	004001f4 	teq	v0,zero,0x7
a0004160:	00001812 	mflo	v1
a0004164:	2462ffff 	addiu	v0,v1,-1
a0004168:	0044102b 	sltu	v0,v0,a0
a000416c:	10400009 	beqz	v0,a0004194 <rtk_erase_block_a+0x74>
a0004170:	00809021 	move	s2,a0
	{
		dprintf("[%s]:%d panic:fatal error *************,try to write in 0,1 block for boot,protect for debug\n",__func__,__LINE__);
a0004174:	3c04a001 	lui	a0,0xa001
a0004178:	2484468c 	addiu	a0,a0,18060
a000417c:	3c05a001 	lui	a1,0xa001
a0004180:	24a50314 	addiu	a1,a1,788
a0004184:	0c002325 	jal	a0008c94 <dprintf>
a0004188:	240609f1 	li	a2,2545
		return FAIL;
a000418c:	080010b0 	j	a00042c0 <rtk_erase_block_a+0x1a0>
a0004190:	2402ffff 	li	v0,-1
	}
	int addr_cycle[5], page_shift;

	//printf("!!!!! rtk_erase_block !!!!!, block = %d\n\r",page/ppb);

	if ( page & (ppb-1) ){
a0004194:	3c02a001 	lui	v0,0xa001
a0004198:	8c42754c 	lw	v0,30028(v0)
a000419c:	2442ffff 	addiu	v0,v0,-1
a00041a0:	00821024 	and	v0,a0,v0
a00041a4:	10400007 	beqz	v0,a00041c4 <rtk_erase_block_a+0xa4>
a00041a8:	3c04a001 	lui	a0,0xa001
		printf("page %d is not block alignment !!\n", page);
a00041ac:	3c04a001 	lui	a0,0xa001
a00041b0:	248446ec 	addiu	a0,a0,18156
a00041b4:	0c002325 	jal	a0008c94 <dprintf>
a00041b8:	02002821 	move	a1,s0
		return 0;
a00041bc:	080010b0 	j	a00042c0 <rtk_erase_block_a+0x1a0>
a00041c0:	00001021 	move	v0,zero
	}
	printf(".");
a00041c4:	0c002325 	jal	a0008c94 <dprintf>
a00041c8:	24846db8 	addiu	a0,a0,28088
	check_ready_nand();
a00041cc:	0c000f80 	jal	a0003e00 <check_ready_nand>
a00041d0:	00000000 	nop

	rtk_writel( (rtk_readl(NACR) |ECC_enable|RBO), NACR);
a00041d4:	3c02b801 	lui	v0,0xb801
a00041d8:	3443a004 	ori	v1,v0,0xa004
a00041dc:	8c650000 	lw	a1,0(v1)
a00041e0:	3c046000 	lui	a0,0x6000
a00041e4:	00a42025 	or	a0,a1,a0
a00041e8:	ac640000 	sw	a0,0(v1)
	rtk_writel((NWER|NRER|NDRS|NDWS), NASR);
a00041ec:	3443a028 	ori	v1,v0,0xa028
a00041f0:	2404000f 	li	a0,15
a00041f4:	ac640000 	sw	a0,0(v1)
	rtk_writel(0x0, NACMR);
a00041f8:	3442a008 	ori	v0,v0,0xa008
a00041fc:	ac400000 	sw	zero,0(v0)

	rtk_writel((CECS0|CMD_BLK_ERASE_C1),NACMR);
a0004200:	3c034000 	lui	v1,0x4000
a0004204:	34630060 	ori	v1,v1,0x60
a0004208:	ac430000 	sw	v1,0(v0)
	check_ready_nand();
a000420c:	0c000f80 	jal	a0003e00 <check_ready_nand>
a0004210:	00000000 	nop


	if(!NAND_ADDR_CYCLE){
		addr_cycle[0] = addr_cycle[1] =0;
a0004214:	afa00014 	sw	zero,20(sp)
a0004218:	afa00010 	sw	zero,16(sp)
a000421c:	27a30018 	addiu	v1,sp,24
a0004220:	00001021 	move	v0,zero
		for(page_shift=0; page_shift<3; page_shift++){
a0004224:	24050018 	li	a1,24
			addr_cycle[page_shift+2] = (page>>(8*page_shift)) & 0xff;
a0004228:	00502007 	srav	a0,s0,v0
a000422c:	308400ff 	andi	a0,a0,0xff
a0004230:	ac640000 	sw	a0,0(v1)
a0004234:	24420008 	addiu	v0,v0,8
	check_ready_nand();


	if(!NAND_ADDR_CYCLE){
		addr_cycle[0] = addr_cycle[1] =0;
		for(page_shift=0; page_shift<3; page_shift++){
a0004238:	1445fffb 	bne	v0,a1,a0004228 <rtk_erase_block_a+0x108>
a000423c:	24630004 	addiu	v1,v1,4
			addr_cycle[page_shift+2] = (page>>(8*page_shift)) & 0xff;
		}

		rtk_writel( ((~enNextAD) & AD2EN|AD1EN|AD0EN|
a0004240:	3c020700 	lui	v0,0x700
a0004244:	8fa30018 	lw	v1,24(sp)
a0004248:	00621825 	or	v1,v1,v0
a000424c:	8fa2001c 	lw	v0,28(sp)
a0004250:	00021200 	sll	v0,v0,0x8
a0004254:	00621825 	or	v1,v1,v0
a0004258:	8fa20020 	lw	v0,32(sp)
a000425c:	00021400 	sll	v0,v0,0x10
a0004260:	00621825 	or	v1,v1,v0
a0004264:	3c11b801 	lui	s1,0xb801
a0004268:	3622a00c 	ori	v0,s1,0xa00c
a000426c:	ac430000 	sw	v1,0(v0)
				(addr_cycle[1]<<CE_ADDR0) |(addr_cycle[2]<<CE_ADDR1)|(addr_cycle[3]<<CE_ADDR2)),NAADR);
	}



	rtk_writel((CECS0|CMD_BLK_ERASE_C2),NACMR);
a0004270:	3634a008 	ori	s4,s1,0xa008
a0004274:	3c134000 	lui	s3,0x4000
a0004278:	366200d0 	ori	v0,s3,0xd0
a000427c:	ae820000 	sw	v0,0(s4)
	check_ready_nand();
a0004280:	0c000f80 	jal	a0003e00 <check_ready_nand>
a0004284:	36730070 	ori	s3,s3,0x70

	rtk_writel((CECS0|CMD_BLK_ERASE_C3),NACMR);
a0004288:	ae930000 	sw	s3,0(s4)
	check_ready_nand();
a000428c:	0c000f80 	jal	a0003e00 <check_ready_nand>
a0004290:	3631a014 	ori	s1,s1,0xa014

	if(rtk_readl(NADR) & 0x01){
a0004294:	8e220000 	lw	v0,0(s1)
a0004298:	30420001 	andi	v0,v0,0x1
a000429c:	10400008 	beqz	v0,a00042c0 <rtk_erase_block_a+0x1a0>
a00042a0:	00001021 	move	v0,zero
		if( page>=0 && page < ppb)
a00042a4:	06000005 	bltz	s0,a00042bc <rtk_erase_block_a+0x19c>
a00042a8:	3c02a001 	lui	v0,0xa001
a00042ac:	8c42754c 	lw	v0,30028(v0)
a00042b0:	0242902b 	sltu	s2,s2,v0
a00042b4:	16400002 	bnez	s2,a00042c0 <rtk_erase_block_a+0x1a0>
a00042b8:	00001021 	move	v0,zero
a00042bc:	2402ffff 	li	v0,-1
			return FAIL;
	}
		
	return SUCCESS;

}
a00042c0:	8fbf003c 	lw	ra,60(sp)
a00042c4:	8fb40038 	lw	s4,56(sp)
a00042c8:	8fb30034 	lw	s3,52(sp)
a00042cc:	8fb20030 	lw	s2,48(sp)
a00042d0:	8fb1002c 	lw	s1,44(sp)
a00042d4:	8fb00028 	lw	s0,40(sp)
a00042d8:	03e00008 	jr	ra
a00042dc:	27bd0040 	addiu	sp,sp,64

a00042e0 <check_BBT>:
}
#endif

#ifdef CONFIG_RTK_NAND_BBT
int check_BBT(unsigned int blk)
{	
a00042e0:	27bdffe8 	addiu	sp,sp,-24
a00042e4:	afbf0014 	sw	ra,20(sp)
a00042e8:	afb00010 	sw	s0,16(sp)
a00042ec:	00808021 	move	s0,a0
	int i;	
	printf("[%s] blk:%d\n", __FUNCTION__, blk);	
a00042f0:	3c04a001 	lui	a0,0xa001
a00042f4:	24844710 	addiu	a0,a0,18192
a00042f8:	3c05a001 	lui	a1,0xa001
a00042fc:	24a50328 	addiu	a1,a1,808
a0004300:	0c002325 	jal	a0008c94 <dprintf>
a0004304:	02003021 	move	a2,s0

	for ( i=0; i<RBA; i++)	
a0004308:	3c02a001 	lui	v0,0xa001
a000430c:	8c457970 	lw	a1,31088(v0)
a0004310:	10a00015 	beqz	a1,a0004368 <check_BBT+0x88>
a0004314:	3c02a001 	lui	v0,0xa001
	{		
	    if ( bbt[i].bad_block == blk )
a0004318:	8c437974 	lw	v1,31092(v0)
a000431c:	94620002 	lhu	v0,2(v1)
a0004320:	1450000c 	bne	v0,s0,a0004354 <check_BBT+0x74>
a0004324:	3c04a001 	lui	a0,0xa001
        {			
            printf("blk 0x%x already exist\n",blk);			
a0004328:	080010d1 	j	a0004344 <check_BBT+0x64>
a000432c:	24844720 	addiu	a0,a0,18208
	int i;	
	printf("[%s] blk:%d\n", __FUNCTION__, blk);	

	for ( i=0; i<RBA; i++)	
	{		
	    if ( bbt[i].bad_block == blk )
a0004330:	9464000a 	lhu	a0,10(v1)
a0004334:	14900008 	bne	a0,s0,a0004358 <check_BBT+0x78>
a0004338:	24630008 	addiu	v1,v1,8
        {			
            printf("blk 0x%x already exist\n",blk);			
a000433c:	3c04a001 	lui	a0,0xa001
a0004340:	24844720 	addiu	a0,a0,18208
a0004344:	0c002325 	jal	a0008c94 <dprintf>
a0004348:	02002821 	move	a1,s0
		    return -1;			
a000434c:	080010db 	j	a000436c <check_BBT+0x8c>
a0004350:	2402ffff 	li	v0,-1
a0004354:	00001021 	move	v0,zero
int check_BBT(unsigned int blk)
{	
	int i;	
	printf("[%s] blk:%d\n", __FUNCTION__, blk);	

	for ( i=0; i<RBA; i++)	
a0004358:	24420001 	addiu	v0,v0,1
a000435c:	0045202b 	sltu	a0,v0,a1
a0004360:	1480fff3 	bnez	a0,a0004330 <check_BBT+0x50>
a0004364:	00000000 	nop
a0004368:	00001021 	move	v0,zero
            printf("blk 0x%x already exist\n",blk);			
		    return -1;			
	    }	
	}	
	return 0;
}
a000436c:	8fbf0014 	lw	ra,20(sp)
a0004370:	8fb00010 	lw	s0,16(sp)
a0004374:	03e00008 	jr	ra
a0004378:	27bd0018 	addiu	sp,sp,24

a000437c <rtk_PIO_read_basic>:

	return 0;

}
int rtk_PIO_read_basic(int page, int offset)
{
a000437c:	27bdffd0 	addiu	sp,sp,-48
a0004380:	afbf002c 	sw	ra,44(sp)
a0004384:	afb30028 	sw	s3,40(sp)
a0004388:	afb20024 	sw	s2,36(sp)
a000438c:	afb10020 	sw	s1,32(sp)
a0004390:	afb0001c 	sw	s0,28(sp)
a0004394:	00809021 	move	s2,a0
a0004398:	00a09821 	move	s3,a1
	int rlen, real_page;
	unsigned int cmd;

	real_page = page;

	rlen = page_size + oob_size;
a000439c:	3c02a001 	lui	v0,0xa001
a00043a0:	8c517548 	lw	s1,30024(v0)
a00043a4:	3c02a001 	lui	v0,0xa001
a00043a8:	8c427544 	lw	v0,30020(v0)
a00043ac:	02228821 	addu	s1,s1,v0
	cmd = CMD_PG_READ_A;

	rtk_writel(0xc00fffff, NACR);
a00043b0:	3c10b801 	lui	s0,0xb801
a00043b4:	3602a004 	ori	v0,s0,0xa004
a00043b8:	3c03c00f 	lui	v1,0xc00f
a00043bc:	3463ffff 	ori	v1,v1,0xffff
a00043c0:	ac430000 	sw	v1,0(v0)

	/* Command cycle 1*/
	rtk_writel((CECS0|cmd), NACMR);
a00043c4:	3602a008 	ori	v0,s0,0xa008
a00043c8:	3c034000 	lui	v1,0x4000
a00043cc:	ac430000 	sw	v1,0(v0)

	check_ready_nand();//check_ready();
a00043d0:	0c000f80 	jal	a0003e00 <check_ready_nand>
a00043d4:	3610a00c 	ori	s0,s0,0xa00c

	flash_addr1 |= ((real_page & 0xffffff) << 8) ;

	/* Give address */
	rtk_writel( (AD2EN|AD1EN|AD0EN|flash_addr1), NAADR);
a00043d8:	00121a00 	sll	v1,s2,0x8
a00043dc:	3c020700 	lui	v0,0x700
a00043e0:	00621025 	or	v0,v1,v0
a00043e4:	ae020000 	sw	v0,0(s0)

	check_ready_nand();//check_ready();
a00043e8:	0c000f80 	jal	a0003e00 <check_ready_nand>
a00043ec:	00000000 	nop

	for(i=0; i<(rlen/4); i++){
a00043f0:	26220003 	addiu	v0,s1,3
a00043f4:	2a230000 	slti	v1,s1,0
a00043f8:	0223100a 	movz	v0,s1,v1
a00043fc:	00021883 	sra	v1,v0,0x2
a0004400:	18600022 	blez	v1,a000448c <rtk_PIO_read_basic+0x110>
a0004404:	3c02b801 	lui	v0,0xb801
		data_out = rtk_readl(NADR);
a0004408:	3442a014 	ori	v0,v0,0xa014
a000440c:	8c460000 	lw	a2,0(v0)
		//printf("[%3d] 0x%08X \n",i, data_out);
		if(data_out!=0xffffffff){
a0004410:	2402ffff 	li	v0,-1
a0004414:	10c20016 	beq	a2,v0,a0004470 <rtk_PIO_read_basic+0xf4>
a0004418:	00008021 	move	s0,zero
			printf("[%3d] 0x%08X \n",i, data_out);
a000441c:	0800110e 	j	a0004438 <rtk_PIO_read_basic+0xbc>
a0004420:	3c04a001 	lui	a0,0xa001
	rtk_writel( (AD2EN|AD1EN|AD0EN|flash_addr1), NAADR);

	check_ready_nand();//check_ready();

	for(i=0; i<(rlen/4); i++){
		data_out = rtk_readl(NADR);
a0004424:	8ca60000 	lw	a2,0(a1)
		//printf("[%3d] 0x%08X \n",i, data_out);
		if(data_out!=0xffffffff){
a0004428:	10c40015 	beq	a2,a0,a0004480 <rtk_PIO_read_basic+0x104>
a000442c:	26100001 	addiu	s0,s0,1
a0004430:	2610ffff 	addiu	s0,s0,-1
			printf("[%3d] 0x%08X \n",i, data_out);
a0004434:	3c04a001 	lui	a0,0xa001
a0004438:	24844738 	addiu	a0,a0,18232
a000443c:	0c002325 	jal	a0008c94 <dprintf>
a0004440:	02002821 	move	a1,s0
			printf("%s: page %d offset %d i %d rlen %d\n",__FUNCTION__, page, offset, i, rlen);
a0004444:	afb00010 	sw	s0,16(sp)
a0004448:	afb10014 	sw	s1,20(sp)
a000444c:	3c04a001 	lui	a0,0xa001
a0004450:	24844748 	addiu	a0,a0,18248
a0004454:	3c05a001 	lui	a1,0xa001
a0004458:	24a50358 	addiu	a1,a1,856
a000445c:	02403021 	move	a2,s2
a0004460:	0c002325 	jal	a0008c94 <dprintf>
a0004464:	02603821 	move	a3,s3
			return -1;
a0004468:	08001131 	j	a00044c4 <rtk_PIO_read_basic+0x148>
a000446c:	2402ffff 	li	v0,-1
	rtk_writel( (AD2EN|AD1EN|AD0EN|flash_addr1), NAADR);

	check_ready_nand();//check_ready();

	for(i=0; i<(rlen/4); i++){
		data_out = rtk_readl(NADR);
a0004470:	3c05b801 	lui	a1,0xb801
a0004474:	34a5a014 	ori	a1,a1,0xa014
		//printf("[%3d] 0x%08X \n",i, data_out);
		if(data_out!=0xffffffff){
a0004478:	2404ffff 	li	a0,-1
	/* Give address */
	rtk_writel( (AD2EN|AD1EN|AD0EN|flash_addr1), NAADR);

	check_ready_nand();//check_ready();

	for(i=0; i<(rlen/4); i++){
a000447c:	26100001 	addiu	s0,s0,1
a0004480:	0203102a 	slt	v0,s0,v1
a0004484:	1440ffe7 	bnez	v0,a0004424 <rtk_PIO_read_basic+0xa8>
a0004488:	00000000 	nop
			printf("%s: page %d offset %d i %d rlen %d\n",__FUNCTION__, page, offset, i, rlen);
			return -1;
		}
	}

	rtk_writel(0, NACMR);
a000448c:	3c11b801 	lui	s1,0xb801
a0004490:	3630a008 	ori	s0,s1,0xa008
a0004494:	ae000000 	sw	zero,0(s0)
	check_ready_nand(); //check_ready();
a0004498:	0c000f80 	jal	a0003e00 <check_ready_nand>
a000449c:	00000000 	nop
	rtk_writel (0x0, NACMR);    
a00044a0:	ae000000 	sw	zero,0(s0)
	rtk_writel (0x0, NAADR);    
a00044a4:	3631a00c 	ori	s1,s1,0xa00c
a00044a8:	ae200000 	sw	zero,0(s1)
	rtk_writel ((CECS0 | CMD_RESET), NACMR);         //reset                 //rtk_nand_read_id () ;    
a00044ac:	3c024000 	lui	v0,0x4000
a00044b0:	344200ff 	ori	v0,v0,0xff
a00044b4:	ae020000 	sw	v0,0(s0)
	check_ready_nand ();
a00044b8:	0c000f80 	jal	a0003e00 <check_ready_nand>
a00044bc:	00000000 	nop
a00044c0:	00001021 	move	v0,zero
	
	return 0;
	
}
a00044c4:	8fbf002c 	lw	ra,44(sp)
a00044c8:	8fb30028 	lw	s3,40(sp)
a00044cc:	8fb20024 	lw	s2,36(sp)
a00044d0:	8fb10020 	lw	s1,32(sp)
a00044d4:	8fb0001c 	lw	s0,28(sp)
a00044d8:	03e00008 	jr	ra
a00044dc:	27bd0030 	addiu	sp,sp,48

a00044e0 <rtk_check_allone_512>:

int rtk_check_allone_512(int page)
{
a00044e0:	27bdffe8 	addiu	sp,sp,-24
a00044e4:	afbf0014 	sw	ra,20(sp)
	int rc=0;

	rc = rtk_PIO_read_basic(page,0);
a00044e8:	0c0010df 	jal	a000437c <rtk_PIO_read_basic>
a00044ec:	00002821 	move	a1,zero
	if(rc < 0)
		goto read_finish;

read_finish:
	return rc;
}
a00044f0:	8fbf0014 	lw	ra,20(sp)
a00044f4:	03e00008 	jr	ra
a00044f8:	27bd0018 	addiu	sp,sp,24

a00044fc <rtk_check_allone>:
}


#endif  /*  */
int rtk_check_allone(int page, int offset)
{
a00044fc:	27bdffd0 	addiu	sp,sp,-48
a0004500:	afbf002c 	sw	ra,44(sp)
a0004504:	afb40028 	sw	s4,40(sp)
a0004508:	afb30024 	sw	s3,36(sp)
a000450c:	afb20020 	sw	s2,32(sp)
a0004510:	afb1001c 	sw	s1,28(sp)
a0004514:	afb00018 	sw	s0,24(sp)
a0004518:	00808821 	move	s1,a0
a000451c:	00a0a021 	move	s4,a1
	real_page = page;

	/* rlen is equal to (512 + 16) */
	rlen = 528; 
	
	rtk_writel(0xc00fffff, NACR);
a0004520:	3c10b801 	lui	s0,0xb801
a0004524:	3602a004 	ori	v0,s0,0xa004
a0004528:	3c03c00f 	lui	v1,0xc00f
a000452c:	3463ffff 	ori	v1,v1,0xffff
a0004530:	ac430000 	sw	v1,0(v0)

	/* Command cycle 1*/
	rtk_writel((CECS0|CMD_PG_READ_C1), NACMR);
a0004534:	3613a008 	ori	s3,s0,0xa008
a0004538:	3c124000 	lui	s2,0x4000
a000453c:	ae720000 	sw	s2,0(s3)

	check_ready_nand();//check_ready();
a0004540:	0c000f80 	jal	a0003e00 <check_ready_nand>
a0004544:	00000000 	nop

	flash_addr1 =  ((real_page & 0xff) << 16) | offset;
	flash_addr2 = (real_page >> 8) & 0xffffff;

	/* Give address */
	rtk_writel( (enNextAD|AD2EN|AD1EN|AD0EN|flash_addr1), NAADR);
a0004548:	322300ff 	andi	v1,s1,0xff
a000454c:	00031c00 	sll	v1,v1,0x10
a0004550:	00741825 	or	v1,v1,s4
a0004554:	3c020f00 	lui	v0,0xf00
a0004558:	00621825 	or	v1,v1,v0
a000455c:	3602a00c 	ori	v0,s0,0xa00c
a0004560:	ac430000 	sw	v1,0(v0)
	rtk_writel( (AD1EN|AD0EN|flash_addr2), NAADR);
a0004564:	00112202 	srl	a0,s1,0x8
a0004568:	3c030300 	lui	v1,0x300
a000456c:	00831825 	or	v1,a0,v1
a0004570:	ac430000 	sw	v1,0(v0)

	/* Command cycle 2*/
	rtk_writel((CECS0|CMD_PG_READ_C2), NACMR);
a0004574:	36520030 	ori	s2,s2,0x30
a0004578:	ae720000 	sw	s2,0(s3)

	check_ready_nand();//check_ready();
a000457c:	0c000f80 	jal	a0003e00 <check_ready_nand>
a0004580:	3610a014 	ori	s0,s0,0xa014

	for(i=0; i<(rlen/4); i++){
		data_out = rtk_readl(NADR);	
a0004584:	8e030000 	lw	v1,0(s0)
		if( data_out != 0xffffffff){
a0004588:	2404ffff 	li	a0,-1
a000458c:	10640003 	beq	v1,a0,a000459c <rtk_check_allone+0xa0>
a0004590:	24020001 	li	v0,1
a0004594:	0800116f 	j	a00045bc <rtk_check_allone+0xc0>
a0004598:	00001021 	move	v0,zero
	rtk_writel((CECS0|CMD_PG_READ_C2), NACMR);

	check_ready_nand();//check_ready();

	for(i=0; i<(rlen/4); i++){
		data_out = rtk_readl(NADR);	
a000459c:	3c05b801 	lui	a1,0xb801
a00045a0:	34a5a014 	ori	a1,a1,0xa014
		if( data_out != 0xffffffff){
a00045a4:	2404ffff 	li	a0,-1
	/* Command cycle 2*/
	rtk_writel((CECS0|CMD_PG_READ_C2), NACMR);

	check_ready_nand();//check_ready();

	for(i=0; i<(rlen/4); i++){
a00045a8:	24060084 	li	a2,132
		data_out = rtk_readl(NADR);	
a00045ac:	8ca30000 	lw	v1,0(a1)
		if( data_out != 0xffffffff){
a00045b0:	1064000d 	beq	v1,a0,a00045e8 <rtk_check_allone+0xec>
a00045b4:	24420001 	addiu	v0,v0,1
a00045b8:	2442ffff 	addiu	v0,v0,-1
			
			printf("%s, page %d offset %x i %x da:%x\n",__FUNCTION__, page, offset, i,data_out);
a00045bc:	afa20010 	sw	v0,16(sp)
a00045c0:	afa30014 	sw	v1,20(sp)
a00045c4:	3c04a001 	lui	a0,0xa001
a00045c8:	2484476c 	addiu	a0,a0,18284
a00045cc:	3c05a001 	lui	a1,0xa001
a00045d0:	24a5036c 	addiu	a1,a1,876
a00045d4:	02203021 	move	a2,s1
a00045d8:	0c002325 	jal	a0008c94 <dprintf>
a00045dc:	02803821 	move	a3,s4
			return -1;
a00045e0:	08001182 	j	a0004608 <rtk_check_allone+0x10c>
a00045e4:	2402ffff 	li	v0,-1
	/* Command cycle 2*/
	rtk_writel((CECS0|CMD_PG_READ_C2), NACMR);

	check_ready_nand();//check_ready();

	for(i=0; i<(rlen/4); i++){
a00045e8:	1446fff0 	bne	v0,a2,a00045ac <rtk_check_allone+0xb0>
a00045ec:	00000000 	nop
			printf("%s, page %d offset %x i %x da:%x\n",__FUNCTION__, page, offset, i,data_out);
			return -1;
		}
	}

	check_ready_nand();//check_ready();
a00045f0:	0c000f80 	jal	a0003e00 <check_ready_nand>
a00045f4:	00000000 	nop
	rtk_writel(0, NACMR);
a00045f8:	3c02b801 	lui	v0,0xb801
a00045fc:	3442a008 	ori	v0,v0,0xa008
a0004600:	ac400000 	sw	zero,0(v0)
a0004604:	00001021 	move	v0,zero

	return 0;

}
a0004608:	8fbf002c 	lw	ra,44(sp)
a000460c:	8fb40028 	lw	s4,40(sp)
a0004610:	8fb30024 	lw	s3,36(sp)
a0004614:	8fb20020 	lw	s2,32(sp)
a0004618:	8fb1001c 	lw	s1,28(sp)
a000461c:	8fb00018 	lw	s0,24(sp)
a0004620:	03e00008 	jr	ra
a0004624:	27bd0030 	addiu	sp,sp,48

a0004628 <rtk_check_pageData>:

read_finish:
	return rc;
}
int rtk_check_pageData(int page, int offset)
{
a0004628:	27bdffd8 	addiu	sp,sp,-40
a000462c:	afbf0024 	sw	ra,36(sp)
a0004630:	afb20020 	sw	s2,32(sp)
a0004634:	afb1001c 	sw	s1,28(sp)
a0004638:	afb00018 	sw	s0,24(sp)
a000463c:	00808021 	move	s0,a0
	int rc = 0;
	int error_count,status;

	status = rtk_readl(NASR);
a0004640:	3c02b801 	lui	v0,0xb801
a0004644:	3442a028 	ori	v0,v0,0xa028
a0004648:	8c510000 	lw	s1,0(v0)

	if( (status & NDRS)== NDRS){		
a000464c:	32220002 	andi	v0,s1,0x2
a0004650:	1040002c 	beqz	v0,a0004704 <rtk_check_pageData+0xdc>
a0004654:	02209021 	move	s2,s1

		 if( status & NRER) {
a0004658:	32220008 	andi	v0,s1,0x8
a000465c:	10400039 	beqz	v0,a0004744 <rtk_check_pageData+0x11c>
a0004660:	3c02b801 	lui	v0,0xb801
			error_count = (status & 0xf0) >> 4;
a0004664:	7e311900 	ext	s1,s1,0x4,0x4
			
			if(error_count <=4 && error_count > 0 ) {
a0004668:	2622ffff 	addiu	v0,s1,-1
a000466c:	2c420004 	sltiu	v0,v0,4
a0004670:	1040000d 	beqz	v0,a00046a8 <rtk_check_pageData+0x80>
a0004674:	02003021 	move	a2,s0
				printf("[%s] boot: Correctable HW ECC Error at page=%x, status=0x%08X\n\r", __FUNCTION__, page,status);
a0004678:	3c04a001 	lui	a0,0xa001
a000467c:	24844790 	addiu	a0,a0,18320
a0004680:	3c05a001 	lui	a1,0xa001
a0004684:	24a50344 	addiu	a1,a1,836
a0004688:	0c002325 	jal	a0008c94 <dprintf>
a000468c:	02403821 	move	a3,s2
				status &= 0x0f; //clear NECN
				rtk_writel(status, NASR);
a0004690:	3252000f 	andi	s2,s2,0xf
a0004694:	3c02b801 	lui	v0,0xb801
a0004698:	3442a028 	ori	v0,v0,0xa028
a000469c:	ac520000 	sw	s2,0(v0)
				return 0;
a00046a0:	080011d4 	j	a0004750 <rtk_check_pageData+0x128>
a00046a4:	00001021 	move	v0,zero
				}
}
else
//#else
{
				if( rtk_check_allone(page,offset) == 0 ){
a00046a8:	0c00113f 	jal	a00044fc <rtk_check_allone>
a00046ac:	00000000 	nop
a00046b0:	14400007 	bnez	v0,a00046d0 <rtk_check_pageData+0xa8>
a00046b4:	3c04a001 	lui	a0,0xa001
					status &= 0x0f; //clear NECN
					rtk_writel(status, NASR);
a00046b8:	3252000f 	andi	s2,s2,0xf
a00046bc:	3c02b801 	lui	v0,0xb801
a00046c0:	3442a028 	ori	v0,v0,0xa028
a00046c4:	ac520000 	sw	s2,0(v0)
				    	//printf("[%s] Page %d is all one page, bypass it !!\n\r",__func__,page);
				    	return 0;
a00046c8:	080011d4 	j	a0004750 <rtk_check_pageData+0x128>
a00046cc:	00001021 	move	v0,zero
				}
}
//#endif			
				printf("[%s] boot: Un-Correctable HW ECC Error at page=%x, status=0x%08X error_count %d\n\r", __FUNCTION__, page,status, error_count);
a00046d0:	afb10010 	sw	s1,16(sp)
a00046d4:	248447d0 	addiu	a0,a0,18384
a00046d8:	3c05a001 	lui	a1,0xa001
a00046dc:	24a50344 	addiu	a1,a1,836
a00046e0:	02003021 	move	a2,s0
a00046e4:	0c002325 	jal	a0008c94 <dprintf>
a00046e8:	02403821 	move	a3,s2
				status &= 0x0f; //clear NECN
				rtk_writel(status, NASR);
a00046ec:	3252000f 	andi	s2,s2,0xf
a00046f0:	3c02b801 	lui	v0,0xb801
a00046f4:	3442a028 	ori	v0,v0,0xa028
a00046f8:	ac520000 	sw	s2,0(v0)
				return -1;				
a00046fc:	080011d4 	j	a0004750 <rtk_check_pageData+0x128>
a0004700:	2402ffff 	li	v0,-1
			}
		}
		
	}
	else if( (status & NDWS)== NDWS){
		 if( status & NWER) {
a0004704:	32230005 	andi	v1,s1,0x5
a0004708:	24020005 	li	v0,5
a000470c:	1462000c 	bne	v1,v0,a0004740 <rtk_check_pageData+0x118>
a0004710:	3c04a001 	lui	a0,0xa001
			printf("[%s] boot: NAND Flash write failed at page=%x, status=0x%08X\n\r", __FUNCTION__, page,status);
a0004714:	24844824 	addiu	a0,a0,18468
a0004718:	3c05a001 	lui	a1,0xa001
a000471c:	24a50344 	addiu	a1,a1,836
a0004720:	02003021 	move	a2,s0
a0004724:	0c002325 	jal	a0008c94 <dprintf>
a0004728:	02203821 	move	a3,s1
			rtk_writel(status, NASR);
a000472c:	3c02b801 	lui	v0,0xb801
a0004730:	3442a028 	ori	v0,v0,0xa028
a0004734:	ac510000 	sw	s1,0(v0)
			return -1;
a0004738:	080011d4 	j	a0004750 <rtk_check_pageData+0x128>
a000473c:	2402ffff 	li	v0,-1
		}
	}

	rtk_writel(status, NASR);
a0004740:	3c02b801 	lui	v0,0xb801
a0004744:	3442a028 	ori	v0,v0,0xa028
a0004748:	ac510000 	sw	s1,0(v0)
a000474c:	00001021 	move	v0,zero

	return rc;
}
a0004750:	8fbf0024 	lw	ra,36(sp)
a0004754:	8fb20020 	lw	s2,32(sp)
a0004758:	8fb1001c 	lw	s1,28(sp)
a000475c:	8fb00018 	lw	s0,24(sp)
a0004760:	03e00008 	jr	ra
a0004764:	27bd0028 	addiu	sp,sp,40

a0004768 <rtk_write_ecc_page_a>:
// Output:
//		BOOL: 0=>OK, -1=>FAIL
//####################################################################
int  rtk_write_ecc_page_a (unsigned int flash_page, unsigned char *image_addr, unsigned char *oob_addr,
		unsigned int image_size)
{
a0004768:	27bdffa8 	addiu	sp,sp,-88
a000476c:	afbf0054 	sw	ra,84(sp)
a0004770:	afbe0050 	sw	s8,80(sp)
a0004774:	afb7004c 	sw	s7,76(sp)
a0004778:	afb60048 	sw	s6,72(sp)
a000477c:	afb50044 	sw	s5,68(sp)
a0004780:	afb40040 	sw	s4,64(sp)
a0004784:	afb3003c 	sw	s3,60(sp)
a0004788:	afb20038 	sw	s2,56(sp)
a000478c:	afb10034 	sw	s1,52(sp)
a0004790:	afb00030 	sw	s0,48(sp)
a0004794:	afa40058 	sw	a0,88(sp)
a0004798:	afa5005c 	sw	a1,92(sp)
    //debug cl for safe not write in 0,1 block that is for boot.
	//printf("[%s:] %d\n",__func__,__LINE__);
	if(flash_page < 128||flash_page > chip_size/page_size - 1)
a000479c:	2c820080 	sltiu	v0,a0,128
a00047a0:	1440000d 	bnez	v0,a00047d8 <rtk_write_ecc_page_a+0x70>
a00047a4:	afa60060 	sw	a2,96(sp)
a00047a8:	3c02a001 	lui	v0,0xa001
a00047ac:	8c427544 	lw	v0,30020(v0)
a00047b0:	3c03a002 	lui	v1,0xa002
a00047b4:	8c638880 	lw	v1,-30592(v1)
a00047b8:	0062001b 	divu	zero,v1,v0
a00047bc:	004001f4 	teq	v0,zero,0x7
a00047c0:	00002012 	mflo	a0
a00047c4:	2483ffff 	addiu	v1,a0,-1
a00047c8:	8fa50058 	lw	a1,88(sp)
a00047cc:	0065182b 	sltu	v1,v1,a1
a00047d0:	10600009 	beqz	v1,a00047f8 <rtk_write_ecc_page_a+0x90>
a00047d4:	3c04c00f 	lui	a0,0xc00f
	{
		dprintf("[%s]:%d panic:fatal error *************,try to write in 0,1 block for boot,protect for debug\n",__func__,__LINE__);
a00047d8:	3c04a001 	lui	a0,0xa001
a00047dc:	2484468c 	addiu	a0,a0,18060
a00047e0:	3c05a001 	lui	a1,0xa001
a00047e4:	24a502fc 	addiu	a1,a1,764
a00047e8:	0c002325 	jal	a0008c94 <dprintf>
a00047ec:	24060a3f 	li	a2,2623
		return FAIL;
a00047f0:	08001296 	j	a0004a58 <rtk_write_ecc_page_a+0x2f0>
a00047f4:	2402ffff 	li	v0,-1
	unsigned char switch_bbi = 0;
	#endif
	//unsigned char *oob_buf;

	//debug cl
	rtk_writel(0xc00fffff, NACR);
a00047f8:	3484ffff 	ori	a0,a0,0xffff
a00047fc:	3c03b801 	lui	v1,0xb801
a0004800:	3463a004 	ori	v1,v1,0xa004
a0004804:	ac640000 	sw	a0,0(v1)
		return FAIL;
	}*/

	//Page size alignment
	dma_size = image_size;
	if( image_size%page_size ){
a0004808:	00e2001b 	divu	zero,a3,v0
a000480c:	004001f4 	teq	v0,zero,0x7
a0004810:	00009010 	mfhi	s2
		dma_size +=(image_size%page_size);
	}
	
	//Translate nand flash address
	page_start = flash_page;   
a0004814:	8fb10058 	lw	s1,88(sp)
	#ifdef SWAP_2K_DATA
	block = flash_page/ppb;
	
	if(block>=BOOT_BLOCK)
a0004818:	3c02a001 	lui	v0,0xa001
a000481c:	8c42754c 	lw	v0,30028(v0)
a0004820:	0222001b 	divu	zero,s1,v0
a0004824:	004001f4 	teq	v0,zero,0x7
a0004828:	00001812 	mflo	v1
a000482c:	28620002 	slti	v0,v1,2
a0004830:	1440000a 	bnez	v0,a000485c <rtk_write_ecc_page_a+0xf4>
a0004834:	00f29021 	addu	s2,a3,s2

		if(!NAND_ADDR_CYCLE)
		{
			unsigned char temp_val;
			if(switch_bbi){
				temp_val = image_addr[BBI_DMA_OFFSET];
a0004838:	8fa4005c 	lw	a0,92(sp)
a000483c:	248307d0 	addiu	v1,a0,2000
a0004840:	90640000 	lbu	a0,0(v1)
				image_addr[BBI_DMA_OFFSET] = oob_addr[BBI_SWAP_OFFSET];
a0004844:	8fa50060 	lw	a1,96(sp)
a0004848:	24a20035 	addiu	v0,a1,53
a000484c:	90450000 	lbu	a1,0(v0)
a0004850:	a0650000 	sb	a1,0(v1)
		if(image_size>=BBI_DMA_OFFSET)
		oob_addr[BBI_SWAP_OFFSET]=image_addr[BBI_DMA_OFFSET];
		image_addr[BBI_DMA_OFFSET]=0xFF;
		#endif
		
		flush_cache ();
a0004854:	0c001eae 	jal	a0007ab8 <flush_cache>
a0004858:	a0440000 	sb	a0,0(v0)
a000485c:	00001021 	move	v0,zero
a0004860:	00008021 	move	s0,zero
		//printf("W  oob_buf [%d] is %x \n",BBI_SWAP_OFFSET, oob_addr[BBI_SWAP_OFFSET]); 
		
	}
	#endif
	
	for(page_shift=0;page_shift<3; page_shift++) {
a0004864:	24050018 	li	a1,24
		 page_num[page_shift] = ((page_start>>(8*page_shift)) & 0xff);
		 if(!NAND_ADDR_CYCLE){
		 	 flash_addr_t |= (page_num[page_shift] << (12+8*page_shift));
a0004868:	00511807 	srav	v1,s1,v0
a000486c:	306300ff 	andi	v1,v1,0xff
a0004870:	2444000c 	addiu	a0,v0,12
a0004874:	00831804 	sllv	v1,v1,a0
a0004878:	24420008 	addiu	v0,v0,8
		//printf("W  oob_buf [%d] is %x \n",BBI_SWAP_OFFSET, oob_addr[BBI_SWAP_OFFSET]); 
		
	}
	#endif
	
	for(page_shift=0;page_shift<3; page_shift++) {
a000487c:	1445fffa 	bne	v0,a1,a0004868 <rtk_write_ecc_page_a+0x100>
a0004880:	02038025 	or	s0,s0,v1
    	}

	//Setting default value of flash_addr_t1
	flash_addr_t1 = flash_addr_t;

	while( dma_size>0 ){
a0004884:	1a40005f 	blez	s2,a0004a04 <rtk_write_ecc_page_a+0x29c>
a0004888:	0000a821 	move	s5,zero
a000488c:	8fa20058 	lw	v0,88(sp)
a0004890:	afa20010 	sw	v0,16(sp)
a0004894:	afa00024 	sw	zero,36(sp)

		if( (dma_size%(ppb*page_size)) == 0)
			printf(".");
a0004898:	3c02a001 	lui	v0,0xa001
a000489c:	24426db8 	addiu	v0,v0,28088
a00048a0:	afa20028 	sw	v0,40(sp)

		while(dma_counter >0) {  //Move 1 page
		//printf("-->dma_counter:%x r\n",dma_counter);
#if 1
			check_ready_nand();
			rtk_writel( (rtk_readl(NACR) |ECC_enable & (~RBO) & (~WBO)), NACR);
a00048a4:	3c02b801 	lui	v0,0xb801
a00048a8:	3456a004 	ori	s6,v0,0xa004

			//set DMA RAM start address
			dram_sa = ((unsigned int)image_addr+buf_pos*512) & (~M_mask);
			rtk_writel( dram_sa, NADRSAR);
a00048ac:	3443a020 	ori	v1,v0,0xa020
a00048b0:	afa30014 	sw	v1,20(sp)
			//printf("NADRSAR : 0x%08X ",rtk_readl(NADRSAR));

			//set DMA OOB start address
			oob_sa = ((unsigned int) oob_addr+buf_pos*16) & (~M_mask);
			rtk_writel( oob_sa, NADTSAR);
a00048b4:	3457a024 	ori	s7,v0,0xa024

			//set DMA flash start address
			   //flash_addr_t &= 0x1fffffff;
			rtk_writel( flash_addr_t, NADFSAR);
a00048b8:	3444a018 	ori	a0,v0,0xa018
a00048bc:	afa40018 	sw	a0,24(sp)
		
			//set OOB address
				rtk_writel(oob_sa, NADTSAR);
	 flush_cache ();		
			//DMA write
			rtk_writel( (~TAG_DIS) & (DESC0|DMAWE|LBC_128),NADCRR);	
a00048c0:	3442a010 	ori	v0,v0,0xa010
a00048c4:	afa2001c 	sw	v0,28(sp)
			check_ready_nand();
			rtk_writel( (rtk_readl(NACR) |ECC_enable & (~RBO) & (~WBO)), NACR);

			//set DMA RAM start address
			dram_sa = ((unsigned int)image_addr+buf_pos*512) & (~M_mask);
			rtk_writel( dram_sa, NADRSAR);
a00048c8:	3c1e1fff 	lui	s8,0x1fff
a00048cc:	37deffff 	ori	s8,s8,0xffff
	//Setting default value of flash_addr_t1
	flash_addr_t1 = flash_addr_t;

	while( dma_size>0 ){

		if( (dma_size%(ppb*page_size)) == 0)
a00048d0:	afb20020 	sw	s2,32(sp)
a00048d4:	3c05a001 	lui	a1,0xa001
a00048d8:	8ca37544 	lw	v1,30020(a1)
a00048dc:	3c04a001 	lui	a0,0xa001
a00048e0:	8c82754c 	lw	v0,30028(a0)
a00048e4:	70621002 	mul	v0,v1,v0
a00048e8:	0242001b 	divu	zero,s2,v0
a00048ec:	004001f4 	teq	v0,zero,0x7
a00048f0:	00001010 	mfhi	v0
a00048f4:	14400004 	bnez	v0,a0004908 <rtk_write_ecc_page_a+0x1a0>
a00048f8:	3c02a001 	lui	v0,0xa001
			printf(".");
a00048fc:	0c002325 	jal	a0008c94 <dprintf>
a0004900:	8fa40028 	lw	a0,40(sp)

		dma_counter = page_size >> 9;
a0004904:	3c02a001 	lui	v0,0xa001
a0004908:	8c517544 	lw	s1,30020(v0)
		//printf("dma_counter:%x image:%x\r\n",dma_counter,page_size);
		

		flush_cache ();
a000490c:	0c001eae 	jal	a0007ab8 <flush_cache>
a0004910:	00118a42 	srl	s1,s1,0x9
		if(oob_addr){
a0004914:	8fa30060 	lw	v1,96(sp)
a0004918:	10600003 	beqz	v1,a0004928 <rtk_write_ecc_page_a+0x1c0>
a000491c:	00000000 	nop
			flush_cache ();
a0004920:	0c001eae 	jal	a0007ab8 <flush_cache>
a0004924:	00000000 	nop
		}

		while(dma_counter >0) {  //Move 1 page
a0004928:	1a20002a 	blez	s1,a00049d4 <rtk_write_ecc_page_a+0x26c>
a000492c:	00151240 	sll	v0,s5,0x9
a0004930:	8fa4005c 	lw	a0,92(sp)
a0004934:	00829021 	addu	s2,a0,v0
a0004938:	0015a100 	sll	s4,s5,0x4
a000493c:	8fa50060 	lw	a1,96(sp)
a0004940:	00b49821 	addu	s3,a1,s4
a0004944:	0282a021 	addu	s4,s4,v0
		//printf("-->dma_counter:%x r\n",dma_counter);
#if 1
			check_ready_nand();
a0004948:	0c000f80 	jal	a0003e00 <check_ready_nand>
a000494c:	00000000 	nop
			rtk_writel( (rtk_readl(NACR) |ECC_enable & (~RBO) & (~WBO)), NACR);
a0004950:	8ec20000 	lw	v0,0(s6)
a0004954:	3c034000 	lui	v1,0x4000
a0004958:	00431025 	or	v0,v0,v1
a000495c:	aec20000 	sw	v0,0(s6)

			//set DMA RAM start address
			dram_sa = ((unsigned int)image_addr+buf_pos*512) & (~M_mask);
			rtk_writel( dram_sa, NADRSAR);
a0004960:	025e1024 	and	v0,s2,s8
a0004964:	8fa40014 	lw	a0,20(sp)
a0004968:	ac820000 	sw	v0,0(a0)
			//printf("NADRSAR : 0x%08X ",rtk_readl(NADRSAR));

			//set DMA OOB start address
			oob_sa = ((unsigned int) oob_addr+buf_pos*16) & (~M_mask);
			rtk_writel( oob_sa, NADTSAR);
a000496c:	027e1024 	and	v0,s3,s8
a0004970:	aee20000 	sw	v0,0(s7)

			//set DMA flash start address
			   //flash_addr_t &= 0x1fffffff;
			rtk_writel( flash_addr_t, NADFSAR);
a0004974:	8fa50018 	lw	a1,24(sp)
a0004978:	acb00000 	sw	s0,0(a1)
			//printf("flash_addr_t:0x%08X NADFSAR : 0x%08X  c:%x\n\r",flash_addr_t,rtk_readl(NADFSAR),dma_counter);
			flash_addr_t +=528;
a000497c:	26100210 	addiu	s0,s0,528
		
			//set OOB address
				rtk_writel(oob_sa, NADTSAR);
a0004980:	aee20000 	sw	v0,0(s7)
	 flush_cache ();		
a0004984:	0c001eae 	jal	a0007ab8 <flush_cache>
a0004988:	00000000 	nop
			//DMA write
			rtk_writel( (~TAG_DIS) & (DESC0|DMAWE|LBC_128),NADCRR);	
a000498c:	24030017 	li	v1,23
a0004990:	8fa2001c 	lw	v0,28(sp)
a0004994:	ac430000 	sw	v1,0(v0)
			check_ready_nand();
a0004998:	0c000f80 	jal	a0003e00 <check_ready_nand>
a000499c:	00000000 	nop
            //DMA write
            rtk_writel ((~TAG_DIS) &
                        ((0 << TAG_SEL) | DESC0 | DMAWE | LBC_128), NADCRR);
          check_ready_nand ();
#endif
			if(FAIL== rtk_check_pageData((page_start+page_counter), buf_pos*(512+16)))
a00049a0:	8fa40010 	lw	a0,16(sp)
a00049a4:	0c00118a 	jal	a0004628 <rtk_check_pageData>
a00049a8:	02802821 	move	a1,s4
a00049ac:	2404ffff 	li	a0,-1
a00049b0:	14440003 	bne	v0,a0,a00049c0 <rtk_write_ecc_page_a+0x258>
a00049b4:	2631ffff 	addiu	s1,s1,-1
a00049b8:	08001296 	j	a0004a58 <rtk_write_ecc_page_a+0x2f0>
a00049bc:	2402ffff 	li	v0,-1
				return FAIL;
			
			dma_counter--;
			buf_pos++;
a00049c0:	26b50001 	addiu	s5,s5,1
a00049c4:	26520200 	addiu	s2,s2,512
a00049c8:	26730010 	addiu	s3,s3,16
		flush_cache ();
		if(oob_addr){
			flush_cache ();
		}

		while(dma_counter >0) {  //Move 1 page
a00049cc:	1e20ffde 	bgtz	s1,a0004948 <rtk_write_ecc_page_a+0x1e0>
a00049d0:	26940210 	addiu	s4,s4,528
		else
			flash_addr_t1 =page_counter*0x200;
		
		
		flash_addr_t = flash_addr_t1;
		dma_size -= page_size;
a00049d4:	3c05a001 	lui	a1,0xa001
a00049d8:	8cb27544 	lw	s2,30020(a1)
a00049dc:	8fa20020 	lw	v0,32(sp)
a00049e0:	00529023 	subu	s2,v0,s2
a00049e4:	8fa30024 	lw	v1,36(sp)
a00049e8:	24701000 	addiu	s0,v1,4096
a00049ec:	8fa40010 	lw	a0,16(sp)
a00049f0:	24840001 	addiu	a0,a0,1
    	}

	//Setting default value of flash_addr_t1
	flash_addr_t1 = flash_addr_t;

	while( dma_size>0 ){
a00049f4:	1a400003 	blez	s2,a0004a04 <rtk_write_ecc_page_a+0x29c>
a00049f8:	afa40010 	sw	a0,16(sp)
a00049fc:	08001234 	j	a00048d0 <rtk_write_ecc_page_a+0x168>
a0004a00:	afb00024 	sw	s0,36(sp)
		flash_addr_t = flash_addr_t1;
		dma_size -= page_size;
		//printf("flash_addr_t:%x dma_size %x\r\n",flash_addr_t,dma_size);

	}
	 flush_cache ();
a0004a04:	0c001eae 	jal	a0007ab8 <flush_cache>
a0004a08:	00000000 	nop
	#ifdef SWAP_2K_DATA
	block = flash_page/ppb;
	//unsigned int write_bbi;
	//unsigned char switch_bbi = 0;
	
	if(block>=BOOT_BLOCK)
a0004a0c:	3c02a001 	lui	v0,0xa001
a0004a10:	8c42754c 	lw	v0,30028(v0)
a0004a14:	8fa40058 	lw	a0,88(sp)
a0004a18:	0082001b 	divu	zero,a0,v0
a0004a1c:	004001f4 	teq	v0,zero,0x7
a0004a20:	00001812 	mflo	v1
a0004a24:	28630002 	slti	v1,v1,2
a0004a28:	1460000b 	bnez	v1,a0004a58 <rtk_write_ecc_page_a+0x2f0>
a0004a2c:	00001021 	move	v0,zero

		if(!NAND_ADDR_CYCLE)
		{
			unsigned char temp_val;
			if(switch_bbi){
				temp_val = image_addr[BBI_DMA_OFFSET];
a0004a30:	8fa5005c 	lw	a1,92(sp)
a0004a34:	24a307d0 	addiu	v1,a1,2000
a0004a38:	90640000 	lbu	a0,0(v1)
				image_addr[BBI_DMA_OFFSET] = oob_addr[BBI_SWAP_OFFSET];
a0004a3c:	8fa50060 	lw	a1,96(sp)
a0004a40:	24a20035 	addiu	v0,a1,53
a0004a44:	90450000 	lbu	a1,0(v0)
a0004a48:	a0650000 	sb	a1,0(v1)
		if(image_size>=BBI_DMA_OFFSET)
			oob_addr[BBI_SWAP_OFFSET]=image_addr[BBI_DMA_OFFSET];
		image_addr[BBI_DMA_OFFSET]=0xFF;
		#endif
		
		flush_cache ();
a0004a4c:	0c001eae 	jal	a0007ab8 <flush_cache>
a0004a50:	a0440000 	sb	a0,0(v0)
a0004a54:	00001021 	move	v0,zero
	}
	#endif

	//free(oob_buf);
	return SUCCESS;
}
a0004a58:	8fbf0054 	lw	ra,84(sp)
a0004a5c:	8fbe0050 	lw	s8,80(sp)
a0004a60:	8fb7004c 	lw	s7,76(sp)
a0004a64:	8fb60048 	lw	s6,72(sp)
a0004a68:	8fb50044 	lw	s5,68(sp)
a0004a6c:	8fb40040 	lw	s4,64(sp)
a0004a70:	8fb3003c 	lw	s3,60(sp)
a0004a74:	8fb20038 	lw	s2,56(sp)
a0004a78:	8fb10034 	lw	s1,52(sp)
a0004a7c:	8fb00030 	lw	s0,48(sp)
a0004a80:	03e00008 	jr	ra
a0004a84:	27bd0058 	addiu	sp,sp,88

a0004a88 <rtk_read_ecc_page_a>:
//		image_size	: the length of image
// Output:
//		BOOL: 0=>OK, -1=>FAIL
//####################################################################
int  rtk_read_ecc_page_a (unsigned int flash_page, unsigned char *image_addr, unsigned char *oob_addr, unsigned int image_size)
{
a0004a88:	27bdffa8 	addiu	sp,sp,-88
a0004a8c:	afbf0054 	sw	ra,84(sp)
a0004a90:	afbe0050 	sw	s8,80(sp)
a0004a94:	afb7004c 	sw	s7,76(sp)
a0004a98:	afb60048 	sw	s6,72(sp)
a0004a9c:	afb50044 	sw	s5,68(sp)
a0004aa0:	afb40040 	sw	s4,64(sp)
a0004aa4:	afb3003c 	sw	s3,60(sp)
a0004aa8:	afb20038 	sw	s2,56(sp)
a0004aac:	afb10034 	sw	s1,52(sp)
a0004ab0:	afb00030 	sw	s0,48(sp)
a0004ab4:	afa40058 	sw	a0,88(sp)
a0004ab8:	afa5005c 	sw	a1,92(sp)
    //debug cl for safe not write in 0,1 block that is for boot.
	if((flash_page < 128||flash_page > chip_size/page_size - 1)
a0004abc:	2c820080 	sltiu	v0,a0,128
a0004ac0:	1440000c 	bnez	v0,a0004af4 <rtk_read_ecc_page_a+0x6c>
a0004ac4:	afa60060 	sw	a2,96(sp)
a0004ac8:	3c02a002 	lui	v0,0xa002
a0004acc:	8c438880 	lw	v1,-30592(v0)
a0004ad0:	3c02a001 	lui	v0,0xa001
a0004ad4:	8c427544 	lw	v0,30020(v0)
a0004ad8:	0062001b 	divu	zero,v1,v0
a0004adc:	004001f4 	teq	v0,zero,0x7
a0004ae0:	00001812 	mflo	v1
a0004ae4:	2462ffff 	addiu	v0,v1,-1
a0004ae8:	0044102b 	sltu	v0,v0,a0
a0004aec:	10400004 	beqz	v0,a0004b00 <rtk_read_ecc_page_a+0x78>
a0004af0:	3c02a001 	lui	v0,0xa001
a0004af4:	3c02a002 	lui	v0,0xa002
a0004af8:	ac408884 	sw	zero,-30588(v0)
	int page_counter=0;
	int page_num[3], page_shift=0, page_start;
	unsigned char * oob_buf;
	unsigned long flash_addr_t=0, flash_addr_t1;
	#ifdef SWAP_2K_DATA
	int block= flash_page/ppb;
a0004afc:	3c02a001 	lui	v0,0xa001
a0004b00:	8c42754c 	lw	v0,30028(v0)
a0004b04:	afa2002c 	sw	v0,44(sp)
	#endif
	
	//Page size alignment
	dma_size = image_size;
	if( image_size%page_size ){
a0004b08:	3c02a001 	lui	v0,0xa001
a0004b0c:	8c427544 	lw	v0,30020(v0)
a0004b10:	00e2001b 	divu	zero,a3,v0
a0004b14:	004001f4 	teq	v0,zero,0x7
a0004b18:	00001010 	mfhi	v0
	#ifdef SWAP_2K_DATA
	int block= flash_page/ppb;
	#endif
	
	//Page size alignment
	dma_size = image_size;
a0004b1c:	00e23821 	addu	a3,a3,v0
a0004b20:	afa70020 	sw	a3,32(sp)
	if( image_size%page_size ){
		dma_size +=(image_size%page_size);
	}

	//Translate nand flash address
	page_start = flash_page;
a0004b24:	8fa60058 	lw	a2,88(sp)
a0004b28:	00001021 	move	v0,zero
a0004b2c:	00008021 	move	s0,zero
	
	for(page_shift=0;page_shift<3; page_shift++) {
a0004b30:	24050018 	li	a1,24
             	page_num[page_shift] = ((page_start>>(8*page_shift)) & 0xff);
		if(!NAND_ADDR_CYCLE)
             		flash_addr_t |= (page_num[page_shift] << (12+8*page_shift));
a0004b34:	00461807 	srav	v1,a2,v0
a0004b38:	306300ff 	andi	v1,v1,0xff
a0004b3c:	2444000c 	addiu	a0,v0,12
a0004b40:	00831804 	sllv	v1,v1,a0
a0004b44:	24420008 	addiu	v0,v0,8
	}

	//Translate nand flash address
	page_start = flash_page;
	
	for(page_shift=0;page_shift<3; page_shift++) {
a0004b48:	1445fffa 	bne	v0,a1,a0004b34 <rtk_read_ecc_page_a+0xac>
a0004b4c:	02038025 	or	s0,s0,v1
    	}

	//Setting default value of flash_addr_t1
	flash_addr_t1 = flash_addr_t;
	
	while( dma_size>0 ){
a0004b50:	8fa20020 	lw	v0,32(sp)
a0004b54:	18400053 	blez	v0,a0004ca4 <rtk_read_ecc_page_a+0x21c>
a0004b58:	8fbe0058 	lw	s8,88(sp)
a0004b5c:	afb00028 	sw	s0,40(sp)
a0004b60:	afa00024 	sw	zero,36(sp)
a0004b64:	0000a821 	move	s5,zero
		}

		while(dma_counter >0) {  //Move 1 page
			flush_cache ();
			check_ready_nand();//check_ready();
			rtk_writel( (rtk_readl(NACR) |ECC_enable & (~RBO) & (~WBO)), NACR);
a0004b68:	3c02b801 	lui	v0,0xb801
a0004b6c:	3456a004 	ori	s6,v0,0xa004

			//set DMA RAM start address
			dram_sa = ((unsigned int)image_addr+buf_pos*512) & (~M_mask);
			rtk_writel( dram_sa, NADRSAR);
a0004b70:	3443a020 	ori	v1,v0,0xa020
a0004b74:	afa30010 	sw	v1,16(sp)
			//printf("SDRAM address: 0x%08X ",dram_sa);

			//set DMA oob start address
			//oob_sa = ((unsigned int)oob_buf+buf_pos*16) & (~M_mask);
			oob_sa = ((unsigned int)oob_addr+buf_pos*16) & (~M_mask);
			rtk_writel( oob_sa, NADTSAR);
a0004b78:	3444a024 	ori	a0,v0,0xa024
a0004b7c:	afa40014 	sw	a0,20(sp)

			//set DMA flash start address
			rtk_writel( flash_addr_t, NADFSAR);
a0004b80:	3445a018 	ori	a1,v0,0xa018
a0004b84:	afa50018 	sw	a1,24(sp)
			//printf("Flash address: 0x%08X \n\r",flash_addr_t);
			flash_addr_t +=528;
			
			//DMA read
			rtk_writel((~TAG_DIS) & (DESC0|DMARE|LBC_128),NADCRR);	
a0004b88:	3442a010 	ori	v0,v0,0xa010
a0004b8c:	afa2001c 	sw	v0,28(sp)
			check_ready_nand();//check_ready();
			rtk_writel( (rtk_readl(NACR) |ECC_enable & (~RBO) & (~WBO)), NACR);

			//set DMA RAM start address
			dram_sa = ((unsigned int)image_addr+buf_pos*512) & (~M_mask);
			rtk_writel( dram_sa, NADRSAR);
a0004b90:	3c171fff 	lui	s7,0x1fff
a0004b94:	36f7ffff 	ori	s7,s7,0xffff
	flash_addr_t1 = flash_addr_t;
	
	while( dma_size>0 ){

		//printf("[%s:] %d\n",__func__,__LINE__);
		dma_counter = page_size >> 9;
a0004b98:	3c02a001 	lui	v0,0xa001
a0004b9c:	8c517544 	lw	s1,30020(v0)

		if(oob_addr){
a0004ba0:	8fa30060 	lw	v1,96(sp)
a0004ba4:	10600003 	beqz	v1,a0004bb4 <rtk_read_ecc_page_a+0x12c>
a0004ba8:	00118a42 	srl	s1,s1,0x9
			flush_cache ();
a0004bac:	0c001eae 	jal	a0007ab8 <flush_cache>
a0004bb0:	00000000 	nop
				//dma_cache_writeb();
		}

		while(dma_counter >0) {  //Move 1 page
a0004bb4:	1a20002c 	blez	s1,a0004c68 <rtk_read_ecc_page_a+0x1e0>
a0004bb8:	00151240 	sll	v0,s5,0x9
a0004bbc:	8fa4005c 	lw	a0,92(sp)
a0004bc0:	00829021 	addu	s2,a0,v0
a0004bc4:	0015a100 	sll	s4,s5,0x4
a0004bc8:	8fa50060 	lw	a1,96(sp)
a0004bcc:	00b49821 	addu	s3,a1,s4
a0004bd0:	0282a021 	addu	s4,s4,v0
			flush_cache ();
a0004bd4:	0c001eae 	jal	a0007ab8 <flush_cache>
a0004bd8:	00000000 	nop
			check_ready_nand();//check_ready();
a0004bdc:	0c000f80 	jal	a0003e00 <check_ready_nand>
a0004be0:	00000000 	nop
			rtk_writel( (rtk_readl(NACR) |ECC_enable & (~RBO) & (~WBO)), NACR);
a0004be4:	8ec20000 	lw	v0,0(s6)
a0004be8:	3c034000 	lui	v1,0x4000
a0004bec:	00431025 	or	v0,v0,v1
a0004bf0:	aec20000 	sw	v0,0(s6)

			//set DMA RAM start address
			dram_sa = ((unsigned int)image_addr+buf_pos*512) & (~M_mask);
			rtk_writel( dram_sa, NADRSAR);
a0004bf4:	02571024 	and	v0,s2,s7
a0004bf8:	8fa40010 	lw	a0,16(sp)
a0004bfc:	ac820000 	sw	v0,0(a0)
			//printf("SDRAM address: 0x%08X ",dram_sa);

			//set DMA oob start address
			//oob_sa = ((unsigned int)oob_buf+buf_pos*16) & (~M_mask);
			oob_sa = ((unsigned int)oob_addr+buf_pos*16) & (~M_mask);
			rtk_writel( oob_sa, NADTSAR);
a0004c00:	02771024 	and	v0,s3,s7
a0004c04:	8fa50014 	lw	a1,20(sp)
a0004c08:	aca20000 	sw	v0,0(a1)

			//set DMA flash start address
			rtk_writel( flash_addr_t, NADFSAR);
a0004c0c:	8fa20018 	lw	v0,24(sp)
a0004c10:	ac500000 	sw	s0,0(v0)
			//printf("Flash address: 0x%08X \n\r",flash_addr_t);
			flash_addr_t +=528;
a0004c14:	26100210 	addiu	s0,s0,528
			
			//DMA read
			rtk_writel((~TAG_DIS) & (DESC0|DMARE|LBC_128),NADCRR);	
a0004c18:	2404001b 	li	a0,27
a0004c1c:	8fa3001c 	lw	v1,28(sp)
a0004c20:	ac640000 	sw	a0,0(v1)
			check_ready_nand(); //check_ready();
a0004c24:	0c000f80 	jal	a0003e00 <check_ready_nand>
a0004c28:	00000000 	nop

			if(FAIL== rtk_check_pageData((page_start+page_counter), buf_pos*(512+16))) {
a0004c2c:	03c02021 	move	a0,s8
a0004c30:	0c00118a 	jal	a0004628 <rtk_check_pageData>
a0004c34:	02802821 	move	a1,s4
a0004c38:	2405ffff 	li	a1,-1
a0004c3c:	14450005 	bne	v0,a1,a0004c54 <rtk_read_ecc_page_a+0x1cc>
a0004c40:	2631ffff 	addiu	s1,s1,-1
				flush_cache ();//dma_cache_writeb();
a0004c44:	0c001eae 	jal	a0007ab8 <flush_cache>
a0004c48:	00000000 	nop
				return FAIL;
a0004c4c:	0800133d 	j	a0004cf4 <rtk_read_ecc_page_a+0x26c>
a0004c50:	2402ffff 	li	v0,-1
			}
			
			dma_counter--;
			buf_pos++;
a0004c54:	26b50001 	addiu	s5,s5,1
a0004c58:	26520200 	addiu	s2,s2,512
a0004c5c:	26730010 	addiu	s3,s3,16
		if(oob_addr){
			flush_cache ();
				//dma_cache_writeb();
		}

		while(dma_counter >0) {  //Move 1 page
a0004c60:	1e20ffdc 	bgtz	s1,a0004bd4 <rtk_read_ecc_page_a+0x14c>
a0004c64:	26940210 	addiu	s4,s4,528
		}else{
			flash_addr_t1 +=page_counter*0x200;
		}
		
		flash_addr_t = flash_addr_t1;
		dma_size -= page_size;
a0004c68:	3c03a001 	lui	v1,0xa001
a0004c6c:	8c627544 	lw	v0,30020(v1)
a0004c70:	8fa40020 	lw	a0,32(sp)
a0004c74:	00822023 	subu	a0,a0,v0
a0004c78:	afa40020 	sw	a0,32(sp)
a0004c7c:	8fa50024 	lw	a1,36(sp)
a0004c80:	24a51000 	addiu	a1,a1,4096
a0004c84:	afa50024 	sw	a1,36(sp)
    	}

	//Setting default value of flash_addr_t1
	flash_addr_t1 = flash_addr_t;
	
	while( dma_size>0 ){
a0004c88:	18800006 	blez	a0,a0004ca4 <rtk_read_ecc_page_a+0x21c>
a0004c8c:	27de0001 	addiu	s8,s8,1
		}

		page_counter +=1;

		if(!NAND_ADDR_CYCLE){
			flash_addr_t1 +=page_counter*0x1000;
a0004c90:	8fa20028 	lw	v0,40(sp)
a0004c94:	00451021 	addu	v0,v0,a1
a0004c98:	afa20028 	sw	v0,40(sp)
a0004c9c:	080012e6 	j	a0004b98 <rtk_read_ecc_page_a+0x110>
a0004ca0:	00408021 	move	s0,v0
		flash_addr_t = flash_addr_t1;
		dma_size -= page_size;
		
	}

	flush_cache ();
a0004ca4:	0c001eae 	jal	a0007ab8 <flush_cache>
a0004ca8:	00000000 	nop
	#ifdef SWAP_2K_DATA
	if(block>=BOOT_BLOCK){
a0004cac:	8fa40058 	lw	a0,88(sp)
a0004cb0:	8fa5002c 	lw	a1,44(sp)
a0004cb4:	0085001b 	divu	zero,a0,a1
a0004cb8:	00a001f4 	teq	a1,zero,0x7
a0004cbc:	00001812 	mflo	v1
a0004cc0:	28630002 	slti	v1,v1,2
a0004cc4:	1460000b 	bnez	v1,a0004cf4 <rtk_read_ecc_page_a+0x26c>
a0004cc8:	00001021 	move	v0,zero
		if(!NAND_ADDR_CYCLE)
		{
			/*switch bad block info*/
			unsigned char temp_val=0;
			if(switch_bbi){
				temp_val = image_addr[DATA_BBI_OFF];
a0004ccc:	8fa2005c 	lw	v0,92(sp)
a0004cd0:	244307d0 	addiu	v1,v0,2000
a0004cd4:	90640000 	lbu	a0,0(v1)
				image_addr[DATA_BBI_OFF] = oob_addr[BBI_SWAP_OFFSET]; 
a0004cd8:	8fa50060 	lw	a1,96(sp)
a0004cdc:	24a20035 	addiu	v0,a1,53
a0004ce0:	90450000 	lbu	a1,0(v0)
a0004ce4:	a0650000 	sb	a1,0(v1)
		if(image_size>=BBI_DMA_OFFSET)
		image_addr[BBI_DMA_OFFSET]=oob_addr[BBI_SWAP_OFFSET];
		oob_addr[BBI_SWAP_OFFSET]=0xFF;
		#endif
		
		flush_cache ();
a0004ce8:	0c001eae 	jal	a0007ab8 <flush_cache>
a0004cec:	a0440000 	sb	a0,0(v0)
a0004cf0:	00001021 	move	v0,zero
		
	}
	#endif
	//free(oob_buf);
	return SUCCESS;
}
a0004cf4:	8fbf0054 	lw	ra,84(sp)
a0004cf8:	8fbe0050 	lw	s8,80(sp)
a0004cfc:	8fb7004c 	lw	s7,76(sp)
a0004d00:	8fb60048 	lw	s6,72(sp)
a0004d04:	8fb50044 	lw	s5,68(sp)
a0004d08:	8fb40040 	lw	s4,64(sp)
a0004d0c:	8fb3003c 	lw	s3,60(sp)
a0004d10:	8fb20038 	lw	s2,56(sp)
a0004d14:	8fb10034 	lw	s1,52(sp)
a0004d18:	8fb00030 	lw	s0,48(sp)
a0004d1c:	03e00008 	jr	ra
a0004d20:	27bd0058 	addiu	sp,sp,88

a0004d24 <rtk_block_isbad>:
//		BOOL: 0=>OK, 
//			 -1=>This block is bad, 
//			   1=>Read oob area fail,
//####################################################################
int rtk_block_isbad(unsigned int ofs)
{
a0004d24:	27bdffe0 	addiu	sp,sp,-32
a0004d28:	afbf001c 	sw	ra,28(sp)
a0004d2c:	afb10018 	sw	s1,24(sp)
a0004d30:	afb00014 	sw	s0,20(sp)
	int i;

	unsigned char * oob_buf = mybuf;
	unsigned char * data_buf = mydatabuf;

	page = ((int) ofs) >> page_shift;
a0004d34:	3c02a002 	lui	v0,0xa002
a0004d38:	8c508878 	lw	s0,-30600(v0)
a0004d3c:	02048007 	srav	s0,a0,s0
	page_offset = page & (ppb-1);
	block = page/ppb;
a0004d40:	3c02a001 	lui	v0,0xa001
a0004d44:	8c42754c 	lw	v0,30028(v0)
a0004d48:	0202001b 	divu	zero,s0,v0
a0004d4c:	004001f4 	teq	v0,zero,0x7

	if ( isLastPage ){
a0004d50:	3c03a002 	lui	v1,0xa002
a0004d54:	8c63887c 	lw	v1,-30596(v1)
a0004d58:	10600018 	beqz	v1,a0004dbc <rtk_block_isbad+0x98>
a0004d5c:	00008812 	mflo	s1
		page = block*ppb + (ppb-1);	
a0004d60:	26300001 	addiu	s0,s1,1
a0004d64:	72028002 	mul	s0,s0,v0
a0004d68:	2610ffff 	addiu	s0,s0,-1
		if(rtk_read_ecc_page_a(page, data_buf, oob_buf, page_size)){
a0004d6c:	02002021 	move	a0,s0
a0004d70:	3c05a002 	lui	a1,0xa002
a0004d74:	24a5a2a8 	addiu	a1,a1,-23896
a0004d78:	3c06a002 	lui	a2,0xa002
a0004d7c:	24c6a204 	addiu	a2,a2,-24060
a0004d80:	3c02a001 	lui	v0,0xa001
a0004d84:	0c0012a2 	jal	a0004a88 <rtk_read_ecc_page_a>
a0004d88:	8c477544 	lw	a3,30020(v0)
a0004d8c:	10400008 	beqz	v0,a0004db0 <rtk_block_isbad+0x8c>
a0004d90:	3c04a001 	lui	a0,0xa001
			printf("%s: read_oob page=%d failed\n", __FUNCTION__, page);
a0004d94:	24844864 	addiu	a0,a0,18532
a0004d98:	3c05a001 	lui	a1,0xa001
a0004d9c:	24a50334 	addiu	a1,a1,820
a0004da0:	0c002325 	jal	a0008c94 <dprintf>
a0004da4:	02003021 	move	a2,s0
			return 1;
a0004da8:	0800138d 	j	a0004e34 <rtk_block_isbad+0x110>
a0004dac:	24020001 	li	v0,1
		}
		//ccwei 111116
        if(!NAND_ADDR_CYCLE)
		#ifdef SWAP_2K_DATA
			block_status_p1 = oob_buf[BBI_SWAP_OFFSET];
a0004db0:	3c02a002 	lui	v0,0xa002
a0004db4:	08001382 	j	a0004e08 <rtk_block_isbad+0xe4>
a0004db8:	9046a239 	lbu	a2,-24007(v0)
		#endif
		else
			block_status_p1 = oob_buf[5];
		
	}else{	
		if ( rtk_read_ecc_page_a(page, data_buf, oob_buf, page_size) ){
a0004dbc:	02002021 	move	a0,s0
a0004dc0:	3c05a002 	lui	a1,0xa002
a0004dc4:	24a5a2a8 	addiu	a1,a1,-23896
a0004dc8:	3c06a002 	lui	a2,0xa002
a0004dcc:	24c6a204 	addiu	a2,a2,-24060
a0004dd0:	3c02a001 	lui	v0,0xa001
a0004dd4:	0c0012a2 	jal	a0004a88 <rtk_read_ecc_page_a>
a0004dd8:	8c477544 	lw	a3,30020(v0)
a0004ddc:	10400008 	beqz	v0,a0004e00 <rtk_block_isbad+0xdc>
a0004de0:	3c04a001 	lui	a0,0xa001
			printf ("%s: read_oob page=%d failed\n", __FUNCTION__, page);
a0004de4:	24844864 	addiu	a0,a0,18532
a0004de8:	3c05a001 	lui	a1,0xa001
a0004dec:	24a50334 	addiu	a1,a1,820
a0004df0:	0c002325 	jal	a0008c94 <dprintf>
a0004df4:	02003021 	move	a2,s0
			return 1;
a0004df8:	0800138d 	j	a0004e34 <rtk_block_isbad+0x110>
a0004dfc:	24020001 	li	v0,1
		}

	    //ccwei 111116
	    if(!NAND_ADDR_CYCLE)
	    #ifdef SWAP_2K_DATA
			block_status_p1 = oob_buf[BBI_SWAP_OFFSET];
a0004e00:	3c02a002 	lui	v0,0xa002
a0004e04:	9046a239 	lbu	a2,-24007(v0)
		#endif
	    else
		    block_status_p1 = oob_buf[5];
	}

	if( block_status_p1 == BBT_TAG){
a0004e08:	240200bb 	li	v0,187
a0004e0c:	10c20008 	beq	a2,v0,a0004e30 <rtk_block_isbad+0x10c>
a0004e10:	240200ff 	li	v0,255
		//printf("Reserved area for BBT: block=%d, block_status_p1=0x%x\n\r",block,block_status_p1);
		//printf("[%s:] %d block=%d is BBT_TAG already init ok\n",__func__,__LINE__,block);
		return 0;
	}else 
	if ( block_status_p1 != 0xff){		
a0004e14:	10c20006 	beq	a2,v0,a0004e30 <rtk_block_isbad+0x10c>
a0004e18:	3c04a001 	lui	a0,0xa001
		printf ("WARNING: Die 0: block=%d is bad, block_status_p1=0x%x\n\r", block, block_status_p1);
a0004e1c:	24844884 	addiu	a0,a0,18564
a0004e20:	0c002325 	jal	a0008c94 <dprintf>
a0004e24:	02202821 	move	a1,s1
		return -1;
a0004e28:	0800138d 	j	a0004e34 <rtk_block_isbad+0x110>
a0004e2c:	2402ffff 	li	v0,-1
a0004e30:	00001021 	move	v0,zero
	}
	//printf("[%s:] %d block is normal good ok\n",__func__,__LINE__);
	return 0;

}
a0004e34:	8fbf001c 	lw	ra,28(sp)
a0004e38:	8fb10018 	lw	s1,24(sp)
a0004e3c:	8fb00014 	lw	s0,20(sp)
a0004e40:	03e00008 	jr	ra
a0004e44:	27bd0020 	addiu	sp,sp,32

a0004e48 <dump_BBT>:
//		NON
// Output:
//		NON
//####################################################################
static void dump_BBT(void)
{
a0004e48:	27bdffc8 	addiu	sp,sp,-56
a0004e4c:	afbf0034 	sw	ra,52(sp)
a0004e50:	afb50030 	sw	s5,48(sp)
a0004e54:	afb4002c 	sw	s4,44(sp)
a0004e58:	afb30028 	sw	s3,40(sp)
a0004e5c:	afb20024 	sw	s2,36(sp)
a0004e60:	afb10020 	sw	s1,32(sp)
a0004e64:	afb0001c 	sw	s0,28(sp)
	int i;
	int BBs=0;

	printf("[%s] Nand BBT Content\n\r", __FUNCTION__);
a0004e68:	3c04a001 	lui	a0,0xa001
a0004e6c:	248448bc 	addiu	a0,a0,18620
a0004e70:	3c05a001 	lui	a1,0xa001
a0004e74:	0c002325 	jal	a0008c94 <dprintf>
a0004e78:	24a50394 	addiu	a1,a1,916

	for ( i=0; i<RBA; i++){
a0004e7c:	3c02a001 	lui	v0,0xa001
a0004e80:	8c427970 	lw	v0,31088(v0)
a0004e84:	10400029 	beqz	v0,a0004f2c <dump_BBT+0xe4>
a0004e88:	00008021 	move	s0,zero
a0004e8c:	00001821 	move	v1,zero
		if ( i==0 && bbt[i].BB_die == BB_DIE_INIT && bbt[i].bad_block == BB_INIT ){
			printf("Congratulation!! No BBs in this Nand.\n\r");
			break;
		}
		if ( bbt[i].bad_block != BB_INIT ){
			printf("[%d] (%d, %x, %x, %x)\n\r", i, bbt[i].BB_die,bbt[i].bad_block, 
a0004e90:	3c14a001 	lui	s4,0xa001
a0004e94:	269448fc 	addiu	s4,s4,18684
	for ( i=0; i<RBA; i++){
		if ( i==0 && bbt[i].BB_die == BB_DIE_INIT && bbt[i].bad_block == BB_INIT ){
			printf("Congratulation!! No BBs in this Nand.\n\r");
			break;
		}
		if ( bbt[i].bad_block != BB_INIT ){
a0004e98:	3c11a001 	lui	s1,0xa001
a0004e9c:	3413fffe 	li	s3,0xfffe
	int BBs=0;

	printf("[%s] Nand BBT Content\n\r", __FUNCTION__);

	for ( i=0; i<RBA; i++){
		if ( i==0 && bbt[i].BB_die == BB_DIE_INIT && bbt[i].bad_block == BB_INIT ){
a0004ea0:	3415eeee 	li	s5,0xeeee
	int i;
	int BBs=0;

	printf("[%s] Nand BBT Content\n\r", __FUNCTION__);

	for ( i=0; i<RBA; i++){
a0004ea4:	3c12a001 	lui	s2,0xa001
		if ( i==0 && bbt[i].BB_die == BB_DIE_INIT && bbt[i].bad_block == BB_INIT ){
a0004ea8:	1600000d 	bnez	s0,a0004ee0 <dump_BBT+0x98>
a0004eac:	000310c0 	sll	v0,v1,0x3
a0004eb0:	8e247974 	lw	a0,31092(s1)
a0004eb4:	00821021 	addu	v0,a0,v0
a0004eb8:	94440000 	lhu	a0,0(v0)
a0004ebc:	14950008 	bne	a0,s5,a0004ee0 <dump_BBT+0x98>
a0004ec0:	00000000 	nop
a0004ec4:	94470002 	lhu	a3,2(v0)
a0004ec8:	14f3000b 	bne	a3,s3,a0004ef8 <dump_BBT+0xb0>
a0004ecc:	3c04a001 	lui	a0,0xa001
			printf("Congratulation!! No BBs in this Nand.\n\r");
a0004ed0:	0c002325 	jal	a0008c94 <dprintf>
a0004ed4:	248448d4 	addiu	a0,a0,18644
			break;
a0004ed8:	080013cc 	j	a0004f30 <dump_BBT+0xe8>
a0004edc:	8fbf0034 	lw	ra,52(sp)
		}
		if ( bbt[i].bad_block != BB_INIT ){
a0004ee0:	000318c0 	sll	v1,v1,0x3
a0004ee4:	8e227974 	lw	v0,31092(s1)
a0004ee8:	00431021 	addu	v0,v0,v1
a0004eec:	94470002 	lhu	a3,2(v0)
a0004ef0:	10f30009 	beq	a3,s3,a0004f18 <dump_BBT+0xd0>
a0004ef4:	00000000 	nop
			printf("[%d] (%d, %x, %x, %x)\n\r", i, bbt[i].BB_die,bbt[i].bad_block, 
a0004ef8:	94460000 	lhu	a2,0(v0)
a0004efc:	94430004 	lhu	v1,4(v0)
a0004f00:	afa30010 	sw	v1,16(sp)
a0004f04:	94420006 	lhu	v0,6(v0)
a0004f08:	afa20014 	sw	v0,20(sp)
a0004f0c:	02802021 	move	a0,s4
a0004f10:	0c002325 	jal	a0008c94 <dprintf>
a0004f14:	02002821 	move	a1,s0
	int i;
	int BBs=0;

	printf("[%s] Nand BBT Content\n\r", __FUNCTION__);

	for ( i=0; i<RBA; i++){
a0004f18:	26100001 	addiu	s0,s0,1
a0004f1c:	8e427970 	lw	v0,31088(s2)
a0004f20:	0202102b 	sltu	v0,s0,v0
a0004f24:	1440ffe0 	bnez	v0,a0004ea8 <dump_BBT+0x60>
a0004f28:	02001821 	move	v1,s0
			BBs++;
		}
	}
	//this->BBs = BBs;
	return;
}
a0004f2c:	8fbf0034 	lw	ra,52(sp)
a0004f30:	8fb50030 	lw	s5,48(sp)
a0004f34:	8fb4002c 	lw	s4,44(sp)
a0004f38:	8fb30028 	lw	s3,40(sp)
a0004f3c:	8fb20024 	lw	s2,36(sp)
a0004f40:	8fb10020 	lw	s1,32(sp)
a0004f44:	8fb0001c 	lw	s0,28(sp)
a0004f48:	03e00008 	jr	ra
a0004f4c:	27bd0038 	addiu	sp,sp,56

a0004f50 <rtk_read_ecc_page>:
#endif
#if 1
void 
rtk_read_ecc_page (unsigned long flash_address, unsigned char *image_addr,
                   unsigned int image_size, char ecc_enable ) 
{
a0004f50:	27bdffb8 	addiu	sp,sp,-72
a0004f54:	afbf0044 	sw	ra,68(sp)
a0004f58:	afbe0040 	sw	s8,64(sp)
a0004f5c:	afb7003c 	sw	s7,60(sp)
a0004f60:	afb60038 	sw	s6,56(sp)
a0004f64:	afb50034 	sw	s5,52(sp)
a0004f68:	afb40030 	sw	s4,48(sp)
a0004f6c:	afb3002c 	sw	s3,44(sp)
a0004f70:	afb20028 	sw	s2,40(sp)
a0004f74:	afb10024 	sw	s1,36(sp)
a0004f78:	afb00020 	sw	s0,32(sp)
a0004f7c:	00808021 	move	s0,a0
a0004f80:	afa5004c 	sw	a1,76(sp)
a0004f84:	00c09021 	move	s2,a2
  //debug cl
  //dprintf("[%s]:%d for boot safe debug return directly\n",__func__,__LINE__);
  //return FAIL;
  flush_cache ();
a0004f88:	0c001eae 	jal	a0007ab8 <flush_cache>
a0004f8c:	7c078c20 	seb	s1,a3
	//	dprintf("[%s]:%d panic:fatal error *************,try to write in 0,1 block for boot,protect for debug\n",__func__,__LINE__);
	//	return FAIL;
	//}
  
    //default enable
    rtk_writel ((rtk_readl (NACR) | ECC_enable), NACR); //Enable ECC function
a0004f90:	3c02b801 	lui	v0,0xb801
a0004f94:	3442a004 	ori	v0,v0,0xa004
a0004f98:	8c440000 	lw	a0,0(v0)
a0004f9c:	3c034000 	lui	v1,0x4000
a0004fa0:	00831825 	or	v1,a0,v1
a0004fa4:	ac430000 	sw	v1,0(v0)
  if (ecc_enable == 0)
a0004fa8:	16200008 	bnez	s1,a0004fcc <rtk_read_ecc_page+0x7c>
a0004fac:	3c02b801 	lui	v0,0xb801
    
      //disable ECC function
      rtk_writel ((rtk_readl (NACR) & ~(ECC_enable)), NACR);
a0004fb0:	3442a004 	ori	v0,v0,0xa004
a0004fb4:	8c440000 	lw	a0,0(v0)
a0004fb8:	3c03bfff 	lui	v1,0xbfff
a0004fbc:	3463ffff 	ori	v1,v1,0xffff
a0004fc0:	00831824 	and	v1,a0,v1
a0004fc4:	ac430000 	sw	v1,0(v0)
    //dprintf("\n\recc_enable=%d\n",ecc_enable);
    
    /* Clear NAND Flash Status Register (NASR , 0xb801a020)
     *   NECN write "0" to clear bit [7:4] and NRER write "1" to clear bit[3].
     */ 
    rtk_writel ((rtk_readl (NASR) & 0xFFFFFF0F), NASR);
a0004fc8:	3c02b801 	lui	v0,0xb801
a0004fcc:	3442a028 	ori	v0,v0,0xa028
a0004fd0:	8c440000 	lw	a0,0(v0)
a0004fd4:	2403ff0f 	li	v1,-241
a0004fd8:	00831824 	and	v1,a0,v1
a0004fdc:	ac430000 	sw	v1,0(v0)
  check_ready_nand ();
a0004fe0:	0c000f80 	jal	a0003e00 <check_ready_nand>
a0004fe4:	00000000 	nop
    {
      dma_size += (image_size % 2048);
    }
  
#else   /*  */
   if ((flash_address % (page_size + oob_size)) != 0)
a0004fe8:	3c02a001 	lui	v0,0xa001
a0004fec:	8c457544 	lw	a1,30020(v0)
a0004ff0:	3c02a001 	lui	v0,0xa001
a0004ff4:	8c467548 	lw	a2,30024(v0)
a0004ff8:	00c51021 	addu	v0,a2,a1
a0004ffc:	0202001b 	divu	zero,s0,v0
a0005000:	004001f4 	teq	v0,zero,0x7
a0005004:	00001810 	mfhi	v1
a0005008:	10600006 	beqz	v1,a0005024 <rtk_read_ecc_page+0xd4>
a000500c:	00001821 	move	v1,zero
    {
     dprintf ("\n\rflash_address must be page(0x%x+0x%x Bytes) aligned!\n",
a0005010:	3c04a001 	lui	a0,0xa001
a0005014:	0c002325 	jal	a0008c94 <dprintf>
a0005018:	24844654 	addiu	a0,a0,18004
               page_size, oob_size);
        
     return;
a000501c:	0800144a 	j	a0005128 <rtk_read_ecc_page+0x1d8>
a0005020:	8fbf0044 	lw	ra,68(sp)
    /*Translate nand flash address formula */ 
#if 0                           //def NAND_Flash_Small_Page_32MB_3cycles
    flash_addr_t = flash_address;
  
#else   /*  */
    page_start = flash_address / (page_size + oob_size);
a0005024:	0202001b 	divu	zero,s0,v0
a0005028:	004001f4 	teq	v0,zero,0x7
a000502c:	00003012 	mflo	a2
a0005030:	00008021 	move	s0,zero
  for (page_shift = 0; page_shift < 3; page_shift++)
a0005034:	24020018 	li	v0,24
    {
      page_num[page_shift] = ((page_start >> (8 * page_shift)) & 0xff);
      flash_addr_t |= (page_num[page_shift] << (12 + 8 * page_shift));
a0005038:	00662007 	srav	a0,a2,v1
a000503c:	308400ff 	andi	a0,a0,0xff
a0005040:	2465000c 	addiu	a1,v1,12
a0005044:	00a42004 	sllv	a0,a0,a1
a0005048:	24630008 	addiu	v1,v1,8
#if 0                           //def NAND_Flash_Small_Page_32MB_3cycles
    flash_addr_t = flash_address;
  
#else   /*  */
    page_start = flash_address / (page_size + oob_size);
  for (page_shift = 0; page_shift < 3; page_shift++)
a000504c:	1462fffa 	bne	v1,v0,a0005038 <rtk_read_ecc_page+0xe8>
a0005050:	02048025 	or	s0,s0,a0
  
#endif  /*  */
    
    //DMA read
    //dprintf("\n\n(DMA Read)\r");
    while (dma_size > 0)
a0005054:	1a400031 	blez	s2,a000511c <rtk_read_ecc_page+0x1cc>
a0005058:	afb20010 	sw	s2,16(sp)
a000505c:	24c60001 	addiu	a2,a2,1
a0005060:	00063300 	sll	a2,a2,0xc
a0005064:	afa60014 	sw	a2,20(sp)
a0005068:	afa00018 	sw	zero,24(sp)
            }
          check_ready_nand ();
          
            //set DMA RAM start address
            dram_sa = ((unsigned int) image_addr + buf_pos * 512) & (~M_mask);
          rtk_writel (dram_sa, NADRSAR);
a000506c:	3c131fff 	lui	s3,0x1fff
a0005070:	3673ffff 	ori	s3,s3,0xffff
a0005074:	3c16b801 	lui	s6,0xb801
a0005078:	36d4a020 	ori	s4,s6,0xa020
          
             //dprintf("\nDMA-R:SDRAM address: 0x%X\n ",(dram_sa));
            
            //set DMA flash start address
            rtk_writel (flash_addr_t, NADFSAR);
a000507c:	36d5a018 	ori	s5,s6,0xa018
             //dprintf("\nFlash Laddress: 0x%X\n\n\r",(flash_addr_t));
            
            //DMA read
            //rtk_writel((~TAG_DIS) & (DESC0|DMARE|LBC_128),NADCRR);       //enable tag access
            //disable tag access
            rtk_writel ((TAG_DIS | DESC0 | DMARE | LBC_128), NADCRR);
a0005080:	36d6a010 	ori	s6,s6,0xa010
a0005084:	2417005b 	li	s7,91
    
    //DMA read
    //dprintf("\n\n(DMA Read)\r");
    while (dma_size > 0)
    {
      dma_counter = page_size >> 9;
a0005088:	3c02a001 	lui	v0,0xa001
a000508c:	8c5e7544 	lw	s8,30020(v0)
a0005090:	001ef242 	srl	s8,s8,0x9
      while (dma_counter > 0) //Move 1 page
a0005094:	1bc0001b 	blez	s8,a0005104 <rtk_read_ecc_page+0x1b4>
a0005098:	8fa20018 	lw	v0,24(sp)
a000509c:	00028a40 	sll	s1,v0,0x9
a00050a0:	8fa2004c 	lw	v0,76(sp)
a00050a4:	00518821 	addu	s1,v0,s1
a00050a8:	03c09021 	move	s2,s8
            {
              dma_total_Rcounter++;
              
                //dprintf("\nNAND_dma_Rcounter_512Bytes=0x%x\n",dma_total_Rcounter);
            }
          check_ready_nand ();
a00050ac:	0c000f80 	jal	a0003e00 <check_ready_nand>
a00050b0:	00000000 	nop
          
            //set DMA RAM start address
            dram_sa = ((unsigned int) image_addr + buf_pos * 512) & (~M_mask);
          rtk_writel (dram_sa, NADRSAR);
a00050b4:	02331024 	and	v0,s1,s3
a00050b8:	ae820000 	sw	v0,0(s4)
          
             //dprintf("\nDMA-R:SDRAM address: 0x%X\n ",(dram_sa));
            
            //set DMA flash start address
            rtk_writel (flash_addr_t, NADFSAR);
a00050bc:	aeb00000 	sw	s0,0(s5)
             //dprintf("\nFlash Laddress: 0x%X\n\n\r",(flash_addr_t));
            
            //DMA read
            //rtk_writel((~TAG_DIS) & (DESC0|DMARE|LBC_128),NADCRR);       //enable tag access
            //disable tag access
            rtk_writel ((TAG_DIS | DESC0 | DMARE | LBC_128), NADCRR);
a00050c0:	aed70000 	sw	s7,0(s6)
            check_ready_nand ();
a00050c4:	0c000f80 	jal	a0003e00 <check_ready_nand>
a00050c8:	26100210 	addiu	s0,s0,528
          
#endif  /*  */
            dma_counter--;
          buf_pos++;
          dma_size -= 512;
          flush_cache ();
a00050cc:	0c001eae 	jal	a0007ab8 <flush_cache>
a00050d0:	2652ffff 	addiu	s2,s2,-1
    //DMA read
    //dprintf("\n\n(DMA Read)\r");
    while (dma_size > 0)
    {
      dma_counter = page_size >> 9;
      while (dma_counter > 0) //Move 1 page
a00050d4:	1e40fff5 	bgtz	s2,a00050ac <rtk_read_ecc_page+0x15c>
a00050d8:	26310200 	addiu	s1,s1,512
a00050dc:	8fa20018 	lw	v0,24(sp)
a00050e0:	005e1021 	addu	v0,v0,s8
a00050e4:	afa20018 	sw	v0,24(sp)
a00050e8:	24020001 	li	v0,1
a00050ec:	005ef023 	subu	s8,v0,s8
a00050f0:	001ef240 	sll	s8,s8,0x9
a00050f4:	27defe00 	addiu	s8,s8,-512
a00050f8:	8fa20010 	lw	v0,16(sp)
a00050fc:	005e1021 	addu	v0,v0,s8
a0005100:	afa20010 	sw	v0,16(sp)
  
#endif  /*  */
    
    //DMA read
    //dprintf("\n\n(DMA Read)\r");
    while (dma_size > 0)
a0005104:	8fa20010 	lw	v0,16(sp)
a0005108:	18400004 	blez	v0,a000511c <rtk_read_ecc_page+0x1cc>
a000510c:	8fb00014 	lw	s0,20(sp)
a0005110:	26021000 	addiu	v0,s0,4096
a0005114:	08001422 	j	a0005088 <rtk_read_ecc_page+0x138>
a0005118:	afa20014 	sw	v0,20(sp)
        flash_addr_t1 = (page_counter * 0x1000) + (page_start * 0x1000);
           
#endif  /*  */
	 flash_addr_t = flash_addr_t1;
    }
  flush_cache ();
a000511c:	0c001eae 	jal	a0007ab8 <flush_cache>
a0005120:	00000000 	nop
}
a0005124:	8fbf0044 	lw	ra,68(sp)
a0005128:	8fbe0040 	lw	s8,64(sp)
a000512c:	8fb7003c 	lw	s7,60(sp)
a0005130:	8fb60038 	lw	s6,56(sp)
a0005134:	8fb50034 	lw	s5,52(sp)
a0005138:	8fb40030 	lw	s4,48(sp)
a000513c:	8fb3002c 	lw	s3,44(sp)
a0005140:	8fb20028 	lw	s2,40(sp)
a0005144:	8fb10024 	lw	s1,36(sp)
a0005148:	8fb00020 	lw	s0,32(sp)
a000514c:	03e00008 	jr	ra
a0005150:	27bd0048 	addiu	sp,sp,72

a0005154 <rtk_erase_block>:
}

#define REG32(reg)	(*(volatile unsigned int *)(reg))
#if 1
int rtk_erase_block (int page ) 
{
a0005154:	27bdffc0 	addiu	sp,sp,-64
a0005158:	afbf003c 	sw	ra,60(sp)
a000515c:	afb30038 	sw	s3,56(sp)
a0005160:	afb20034 	sw	s2,52(sp)
a0005164:	afb10030 	sw	s1,48(sp)
a0005168:	afb0002c 	sw	s0,44(sp)
  //dprintf("[%s]:%d for boot safe debug return directly\n",__func__,__LINE__);
  //return FAIL;

    //debug cl for safe not write in 0,1 block that is for boot.
	//if(page < 128||page > chip_size/page_size - 1)
	if(page > chip_size/page_size - 1)
a000516c:	3c02a002 	lui	v0,0xa002
a0005170:	8c438880 	lw	v1,-30592(v0)
a0005174:	3c02a001 	lui	v0,0xa001
a0005178:	8c427544 	lw	v0,30020(v0)
a000517c:	0062001b 	divu	zero,v1,v0
a0005180:	004001f4 	teq	v0,zero,0x7
a0005184:	00001812 	mflo	v1
a0005188:	2462ffff 	addiu	v0,v1,-1
a000518c:	0044102b 	sltu	v0,v0,a0
a0005190:	10400009 	beqz	v0,a00051b8 <rtk_erase_block+0x64>
a0005194:	00808021 	move	s0,a0
	{
		dprintf("[%s]:%d panic:fatal error *************,try to write in 0,1 block for boot,protect for debug\n",__func__,__LINE__);
a0005198:	3c04a001 	lui	a0,0xa001
a000519c:	2484468c 	addiu	a0,a0,18060
a00051a0:	3c05a001 	lui	a1,0xa001
a00051a4:	24a503d8 	addiu	a1,a1,984
a00051a8:	0c002325 	jal	a0008c94 <dprintf>
a00051ac:	2406010e 	li	a2,270
    rtk_writel ((CECS0 | CMD_BLK_ERASE_C2), NACMR);
  check_ready_nand ();
  rtk_writel ((CECS0 | CMD_BLK_ERASE_C3), NACMR);
  check_ready_nand ();
  return;
}
a00051b0:	0800149d 	j	a0005274 <rtk_erase_block+0x120>
a00051b4:	2402ffff 	li	v0,-1
  dprintf ("Erase NAND Flash Size=0x%x ~ 0x%x\n\n\r", (528) * page, 
            ((528) * (page + 32)) - 1);
  
#endif  /*  */
#endif  /*  */
    check_ready_nand ();
a00051b8:	0c000f80 	jal	a0003e00 <check_ready_nand>
a00051bc:	00000000 	nop
      return;
    }
  
#endif  /*  */
#ifdef CONFIG_NAND_Flash_Large_Page_128MB_4cycles
    if (page & (ppb - 1))
a00051c0:	3c02a001 	lui	v0,0xa001
a00051c4:	8c42754c 	lw	v0,30028(v0)
a00051c8:	2442ffff 	addiu	v0,v0,-1
a00051cc:	02028824 	and	s1,s0,v0
a00051d0:	12200006 	beqz	s1,a00051ec <rtk_erase_block+0x98>
a00051d4:	3c04a001 	lui	a0,0xa001
    {
      dprintf ("page %d is not block alignment (1 block=64=0x40 pages)!!\n",
a00051d8:	24844914 	addiu	a0,a0,18708
a00051dc:	0c002325 	jal	a0008c94 <dprintf>
a00051e0:	02002821 	move	a1,s0
                page);
      return;
a00051e4:	0800149e 	j	a0005278 <rtk_erase_block+0x124>
a00051e8:	8fbf003c 	lw	ra,60(sp)
                page);
      return;
    }
  
#endif  /*  */
    check_ready_nand ();
a00051ec:	0c000f80 	jal	a0003e00 <check_ready_nand>
a00051f0:	3c11b801 	lui	s1,0xb801
  
    //rtk_writel( (rtk_readl(NACR) |ECC_enable|RBO), NACR);
    //JSW RBO=0 ,WBO=0
    rtk_writel ((rtk_readl (NACR) | ECC_enable & ~(3 << 28)), NACR);
a00051f4:	3622a004 	ori	v0,s1,0xa004
a00051f8:	8c430000 	lw	v1,0(v0)
a00051fc:	3c124000 	lui	s2,0x4000
a0005200:	00721825 	or	v1,v1,s2
a0005204:	ac430000 	sw	v1,0(v0)
  rtk_writel ((NWER | NRER | NDRS | NDWS), NASR);
a0005208:	3622a028 	ori	v0,s1,0xa028
a000520c:	2403000f 	li	v1,15
a0005210:	ac430000 	sw	v1,0(v0)
  rtk_writel (0x0, NACMR);
a0005214:	3633a008 	ori	s3,s1,0xa008
a0005218:	ae600000 	sw	zero,0(s3)
  rtk_writel ((CECS0 | CMD_BLK_ERASE_C1), NACMR);
a000521c:	36420060 	ori	v0,s2,0x60
a0005220:	ae620000 	sw	v0,0(s3)
  check_ready_nand ();
a0005224:	0c000f80 	jal	a0003e00 <check_ready_nand>
a0005228:	3631a00c 	ori	s1,s1,0xa00c
    (((~enNextAD) & AD2EN | AD1EN | AD0EN | (addr_cycle[2] << CE_ADDR0) | 
      (addr_cycle[3] << CE_ADDR1) | (addr_cycle[4] << CE_ADDR2) ), NAADR);
  
#endif  /*  */
#ifdef CONFIG_NAND_Flash_Large_Page_128MB_4cycles
    addr_cycle[0] = addr_cycle[1] = 0;
a000522c:	afa00014 	sw	zero,20(sp)
a0005230:	afa00010 	sw	zero,16(sp)
  for (page_shift = 0; page_shift < 2; page_shift++)
    {
      addr_cycle[page_shift + 2] = (page >> (8 * page_shift)) & 0xff;
a0005234:	320200ff 	andi	v0,s0,0xff
a0005238:	afa20018 	sw	v0,24(sp)
a000523c:	7e103a00 	ext	s0,s0,0x8,0x8
a0005240:	afb0001c 	sw	s0,28(sp)
    }
  
    //rtk_writel( (enNextAD|AD2EN|AD1EN|AD0EN|(addr_cycle[2]<<CE_ADDR2)),NAADR);
    rtk_writel 
a0005244:	3c030300 	lui	v1,0x300
a0005248:	00431025 	or	v0,v0,v1
a000524c:	00108200 	sll	s0,s0,0x8
a0005250:	00508025 	or	s0,v0,s0
a0005254:	ae300000 	sw	s0,0(s1)
   //dprintf ("page=0x%x\n",page);
   //dprintf ("NAADR_data=0x%x\n",NAADR_data);
   //dprintf ("NAADR=0x%x\n",REG32(NAADR));
  
#endif  /*  */
    rtk_writel ((CECS0 | CMD_BLK_ERASE_C2), NACMR);
a0005258:	364200d0 	ori	v0,s2,0xd0
a000525c:	ae620000 	sw	v0,0(s3)
  check_ready_nand ();
a0005260:	0c000f80 	jal	a0003e00 <check_ready_nand>
a0005264:	36520070 	ori	s2,s2,0x70
  rtk_writel ((CECS0 | CMD_BLK_ERASE_C3), NACMR);
a0005268:	ae720000 	sw	s2,0(s3)
  check_ready_nand ();
a000526c:	0c000f80 	jal	a0003e00 <check_ready_nand>
a0005270:	00000000 	nop
  return;
}
a0005274:	8fbf003c 	lw	ra,60(sp)
a0005278:	8fb30038 	lw	s3,56(sp)
a000527c:	8fb20034 	lw	s2,52(sp)
a0005280:	8fb10030 	lw	s1,48(sp)
a0005284:	8fb0002c 	lw	s0,44(sp)
a0005288:	03e00008 	jr	ra
a000528c:	27bd0040 	addiu	sp,sp,64

a0005290 <rtk_write_ecc_page>:
#if 1

void 
rtk_write_ecc_page (unsigned long flash_address, unsigned char *image_addr,
                    unsigned int image_size ) 
{
a0005290:	27bdffb8 	addiu	sp,sp,-72
a0005294:	afbf0044 	sw	ra,68(sp)
a0005298:	afbe0040 	sw	s8,64(sp)
a000529c:	afb7003c 	sw	s7,60(sp)
a00052a0:	afb60038 	sw	s6,56(sp)
a00052a4:	afb50034 	sw	s5,52(sp)
a00052a8:	afb40030 	sw	s4,48(sp)
a00052ac:	afb3002c 	sw	s3,44(sp)
a00052b0:	afb20028 	sw	s2,40(sp)
a00052b4:	afb10024 	sw	s1,36(sp)
a00052b8:	afb00020 	sw	s0,32(sp)
a00052bc:	00808821 	move	s1,a0
a00052c0:	afa5004c 	sw	a1,76(sp)
  //debug cl
  //dprintf("[%s]:%d for boot safe debug return directly\n",__func__,__LINE__);
  //return FAIL;
  //end debug cl
  flush_cache ();
a00052c4:	0c001eae 	jal	a0007ab8 <flush_cache>
a00052c8:	00c09821 	move	s3,a2


    int page = flash_address / (page_size + oob_size);
a00052cc:	3c02a001 	lui	v0,0xa001
a00052d0:	8c457544 	lw	a1,30020(v0)
a00052d4:	3c02a001 	lui	v0,0xa001
a00052d8:	8c467548 	lw	a2,30024(v0)
a00052dc:	00c51021 	addu	v0,a2,a1
	//if(page < 128||page > chip_size/page_size - 1)
	if(page > chip_size/page_size - 1)
a00052e0:	0222001b 	divu	zero,s1,v0
a00052e4:	004001f4 	teq	v0,zero,0x7
a00052e8:	00001812 	mflo	v1
a00052ec:	3c04a002 	lui	a0,0xa002
a00052f0:	8c848880 	lw	a0,-30592(a0)
a00052f4:	0085001b 	divu	zero,a0,a1
a00052f8:	00a001f4 	teq	a1,zero,0x7
a00052fc:	00003812 	mflo	a3
a0005300:	24e4ffff 	addiu	a0,a3,-1
a0005304:	0083182b 	sltu	v1,a0,v1
a0005308:	10600008 	beqz	v1,a000532c <rtk_write_ecc_page+0x9c>
a000530c:	3c04a001 	lui	a0,0xa001
	{
		dprintf("[%s]:%d panic:fatal error *************,try to write in 0,1 block for boot,protect for debug\n",__func__,__LINE__);
a0005310:	2484468c 	addiu	a0,a0,18060
a0005314:	3c05a001 	lui	a1,0xa001
a0005318:	24a503b4 	addiu	a1,a1,948
a000531c:	0c002325 	jal	a0008c94 <dprintf>
a0005320:	24060309 	li	a2,777
		return FAIL;
a0005324:	08001542 	j	a0005508 <rtk_write_ecc_page+0x278>
a0005328:	8fbf0044 	lw	ra,68(sp)
  int page_num[3], page_shift = 0, page_start;
  unsigned long flash_addr_t = 0, flash_addr_t1;
  char *oob_buf;
  int dma_total_Wcounter = 0;
  
  if ((flash_address % (page_size + oob_size)) != 0)
a000532c:	0222001b 	divu	zero,s1,v0
a0005330:	004001f4 	teq	v0,zero,0x7
a0005334:	00001010 	mfhi	v0
a0005338:	10400005 	beqz	v0,a0005350 <rtk_write_ecc_page+0xc0>
a000533c:	3c04a001 	lui	a0,0xa001
    {
      dprintf ("\n\rflash_address must be page(0x%x+0x%x Bytes) aligned!\n",
a0005340:	0c002325 	jal	a0008c94 <dprintf>
a0005344:	24844654 	addiu	a0,a0,18004
                page_size, oob_size);
      return;
a0005348:	08001542 	j	a0005508 <rtk_write_ecc_page+0x278>
a000534c:	8fbf0044 	lw	ra,68(sp)
    }
  
  oob_buf = malloc (oob_size);
a0005350:	0c001f55 	jal	a0007d54 <malloc>
a0005354:	00c02021 	move	a0,a2
  if (!oob_buf)
a0005358:	14400006 	bnez	v0,a0005374 <rtk_write_ecc_page+0xe4>
a000535c:	3c02a001 	lui	v0,0xa001
    {
      dprintf ("allocate fail!!\n\r");
a0005360:	3c04a001 	lui	a0,0xa001
a0005364:	0c002325 	jal	a0008c94 <dprintf>
a0005368:	24844950 	addiu	a0,a0,18768
      return;
a000536c:	08001542 	j	a0005508 <rtk_write_ecc_page+0x278>
a0005370:	8fbf0044 	lw	ra,68(sp)
      dma_size += (image_size % 2048);
    }
  
#endif  /*  */
#ifdef CONFIG_NAND_Flash_Large_Page_128MB_4cycles
    if (image_size % page_size)
a0005374:	8c427544 	lw	v0,30020(v0)
a0005378:	0262001b 	divu	zero,s3,v0
a000537c:	004001f4 	teq	v0,zero,0x7
a0005380:	00001810 	mfhi	v1
a0005384:	10600004 	beqz	v1,a0005398 <rtk_write_ecc_page+0x108>
a0005388:	afb30014 	sw	s3,20(sp)
    {
      dma_size += (image_size % 2048);
a000538c:	326307ff 	andi	v1,s3,0x7ff
a0005390:	00731821 	addu	v1,v1,s3
a0005394:	afa30014 	sw	v1,20(sp)
    /*Translate nand flash address formula */ 
#if 0                           //def NAND_Flash_Small_Page_32MB_3cycles
    flash_addr_t = flash_address;
  
#else   /*  */
    page_start = flash_address / (page_size + oob_size);
a0005398:	3c03a001 	lui	v1,0xa001
a000539c:	8c747548 	lw	s4,30024(v1)
a00053a0:	00541021 	addu	v0,v0,s4
a00053a4:	0222001b 	divu	zero,s1,v0
a00053a8:	004001f4 	teq	v0,zero,0x7
a00053ac:	0000a012 	mflo	s4
a00053b0:	00001021 	move	v0,zero
a00053b4:	00008021 	move	s0,zero
  for (page_shift = 0; page_shift < 3; page_shift++)
a00053b8:	24050018 	li	a1,24
    {
      page_num[page_shift] = ((page_start >> (8 * page_shift)) & 0xff);
      flash_addr_t |= (page_num[page_shift] << (12 + 8 * page_shift));
a00053bc:	00541807 	srav	v1,s4,v0
a00053c0:	306300ff 	andi	v1,v1,0xff
a00053c4:	2444000c 	addiu	a0,v0,12
a00053c8:	00831804 	sllv	v1,v1,a0
a00053cc:	24420008 	addiu	v0,v0,8
#if 0                           //def NAND_Flash_Small_Page_32MB_3cycles
    flash_addr_t = flash_address;
  
#else   /*  */
    page_start = flash_address / (page_size + oob_size);
  for (page_shift = 0; page_shift < 3; page_shift++)
a00053d0:	1445fffa 	bne	v0,a1,a00053bc <rtk_write_ecc_page+0x12c>
a00053d4:	02038025 	or	s0,s0,v1
#endif  /*  */
#ifdef CONFIG_NAND_Flash_Large_Page_128MB_4cycles
    
    //Erase NAND
  unsigned int NAND_Blk_ecnt;
  unsigned int NAND_Blk_ecnt_start = flash_address / (2112 * 64);
a00053d8:	3c023e0f 	lui	v0,0x3e0f
a00053dc:	344283e1 	ori	v0,v0,0x83e1
a00053e0:	02220019 	multu	s1,v0
a00053e4:	00008810 	mfhi	s1
a00053e8:	001193c2 	srl	s2,s1,0xf
  for (NAND_Blk_ecnt = NAND_Blk_ecnt_start;
        NAND_Blk_ecnt <= (NAND_Blk_ecnt_start + (image_size / (2048 * 64)));
a00053ec:	00139c42 	srl	s3,s3,0x11
a00053f0:	02729821 	addu	s3,s3,s2
#ifdef CONFIG_NAND_Flash_Large_Page_128MB_4cycles
    
    //Erase NAND
  unsigned int NAND_Blk_ecnt;
  unsigned int NAND_Blk_ecnt_start = flash_address / (2112 * 64);
  for (NAND_Blk_ecnt = NAND_Blk_ecnt_start;
a00053f4:	0272102b 	sltu	v0,s3,s2
a00053f8:	14400009 	bnez	v0,a0005420 <rtk_write_ecc_page+0x190>
a00053fc:	8fa20014 	lw	v0,20(sp)
a0005400:	00128980 	sll	s1,s2,0x6
        NAND_Blk_ecnt <= (NAND_Blk_ecnt_start + (image_size / (2048 * 64)));
        NAND_Blk_ecnt++)
    {
      rtk_erase_block (NAND_Blk_ecnt * 64);     //JSW:Large page's block=64=0x40 pages , it needs input page count
a0005404:	0c001455 	jal	a0005154 <rtk_erase_block>
a0005408:	02202021 	move	a0,s1
    //Erase NAND
  unsigned int NAND_Blk_ecnt;
  unsigned int NAND_Blk_ecnt_start = flash_address / (2112 * 64);
  for (NAND_Blk_ecnt = NAND_Blk_ecnt_start;
        NAND_Blk_ecnt <= (NAND_Blk_ecnt_start + (image_size / (2048 * 64)));
        NAND_Blk_ecnt++)
a000540c:	26520001 	addiu	s2,s2,1
#ifdef CONFIG_NAND_Flash_Large_Page_128MB_4cycles
    
    //Erase NAND
  unsigned int NAND_Blk_ecnt;
  unsigned int NAND_Blk_ecnt_start = flash_address / (2112 * 64);
  for (NAND_Blk_ecnt = NAND_Blk_ecnt_start;
a0005410:	0272102b 	sltu	v0,s3,s2
a0005414:	1040fffb 	beqz	v0,a0005404 <rtk_write_ecc_page+0x174>
a0005418:	26310040 	addiu	s1,s1,64
    }
  
#endif  /*  */


    while (dma_size > 0)
a000541c:	8fa20014 	lw	v0,20(sp)
a0005420:	18400036 	blez	v0,a00054fc <rtk_write_ecc_page+0x26c>
a0005424:	26940001 	addiu	s4,s4,1
a0005428:	0014a300 	sll	s4,s4,0xc
a000542c:	afb40018 	sw	s4,24(sp)
a0005430:	afa0001c 	sw	zero,28(sp)
      while (dma_counter > 0) //Move 1 page
        {
          
            //prom_printf("\n DMA(512 Bytes) Start, DMA total count=%d\n\n\r",buf_pos);
            check_ready_nand ();
          rtk_writel ((rtk_readl (NACR) | ECC_enable), NACR);
a0005434:	3c1eb801 	lui	s8,0xb801
a0005438:	37d3a004 	ori	s3,s8,0xa004
a000543c:	3c144000 	lui	s4,0x4000
          
            //set DMA RAM start address
            dram_sa = ((unsigned int) image_addr + buf_pos * 512) & (~M_mask);
          rtk_writel (dram_sa, NADRSAR);
a0005440:	3c151fff 	lui	s5,0x1fff
a0005444:	36b5ffff 	ori	s5,s5,0xffff
a0005448:	37d6a020 	ori	s6,s8,0xa020
          
           //dprintf("\nDMA-W:SDRAM address: 0x%X\n ",(dram_sa));
            //set DMA flash start address
            //flash_addr_t &= 0x1fffffff;
          rtk_writel (flash_addr_t, NADFSAR);
a000544c:	37d7a018 	ori	s7,s8,0xa018
          
            //dprintf("\nFlash Laddress: 0x%X\n\n\r",(flash_addr_t));
            //set OOB address
            //rtk_writel(oob_sa, NADTSAR);
            //DMA write
            rtk_writel ((~TAG_DIS) &
a0005450:	37dea010 	ori	s8,s8,0xa010
#endif  /*  */


    while (dma_size > 0)
    {
      dma_counter = page_size >> 9;
a0005454:	3c03a001 	lui	v1,0xa001
a0005458:	8c627544 	lw	v0,30020(v1)
a000545c:	00021242 	srl	v0,v0,0x9
      while (dma_counter > 0) //Move 1 page
a0005460:	18400020 	blez	v0,a00054e4 <rtk_write_ecc_page+0x254>
a0005464:	afa20010 	sw	v0,16(sp)
a0005468:	8fa4001c 	lw	a0,28(sp)
a000546c:	00048a40 	sll	s1,a0,0x9
a0005470:	8fa7004c 	lw	a3,76(sp)
a0005474:	00f18821 	addu	s1,a3,s1
a0005478:	00409021 	move	s2,v0
        {
          
            //prom_printf("\n DMA(512 Bytes) Start, DMA total count=%d\n\n\r",buf_pos);
            check_ready_nand ();
a000547c:	0c000f80 	jal	a0003e00 <check_ready_nand>
a0005480:	00000000 	nop
          rtk_writel ((rtk_readl (NACR) | ECC_enable), NACR);
a0005484:	8e620000 	lw	v0,0(s3)
a0005488:	00541025 	or	v0,v0,s4
a000548c:	ae620000 	sw	v0,0(s3)
          
            //set DMA RAM start address
            dram_sa = ((unsigned int) image_addr + buf_pos * 512) & (~M_mask);
          rtk_writel (dram_sa, NADRSAR);
a0005490:	02351024 	and	v0,s1,s5
a0005494:	aec20000 	sw	v0,0(s6)
          
           //dprintf("\nDMA-W:SDRAM address: 0x%X\n ",(dram_sa));
            //set DMA flash start address
            //flash_addr_t &= 0x1fffffff;
          rtk_writel (flash_addr_t, NADFSAR);
a0005498:	aef00000 	sw	s0,0(s7)
          
            //dprintf("\nFlash Laddress: 0x%X\n\n\r",(flash_addr_t));
            //set OOB address
            //rtk_writel(oob_sa, NADTSAR);
            //DMA write
            rtk_writel ((~TAG_DIS) &
a000549c:	24020017 	li	v0,23
a00054a0:	afc20000 	sw	v0,0(s8)
                        ((0 << TAG_SEL) | DESC0 | DMAWE | LBC_128), NADCRR);
          check_ready_nand ();
a00054a4:	0c000f80 	jal	a0003e00 <check_ready_nand>
a00054a8:	26100210 	addiu	s0,s0,528
          
#else   /*  */
            flash_addr_t += 528;
          
#endif  /*  */
            dma_counter--;
a00054ac:	2652ffff 	addiu	s2,s2,-1


    while (dma_size > 0)
    {
      dma_counter = page_size >> 9;
      while (dma_counter > 0) //Move 1 page
a00054b0:	1e40fff2 	bgtz	s2,a000547c <rtk_write_ecc_page+0x1ec>
a00054b4:	26310200 	addiu	s1,s1,512
a00054b8:	8fa3001c 	lw	v1,28(sp)
a00054bc:	8fa40010 	lw	a0,16(sp)
a00054c0:	00641821 	addu	v1,v1,a0
a00054c4:	afa3001c 	sw	v1,28(sp)
a00054c8:	24070001 	li	a3,1
a00054cc:	00e41023 	subu	v0,a3,a0
a00054d0:	00021240 	sll	v0,v0,0x9
a00054d4:	2442fe00 	addiu	v0,v0,-512
a00054d8:	8fa30014 	lw	v1,20(sp)
a00054dc:	00621821 	addu	v1,v1,v0
a00054e0:	afa30014 	sw	v1,20(sp)
    }
  
#endif  /*  */


    while (dma_size > 0)
a00054e4:	8fa40014 	lw	a0,20(sp)
a00054e8:	18800004 	blez	a0,a00054fc <rtk_write_ecc_page+0x26c>
a00054ec:	8fb00018 	lw	s0,24(sp)
a00054f0:	26071000 	addiu	a3,s0,4096
a00054f4:	08001515 	j	a0005454 <rtk_write_ecc_page+0x1c4>
a00054f8:	afa70018 	sw	a3,24(sp)
        flash_addr_t1 = (page_counter * 0x1000) + (page_start * 0x1000);
           
#endif  /*  */
	 flash_addr_t = flash_addr_t1;
    }
  flush_cache ();
a00054fc:	0c001eae 	jal	a0007ab8 <flush_cache>
a0005500:	00000000 	nop

 
}
a0005504:	8fbf0044 	lw	ra,68(sp)
a0005508:	8fbe0040 	lw	s8,64(sp)
a000550c:	8fb7003c 	lw	s7,60(sp)
a0005510:	8fb60038 	lw	s6,56(sp)
a0005514:	8fb50034 	lw	s5,52(sp)
a0005518:	8fb40030 	lw	s4,48(sp)
a000551c:	8fb3002c 	lw	s3,44(sp)
a0005520:	8fb20028 	lw	s2,40(sp)
a0005524:	8fb10024 	lw	s1,36(sp)
a0005528:	8fb00020 	lw	s0,32(sp)
a000552c:	03e00008 	jr	ra
a0005530:	27bd0048 	addiu	sp,sp,72

a0005534 <rtk_update_bbt>:
	}		
	return rc;

}
int rtk_update_bbt (struct BB_t *bbt)
{
a0005534:	27bdffa8 	addiu	sp,sp,-88
a0005538:	afbf0054 	sw	ra,84(sp)
a000553c:	afbe0050 	sw	s8,80(sp)
a0005540:	afb7004c 	sw	s7,76(sp)
a0005544:	afb60048 	sw	s6,72(sp)
a0005548:	afb50044 	sw	s5,68(sp)
a000554c:	afb40040 	sw	s4,64(sp)
a0005550:	afb3003c 	sw	s3,60(sp)
a0005554:	afb20038 	sw	s2,56(sp)
a0005558:	afb10034 	sw	s1,52(sp)
a000555c:	afb00030 	sw	s0,48(sp)
a0005560:	00808821 	move	s1,a0
	unsigned char mem_page_num=0, page_counter=0;
	unsigned char mem_page_num_tmp=0, page_counter_tmp=0;

	//czyao, reserve 1M bytes area for bootloader, and the last 2 blocks of 1M area is for bad block table
	//bbt_page = ((BOOT_SIZE/block_size)-BACKUP_BBT)*ppb;
	bbt_page = ((REMAP_BBT_POS/block_size)+BACKUP_BBT)*ppb;
a0005564:	3c140010 	lui	s4,0x10
a0005568:	3c02a001 	lui	v0,0xa001
a000556c:	8c427524 	lw	v0,29988(v0)
a0005570:	0282001a 	div	zero,s4,v0
a0005574:	004001f4 	teq	v0,zero,0x7
a0005578:	0000a012 	mflo	s4
a000557c:	26940003 	addiu	s4,s4,3
a0005580:	3c02a001 	lui	v0,0xa001
a0005584:	8c43754c 	lw	v1,30028(v0)
a0005588:	7283a002 	mul	s4,s4,v1
	
	//dprintf("[%s]:%d (BOOT_SIZE/block_size) = %d\n",__func__,__LINE__,BOOT_SIZE/block_size); //should be 8
	mem_page_num = (sizeof(struct BB_t)*RBA + page_size-1 )/page_size;
a000558c:	3c02a001 	lui	v0,0xa001
a0005590:	8c447544 	lw	a0,30020(v0)
a0005594:	2483ffff 	addiu	v1,a0,-1
a0005598:	3c02a001 	lui	v0,0xa001
a000559c:	8c427970 	lw	v0,31088(v0)
a00055a0:	000210c0 	sll	v0,v0,0x3
a00055a4:	00621021 	addu	v0,v1,v0
a00055a8:	0044001b 	divu	zero,v0,a0
a00055ac:	008001f4 	teq	a0,zero,0x7
a00055b0:	00001012 	mflo	v0
a00055b4:	304200ff 	andi	v0,v0,0xff
a00055b8:	afa20018 	sw	v0,24(sp)
	//printf("[%s] mem_page_num %d\n\r", __FUNCTION__, mem_page_num);
	
	temp_BBT = (unsigned char *)malloc(mem_page_num*page_size);
a00055bc:	00408021 	move	s0,v0
a00055c0:	0c001f55 	jal	a0007d54 <malloc>
a00055c4:	70442002 	mul	a0,v0,a0
	if ( !(temp_BBT) ){
a00055c8:	14400008 	bnez	v0,a00055ec <rtk_update_bbt+0xb8>
a00055cc:	0040b021 	move	s6,v0
		printf("%s: Error, no enough memory for temp_BBT\n",__FUNCTION__);
a00055d0:	3c04a001 	lui	a0,0xa001
a00055d4:	24844964 	addiu	a0,a0,18788
a00055d8:	3c05a001 	lui	a1,0xa001
a00055dc:	0c002325 	jal	a0008c94 <dprintf>
a00055e0:	24a5024c 	addiu	a1,a1,588
		return FAIL;
a00055e4:	080015dc 	j	a0005770 <rtk_update_bbt+0x23c>
a00055e8:	2402ffff 	li	v0,-1
	}	
	memset(temp_BBT, 0xff, mem_page_num*page_size);
a00055ec:	3c02a001 	lui	v0,0xa001
a00055f0:	8c467544 	lw	a2,30020(v0)
a00055f4:	02c02021 	move	a0,s6
a00055f8:	240500ff 	li	a1,255
a00055fc:	0c00203d 	jal	a00080f4 <memset>
a0005600:	72063002 	mul	a2,s0,a2
	memcpy(temp_BBT, bbt, sizeof(struct BB_t)*RBA );
a0005604:	3c02a001 	lui	v0,0xa001
a0005608:	8c467970 	lw	a2,31088(v0)
a000560c:	02c02021 	move	a0,s6
a0005610:	02202821 	move	a1,s1
a0005614:	0c002046 	jal	a0008118 <memcpy>
a0005618:	000630c0 	sll	a2,a2,0x3
a000561c:	afa00014 	sw	zero,20(sp)
a0005620:	afa00010 	sw	zero,16(sp)
    for(i=0;i<BACKUP_BBT;i++){
		mem_page_num_tmp = mem_page_num;
		page_counter=0;
		if(!NAND_ADDR_CYCLE)
		#ifdef SWAP_2K_DATA
			NfSpareBuf[BBI_SWAP_OFFSET] = BBT_TAG;
a0005624:	3c17a002 	lui	s7,0xa002
a0005628:	26f7a268 	addiu	s7,s7,-23960
		#else
			NfSpareBuf[0] = BBT_TAG;
		#endif
		else
			NfSpareBuf[5] = BBT_TAG;
		if(rtk_erase_block_a(bbt_page+(ppb*i))){
a000562c:	3c12a001 	lui	s2,0xa001
			printf("[%s]error: erase BBT%d page %d failure\n\r", __FUNCTION__,i, bbt_page+(ppb*i));
			/*erase fail: mean this block is bad, so do not write data!!!*/
			mem_page_num_tmp = 0; 
			error_count++;
		}
		while( mem_page_num_tmp>0 ){
a0005630:	8fa20018 	lw	v0,24(sp)
a0005634:	afa20020 	sw	v0,32(sp)
			//if ( this->write_ecc_page(mtd, 0, page+page_counter, temp_BBT+page_counter*page_size, 
			//	this->g_oobbuf, 1) )
			if(rtk_write_ecc_page_a(bbt_page+(ppb*i)+page_counter,temp_BBT+page_counter*page_size, &NfSpareBuf, page_size))	{
a0005638:	3c13a001 	lui	s3,0xa001
					printf("[%s] write BBT%d page %d failure!!\n\r", __FUNCTION__,i, bbt_page+(ppb*i)+page_counter);
a000563c:	3c02a001 	lui	v0,0xa001
a0005640:	244249bc 	addiu	v0,v0,18876
a0005644:	afa20024 	sw	v0,36(sp)
a0005648:	3c02a001 	lui	v0,0xa001
a000564c:	2442024c 	addiu	v0,v0,588
a0005650:	afa2001c 	sw	v0,28(sp)
			NfSpareBuf[0] = BBT_TAG;
		#endif
		else
			NfSpareBuf[5] = BBT_TAG;
		if(rtk_erase_block_a(bbt_page+(ppb*i))){
			printf("[%s]error: erase BBT%d page %d failure\n\r", __FUNCTION__,i, bbt_page+(ppb*i));
a0005654:	3c02a001 	lui	v0,0xa001
a0005658:	24424990 	addiu	v0,v0,18832
a000565c:	afa20028 	sw	v0,40(sp)
    for(i=0;i<BACKUP_BBT;i++){
		mem_page_num_tmp = mem_page_num;
		page_counter=0;
		if(!NAND_ADDR_CYCLE)
		#ifdef SWAP_2K_DATA
			NfSpareBuf[BBI_SWAP_OFFSET] = BBT_TAG;
a0005660:	2403ffbb 	li	v1,-69
a0005664:	a2e30035 	sb	v1,53(s7)
a0005668:	8fb50010 	lw	s5,16(sp)
		#else
			NfSpareBuf[0] = BBT_TAG;
		#endif
		else
			NfSpareBuf[5] = BBT_TAG;
		if(rtk_erase_block_a(bbt_page+(ppb*i))){
a000566c:	8e44754c 	lw	a0,30028(s2)
a0005670:	72a41002 	mul	v0,s5,a0
a0005674:	0c001048 	jal	a0004120 <rtk_erase_block_a>
a0005678:	00542021 	addu	a0,v0,s4
a000567c:	1040000c 	beqz	v0,a00056b0 <rtk_update_bbt+0x17c>
a0005680:	8fa20018 	lw	v0,24(sp)
			printf("[%s]error: erase BBT%d page %d failure\n\r", __FUNCTION__,i, bbt_page+(ppb*i));
a0005684:	8e47754c 	lw	a3,30028(s2)
a0005688:	8fa40028 	lw	a0,40(sp)
a000568c:	8fa5001c 	lw	a1,28(sp)
a0005690:	8fa60010 	lw	a2,16(sp)
a0005694:	72a71002 	mul	v0,s5,a3
a0005698:	0c002325 	jal	a0008c94 <dprintf>
a000569c:	00543821 	addu	a3,v0,s4
			/*erase fail: mean this block is bad, so do not write data!!!*/
			mem_page_num_tmp = 0; 
			error_count++;
a00056a0:	8fa30014 	lw	v1,20(sp)
a00056a4:	24630001 	addiu	v1,v1,1
a00056a8:	080015cc 	j	a0005730 <rtk_update_bbt+0x1fc>
a00056ac:	afa30014 	sw	v1,20(sp)
		}
		while( mem_page_num_tmp>0 ){
a00056b0:	1040001f 	beqz	v0,a0005730 <rtk_update_bbt+0x1fc>
a00056b4:	8fb10020 	lw	s1,32(sp)
a00056b8:	00008021 	move	s0,zero
			//if ( this->write_ecc_page(mtd, 0, page+page_counter, temp_BBT+page_counter*page_size, 
			//	this->g_oobbuf, 1) )
			if(rtk_write_ecc_page_a(bbt_page+(ppb*i)+page_counter,temp_BBT+page_counter*page_size, &NfSpareBuf, page_size))	{
a00056bc:	8e677544 	lw	a3,30020(s3)
a00056c0:	8e44754c 	lw	a0,30028(s2)
a00056c4:	72a41002 	mul	v0,s5,a0
a00056c8:	00542021 	addu	a0,v0,s4
a00056cc:	00902021 	addu	a0,a0,s0
a00056d0:	72071002 	mul	v0,s0,a3
a00056d4:	00562821 	addu	a1,v0,s6
a00056d8:	0c0011da 	jal	a0004768 <rtk_write_ecc_page_a>
a00056dc:	02e03021 	move	a2,s7
a00056e0:	1040000e 	beqz	v0,a000571c <rtk_update_bbt+0x1e8>
a00056e4:	2631ffff 	addiu	s1,s1,-1
a00056e8:	26310001 	addiu	s1,s1,1
					printf("[%s] write BBT%d page %d failure!!\n\r", __FUNCTION__,i, bbt_page+(ppb*i)+page_counter);
a00056ec:	8e42754c 	lw	v0,30028(s2)
a00056f0:	72a21802 	mul	v1,s5,v0
a00056f4:	0074a821 	addu	s5,v1,s4
a00056f8:	8fa40024 	lw	a0,36(sp)
a00056fc:	8fa5001c 	lw	a1,28(sp)
a0005700:	8fa60010 	lw	a2,16(sp)
a0005704:	0c002325 	jal	a0008c94 <dprintf>
a0005708:	02b03821 	addu	a3,s5,s0
					//rc =  -1;
					//goto EXIT;
					error_count++;
a000570c:	8fa20014 	lw	v0,20(sp)
a0005710:	24420001 	addiu	v0,v0,1
					break;
a0005714:	080015cc 	j	a0005730 <rtk_update_bbt+0x1fc>
a0005718:	afa20014 	sw	v0,20(sp)
			}
		//printf("[%s, line %d] mem_page_num = %d page_counter %d\n\r",__FUNCTION__,__LINE__,mem_page_num, page_counter);
			page_counter++;
			mem_page_num_tmp--; 	
a000571c:	323100ff 	andi	s1,s1,0xff
			printf("[%s]error: erase BBT%d page %d failure\n\r", __FUNCTION__,i, bbt_page+(ppb*i));
			/*erase fail: mean this block is bad, so do not write data!!!*/
			mem_page_num_tmp = 0; 
			error_count++;
		}
		while( mem_page_num_tmp>0 ){
a0005720:	12200003 	beqz	s1,a0005730 <rtk_update_bbt+0x1fc>
a0005724:	26100001 	addiu	s0,s0,1
					//goto EXIT;
					error_count++;
					break;
			}
		//printf("[%s, line %d] mem_page_num = %d page_counter %d\n\r",__FUNCTION__,__LINE__,mem_page_num, page_counter);
			page_counter++;
a0005728:	080015af 	j	a00056bc <rtk_update_bbt+0x188>
a000572c:	321000ff 	andi	s0,s0,0xff
	    NfSpareBuf[0] = BBT_TAG;
	else
	    NfSpareBuf[5] = BBT_TAG;
*/	    
//test new method
    for(i=0;i<BACKUP_BBT;i++){
a0005730:	8fa30010 	lw	v1,16(sp)
a0005734:	24630001 	addiu	v1,v1,1
a0005738:	24020003 	li	v0,3
a000573c:	1462ffc8 	bne	v1,v0,a0005660 <rtk_update_bbt+0x12c>
a0005740:	afa30010 	sw	v1,16(sp)
		}		
	}
#endif
EXIT:
	if (temp_BBT)
		free(temp_BBT);
a0005744:	0c001f86 	jal	a0007e18 <free>
a0005748:	02c02021 	move	a0,s6
    if(error_count >= BACKUP_BBT){
a000574c:	8fa20014 	lw	v0,20(sp)
a0005750:	28430003 	slti	v1,v0,3
a0005754:	14600006 	bnez	v1,a0005770 <rtk_update_bbt+0x23c>
a0005758:	00001021 	move	v0,zero
		rc = -1;
		printf("%d table are all bad!(T______T)\n\r", BACKUP_BBT);
a000575c:	3c04a001 	lui	a0,0xa001
a0005760:	248449e4 	addiu	a0,a0,18916
a0005764:	0c002325 	jal	a0008c94 <dprintf>
a0005768:	24050003 	li	a1,3
a000576c:	2402ffff 	li	v0,-1
	}
	return rc;
}
a0005770:	8fbf0054 	lw	ra,84(sp)
a0005774:	8fbe0050 	lw	s8,80(sp)
a0005778:	8fb7004c 	lw	s7,76(sp)
a000577c:	8fb60048 	lw	s6,72(sp)
a0005780:	8fb50044 	lw	s5,68(sp)
a0005784:	8fb40040 	lw	s4,64(sp)
a0005788:	8fb3003c 	lw	s3,60(sp)
a000578c:	8fb20038 	lw	s2,56(sp)
a0005790:	8fb10034 	lw	s1,52(sp)
a0005794:	8fb00030 	lw	s0,48(sp)
a0005798:	03e00008 	jr	ra
a000579c:	27bd0058 	addiu	sp,sp,88

a00057a0 <rtk_nand_scan_bbt>:
//		NON
// Output:
//		BOOL: 0=>OK, -1=>FAIL
//####################################################################
int rtk_nand_scan_bbt(void)
{
a00057a0:	27bdff88 	addiu	sp,sp,-120
a00057a4:	afbf0074 	sw	ra,116(sp)
a00057a8:	afbe0070 	sw	s8,112(sp)
a00057ac:	afb7006c 	sw	s7,108(sp)
a00057b0:	afb60068 	sw	s6,104(sp)
a00057b4:	afb50064 	sw	s5,100(sp)
a00057b8:	afb40060 	sw	s4,96(sp)
a00057bc:	afb3005c 	sw	s3,92(sp)
a00057c0:	afb20058 	sw	s2,88(sp)
a00057c4:	afb10054 	sw	s1,84(sp)
a00057c8:	afb00050 	sw	s0,80(sp)
	extern int block_size;
		{
    /*czyao, reserve RESERVED_AREA bytes area for bootloader, 
      and the last 'BACKUP_BBT' blocks of RESERVED_AREA area is for bad block table*/
	//bbt_page = ((BOOT_SIZE/block_size)-BACKUP_BBT)*ppb;
	bbt_page = ((REMAP_BBT_POS/block_size)+BACKUP_BBT)*ppb;
a00057cc:	3c02a001 	lui	v0,0xa001
a00057d0:	8c427524 	lw	v0,29988(v0)
a00057d4:	3c030010 	lui	v1,0x10
a00057d8:	0062001a 	div	zero,v1,v0
a00057dc:	004001f4 	teq	v0,zero,0x7
a00057e0:	0000f012 	mflo	s8
a00057e4:	27de0003 	addiu	s8,s8,3
a00057e8:	3c03a001 	lui	v1,0xa001
a00057ec:	8c64754c 	lw	a0,30028(v1)
a00057f0:	73c4f002 	mul	s8,s8,a0
		}
	
	//printf("[%s, line %d] bbt_page = %d \n\r",__FUNCTION__,__LINE__,bbt_page);
	//printf("[%s, line %d] bbt_block = %d \n\r",__FUNCTION__,__LINE__,bbt_page/ppb);

	RBA = ((unsigned int)chip_size/block_size)*RBA_PERCENT / 100;
a00057f4:	3c03a002 	lui	v1,0xa002
a00057f8:	8c638880 	lw	v1,-30592(v1)
a00057fc:	0062001b 	divu	zero,v1,v0
a0005800:	004001f4 	teq	v0,zero,0x7
a0005804:	00001012 	mflo	v0
a0005808:	3c03a001 	lui	v1,0xa001
a000580c:	8c647528 	lw	a0,29992(v1)
a0005810:	70441002 	mul	v0,v0,a0
a0005814:	3c0451eb 	lui	a0,0x51eb
a0005818:	3484851f 	ori	a0,a0,0x851f
a000581c:	00440019 	multu	v0,a0
a0005820:	00001010 	mfhi	v0
a0005824:	00021142 	srl	v0,v0,0x5
a0005828:	3c03a001 	lui	v1,0xa001
a000582c:	ac627970 	sw	v0,31088(v1)

	//printf("[%s, line %d] RBA = %d \n\r",__FUNCTION__,__LINE__,RBA);

	//czyao 
	bbt = (unsigned char *) malloc(sizeof(struct BB_t)*RBA);
a0005830:	0c001f55 	jal	a0007d54 <malloc>
a0005834:	000220c0 	sll	a0,v0,0x3
a0005838:	3c03a001 	lui	v1,0xa001
	if(!bbt){
a000583c:	14400009 	bnez	v0,a0005864 <rtk_nand_scan_bbt+0xc4>
a0005840:	ac627974 	sw	v0,31092(v1)
		printf("%s-%d: Error, no enough memory for bbt\n",__FUNCTION__,__LINE__);
a0005844:	3c04a001 	lui	a0,0xa001
a0005848:	24844a08 	addiu	a0,a0,18952
a000584c:	3c05a001 	lui	a1,0xa001
a0005850:	24a5025c 	addiu	a1,a1,604
a0005854:	0c002325 	jal	a0008c94 <dprintf>
a0005858:	24060d94 	li	a2,3476
		return FAIL;
a000585c:	080017b3 	j	a0005ecc <rtk_nand_scan_bbt+0x72c>
a0005860:	2402ffff 	li	v0,-1
	}

	mem_page_num = (sizeof(struct BB_t)*RBA + page_size-1 )/page_size;
a0005864:	3c02a001 	lui	v0,0xa001
a0005868:	8c447544 	lw	a0,30020(v0)
a000586c:	2483ffff 	addiu	v1,a0,-1
a0005870:	3c02a001 	lui	v0,0xa001
a0005874:	8c427970 	lw	v0,31088(v0)
a0005878:	000210c0 	sll	v0,v0,0x3
a000587c:	00621021 	addu	v0,v1,v0
a0005880:	0044001b 	divu	zero,v0,a0
a0005884:	008001f4 	teq	a0,zero,0x7
a0005888:	00001012 	mflo	v0
a000588c:	304200ff 	andi	v0,v0,0xff
a0005890:	afa20024 	sw	v0,36(sp)
	//printf("[%s, line %d] mem_page_num = %d\n\r",__FUNCTION__,__LINE__,mem_page_num);

	temp_BBT =(unsigned char *)malloc( mem_page_num*page_size );
a0005894:	00408021 	move	s0,v0
a0005898:	0c001f55 	jal	a0007d54 <malloc>
a000589c:	70442002 	mul	a0,v0,a0
	if(!temp_BBT){
a00058a0:	14400008 	bnez	v0,a00058c4 <rtk_nand_scan_bbt+0x124>
a00058a4:	00409821 	move	s3,v0
		printf("%s: Error, no enough memory for temp_BBT\n",__FUNCTION__);
a00058a8:	3c04a001 	lui	a0,0xa001
a00058ac:	24844964 	addiu	a0,a0,18788
a00058b0:	3c05a001 	lui	a1,0xa001
a00058b4:	0c002325 	jal	a0008c94 <dprintf>
a00058b8:	24a5025c 	addiu	a1,a1,604
		return FAIL;
a00058bc:	080017b3 	j	a0005ecc <rtk_nand_scan_bbt+0x72c>
a00058c0:	2402ffff 	li	v0,-1
	}

	memset( temp_BBT, 0xff, mem_page_num*page_size);
a00058c4:	3c02a001 	lui	v0,0xa001
a00058c8:	8c467544 	lw	a2,30020(v0)
a00058cc:	02602021 	move	a0,s3
a00058d0:	240500ff 	li	a1,255
a00058d4:	0c00203d 	jal	a00080f4 <memset>
a00058d8:	72063002 	mul	a2,s0,a2
a00058dc:	24020001 	li	v0,1
a00058e0:	afa20020 	sw	v0,32(sp)
a00058e4:	00008021 	move	s0,zero
//test NEW method!
	for(i=0;i<BACKUP_BBT;i++){
	    rc = rtk_read_ecc_page_a(bbt_page+(i*ppb), &NfDataBuf, &NfSpareBuf,page_size);
a00058e8:	3c11a001 	lui	s1,0xa001
a00058ec:	3c14a001 	lui	s4,0xa001
a00058f0:	3c15a002 	lui	s5,0xa002
a00058f4:	26b59a04 	addiu	s5,s5,-26108
a00058f8:	3c12a002 	lui	s2,0xa002
a00058fc:	2652a268 	addiu	s2,s2,-23960
			isbbt = NfSpareBuf[0];
		#endif
	    else
		    isbbt = NfSpareBuf[5];
		if(!rc){
		    if(isbbt==BBT_TAG)//check bbt has already created
a0005900:	241600bb 	li	s6,187
		return FAIL;
	}

	memset( temp_BBT, 0xff, mem_page_num*page_size);
//test NEW method!
	for(i=0;i<BACKUP_BBT;i++){
a0005904:	24170003 	li	s7,3
	    rc = rtk_read_ecc_page_a(bbt_page+(i*ppb), &NfDataBuf, &NfSpareBuf,page_size);
a0005908:	8e24754c 	lw	a0,30028(s1)
a000590c:	72041002 	mul	v0,s0,a0
a0005910:	005e2021 	addu	a0,v0,s8
a0005914:	02a02821 	move	a1,s5
a0005918:	02403021 	move	a2,s2
a000591c:	0c0012a2 	jal	a0004a88 <rtk_read_ecc_page_a>
a0005920:	8e877544 	lw	a3,30020(s4)
		#else
			isbbt = NfSpareBuf[0];
		#endif
	    else
		    isbbt = NfSpareBuf[5];
		if(!rc){
a0005924:	14400005 	bnez	v0,a000593c <rtk_nand_scan_bbt+0x19c>
a0005928:	92430035 	lbu	v1,53(s2)
		    if(isbbt==BBT_TAG)//check bbt has already created
a000592c:	00761826 	xor	v1,v1,s6
a0005930:	8fa20020 	lw	v0,32(sp)
a0005934:	0003100a 	movz	v0,zero,v1
a0005938:	afa20020 	sw	v0,32(sp)
		return FAIL;
	}

	memset( temp_BBT, 0xff, mem_page_num*page_size);
//test NEW method!
	for(i=0;i<BACKUP_BBT;i++){
a000593c:	26100001 	addiu	s0,s0,1
a0005940:	1617fff1 	bne	s0,s7,a0005908 <rtk_nand_scan_bbt+0x168>
a0005944:	3c02a002 	lui	v0,0xa002
a0005948:	afa00010 	sw	zero,16(sp)
a000594c:	00009021 	move	s2,zero
	//printf("%s: is_first_boot:%d\n\r",__FUNCTION__, is_first_boot);
	//is_first_boot = 1;
	for(i=0;i<BACKUP_BBT;i++){
		mem_page_num_tmp = mem_page_num;
		page_counter=0;load_bbt_error=0;
		rc = rtk_block_isbad((bbt_page+(i*ppb))*page_size);
a0005950:	3c11a001 	lui	s1,0xa001
		if(!rc){
			//printf("load bbt table:%d page:%d\n\r",i, (bbt_page+(i*ppb)));
		    rc = rtk_read_ecc_page_a(bbt_page+(i*ppb), &NfDataBuf, &NfSpareBuf,page_size);
a0005954:	24429a04 	addiu	v0,v0,-26108
a0005958:	afa20028 	sw	v0,40(sp)
a000595c:	3c02a002 	lui	v0,0xa002
a0005960:	2442a268 	addiu	v0,v0,-23960
a0005964:	afa20014 	sw	v0,20(sp)
			    }else{
					//printf("Create bbt table:%d is_first_boot:%d\n\r",i, is_first_boot);
					if(is_first_boot)
					{
						//debug cl for safe boot
						static_for_create_v2r_bbt = 1;
a0005968:	24030001 	li	v1,1
a000596c:	afa30038 	sw	v1,56(sp)
// Output:
//		BOOL: 0=>OK, -1=>FAIL 
//####################################################################
static int rtk_create_bbt( int page)
{
    dprintf("[%s:] %d\n",__func__,__LINE__);
a0005970:	3c02a001 	lui	v0,0xa001
a0005974:	24424a50 	addiu	v0,v0,19024
a0005978:	afa2002c 	sw	v0,44(sp)
a000597c:	3c02a001 	lui	v0,0xa001
a0005980:	24420280 	addiu	v0,v0,640
a0005984:	afa2003c 	sw	v0,60(sp)
// Output:
//		BOOL: 0=>OK, -1=>FAIL 
//####################################################################
static int scan_last_die_BB(void)
{
    dprintf("[%s:] %d\n",__func__,__LINE__);
a0005988:	3c02a001 	lui	v0,0xa001
a000598c:	244202a4 	addiu	v0,v0,676
a0005990:	afa20030 	sw	v0,48(sp)
	int remap_count = 0;
	int i,j, table_index=0 , numchips=1;
	//start_page = BOOT_SIZE;
	block_num = (chip_size/block_size);

    dprintf("[%s:] %d block_num = %d\n",__func__,__LINE__,block_num );
a0005994:	3c02a001 	lui	v0,0xa001
a0005998:	24424a5c 	addiu	v0,v0,19036
a000599c:	afa20040 	sw	v0,64(sp)
	memcpy( temp_BBT, bbt, sizeof(struct BB_t)*RBA );
	while( mem_page_num>0 ){
		//if ( this->write_ecc_page(mtd, 0, page+page_counter, temp_BBT+page_counter*page_size, 
		//	this->g_oobbuf, 1) )
		if(rtk_write_ecc_page_a(page+page_counter,temp_BBT+page_counter*page_size, &NfSpareBuf, page_size))	{
				printf("[%s] write BBT page %d failure!!\n\r", __FUNCTION__, page+page_counter);
a00059a0:	3c02a001 	lui	v0,0xa001
a00059a4:	24424b38 	addiu	v0,v0,19256
a00059a8:	afa20044 	sw	v0,68(sp)
	/*search bad block of all Nand flash area.*/
	for( addr=0; addr<chip_size; addr+=block_size ){
		int bb = addr >> block_shift;
		if ( rtk_block_isbad(addr) ){
			block_status[bb] = 0xff;
			printf("block[%d] is bad\n",bb);
a00059ac:	3c02a001 	lui	v0,0xa001
a00059b0:	24424ad8 	addiu	v0,v0,19160
a00059b4:	afa20048 	sw	v0,72(sp)
a00059b8:	0260b821 	move	s7,s3
	//printf("%s: is_first_boot:%d\n\r",__FUNCTION__, is_first_boot);
	//is_first_boot = 1;
	for(i=0;i<BACKUP_BBT;i++){
		mem_page_num_tmp = mem_page_num;
		page_counter=0;load_bbt_error=0;
		rc = rtk_block_isbad((bbt_page+(i*ppb))*page_size);
a00059bc:	3c02a001 	lui	v0,0xa001
a00059c0:	8c44754c 	lw	a0,30028(v0)
a00059c4:	72441002 	mul	v0,s2,a0
a00059c8:	005e2021 	addu	a0,v0,s8
a00059cc:	8e227544 	lw	v0,30020(s1)
a00059d0:	0c001349 	jal	a0004d24 <rtk_block_isbad>
a00059d4:	70822002 	mul	a0,a0,v0
		if(!rc){
a00059d8:	14400129 	bnez	v0,a0005e80 <rtk_nand_scan_bbt+0x6e0>
a00059dc:	afa20018 	sw	v0,24(sp)
			//printf("load bbt table:%d page:%d\n\r",i, (bbt_page+(i*ppb)));
		    rc = rtk_read_ecc_page_a(bbt_page+(i*ppb), &NfDataBuf, &NfSpareBuf,page_size);
a00059e0:	3c02a001 	lui	v0,0xa001
a00059e4:	8c44754c 	lw	a0,30028(v0)
a00059e8:	72441002 	mul	v0,s2,a0
a00059ec:	005e2021 	addu	a0,v0,s8
a00059f0:	8fa50028 	lw	a1,40(sp)
a00059f4:	8fa60014 	lw	a2,20(sp)
a00059f8:	0c0012a2 	jal	a0004a88 <rtk_read_ecc_page_a>
a00059fc:	8e277544 	lw	a3,30020(s1)
a0005a00:	afa20018 	sw	v0,24(sp)
		    if(!NAND_ADDR_CYCLE)
		    #ifdef SWAP_2K_DATA
				isbbt = NfSpareBuf[BBI_SWAP_OFFSET];
a0005a04:	8fa20014 	lw	v0,20(sp)
a0005a08:	90430035 	lbu	v1,53(v0)
			#else
				isbbt = NfSpareBuf[0];
			#endif
		    else
			    isbbt = NfSpareBuf[5];
	        if(!rc){
a0005a0c:	8fa20018 	lw	v0,24(sp)
a0005a10:	1440011e 	bnez	v0,a0005e8c <rtk_nand_scan_bbt+0x6ec>
a0005a14:	240200bb 	li	v0,187
			    //if(isbbt == BBT_TAG &&0) //if v2r bbt table write error,can use the code to rebuild table
			    if(isbbt == BBT_TAG){
a0005a18:	14620033 	bne	v1,v0,a0005ae8 <rtk_nand_scan_bbt+0x348>
a0005a1c:	8fa30020 	lw	v1,32(sp)
			        //printf("[%s] have created bbt table:%d on block %d, just loads it !!\n\r", __FUNCTION__,i,(bbt_page/ppb)+i);
			        memcpy( temp_BBT, &NfDataBuf, page_size );
a0005a20:	02e02021 	move	a0,s7
a0005a24:	8fa50028 	lw	a1,40(sp)
a0005a28:	0c002046 	jal	a0008118 <memcpy>
a0005a2c:	8e267544 	lw	a2,30020(s1)
			        page_counter++;
			        mem_page_num_tmp--;
a0005a30:	8fa30024 	lw	v1,36(sp)
a0005a34:	2473ffff 	addiu	s3,v1,-1
a0005a38:	327300ff 	andi	s3,s3,0xff
a0005a3c:	24100001 	li	s0,1
			        while( mem_page_num_tmp>0 ){
				        if( rtk_read_ecc_page_a((bbt_page+(i*ppb)+page_counter), &NfDataBuf, &NfSpareBuf, page_size)){
a0005a40:	3c14a001 	lui	s4,0xa001
			    if(isbbt == BBT_TAG){
			        //printf("[%s] have created bbt table:%d on block %d, just loads it !!\n\r", __FUNCTION__,i,(bbt_page/ppb)+i);
			        memcpy( temp_BBT, &NfDataBuf, page_size );
			        page_counter++;
			        mem_page_num_tmp--;
			        while( mem_page_num_tmp>0 ){
a0005a44:	080016ae 	j	a0005ab8 <rtk_nand_scan_bbt+0x318>
a0005a48:	8fb60028 	lw	s6,40(sp)
				        if( rtk_read_ecc_page_a((bbt_page+(i*ppb)+page_counter), &NfDataBuf, &NfSpareBuf, page_size)){
a0005a4c:	8e84754c 	lw	a0,30028(s4)
a0005a50:	72441002 	mul	v0,s2,a0
a0005a54:	005e2021 	addu	a0,v0,s8
a0005a58:	00902021 	addu	a0,a0,s0
a0005a5c:	8fa60014 	lw	a2,20(sp)
a0005a60:	0c0012a2 	jal	a0004a88 <rtk_read_ecc_page_a>
a0005a64:	8e277544 	lw	a3,30020(s1)
a0005a68:	1040000b 	beqz	v0,a0005a98 <rtk_nand_scan_bbt+0x2f8>
a0005a6c:	8e267544 	lw	a2,30020(s1)
					        printf("[%s] load bbt table%d error!!\n\r", __FUNCTION__,i);
a0005a70:	3c04a001 	lui	a0,0xa001
a0005a74:	24844a30 	addiu	a0,a0,18992
a0005a78:	3c05a001 	lui	a1,0xa001
a0005a7c:	24a5025c 	addiu	a1,a1,604
a0005a80:	0c002325 	jal	a0008c94 <dprintf>
a0005a84:	02403021 	move	a2,s2
					        //free(temp_BBT);
					        //load_bbt1 = 1;
                            load_bbt_error=1;
					        //return -1;
					        //goto TRY_LOAD_BBT1;
			                error_count++;					        
a0005a88:	8fa30010 	lw	v1,16(sp)
a0005a8c:	24630001 	addiu	v1,v1,1
a0005a90:	080017a3 	j	a0005e8c <rtk_nand_scan_bbt+0x6ec>
a0005a94:	afa30010 	sw	v1,16(sp)
					        break;
				        }
				        memcpy( temp_BBT+page_counter*page_size, &NfDataBuf, page_size );
a0005a98:	72061002 	mul	v0,s0,a2
a0005a9c:	00572021 	addu	a0,v0,s7
a0005aa0:	0c002046 	jal	a0008118 <memcpy>
a0005aa4:	02c02821 	move	a1,s6
				        page_counter++;
a0005aa8:	26100001 	addiu	s0,s0,1
a0005aac:	321000ff 	andi	s0,s0,0xff
				        mem_page_num_tmp--;
a0005ab0:	2673ffff 	addiu	s3,s3,-1
a0005ab4:	327300ff 	andi	s3,s3,0xff
			    if(isbbt == BBT_TAG){
			        //printf("[%s] have created bbt table:%d on block %d, just loads it !!\n\r", __FUNCTION__,i,(bbt_page/ppb)+i);
			        memcpy( temp_BBT, &NfDataBuf, page_size );
			        page_counter++;
			        mem_page_num_tmp--;
			        while( mem_page_num_tmp>0 ){
a0005ab8:	1660ffe4 	bnez	s3,a0005a4c <rtk_nand_scan_bbt+0x2ac>
a0005abc:	02c02821 	move	a1,s6
a0005ac0:	02e09821 	move	s3,s7
				        memcpy( temp_BBT+page_counter*page_size, &NfDataBuf, page_size );
				        page_counter++;
				        mem_page_num_tmp--;
			        }
					if(!load_bbt_error){
					    memcpy( bbt, temp_BBT, sizeof(struct BB_t)*RBA );
a0005ac4:	3c02a001 	lui	v0,0xa001
a0005ac8:	8c467970 	lw	a2,31088(v0)
a0005acc:	3c02a001 	lui	v0,0xa001
a0005ad0:	8c447974 	lw	a0,31092(v0)
a0005ad4:	02e02821 	move	a1,s7
a0005ad8:	0c002046 	jal	a0008118 <memcpy>
a0005adc:	000630c0 	sll	a2,a2,0x3
					    //printf("check bbt table:%d OK\n\r",i);
					    goto CHECK_BBT_OK;
a0005ae0:	080017a7 	j	a0005e9c <rtk_nand_scan_bbt+0x6fc>
a0005ae4:	00000000 	nop
					}
			    }else{
					//printf("Create bbt table:%d is_first_boot:%d\n\r",i, is_first_boot);
					if(is_first_boot)
a0005ae8:	106000e8 	beqz	v1,a0005e8c <rtk_nand_scan_bbt+0x6ec>
a0005aec:	8fa30038 	lw	v1,56(sp)
					{
						//debug cl for safe boot
						static_for_create_v2r_bbt = 1;
a0005af0:	3c02a002 	lui	v0,0xa002
a0005af4:	ac438884 	sw	v1,-30588(v0)
				        rtk_create_bbt(bbt_page+(i*ppb));
a0005af8:	3c02a001 	lui	v0,0xa001
a0005afc:	8c42754c 	lw	v0,30028(v0)
a0005b00:	afa20034 	sw	v0,52(sp)
// Output:
//		BOOL: 0=>OK, -1=>FAIL 
//####################################################################
static int rtk_create_bbt( int page)
{
    dprintf("[%s:] %d\n",__func__,__LINE__);
a0005b04:	8fa4002c 	lw	a0,44(sp)
a0005b08:	8fa5003c 	lw	a1,60(sp)
a0005b0c:	0c002325 	jal	a0008c94 <dprintf>
a0005b10:	24060bac 	li	a2,2988
// Output:
//		BOOL: 0=>OK, -1=>FAIL 
//####################################################################
static int scan_last_die_BB(void)
{
    dprintf("[%s:] %d\n",__func__,__LINE__);
a0005b14:	8fa4002c 	lw	a0,44(sp)
a0005b18:	8fa50030 	lw	a1,48(sp)
a0005b1c:	0c002325 	jal	a0008c94 <dprintf>
a0005b20:	24060b42 	li	a2,2882
	//int remap_block[RBA];
	int block_offset=0;
	int remap_count = 0;
	int i,j, table_index=0 , numchips=1;
	//start_page = BOOT_SIZE;
	block_num = (chip_size/block_size);
a0005b24:	3c02a002 	lui	v0,0xa002
a0005b28:	8c548880 	lw	s4,-30592(v0)
a0005b2c:	3c02a001 	lui	v0,0xa001
a0005b30:	8c427524 	lw	v0,29988(v0)
a0005b34:	0282001b 	divu	zero,s4,v0
a0005b38:	004001f4 	teq	v0,zero,0x7
a0005b3c:	0000a012 	mflo	s4

    dprintf("[%s:] %d block_num = %d\n",__func__,__LINE__,block_num );
a0005b40:	8fa40040 	lw	a0,64(sp)
a0005b44:	8fa50030 	lw	a1,48(sp)
a0005b48:	24060b4e 	li	a2,2894
a0005b4c:	0c002325 	jal	a0008c94 <dprintf>
a0005b50:	00003812 	mflo	a3
	unsigned char *block_status = (unsigned char *) malloc( block_num );
a0005b54:	0c001f55 	jal	a0007d54 <malloc>
a0005b58:	02802021 	move	a0,s4
	if ( !block_status ){
a0005b5c:	14400008 	bnez	v0,a0005b80 <rtk_nand_scan_bbt+0x3e0>
a0005b60:	0040a821 	move	s5,v0
		printf("%s: Error, no enough memory for block_status\n\r",__FUNCTION__);
a0005b64:	3c04a001 	lui	a0,0xa001
a0005b68:	24844a78 	addiu	a0,a0,19064
a0005b6c:	3c05a001 	lui	a1,0xa001
a0005b70:	0c002325 	jal	a0008c94 <dprintf>
a0005b74:	24a50290 	addiu	a1,a1,656
	if ( scan_last_die_BB() ){
		printf("[%s] scan_last_die_BB() error !!\n\r", __FUNCTION__);
		return -1;
	}

	mem_page_num = (sizeof(struct BB_t)*RBA + page_size-1 )/page_size;
a0005b78:	08001750 	j	a0005d40 <rtk_nand_scan_bbt+0x5a0>
a0005b7c:	8e247544 	lw	a0,30020(s1)
	if ( !block_status ){
		printf("%s: Error, no enough memory for block_status\n\r",__FUNCTION__);
		rc = FAIL;
		goto EXIT;
	}
	memset ( (unsigned int *)block_status, 0, block_num );
a0005b80:	00402021 	move	a0,v0
a0005b84:	00002821 	move	a1,zero
a0005b88:	0c00203d 	jal	a00080f4 <memset>
a0005b8c:	02803021 	move	a2,s4

	int *remap_block = (unsigned int*)malloc(sizeof(int)*RBA);
a0005b90:	3c02a001 	lui	v0,0xa001
a0005b94:	8c447970 	lw	a0,31088(v0)
a0005b98:	0c001f55 	jal	a0007d54 <malloc>
a0005b9c:	00042080 	sll	a0,a0,0x2
a0005ba0:	afa2001c 	sw	v0,28(sp)
	if ( !remap_block ){
a0005ba4:	14400008 	bnez	v0,a0005bc8 <rtk_nand_scan_bbt+0x428>
a0005ba8:	0040b021 	move	s6,v0
		printf("%s: Error, no enough memory for remap_block\n\r",__FUNCTION__);
a0005bac:	3c04a001 	lui	a0,0xa001
a0005bb0:	24844aa8 	addiu	a0,a0,19112
a0005bb4:	3c05a001 	lui	a1,0xa001
a0005bb8:	0c002325 	jal	a0008c94 <dprintf>
a0005bbc:	24a50290 	addiu	a1,a1,656
a0005bc0:	080017bf 	j	a0005efc <rtk_nand_scan_bbt+0x75c>
a0005bc4:	00000000 	nop
		rc = FAIL;
		goto EXIT;
	}
	memset ( (unsigned int *)remap_block, 0, sizeof(int)*RBA );
a0005bc8:	3c02a001 	lui	v0,0xa001
a0005bcc:	8c467970 	lw	a2,31088(v0)
a0005bd0:	02c02021 	move	a0,s6
a0005bd4:	00002821 	move	a1,zero
a0005bd8:	0c00203d 	jal	a00080f4 <memset>
a0005bdc:	00063080 	sll	a2,a2,0x2
a0005be0:	08001709 	j	a0005c24 <rtk_nand_scan_bbt+0x484>
a0005be4:	00009821 	move	s3,zero


	/*search bad block of all Nand flash area.*/
	for( addr=0; addr<chip_size; addr+=block_size ){
		int bb = addr >> block_shift;
a0005be8:	3c02a002 	lui	v0,0xa002
a0005bec:	8c508870 	lw	s0,-30608(v0)
		if ( rtk_block_isbad(addr) ){
a0005bf0:	0c001349 	jal	a0004d24 <rtk_block_isbad>
a0005bf4:	02602021 	move	a0,s3
a0005bf8:	10400008 	beqz	v0,a0005c1c <rtk_nand_scan_bbt+0x47c>
a0005bfc:	3c03a001 	lui	v1,0xa001
	memset ( (unsigned int *)remap_block, 0, sizeof(int)*RBA );


	/*search bad block of all Nand flash area.*/
	for( addr=0; addr<chip_size; addr+=block_size ){
		int bb = addr >> block_shift;
a0005c00:	02132806 	srlv	a1,s3,s0
		if ( rtk_block_isbad(addr) ){
			block_status[bb] = 0xff;
a0005c04:	02a51021 	addu	v0,s5,a1
a0005c08:	2403ffff 	li	v1,-1
a0005c0c:	a0430000 	sb	v1,0(v0)
			printf("block[%d] is bad\n",bb);
a0005c10:	0c002325 	jal	a0008c94 <dprintf>
a0005c14:	8fa40048 	lw	a0,72(sp)
	}
	memset ( (unsigned int *)remap_block, 0, sizeof(int)*RBA );


	/*search bad block of all Nand flash area.*/
	for( addr=0; addr<chip_size; addr+=block_size ){
a0005c18:	3c03a001 	lui	v1,0xa001
a0005c1c:	8c627524 	lw	v0,29988(v1)
a0005c20:	02629821 	addu	s3,s3,v0
a0005c24:	3c03a002 	lui	v1,0xa002
a0005c28:	8c628880 	lw	v0,-30592(v1)
a0005c2c:	0262102b 	sltu	v0,s3,v0
a0005c30:	1440ffed 	bnez	v0,a0005be8 <rtk_nand_scan_bbt+0x448>
a0005c34:	02b42021 	addu	a0,s5,s4
a0005c38:	2694ffff 	addiu	s4,s4,-1
a0005c3c:	00001821 	move	v1,zero




    /*check  bad block in RBA;*/
	for ( i=0; i<RBA; i++){
a0005c40:	0800171b 	j	a0005c6c <rtk_nand_scan_bbt+0x4cc>
a0005c44:	3c06a001 	lui	a2,0xa001
		if ( block_status[(block_num-1)-i] == 0x00){
a0005c48:	9085ffff 	lbu	a1,-1(a0)
a0005c4c:	14a00004 	bnez	a1,a0005c60 <rtk_nand_scan_bbt+0x4c0>
a0005c50:	00022880 	sll	a1,v0,0x2
			remap_block[remap_count] = (block_num-1)-i;
a0005c54:	02c52821 	addu	a1,s6,a1
a0005c58:	acb40000 	sw	s4,0(a1)
			//printf("A: remap_block[%d]=%x %x\n",remap_count, remap_block[remap_count], (block_num-1)-i);
			remap_count++;
a0005c5c:	24420001 	addiu	v0,v0,1




    /*check  bad block in RBA;*/
	for ( i=0; i<RBA; i++){
a0005c60:	24630001 	addiu	v1,v1,1
a0005c64:	2484ffff 	addiu	a0,a0,-1
a0005c68:	2694ffff 	addiu	s4,s4,-1
a0005c6c:	8cc57970 	lw	a1,31088(a2)
a0005c70:	0065382b 	sltu	a3,v1,a1
a0005c74:	14e0fff4 	bnez	a3,a0005c48 <rtk_nand_scan_bbt+0x4a8>
a0005c78:	24a50001 	addiu	a1,a1,1
			remap_count++;
		}
	}

    /*If there are some bad blocks in RBA, the remain remap block just map to RB_INIT*/
	if (remap_count<RBA+1){
a0005c7c:	0045282b 	sltu	a1,v0,a1
a0005c80:	10a0000f 	beqz	a1,a0005cc0 <rtk_nand_scan_bbt+0x520>
a0005c84:	00401821 	move	v1,v0
		for (j=remap_count+1; j<RBA+1; j++){
a0005c88:	24420001 	addiu	v0,v0,1
a0005c8c:	00031880 	sll	v1,v1,0x2
a0005c90:	02c31821 	addu	v1,s6,v1
a0005c94:	3c05a001 	lui	a1,0xa001
			remap_block[j-1] = RB_INIT;
a0005c98:	0800172b 	j	a0005cac <rtk_nand_scan_bbt+0x50c>
a0005c9c:	3404fffd 	li	a0,0xfffd
a0005ca0:	ac640000 	sw	a0,0(v1)
		}
	}

    /*If there are some bad blocks in RBA, the remain remap block just map to RB_INIT*/
	if (remap_count<RBA+1){
		for (j=remap_count+1; j<RBA+1; j++){
a0005ca4:	24420001 	addiu	v0,v0,1
a0005ca8:	24630004 	addiu	v1,v1,4
a0005cac:	8ca67970 	lw	a2,31088(a1)
a0005cb0:	24c60001 	addiu	a2,a2,1
a0005cb4:	0046302b 	sltu	a2,v0,a2
a0005cb8:	14c0fff9 	bnez	a2,a0005ca0 <rtk_nand_scan_bbt+0x500>
a0005cbc:	00000000 	nop
a0005cc0:	8fa5001c 	lw	a1,28(sp)
a0005cc4:	00001821 	move	v1,zero
printf("A:bbt[%d].remap_block = %x \n",table_index, bbt[table_index].remap_block);			
			table_index++;
		}
	}
#endif
	for( i=table_index; table_index<RBA; table_index++){
a0005cc8:	3c08a001 	lui	t0,0xa001
		bbt[table_index].bad_block = BB_INIT;
a0005ccc:	3c02a001 	lui	v0,0xa001
a0005cd0:	2407fffe 	li	a3,-2
		bbt[table_index].BB_die = BB_DIE_INIT;
a0005cd4:	08001747 	j	a0005d1c <rtk_nand_scan_bbt+0x57c>
a0005cd8:	2406eeee 	li	a2,-4370
		}
	}

    /*If there are some bad blocks in RBA, the remain remap block just map to RB_INIT*/
	if (remap_count<RBA+1){
		for (j=remap_count+1; j<RBA+1; j++){
a0005cdc:	000420c0 	sll	a0,a0,0x3
			table_index++;
		}
	}
#endif
	for( i=table_index; table_index<RBA; table_index++){
		bbt[table_index].bad_block = BB_INIT;
a0005ce0:	8c497974 	lw	t1,31092(v0)
a0005ce4:	01244821 	addu	t1,t1,a0
a0005ce8:	a5270002 	sh	a3,2(t1)
		bbt[table_index].BB_die = BB_DIE_INIT;
a0005cec:	8c497974 	lw	t1,31092(v0)
a0005cf0:	01244821 	addu	t1,t1,a0
a0005cf4:	a5260000 	sh	a2,0(t1)
		bbt[table_index].remap_block = remap_block[table_index];
a0005cf8:	8c497974 	lw	t1,31092(v0)
a0005cfc:	01244821 	addu	t1,t1,a0
a0005d00:	8caa0000 	lw	t2,0(a1)
a0005d04:	a52a0006 	sh	t2,6(t1)
		bbt[table_index].RB_die = numchips-1;
a0005d08:	8c497974 	lw	t1,31092(v0)
a0005d0c:	01242021 	addu	a0,t1,a0
a0005d10:	a4800004 	sh	zero,4(a0)
printf("A:bbt[%d].remap_block = %x \n",table_index, bbt[table_index].remap_block);			
			table_index++;
		}
	}
#endif
	for( i=table_index; table_index<RBA; table_index++){
a0005d14:	24630001 	addiu	v1,v1,1
a0005d18:	24a50004 	addiu	a1,a1,4
a0005d1c:	8d097970 	lw	t1,31088(t0)
a0005d20:	0069482b 	sltu	t1,v1,t1
a0005d24:	1520ffed 	bnez	t1,a0005cdc <rtk_nand_scan_bbt+0x53c>
a0005d28:	00602021 	move	a0,v1
a0005d2c:	080017bf 	j	a0005efc <rtk_nand_scan_bbt+0x75c>
a0005d30:	00000000 	nop
	if (rc){
		if (block_status)
			free(block_status);	
	}
	if(remap_block)
		free(remap_block);
a0005d34:	0c001f86 	jal	a0007e18 <free>
a0005d38:	02c02021 	move	a0,s6
	if ( scan_last_die_BB() ){
		printf("[%s] scan_last_die_BB() error !!\n\r", __FUNCTION__);
		return -1;
	}

	mem_page_num = (sizeof(struct BB_t)*RBA + page_size-1 )/page_size;
a0005d3c:	8e247544 	lw	a0,30020(s1)
a0005d40:	2483ffff 	addiu	v1,a0,-1
a0005d44:	3c02a001 	lui	v0,0xa001
a0005d48:	8c427970 	lw	v0,31088(v0)
a0005d4c:	000210c0 	sll	v0,v0,0x3
a0005d50:	00621021 	addu	v0,v1,v0
a0005d54:	0044001b 	divu	zero,v0,a0
a0005d58:	008001f4 	teq	a0,zero,0x7
a0005d5c:	00009812 	mflo	s3
a0005d60:	327300ff 	andi	s3,s3,0xff
	temp_BBT = (unsigned char *) malloc( mem_page_num*page_size);
a0005d64:	0c001f55 	jal	a0007d54 <malloc>
a0005d68:	72642002 	mul	a0,s3,a0
	if ( !temp_BBT ){
a0005d6c:	14400008 	bnez	v0,a0005d90 <rtk_nand_scan_bbt+0x5f0>
a0005d70:	0040a021 	move	s4,v0
		printf("%s: Error, no enough memory for temp_BBT\n\r",__FUNCTION__);
a0005d74:	3c04a001 	lui	a0,0xa001
a0005d78:	24844aec 	addiu	a0,a0,19180
a0005d7c:	3c05a001 	lui	a1,0xa001
a0005d80:	0c002325 	jal	a0008c94 <dprintf>
a0005d84:	24a50270 	addiu	a1,a1,624
					if(is_first_boot)
					{
						//debug cl for safe boot
						static_for_create_v2r_bbt = 1;
				        rtk_create_bbt(bbt_page+(i*ppb));
						static_for_create_v2r_bbt = 0;
a0005d88:	0800179e 	j	a0005e78 <rtk_nand_scan_bbt+0x6d8>
a0005d8c:	3c03a002 	lui	v1,0xa002
					//printf("Create bbt table:%d is_first_boot:%d\n\r",i, is_first_boot);
					if(is_first_boot)
					{
						//debug cl for safe boot
						static_for_create_v2r_bbt = 1;
				        rtk_create_bbt(bbt_page+(i*ppb));
a0005d90:	8fa20034 	lw	v0,52(sp)
a0005d94:	72421802 	mul	v1,s2,v0
a0005d98:	007e8021 	addu	s0,v1,s8
	if ( !temp_BBT ){
		printf("%s: Error, no enough memory for temp_BBT\n\r",__FUNCTION__);
		return -1;
	}

	memset( temp_BBT, 0xff, mem_page_num*page_size);
a0005d9c:	8e267544 	lw	a2,30020(s1)
a0005da0:	02802021 	move	a0,s4
a0005da4:	240500ff 	li	a1,255
a0005da8:	0c00203d 	jal	a00080f4 <memset>
a0005dac:	72663002 	mul	a2,s3,a2
	//while(1);//debug cl

  	if ( rtk_erase_block_a( page)){
a0005db0:	0c001048 	jal	a0004120 <rtk_erase_block_a>
a0005db4:	02002021 	move	a0,s0
a0005db8:	1040000d 	beqz	v0,a0005df0 <rtk_nand_scan_bbt+0x650>
a0005dbc:	2402ffbb 	li	v0,-69
		printf("[%s]erase block %d failure !!\n\r", __FUNCTION__, page/ppb);
a0005dc0:	3c02a001 	lui	v0,0xa001
a0005dc4:	8c46754c 	lw	a2,30028(v0)
a0005dc8:	0206001b 	divu	zero,s0,a2
a0005dcc:	00c001f4 	teq	a2,zero,0x7
a0005dd0:	00003012 	mflo	a2
a0005dd4:	3c04a001 	lui	a0,0xa001
a0005dd8:	24844b18 	addiu	a0,a0,19224
a0005ddc:	3c05a001 	lui	a1,0xa001
a0005de0:	0c002325 	jal	a0008c94 <dprintf>
a0005de4:	24a50270 	addiu	a1,a1,624
a0005de8:	0800179b 	j	a0005e6c <rtk_nand_scan_bbt+0x6cc>
a0005dec:	00000000 	nop
		rc =  -1;
		goto EXIT;
	}
    if(!NAND_ADDR_CYCLE)
	#ifdef SWAP_2K_DATA
		NfSpareBuf[BBI_SWAP_OFFSET] = BBT_TAG;
a0005df0:	8fa30014 	lw	v1,20(sp)
a0005df4:	a0620035 	sb	v0,53(v1)
	#else
		NfSpareBuf[0] = BBT_TAG;
	#endif
    else
		NfSpareBuf[5] = BBT_TAG;
	memcpy( temp_BBT, bbt, sizeof(struct BB_t)*RBA );
a0005df8:	3c02a001 	lui	v0,0xa001
a0005dfc:	8c467970 	lw	a2,31088(v0)
a0005e00:	02802021 	move	a0,s4
a0005e04:	3c02a001 	lui	v0,0xa001
a0005e08:	8c457974 	lw	a1,31092(v0)
a0005e0c:	0c002046 	jal	a0008118 <memcpy>
a0005e10:	000630c0 	sll	a2,a2,0x3
a0005e14:	08001799 	j	a0005e64 <rtk_nand_scan_bbt+0x6c4>
a0005e18:	0000a821 	move	s5,zero
	while( mem_page_num>0 ){
		//if ( this->write_ecc_page(mtd, 0, page+page_counter, temp_BBT+page_counter*page_size, 
		//	this->g_oobbuf, 1) )
		if(rtk_write_ecc_page_a(page+page_counter,temp_BBT+page_counter*page_size, &NfSpareBuf, page_size))	{
a0005e1c:	8e277544 	lw	a3,30020(s1)
a0005e20:	02002021 	move	a0,s0
a0005e24:	70f51002 	mul	v0,a3,s5
a0005e28:	00542821 	addu	a1,v0,s4
a0005e2c:	0c0011da 	jal	a0004768 <rtk_write_ecc_page_a>
a0005e30:	8fa60014 	lw	a2,20(sp)
a0005e34:	26b50001 	addiu	s5,s5,1
a0005e38:	10400008 	beqz	v0,a0005e5c <rtk_nand_scan_bbt+0x6bc>
a0005e3c:	26100001 	addiu	s0,s0,1
				printf("[%s] write BBT page %d failure!!\n\r", __FUNCTION__, page+page_counter);
a0005e40:	8fa40044 	lw	a0,68(sp)
a0005e44:	3c05a001 	lui	a1,0xa001
a0005e48:	24a50270 	addiu	a1,a1,624
a0005e4c:	0c002325 	jal	a0008c94 <dprintf>
a0005e50:	02c03021 	move	a2,s6
a0005e54:	0800179b 	j	a0005e6c <rtk_nand_scan_bbt+0x6cc>
a0005e58:	00000000 	nop
				rc =  -1;
				goto EXIT;
		}
		page_counter++;
		mem_page_num--;		
a0005e5c:	2673ffff 	addiu	s3,s3,-1
a0005e60:	327300ff 	andi	s3,s3,0xff
		NfSpareBuf[0] = BBT_TAG;
	#endif
    else
		NfSpareBuf[5] = BBT_TAG;
	memcpy( temp_BBT, bbt, sizeof(struct BB_t)*RBA );
	while( mem_page_num>0 ){
a0005e64:	1660ffed 	bnez	s3,a0005e1c <rtk_nand_scan_bbt+0x67c>
a0005e68:	0200b021 	move	s6,s0
		mem_page_num--;		
	}

EXIT:
	if (temp_BBT)
		free(temp_BBT);
a0005e6c:	0c001f86 	jal	a0007e18 <free>
a0005e70:	02802021 	move	a0,s4
					if(is_first_boot)
					{
						//debug cl for safe boot
						static_for_create_v2r_bbt = 1;
				        rtk_create_bbt(bbt_page+(i*ppb));
						static_for_create_v2r_bbt = 0;
a0005e74:	3c03a002 	lui	v1,0xa002
a0005e78:	080017a3 	j	a0005e8c <rtk_nand_scan_bbt+0x6ec>
a0005e7c:	ac608884 	sw	zero,-30588(v1)
					}
			    }
		    }
		}else{
            //printf("bbt table:%d block:%d page:%d is bad\n\r",i,(bbt_page/ppb)+i,bbt_page+(i*ppb));
			error_count++;
a0005e80:	8fa20010 	lw	v0,16(sp)
a0005e84:	24420001 	addiu	v0,v0,1
a0005e88:	afa20010 	sw	v0,16(sp)
				is_first_boot = 0;
		}
	}
	//printf("%s: is_first_boot:%d\n\r",__FUNCTION__, is_first_boot);
	//is_first_boot = 1;
	for(i=0;i<BACKUP_BBT;i++){
a0005e8c:	26520001 	addiu	s2,s2,1
a0005e90:	24020003 	li	v0,3
a0005e94:	1642fec9 	bne	s2,v0,a00059bc <rtk_nand_scan_bbt+0x21c>
a0005e98:	02e09821 	move	s3,s7
	}
#endif	
	//dump_BBT();

	if (temp_BBT)
		free(temp_BBT);
a0005e9c:	0c001f86 	jal	a0007e18 <free>
a0005ea0:	02602021 	move	a0,s3
    if(error_count >= BACKUP_BBT){
a0005ea4:	8fa20010 	lw	v0,16(sp)
a0005ea8:	2c430003 	sltiu	v1,v0,3
a0005eac:	14600007 	bnez	v1,a0005ecc <rtk_nand_scan_bbt+0x72c>
a0005eb0:	8fa20018 	lw	v0,24(sp)
        rc = -1;
		printf("%d bbt table are all bad!(T______T)\n\r", BACKUP_BBT);
a0005eb4:	3c04a001 	lui	a0,0xa001
a0005eb8:	24844b5c 	addiu	a0,a0,19292
a0005ebc:	0c002325 	jal	a0008c94 <dprintf>
a0005ec0:	24050003 	li	a1,3
a0005ec4:	080017b1 	j	a0005ec4 <rtk_nand_scan_bbt+0x724>
a0005ec8:	00000000 	nop
		while(1); //debug cl for safe boot.
	}		
	return rc;

}
a0005ecc:	8fbf0074 	lw	ra,116(sp)
a0005ed0:	8fbe0070 	lw	s8,112(sp)
a0005ed4:	8fb7006c 	lw	s7,108(sp)
a0005ed8:	8fb60068 	lw	s6,104(sp)
a0005edc:	8fb50064 	lw	s5,100(sp)
a0005ee0:	8fb40060 	lw	s4,96(sp)
a0005ee4:	8fb3005c 	lw	s3,92(sp)
a0005ee8:	8fb20058 	lw	s2,88(sp)
a0005eec:	8fb10054 	lw	s1,84(sp)
a0005ef0:	8fb00050 	lw	s0,80(sp)
a0005ef4:	03e00008 	jr	ra
a0005ef8:	27bd0078 	addiu	sp,sp,120
	}
	
EXIT:
	if (rc){
		if (block_status)
			free(block_status);	
a0005efc:	0c001f86 	jal	a0007e18 <free>
a0005f00:	02a02021 	move	a0,s5
	}
	if(remap_block)
a0005f04:	16c0ff8b 	bnez	s6,a0005d34 <rtk_nand_scan_bbt+0x594>
a0005f08:	00000000 	nop
	if ( scan_last_die_BB() ){
		printf("[%s] scan_last_die_BB() error !!\n\r", __FUNCTION__);
		return -1;
	}

	mem_page_num = (sizeof(struct BB_t)*RBA + page_size-1 )/page_size;
a0005f0c:	08001750 	j	a0005d40 <rtk_nand_scan_bbt+0x5a0>
a0005f10:	8e247544 	lw	a0,30020(s1)

a0005f14 <rtk_scan_v2r_bbt>:

}


int rtk_scan_v2r_bbt(void)
{
a0005f14:	27bdff90 	addiu	sp,sp,-112
a0005f18:	afbf006c 	sw	ra,108(sp)
a0005f1c:	afbe0068 	sw	s8,104(sp)
a0005f20:	afb70064 	sw	s7,100(sp)
a0005f24:	afb60060 	sw	s6,96(sp)
a0005f28:	afb5005c 	sw	s5,92(sp)
a0005f2c:	afb40058 	sw	s4,88(sp)
a0005f30:	afb30054 	sw	s3,84(sp)
a0005f34:	afb20050 	sw	s2,80(sp)
a0005f38:	afb1004c 	sw	s1,76(sp)
a0005f3c:	afb00048 	sw	s0,72(sp)
	unsigned char mem_page_num=0, page_counter=0, mem_page_num_tmp=0;
	unsigned char *temp_BBT=NULL;
	unsigned int block_v2r_num=0;
	unsigned char load_bbt_error = 0, is_first_boot=1;
    //bbt_v2r_page = ((BOOT_SIZE/block_size)-(2*BACKUP_BBT))*ppb;
    bbt_v2r_page = (REMAP_BBT_POS/block_size)*ppb;
a0005f40:	3c02a001 	lui	v0,0xa001
a0005f44:	8c427524 	lw	v0,29988(v0)
a0005f48:	3c030010 	lui	v1,0x10
a0005f4c:	0062001a 	div	zero,v1,v0
a0005f50:	004001f4 	teq	v0,zero,0x7
a0005f54:	0000a812 	mflo	s5
a0005f58:	3c03a001 	lui	v1,0xa001
a0005f5c:	8c64754c 	lw	a0,30028(v1)
a0005f60:	72a4a802 	mul	s5,s5,a0

	//block_v2r_num = ((BOOT_SIZE + USER_SPACE_SIZE + VIMG_SPACE_SIZE + VIMG_SPACE_SIZE) >> block_shift);//jasonwang
	//block_v2r_num = ((chip_size) >> block_shift);//jasonwang
	/* winfred_wang */
	RBA = ((unsigned int)chip_size/block_size)*RBA_PERCENT / 100;
a0005f64:	3c03a002 	lui	v1,0xa002
a0005f68:	8c638880 	lw	v1,-30592(v1)
a0005f6c:	0062001b 	divu	zero,v1,v0
a0005f70:	004001f4 	teq	v0,zero,0x7
a0005f74:	00001012 	mflo	v0
a0005f78:	3c04a001 	lui	a0,0xa001
a0005f7c:	8c847528 	lw	a0,29992(a0)
a0005f80:	70441002 	mul	v0,v0,a0
a0005f84:	3c0451eb 	lui	a0,0x51eb
a0005f88:	3484851f 	ori	a0,a0,0x851f
a0005f8c:	00440019 	multu	v0,a0
a0005f90:	00001010 	mfhi	v0
a0005f94:	00021142 	srl	v0,v0,0x5
a0005f98:	3c04a001 	lui	a0,0xa001
a0005f9c:	ac827970 	sw	v0,31088(a0)
	block_v2r_num = ((chip_size) >> block_shift) - RBA;
a0005fa0:	3c04a002 	lui	a0,0xa002
a0005fa4:	8c848870 	lw	a0,-30608(a0)
a0005fa8:	00831806 	srlv	v1,v1,a0
a0005fac:	00621823 	subu	v1,v1,v0
a0005fb0:	afa30028 	sw	v1,40(sp)
	dprintf("[%s, line %d] block_v2r_num %d bbt_v2r_page %d\n\r",__FUNCTION__,__LINE__, block_v2r_num, bbt_v2r_page);
#endif	
	//while(1);//debug cl

	//create virtual block to real good block remapping table!!!
	bbt_v2r = (unsigned char *) malloc(sizeof(struct BBT_v2r)*(block_v2r_num));
a0005fb4:	00031080 	sll	v0,v1,0x2
a0005fb8:	afa20018 	sw	v0,24(sp)
a0005fbc:	0c001f55 	jal	a0007d54 <malloc>
a0005fc0:	00402021 	move	a0,v0
a0005fc4:	3c03a001 	lui	v1,0xa001
	if(!bbt_v2r){
a0005fc8:	14400009 	bnez	v0,a0005ff0 <rtk_scan_v2r_bbt+0xdc>
a0005fcc:	ac62796c 	sw	v0,31084(v1)
		printf("%s-%d: Error, no enough memory for bbt_v2r\n",__FUNCTION__,__LINE__);
a0005fd0:	3c04a001 	lui	a0,0xa001
a0005fd4:	24844b84 	addiu	a0,a0,19332
a0005fd8:	3c05a001 	lui	a1,0xa001
a0005fdc:	24a502b8 	addiu	a1,a1,696
a0005fe0:	0c002325 	jal	a0008c94 <dprintf>
a0005fe4:	24060c60 	li	a2,3168
		return FAIL;
a0005fe8:	0800191b 	j	a000646c <rtk_scan_v2r_bbt+0x558>
a0005fec:	2413ffff 	li	s3,-1
	}

	mem_page_num = ((sizeof(struct BBT_v2r)*block_v2r_num) + page_size-1 )/page_size;
a0005ff0:	3c02a001 	lui	v0,0xa001
a0005ff4:	8c447544 	lw	a0,30020(v0)
a0005ff8:	2482ffff 	addiu	v0,a0,-1
a0005ffc:	8fa30018 	lw	v1,24(sp)
a0006000:	00431021 	addu	v0,v0,v1
a0006004:	0044001b 	divu	zero,v0,a0
a0006008:	008001f4 	teq	a0,zero,0x7
a000600c:	00001012 	mflo	v0
a0006010:	304200ff 	andi	v0,v0,0xff
a0006014:	afa20030 	sw	v0,48(sp)
	//printf("[%s, line %d] mem_page_num = %d\n\r",__FUNCTION__,__LINE__,mem_page_num);


	temp_BBT =(unsigned char *)malloc( mem_page_num*page_size );
a0006018:	0c001f55 	jal	a0007d54 <malloc>
a000601c:	70442002 	mul	a0,v0,a0
	if(!temp_BBT){
a0006020:	14400008 	bnez	v0,a0006044 <rtk_scan_v2r_bbt+0x130>
a0006024:	0040f021 	move	s8,v0
		printf("%s: Error, no enough memory for temp_BBT_v2r\n",__FUNCTION__);
a0006028:	3c04a001 	lui	a0,0xa001
a000602c:	24844bb0 	addiu	a0,a0,19376
a0006030:	3c05a001 	lui	a1,0xa001
a0006034:	0c002325 	jal	a0008c94 <dprintf>
a0006038:	24a502b8 	addiu	a1,a1,696
		return FAIL;
a000603c:	0800191b 	j	a000646c <rtk_scan_v2r_bbt+0x558>
a0006040:	2413ffff 	li	s3,-1
a0006044:	24020001 	li	v0,1
a0006048:	afa20024 	sw	v0,36(sp)
a000604c:	00008021 	move	s0,zero
	}
//test NEW method!
	for(i=0;i<BACKUP_BBT;i++){
	    rc = rtk_read_ecc_page_a(bbt_v2r_page+(i*ppb), &NfDataBuf, &NfSpareBuf,page_size);
a0006050:	3c11a001 	lui	s1,0xa001
a0006054:	3c13a001 	lui	s3,0xa001
a0006058:	3c14a002 	lui	s4,0xa002
a000605c:	26949a04 	addiu	s4,s4,-26108
a0006060:	3c12a002 	lui	s2,0xa002
a0006064:	2652a268 	addiu	s2,s2,-23960
			isbbt = NfSpareBuf[0];
		#endif
	    else
		    isbbt = NfSpareBuf[5];
		if(!rc){
		    if(isbbt==BBT_TAG)
a0006068:	241600bb 	li	s6,187
	if(!temp_BBT){
		printf("%s: Error, no enough memory for temp_BBT_v2r\n",__FUNCTION__);
		return FAIL;
	}
//test NEW method!
	for(i=0;i<BACKUP_BBT;i++){
a000606c:	24170003 	li	s7,3
	    rc = rtk_read_ecc_page_a(bbt_v2r_page+(i*ppb), &NfDataBuf, &NfSpareBuf,page_size);
a0006070:	8e24754c 	lw	a0,30028(s1)
a0006074:	72041002 	mul	v0,s0,a0
a0006078:	00552021 	addu	a0,v0,s5
a000607c:	02802821 	move	a1,s4
a0006080:	02403021 	move	a2,s2
a0006084:	0c0012a2 	jal	a0004a88 <rtk_read_ecc_page_a>
a0006088:	8e677544 	lw	a3,30020(s3)
		#else
			isbbt = NfSpareBuf[0];
		#endif
	    else
		    isbbt = NfSpareBuf[5];
		if(!rc){
a000608c:	14400005 	bnez	v0,a00060a4 <rtk_scan_v2r_bbt+0x190>
a0006090:	92430035 	lbu	v1,53(s2)
		    if(isbbt==BBT_TAG)
a0006094:	00761826 	xor	v1,v1,s6
a0006098:	8fa40024 	lw	a0,36(sp)
a000609c:	0003200a 	movz	a0,zero,v1
a00060a0:	afa40024 	sw	a0,36(sp)
	if(!temp_BBT){
		printf("%s: Error, no enough memory for temp_BBT_v2r\n",__FUNCTION__);
		return FAIL;
	}
//test NEW method!
	for(i=0;i<BACKUP_BBT;i++){
a00060a4:	26100001 	addiu	s0,s0,1
a00060a8:	1617fff1 	bne	s0,s7,a0006070 <rtk_scan_v2r_bbt+0x15c>
a00060ac:	3c02a002 	lui	v0,0xa002
a00060b0:	0000b821 	move	s7,zero
a00060b4:	00009021 	move	s2,zero
	//dprintf("[%s:] %d is_first_boot:%d, isbbt = 0x%X\n\r",__FUNCTION__,__LINE__, is_first_boot,isbbt);
	for(i=0;i<BACKUP_BBT;i++){
		mem_page_num_tmp = mem_page_num;
		page_counter=0;load_bbt_error=0;
		
		rc = rtk_block_isbad((bbt_v2r_page+(i*ppb))*page_size);
a00060b8:	3c10a001 	lui	s0,0xa001
		if(!rc){
			//printf("load v2r bbt table:%d page:%d\n\r",i, (bbt_v2r_page+(i*ppb)));
		    rc = rtk_read_ecc_page_a(bbt_v2r_page+(i*ppb), &NfDataBuf, &NfSpareBuf,page_size);
a00060bc:	24429a04 	addiu	v0,v0,-26108
a00060c0:	afa2001c 	sw	v0,28(sp)
a00060c4:	3c16a002 	lui	s6,0xa002
a00060c8:	26d6a268 	addiu	s6,s6,-23960
					//printf("Create bbt_v2r table:%d is_first_boot %d\n\r",i,is_first_boot);
					if(is_first_boot)
					{
							//while(1);//debug cl
						//porting cl for debug not heart first two block
						static_for_create_v2r_bbt  = 1;
a00060cc:	24020001 	li	v0,1
a00060d0:	afa20038 	sw	v0,56(sp)
// Output:
//		BOOL: 0=>OK, -1=>FAIL 
//####################################################################
static int create_v2r_remapping(unsigned int page, unsigned int block_v2r_num)
{
    printf("[%s:] %d block_v2r_num = %d\n",__func__,__LINE__,block_v2r_num);
a00060d4:	3c02a001 	lui	v0,0xa001
a00060d8:	24424c04 	addiu	v0,v0,19460
a00060dc:	afa2003c 	sw	v0,60(sp)
a00060e0:	3c02a001 	lui	v0,0xa001
a00060e4:	244202e4 	addiu	v0,v0,740
a00060e8:	afa20034 	sw	v0,52(sp)
//printf("bbt_v2r[%d].block_r = %d\n",count,bbt_v2r[count].block_r);
			count++;
		}
	}
	
	printf("[%s:] %d bad block number iii = %d\n",__func__,__LINE__,iii);
a00060ec:	3c02a001 	lui	v0,0xa001
a00060f0:	24424c24 	addiu	v0,v0,19492
a00060f4:	afa20040 	sw	v0,64(sp)
	if(!temp_BBT){
		printf("%s: Error, no enough memory for temp_BBT_v2r\n",__FUNCTION__);
		return FAIL;
	}
//test NEW method!
	for(i=0;i<BACKUP_BBT;i++){
a00060f8:	afb20014 	sw	s2,20(sp)
	//dprintf("[%s:] %d is_first_boot:%d, isbbt = 0x%X\n\r",__FUNCTION__,__LINE__, is_first_boot,isbbt);
	for(i=0;i<BACKUP_BBT;i++){
		mem_page_num_tmp = mem_page_num;
		page_counter=0;load_bbt_error=0;
		
		rc = rtk_block_isbad((bbt_v2r_page+(i*ppb))*page_size);
a00060fc:	3c02a001 	lui	v0,0xa001
a0006100:	8c44754c 	lw	a0,30028(v0)
a0006104:	72441002 	mul	v0,s2,a0
a0006108:	00552021 	addu	a0,v0,s5
a000610c:	8e027544 	lw	v0,30020(s0)
a0006110:	0c001349 	jal	a0004d24 <rtk_block_isbad>
a0006114:	70822002 	mul	a0,a0,v0
		if(!rc){
a0006118:	144000c4 	bnez	v0,a000642c <rtk_scan_v2r_bbt+0x518>
a000611c:	00409821 	move	s3,v0
			//printf("load v2r bbt table:%d page:%d\n\r",i, (bbt_v2r_page+(i*ppb)));
		    rc = rtk_read_ecc_page_a(bbt_v2r_page+(i*ppb), &NfDataBuf, &NfSpareBuf,page_size);
a0006120:	3c02a001 	lui	v0,0xa001
a0006124:	8c44754c 	lw	a0,30028(v0)
a0006128:	8fb20014 	lw	s2,20(sp)
a000612c:	72441002 	mul	v0,s2,a0
a0006130:	00552021 	addu	a0,v0,s5
a0006134:	8fa5001c 	lw	a1,28(sp)
a0006138:	02c03021 	move	a2,s6
a000613c:	0c0012a2 	jal	a0004a88 <rtk_read_ecc_page_a>
a0006140:	8e077544 	lw	a3,30020(s0)
a0006144:	00409821 	move	s3,v0
			#else
				isbbt = NfSpareBuf[0];
			#endif
		    else
			    isbbt = NfSpareBuf[5];
	        if(!rc){
a0006148:	144000b9 	bnez	v0,a0006430 <rtk_scan_v2r_bbt+0x51c>
a000614c:	92c30035 	lbu	v1,53(s6)
			    //if(isbbt == BBT_TAG && 0)
			    if(isbbt == BBT_TAG){
a0006150:	240200bb 	li	v0,187
a0006154:	1462002b 	bne	v1,v0,a0006204 <rtk_scan_v2r_bbt+0x2f0>
a0006158:	8fa40024 	lw	a0,36(sp)
			        //printf("[%s] have created bbt_v2r table:%d on block %d, just loads it !!\n\r", __FUNCTION__,i,(bbt_v2r_page/ppb)+i);
			        memcpy( temp_BBT, &NfDataBuf, page_size );
a000615c:	03c02021 	move	a0,s8
a0006160:	8fa5001c 	lw	a1,28(sp)
a0006164:	0c002046 	jal	a0008118 <memcpy>
a0006168:	8e067544 	lw	a2,30020(s0)
			        page_counter++;
			        mem_page_num_tmp--;
a000616c:	8fa30030 	lw	v1,48(sp)
a0006170:	2474ffff 	addiu	s4,v1,-1
a0006174:	329400ff 	andi	s4,s4,0xff
			        while( mem_page_num_tmp>0 ){
a0006178:	0800187d 	j	a00061f4 <rtk_scan_v2r_bbt+0x2e0>
a000617c:	24110001 	li	s1,1
				        if( rtk_read_ecc_page_a((bbt_v2r_page+(i*ppb)+page_counter), &NfDataBuf, &NfSpareBuf, page_size)){
a0006180:	afb10010 	sw	s1,16(sp)
a0006184:	3c02a001 	lui	v0,0xa001
a0006188:	8c44754c 	lw	a0,30028(v0)
a000618c:	8fa20014 	lw	v0,20(sp)
a0006190:	70441802 	mul	v1,v0,a0
a0006194:	00752021 	addu	a0,v1,s5
a0006198:	00912021 	addu	a0,a0,s1
a000619c:	8fa5001c 	lw	a1,28(sp)
a00061a0:	0c0012a2 	jal	a0004a88 <rtk_read_ecc_page_a>
a00061a4:	8e077544 	lw	a3,30020(s0)
a00061a8:	10400009 	beqz	v0,a00061d0 <rtk_scan_v2r_bbt+0x2bc>
a00061ac:	8e067544 	lw	a2,30020(s0)
					        printf("[%s] load bbt_v2r table%d error!!\n\r", __FUNCTION__,i);
a00061b0:	3c04a001 	lui	a0,0xa001
a00061b4:	24844be0 	addiu	a0,a0,19424
a00061b8:	3c05a001 	lui	a1,0xa001
a00061bc:	24a502b8 	addiu	a1,a1,696
a00061c0:	0c002325 	jal	a0008c94 <dprintf>
a00061c4:	02403021 	move	a2,s2
					        //free(temp_BBT);
					        //load_bbt1 = 1;
					        load_bbt_error = 1;
					        //return -1;
					        //goto TRY_LOAD_BBT1;
			                error_count++;					        
a00061c8:	0800190c 	j	a0006430 <rtk_scan_v2r_bbt+0x51c>
a00061cc:	26f70001 	addiu	s7,s7,1
					        break;
				        }
				        memcpy( temp_BBT+page_counter*page_size, &NfDataBuf, page_size );
a00061d0:	8fa20010 	lw	v0,16(sp)
a00061d4:	70461802 	mul	v1,v0,a2
a00061d8:	007e2021 	addu	a0,v1,s8
a00061dc:	0c002046 	jal	a0008118 <memcpy>
a00061e0:	8fa5001c 	lw	a1,28(sp)
				        page_counter++;
a00061e4:	26310001 	addiu	s1,s1,1
a00061e8:	323100ff 	andi	s1,s1,0xff
				        mem_page_num_tmp--;
a00061ec:	2694ffff 	addiu	s4,s4,-1
a00061f0:	329400ff 	andi	s4,s4,0xff
			    if(isbbt == BBT_TAG){
			        //printf("[%s] have created bbt_v2r table:%d on block %d, just loads it !!\n\r", __FUNCTION__,i,(bbt_v2r_page/ppb)+i);
			        memcpy( temp_BBT, &NfDataBuf, page_size );
			        page_counter++;
			        mem_page_num_tmp--;
			        while( mem_page_num_tmp>0 ){
a00061f4:	1680ffe2 	bnez	s4,a0006180 <rtk_scan_v2r_bbt+0x26c>
a00061f8:	02c03021 	move	a2,s6
				        memcpy( temp_BBT+page_counter*page_size, &NfDataBuf, page_size );
				        page_counter++;
				        mem_page_num_tmp--;
			        }
					if(!load_bbt_error){
			            memcpy( bbt_v2r, temp_BBT, sizeof(struct BBT_v2r)*(block_v2r_num));
a00061fc:	08001928 	j	a00064a0 <rtk_scan_v2r_bbt+0x58c>
a0006200:	3c02a001 	lui	v0,0xa001
					    //printf("check bbt_v2r table:%d OK\n\r",i);
					    goto CHECK_V2R_BBT_OK;
					}
			    }else{
					//printf("Create bbt_v2r table:%d is_first_boot %d\n\r",i,is_first_boot);
					if(is_first_boot)
a0006204:	1080008a 	beqz	a0,a0006430 <rtk_scan_v2r_bbt+0x51c>
a0006208:	8fa30038 	lw	v1,56(sp)
					{
							//while(1);//debug cl
						//porting cl for debug not heart first two block
						static_for_create_v2r_bbt  = 1;
a000620c:	3c02a002 	lui	v0,0xa002
a0006210:	ac438884 	sw	v1,-30588(v0)
					    create_v2r_remapping(bbt_v2r_page+(i*ppb),block_v2r_num);
a0006214:	3c02a001 	lui	v0,0xa001
a0006218:	8c42754c 	lw	v0,30028(v0)
a000621c:	afa20020 	sw	v0,32(sp)
// Output:
//		BOOL: 0=>OK, -1=>FAIL 
//####################################################################
static int create_v2r_remapping(unsigned int page, unsigned int block_v2r_num)
{
    printf("[%s:] %d block_v2r_num = %d\n",__func__,__LINE__,block_v2r_num);
a0006220:	8fa4003c 	lw	a0,60(sp)
a0006224:	8fa50034 	lw	a1,52(sp)
a0006228:	24060bec 	li	a2,3052
a000622c:	0c002325 	jal	a0008c94 <dprintf>
a0006230:	8fa70028 	lw	a3,40(sp)
	//offs_real = start_page;
#if 1
	count = 0;
	//debug cl
	int iii = 0;
	search_region = (block_v2r_num << block_shift);
a0006234:	3c04a002 	lui	a0,0xa002
a0006238:	8c828870 	lw	v0,-30608(a0)
a000623c:	8fa30028 	lw	v1,40(sp)
a0006240:	00431004 	sllv	v0,v1,v0
a0006244:	afa2002c 	sw	v0,44(sp)
a0006248:	0000a021 	move	s4,zero
a000624c:	afa00010 	sw	zero,16(sp)
a0006250:	080018ad 	j	a00062b4 <rtk_scan_v2r_bbt+0x3a0>
a0006254:	00008821 	move	s1,zero
	//just create [bootloader+user+rootfs+rootfs2] region remapping
    while(offs_real < search_region){
		if ( rtk_block_isbad(offs_real) ){
a0006258:	0c001349 	jal	a0004d24 <rtk_block_isbad>
a000625c:	02202021 	move	a0,s1
a0006260:	10400006 	beqz	v0,a000627c <rtk_scan_v2r_bbt+0x368>
a0006264:	3c02a001 	lui	v0,0xa001
			offs_real += block_size;
a0006268:	3c04a001 	lui	a0,0xa001
a000626c:	8c827524 	lw	v0,29988(a0)
a0006270:	02228821 	addu	s1,s1,v0
			iii++;
a0006274:	080018ad 	j	a00062b4 <rtk_scan_v2r_bbt+0x3a0>
a0006278:	26940001 	addiu	s4,s4,1
		}else{
    		//bbt_v2r[count].block_v = (offs >> block_shift);
    		bbt_v2r[count].block_r = (offs_real >> block_shift);			
a000627c:	8c43796c 	lw	v1,31084(v0)
a0006280:	8fa40010 	lw	a0,16(sp)
a0006284:	00041080 	sll	v0,a0,0x2
a0006288:	00621021 	addu	v0,v1,v0
a000628c:	3c04a002 	lui	a0,0xa002
a0006290:	8c838870 	lw	v1,-30608(a0)
a0006294:	00711806 	srlv	v1,s1,v1
a0006298:	ac430000 	sw	v1,0(v0)
			offs+=block_size;
			offs_real += block_size;			
a000629c:	3c03a001 	lui	v1,0xa001
a00062a0:	8c627524 	lw	v0,29988(v1)
a00062a4:	02228821 	addu	s1,s1,v0
//printf("bbt_v2r[%d].block_v %d,  bbt_v2r[%d].block_r %d\n",count,bbt_v2r[count].block_v,count,bbt_v2r[count].block_r);
//printf("bbt_v2r[%d].block_r = %d\n",count,bbt_v2r[count].block_r);
			count++;
a00062a8:	8fa40010 	lw	a0,16(sp)
a00062ac:	24840001 	addiu	a0,a0,1
a00062b0:	afa40010 	sw	a0,16(sp)
	count = 0;
	//debug cl
	int iii = 0;
	search_region = (block_v2r_num << block_shift);
	//just create [bootloader+user+rootfs+rootfs2] region remapping
    while(offs_real < search_region){
a00062b4:	8fa3002c 	lw	v1,44(sp)
a00062b8:	0223102b 	sltu	v0,s1,v1
a00062bc:	1440ffe6 	bnez	v0,a0006258 <rtk_scan_v2r_bbt+0x344>
a00062c0:	8fa40040 	lw	a0,64(sp)
//printf("bbt_v2r[%d].block_r = %d\n",count,bbt_v2r[count].block_r);
			count++;
		}
	}
	
	printf("[%s:] %d bad block number iii = %d\n",__func__,__LINE__,iii);
a00062c4:	8fa50034 	lw	a1,52(sp)
a00062c8:	24060c0a 	li	a2,3082
a00062cc:	0c002325 	jal	a0008c94 <dprintf>
a00062d0:	02803821 	move	a3,s4
	//printf("[%s, line %d] block_v2r_num %d\n\r",__FUNCTION__,__LINE__, block_v2r_num);
#endif
	mem_page_num = ((sizeof(struct BBT_v2r)*block_v2r_num) + page_size-1 )/page_size;
a00062d4:	8e047544 	lw	a0,30020(s0)
a00062d8:	2482ffff 	addiu	v0,a0,-1
a00062dc:	8fa30018 	lw	v1,24(sp)
a00062e0:	00431021 	addu	v0,v0,v1
a00062e4:	0044001b 	divu	zero,v0,a0
a00062e8:	008001f4 	teq	a0,zero,0x7
a00062ec:	00008812 	mflo	s1
a00062f0:	323100ff 	andi	s1,s1,0xff
	//printf("[%s, line %d] mem_page_num = %d\n\r",__FUNCTION__,__LINE__,mem_page_num);

	temp_BBT = (unsigned char *) malloc( mem_page_num*page_size);
a00062f4:	afb1002c 	sw	s1,44(sp)
a00062f8:	0c001f55 	jal	a0007d54 <malloc>
a00062fc:	72242002 	mul	a0,s1,a0
	if ( !temp_BBT ){
a0006300:	14400008 	bnez	v0,a0006324 <rtk_scan_v2r_bbt+0x410>
a0006304:	0040a021 	move	s4,v0
		printf("%s: Error, no enough memory for temp_BBT v2r\n\r",__FUNCTION__);
a0006308:	3c04a001 	lui	a0,0xa001
a000630c:	24844c48 	addiu	a0,a0,19528
a0006310:	3c05a001 	lui	a1,0xa001
a0006314:	0c002325 	jal	a0008c94 <dprintf>
a0006318:	24a502cc 	addiu	a1,a1,716
					{
							//while(1);//debug cl
						//porting cl for debug not heart first two block
						static_for_create_v2r_bbt  = 1;
					    create_v2r_remapping(bbt_v2r_page+(i*ppb),block_v2r_num);
						static_for_create_v2r_bbt  = 0;
a000631c:	08001909 	j	a0006424 <rtk_scan_v2r_bbt+0x510>
a0006320:	3c02a002 	lui	v0,0xa002
					if(is_first_boot)
					{
							//while(1);//debug cl
						//porting cl for debug not heart first two block
						static_for_create_v2r_bbt  = 1;
					    create_v2r_remapping(bbt_v2r_page+(i*ppb),block_v2r_num);
a0006324:	8fa20020 	lw	v0,32(sp)
a0006328:	8fa30014 	lw	v1,20(sp)
a000632c:	70432002 	mul	a0,v0,v1
a0006330:	00951021 	addu	v0,a0,s5
a0006334:	afa20010 	sw	v0,16(sp)
	if ( !temp_BBT ){
		printf("%s: Error, no enough memory for temp_BBT v2r\n\r",__FUNCTION__);
		rc = FAIL;
		goto EXIT_V2R;
	}
	memset( temp_BBT, 0xff, mem_page_num*page_size);
a0006338:	8e067544 	lw	a2,30020(s0)
a000633c:	02802021 	move	a0,s4
a0006340:	240500ff 	li	a1,255
a0006344:	8fa2002c 	lw	v0,44(sp)
a0006348:	0c00203d 	jal	a00080f4 <memset>
a000634c:	70463002 	mul	a2,v0,a2
	//while(1); //debug cl

	if ( rtk_erase_block_a(page)){
a0006350:	0c001048 	jal	a0004120 <rtk_erase_block_a>
a0006354:	8fa40010 	lw	a0,16(sp)
a0006358:	1040000d 	beqz	v0,a0006390 <rtk_scan_v2r_bbt+0x47c>
a000635c:	3c02a001 	lui	v0,0xa001
		printf("[%s]erase block %d failure !!\n\r", __FUNCTION__, page/ppb);
a0006360:	8c42754c 	lw	v0,30028(v0)
a0006364:	8fa30010 	lw	v1,16(sp)
a0006368:	0062001b 	divu	zero,v1,v0
a000636c:	004001f4 	teq	v0,zero,0x7
a0006370:	00003012 	mflo	a2
a0006374:	3c04a001 	lui	a0,0xa001
a0006378:	24844b18 	addiu	a0,a0,19224
a000637c:	3c05a001 	lui	a1,0xa001
a0006380:	0c002325 	jal	a0008c94 <dprintf>
a0006384:	24a502cc 	addiu	a1,a1,716
a0006388:	0800192e 	j	a00064b8 <rtk_scan_v2r_bbt+0x5a4>
a000638c:	00000000 	nop
		rc =  -1;
		goto EXIT_V2R;
	}
	if(!NAND_ADDR_CYCLE)
	#ifdef SWAP_2K_DATA
		NfSpareBuf[BBI_SWAP_OFFSET] = BBT_TAG;
a0006390:	2402ffbb 	li	v0,-69
a0006394:	a2c20035 	sb	v0,53(s6)
	#else
		NfSpareBuf[0] = BBT_TAG;
	#endif
	else
		NfSpareBuf[5] = BBT_TAG;
	memcpy( temp_BBT, bbt_v2r, sizeof(struct BBT_v2r)*block_v2r_num );
a0006398:	02802021 	move	a0,s4
a000639c:	3c02a001 	lui	v0,0xa001
a00063a0:	8c45796c 	lw	a1,31084(v0)
a00063a4:	0c002046 	jal	a0008118 <memcpy>
a00063a8:	8fa60018 	lw	a2,24(sp)
a00063ac:	08001905 	j	a0006414 <rtk_scan_v2r_bbt+0x500>
a00063b0:	afa00014 	sw	zero,20(sp)
a00063b4:	8fa40010 	lw	a0,16(sp)
a00063b8:	00641821 	addu	v1,v1,a0
a00063bc:	afa30020 	sw	v1,32(sp)
	//dump_mem((unsigned int)temp_BBT,512);
	while( mem_page_num>0 ){
		//if ( this->write_ecc_page(mtd, 0, page+page_counter, temp_BBT+page_counter*page_size, 
		//	this->g_oobbuf, 1) )
		if(rtk_write_ecc_page_a(page+page_counter,temp_BBT+page_counter*page_size, &NfSpareBuf, page_size))	{
a00063c0:	8e077544 	lw	a3,30020(s0)
a00063c4:	00602021 	move	a0,v1
a00063c8:	8fa20014 	lw	v0,20(sp)
a00063cc:	70e21802 	mul	v1,a3,v0
a00063d0:	00742821 	addu	a1,v1,s4
a00063d4:	0c0011da 	jal	a0004768 <rtk_write_ecc_page_a>
a00063d8:	02c03021 	move	a2,s6
a00063dc:	8fa40014 	lw	a0,20(sp)
a00063e0:	24840001 	addiu	a0,a0,1
a00063e4:	10400009 	beqz	v0,a000640c <rtk_scan_v2r_bbt+0x4f8>
a00063e8:	afa40014 	sw	a0,20(sp)
				printf("[%s] write BBT page %d failure!!\n\r", __FUNCTION__, page+page_counter);
a00063ec:	3c04a001 	lui	a0,0xa001
a00063f0:	24844b38 	addiu	a0,a0,19256
a00063f4:	3c05a001 	lui	a1,0xa001
a00063f8:	24a502cc 	addiu	a1,a1,716
a00063fc:	0c002325 	jal	a0008c94 <dprintf>
a0006400:	8fa60020 	lw	a2,32(sp)
a0006404:	0800192e 	j	a00064b8 <rtk_scan_v2r_bbt+0x5a4>
a0006408:	00000000 	nop
				rc =  -1;
				goto EXIT_V2R;
		}
//printf("[%s, line %d] mem_page_num = %d page_counter %d\n\r",__FUNCTION__,__LINE__,mem_page_num, page_counter);
			page_counter++;
			mem_page_num--; 	
a000640c:	2631ffff 	addiu	s1,s1,-1
a0006410:	323100ff 	andi	s1,s1,0xff
	#endif
	else
		NfSpareBuf[5] = BBT_TAG;
	memcpy( temp_BBT, bbt_v2r, sizeof(struct BBT_v2r)*block_v2r_num );
	//dump_mem((unsigned int)temp_BBT,512);
	while( mem_page_num>0 ){
a0006414:	1620ffe7 	bnez	s1,a00063b4 <rtk_scan_v2r_bbt+0x4a0>
a0006418:	8fa30014 	lw	v1,20(sp)
a000641c:	0800192e 	j	a00064b8 <rtk_scan_v2r_bbt+0x5a4>
a0006420:	00000000 	nop
					{
							//while(1);//debug cl
						//porting cl for debug not heart first two block
						static_for_create_v2r_bbt  = 1;
					    create_v2r_remapping(bbt_v2r_page+(i*ppb),block_v2r_num);
						static_for_create_v2r_bbt  = 0;
a0006424:	0800190c 	j	a0006430 <rtk_scan_v2r_bbt+0x51c>
a0006428:	ac408884 	sw	zero,-30588(v0)
					}
			    }
		    }
		}else{
            //printf("bbt_v2r table:%d block:%d page:%d is bad\n\r",i,(bbt_v2r_page/ppb)+i,bbt_v2r_page+(i*ppb));
			error_count++;
a000642c:	26f70001 	addiu	s7,s7,1
	//is_first_boot = 1;
	//while(1);


	//dprintf("[%s:] %d is_first_boot:%d, isbbt = 0x%X\n\r",__FUNCTION__,__LINE__, is_first_boot,isbbt);
	for(i=0;i<BACKUP_BBT;i++){
a0006430:	26520001 	addiu	s2,s2,1
a0006434:	24020003 	li	v0,3
a0006438:	1642ff2f 	bne	s2,v0,a00060f8 <rtk_scan_v2r_bbt+0x1e4>
a000643c:	00000000 	nop
			}
		}
	}
#endif
	if (temp_BBT)
		free(temp_BBT);
a0006440:	0c001f86 	jal	a0007e18 <free>
a0006444:	03c02021 	move	a0,s8
    if(error_count >= BACKUP_BBT){
a0006448:	2af70003 	slti	s7,s7,3
a000644c:	16e00008 	bnez	s7,a0006470 <rtk_scan_v2r_bbt+0x55c>
a0006450:	02601021 	move	v0,s3
        rc = -1;
		printf("%d v2r table are all bad!(T______T)\n\r", BACKUP_BBT);
a0006454:	3c04a001 	lui	a0,0xa001
a0006458:	24844c78 	addiu	a0,a0,19576
a000645c:	0c002325 	jal	a0008c94 <dprintf>
a0006460:	24050003 	li	a1,3
a0006464:	08001919 	j	a0006464 <rtk_scan_v2r_bbt+0x550>
a0006468:	00000000 	nop
		while(1); //debug cl porting for safe
	}
    return rc;
}
a000646c:	02601021 	move	v0,s3
a0006470:	8fbf006c 	lw	ra,108(sp)
a0006474:	8fbe0068 	lw	s8,104(sp)
a0006478:	8fb70064 	lw	s7,100(sp)
a000647c:	8fb60060 	lw	s6,96(sp)
a0006480:	8fb5005c 	lw	s5,92(sp)
a0006484:	8fb40058 	lw	s4,88(sp)
a0006488:	8fb30054 	lw	s3,84(sp)
a000648c:	8fb20050 	lw	s2,80(sp)
a0006490:	8fb1004c 	lw	s1,76(sp)
a0006494:	8fb00048 	lw	s0,72(sp)
a0006498:	03e00008 	jr	ra
a000649c:	27bd0070 	addiu	sp,sp,112
				        memcpy( temp_BBT+page_counter*page_size, &NfDataBuf, page_size );
				        page_counter++;
				        mem_page_num_tmp--;
			        }
					if(!load_bbt_error){
			            memcpy( bbt_v2r, temp_BBT, sizeof(struct BBT_v2r)*(block_v2r_num));
a00064a0:	8c44796c 	lw	a0,31084(v0)
a00064a4:	03c02821 	move	a1,s8
a00064a8:	0c002046 	jal	a0008118 <memcpy>
a00064ac:	8fa60018 	lw	a2,24(sp)
					    //printf("check bbt_v2r table:%d OK\n\r",i);
					    goto CHECK_V2R_BBT_OK;
a00064b0:	08001910 	j	a0006440 <rtk_scan_v2r_bbt+0x52c>
a00064b4:	00000000 	nop
			page_counter++;
			mem_page_num--; 	
	}
	EXIT_V2R:
	if(temp_BBT)
		free(temp_BBT);
a00064b8:	0c001f86 	jal	a0007e18 <free>
a00064bc:	02802021 	move	a0,s4
					{
							//while(1);//debug cl
						//porting cl for debug not heart first two block
						static_for_create_v2r_bbt  = 1;
					    create_v2r_remapping(bbt_v2r_page+(i*ppb),block_v2r_num);
						static_for_create_v2r_bbt  = 0;
a00064c0:	08001909 	j	a0006424 <rtk_scan_v2r_bbt+0x510>
a00064c4:	3c02a002 	lui	v0,0xa002

a00064c8 <rtk_PIO_read_page>:
                 ew $start_addr2	 = 0x03000000  //page 0x40
                 ...
                 */

int rtk_PIO_read_page (int flash_address,int enable_show_page_content,int report_bad_block)
{
a00064c8:	27bdffa8 	addiu	sp,sp,-88
a00064cc:	afbf0054 	sw	ra,84(sp)
a00064d0:	afbe0050 	sw	s8,80(sp)
a00064d4:	afb7004c 	sw	s7,76(sp)
a00064d8:	afb60048 	sw	s6,72(sp)
a00064dc:	afb50044 	sw	s5,68(sp)
a00064e0:	afb40040 	sw	s4,64(sp)
a00064e4:	afb3003c 	sw	s3,60(sp)
a00064e8:	afb20038 	sw	s2,56(sp)
a00064ec:	afb10034 	sw	s1,52(sp)
a00064f0:	afb00030 	sw	s0,48(sp)
a00064f4:	00809821 	move	s3,a0
a00064f8:	00a0b821 	move	s7,a1
    flush_cache ();
a00064fc:	0c001eae 	jal	a0007ab8 <flush_cache>
a0006500:	afa60060 	sw	a2,96(sp)

    if ((flash_address % (page_size + oob_size)) != 0)
a0006504:	3c02a001 	lui	v0,0xa001
a0006508:	8c457544 	lw	a1,30020(v0)
a000650c:	3c02a001 	lui	v0,0xa001
a0006510:	8c467548 	lw	a2,30024(v0)
a0006514:	00c52021 	addu	a0,a2,a1
a0006518:	0264001b 	divu	zero,s3,a0
a000651c:	008001f4 	teq	a0,zero,0x7
a0006520:	00001010 	mfhi	v0
a0006524:	10400006 	beqz	v0,a0006540 <rtk_PIO_read_page+0x78>
a0006528:	00000000 	nop
    {
        dprintf ("\n\rflash_address must be page(0x%x+0x%x Bytes) aligned!\n",
a000652c:	3c04a001 	lui	a0,0xa001
a0006530:	0c002325 	jal	a0008c94 <dprintf>
a0006534:	24844654 	addiu	a0,a0,18004

    free(ptr_PIO_READ_NADR);

    return block_indicator;

}
a0006538:	080019c2 	j	a0006708 <rtk_PIO_read_page+0x240>
a000653c:	8fbf0054 	lw	ra,84(sp)

    int block_indicator=1;                           //"1':good block , "0":bad block
    int bad_block_byte_index=0;

                                                     //pre-allocat
    int* ptr_PIO_READ_NADR= malloc (page_size + oob_size);
a0006540:	0c001f55 	jal	a0007d54 <malloc>
a0006544:	3c11a001 	lui	s1,0xa001
a0006548:	0040f021 	move	s8,v0

    int page_PIO_num = flash_address / (page_size + oob_size);
a000654c:	3c12a001 	lui	s2,0xa001
a0006550:	8e347548 	lw	s4,30024(s1)
a0006554:	8e427544 	lw	v0,30020(s2)
a0006558:	0282a021 	addu	s4,s4,v0
a000655c:	0274001b 	divu	zero,s3,s4
a0006560:	028001f4 	teq	s4,zero,0x7
                 //dprintf ("page_PIO_num=0x%x\n", page_PIO_num);

    int i,j;

                 /*PIO read step-1.*/
    check_ready_nand ();
a0006564:	0c000f80 	jal	a0003e00 <check_ready_nand>
a0006568:	0000a012 	mflo	s4

                 //rtk_writel ((rtk_readl (NACR) & ~(ECC_enable)), NACR); //disable ECC function
    check_ready_nand ();
a000656c:	0c000f80 	jal	a0003e00 <check_ready_nand>
a0006570:	3c15b801 	lui	s5,0xb801

                 /*PIO read step-2.*/
    rtk_writel (0x0, NACMR);
a0006574:	36b0a008 	ori	s0,s5,0xa008
a0006578:	ae000000 	sw	zero,0(s0)
    rtk_writel ((CECS0 ), NACMR);
a000657c:	3c164000 	lui	s6,0x4000
a0006580:	ae160000 	sw	s6,0(s0)
    check_ready_nand ();
                 //dprintf (" c1-NAADR_REG_value=0x%x\n", NAADR_REG_value);
#endif

#ifdef CONFIG_NAND_Flash_Large_Page_128MB_4cycles
    addr_cycle[0] = addr_cycle[1] = 0;               //Basic PIO read is "Page"
a0006584:	afa00014 	sw	zero,20(sp)
a0006588:	afa00010 	sw	zero,16(sp)

    for (page_shift = 0; page_shift < 2; page_shift++)
    {
        addr_cycle[page_shift + 2] = (page_PIO_num >> (8 * page_shift)) & 0xff;
a000658c:	328200ff 	andi	v0,s4,0xff
a0006590:	afa20018 	sw	v0,24(sp)
a0006594:	7e943a00 	ext	s4,s4,0x8,0x8
a0006598:	afb4001c 	sw	s4,28(sp)
    }

    NAADR_REG_value=enNextAD|AD2EN|AD1EN|AD0EN|(addr_cycle[2]<<CE_ADDR2);
    rtk_writel(NAADR_REG_value,NAADR);
a000659c:	00021400 	sll	v0,v0,0x10
a00065a0:	3c030f00 	lui	v1,0xf00
a00065a4:	00431025 	or	v0,v0,v1
a00065a8:	36b5a00c 	ori	s5,s5,0xa00c
a00065ac:	aea20000 	sw	v0,0(s5)
    check_ready_nand ();
a00065b0:	0c000f80 	jal	a0003e00 <check_ready_nand>
a00065b4:	00000000 	nop
                 //dprintf ("c0-NAADR_REG_value=0x%x\n", NAADR_REG_value);

    NAADR_REG_value=(~enNextAD) & AD0EN |(addr_cycle[3]<<CE_ADDR0) ;
    rtk_writel(NAADR_REG_value,NAADR);
a00065b8:	3c020100 	lui	v0,0x100
a00065bc:	0282a025 	or	s4,s4,v0
a00065c0:	aeb40000 	sw	s4,0(s5)
    check_ready_nand ();
a00065c4:	0c000f80 	jal	a0003e00 <check_ready_nand>
a00065c8:	36d60030 	ori	s6,s6,0x30
                   //dprintf ("addr_cycle[1]=0x%x\n", addr_cycle[1]);
                    //dprintf ("addr_cycle[2]=0x%x\n", addr_cycle[2]);
#endif                                           /*  */

                 /*PIO read step-4.*/
    rtk_writel ((CECS0 | CMD_PG_READ_C2), NACMR);
a00065cc:	ae160000 	sw	s6,0(s0)
    check_ready_nand ();
a00065d0:	0c000f80 	jal	a0003e00 <check_ready_nand>
a00065d4:	00000000 	nop

                 /*PIO read step-5.*/
#if 1
                 /*before setting CES0 to 1 (step.6) , user can successively read NADR for the continue next 4 bytes*/
    for (i=0;i<((page_size + oob_size)/4);i++)
a00065d8:	8e237548 	lw	v1,30024(s1)
a00065dc:	8e427544 	lw	v0,30020(s2)
a00065e0:	00621021 	addu	v0,v1,v0
a00065e4:	2c420004 	sltiu	v0,v0,4
a00065e8:	14400034 	bnez	v0,a00066bc <rtk_PIO_read_page+0x1f4>
a00065ec:	00009021 	move	s2,zero
a00065f0:	00008021 	move	s0,zero
    {
        *(ptr_PIO_READ_NADR+i) = rtk_readl (NADR);
a00065f4:	3c14b801 	lui	s4,0xb801
a00065f8:	3694a014 	ori	s4,s4,0xa014
            if(i%4==0)
            {
                dprintf ("\n%08X:    ",(i*4)+flash_address);

            }
            dprintf ("%08X    ",*(ptr_PIO_READ_NADR+i));
a00065fc:	3c02a001 	lui	v0,0xa001
a0006600:	24424cac 	addiu	v0,v0,19628
a0006604:	afa20028 	sw	v0,40(sp)
            dprintf ("*(ptr_PIO_READ_NADR+%d)=0x%x\n",i,*(ptr_PIO_READ_NADR+i));
#else

            if(i%4==0)
            {
                dprintf ("\n%08X:    ",(i*4)+flash_address);
a0006608:	3c02a001 	lui	v0,0xa001
a000660c:	24424ca0 	addiu	v0,v0,19616
a0006610:	afa2002c 	sw	v0,44(sp)
    check_ready_nand ();

                 /*PIO read step-5.*/
#if 1
                 /*before setting CES0 to 1 (step.6) , user can successively read NADR for the continue next 4 bytes*/
    for (i=0;i<((page_size + oob_size)/4);i++)
a0006614:	0220a821 	move	s5,s1
a0006618:	3c16a001 	lui	s6,0xa001
    {
        *(ptr_PIO_READ_NADR+i) = rtk_readl (NADR);
a000661c:	00128880 	sll	s1,s2,0x2
a0006620:	03d18821 	addu	s1,s8,s1
a0006624:	8e820000 	lw	v0,0(s4)

        check_ready_nand ();
a0006628:	0c000f80 	jal	a0003e00 <check_ready_nand>
a000662c:	ae220000 	sw	v0,0(s1)

        if(enable_show_page_content)
a0006630:	12e00009 	beqz	s7,a0006658 <rtk_PIO_read_page+0x190>
a0006634:	32520003 	andi	s2,s2,0x3
        {
#if 0
            dprintf ("*(ptr_PIO_READ_NADR+%d)=0x%x\n",i,*(ptr_PIO_READ_NADR+i));
#else

            if(i%4==0)
a0006638:	16400005 	bnez	s2,a0006650 <rtk_PIO_read_page+0x188>
a000663c:	8fa40028 	lw	a0,40(sp)
            {
                dprintf ("\n%08X:    ",(i*4)+flash_address);
a0006640:	8fa4002c 	lw	a0,44(sp)
a0006644:	0c002325 	jal	a0008c94 <dprintf>
a0006648:	02602821 	move	a1,s3

            }
            dprintf ("%08X    ",*(ptr_PIO_READ_NADR+i));
a000664c:	8fa40028 	lw	a0,40(sp)
a0006650:	0c002325 	jal	a0008c94 <dprintf>
a0006654:	8e250000 	lw	a1,0(s1)
#endif
        }

                 //Show Bad block information and location
        if((*(ptr_PIO_READ_NADR+i)!=0xffffffff)&&(report_bad_block==1))
a0006658:	8e260000 	lw	a2,0(s1)
a000665c:	2402ffff 	li	v0,-1
a0006660:	10c2000d 	beq	a2,v0,a0006698 <rtk_PIO_read_page+0x1d0>
a0006664:	8fa30060 	lw	v1,96(sp)
a0006668:	24020001 	li	v0,1
a000666c:	1462000b 	bne	v1,v0,a000669c <rtk_PIO_read_page+0x1d4>
a0006670:	26100001 	addiu	s0,s0,1
a0006674:	2610ffff 	addiu	s0,s0,-1
        {
            block_indicator=0;                       //bad block
            bad_block_byte_index=i;
                 //dprintf ("\nTotal page size=[0x%x]\n",(page_size + oob_size));
            dprintf ("\nNot equal to 0xffffffff at Byte[%d] , data =0x%x\n",i*4,*(ptr_PIO_READ_NADR+bad_block_byte_index));
a0006678:	3c04a001 	lui	a0,0xa001
a000667c:	24844cb8 	addiu	a0,a0,19640
a0006680:	0c002325 	jal	a0008c94 <dprintf>
a0006684:	00102880 	sll	a1,s0,0x2

            free(ptr_PIO_READ_NADR);
a0006688:	0c001f86 	jal	a0007e18 <free>
a000668c:	03c02021 	move	a0,s8

            return block_indicator;
a0006690:	080019c1 	j	a0006704 <rtk_PIO_read_page+0x23c>
a0006694:	00001021 	move	v0,zero
    check_ready_nand ();

                 /*PIO read step-5.*/
#if 1
                 /*before setting CES0 to 1 (step.6) , user can successively read NADR for the continue next 4 bytes*/
    for (i=0;i<((page_size + oob_size)/4);i++)
a0006698:	26100001 	addiu	s0,s0,1
a000669c:	02009021 	move	s2,s0
a00066a0:	8ea37548 	lw	v1,30024(s5)
a00066a4:	8ec27544 	lw	v0,30020(s6)
a00066a8:	00621021 	addu	v0,v1,v0
a00066ac:	00021082 	srl	v0,v0,0x2
a00066b0:	0202102b 	sltu	v0,s0,v0
a00066b4:	1440ffd9 	bnez	v0,a000661c <rtk_PIO_read_page+0x154>
a00066b8:	26730004 	addiu	s3,s3,4
        }

    }
#endif

    if(enable_show_page_content)
a00066bc:	12e00005 	beqz	s7,a00066d4 <rtk_PIO_read_page+0x20c>
a00066c0:	3c03b801 	lui	v1,0xb801
        dprintf ("\n");
a00066c4:	3c04a001 	lui	a0,0xa001
a00066c8:	0c002325 	jal	a0008c94 <dprintf>
a00066cc:	248457b8 	addiu	a0,a0,22456

                 /*PIO read step-6.*/

    rtk_writel (0x0, NACMR);
a00066d0:	3c03b801 	lui	v1,0xb801
a00066d4:	3462a008 	ori	v0,v1,0xa008
a00066d8:	ac400000 	sw	zero,0(v0)
    rtk_writel (0x0, NAADR);
a00066dc:	3463a00c 	ori	v1,v1,0xa00c
a00066e0:	ac600000 	sw	zero,0(v1)
    rtk_writel ((CECS0 | CMD_RESET), NACMR);         //reset
a00066e4:	3c034000 	lui	v1,0x4000
a00066e8:	346300ff 	ori	v1,v1,0xff
a00066ec:	ac430000 	sw	v1,0(v0)
                 //rtk_nand_read_id () ;
    check_ready_nand ();
a00066f0:	0c000f80 	jal	a0003e00 <check_ready_nand>
a00066f4:	00000000 	nop

                 //dprintf ("page=0x%x\n",page_PIO_num);

                 //dprintf ("ptr_PIO_READ_NADR=0x%x\n",ptr_PIO_READ_NADR);

    free(ptr_PIO_READ_NADR);
a00066f8:	0c001f86 	jal	a0007e18 <free>
a00066fc:	03c02021 	move	a0,s8
a0006700:	24020001 	li	v0,1

    return block_indicator;

}
a0006704:	8fbf0054 	lw	ra,84(sp)
a0006708:	8fbe0050 	lw	s8,80(sp)
a000670c:	8fb7004c 	lw	s7,76(sp)
a0006710:	8fb60048 	lw	s6,72(sp)
a0006714:	8fb50044 	lw	s5,68(sp)
a0006718:	8fb40040 	lw	s4,64(sp)
a000671c:	8fb3003c 	lw	s3,60(sp)
a0006720:	8fb20038 	lw	s2,56(sp)
a0006724:	8fb10034 	lw	s1,52(sp)
a0006728:	8fb00030 	lw	s0,48(sp)
a000672c:	03e00008 	jr	ra
a0006730:	27bd0058 	addiu	sp,sp,88

a0006734 <rtk_nand_probe>:
}

int
rtk_nand_probe(void
)
{
a0006734:	27bdffd8 	addiu	sp,sp,-40
a0006738:	afbf0024 	sw	ra,36(sp)
a000673c:	afb30020 	sw	s3,32(sp)
a0006740:	afb2001c 	sw	s2,28(sp)
a0006744:	afb10018 	sw	s1,24(sp)
a0006748:	afb00014 	sw	s0,20(sp)

rtk_nand_strapin_setting();
a000674c:	0c000fc2 	jal	a0003f08 <rtk_nand_strapin_setting>
a0006750:	00008821 	move	s1,zero
rtk_nand_strapin_setting();
a0006754:	0c000fc2 	jal	a0003f08 <rtk_nand_strapin_setting>
a0006758:	00000000 	nop
rtk_PIO_read_page(0,0,0);
a000675c:	00002021 	move	a0,zero
a0006760:	00002821 	move	a1,zero
a0006764:	0c001932 	jal	a00064c8 <rtk_PIO_read_page>
a0006768:	00003021 	move	a2,zero
rtk_nand_strapin_setting();
a000676c:	0c000fc2 	jal	a0003f08 <rtk_nand_strapin_setting>
a0006770:	00000000 	nop


  int id_chain = rtk_nand_read_id();
a0006774:	0c000f87 	jal	a0003e1c <rtk_nand_read_id>
a0006778:	00000000 	nop
a000677c:	00408021 	move	s0,v0
  }
#endif /*  */

  //int i=0;
  //dprintf("[%s:] %d id_chain = 0x%X\n",__func__,__LINE__,id_chain);
  memset(&nand_info, 0, sizeof(struct device_type));
a0006780:	3c04a002 	lui	a0,0xa002
a0006784:	2484a244 	addiu	a0,a0,-23996
a0006788:	00002821 	move	a1,zero
a000678c:	0c00203d 	jal	a00080f4 <memset>
a0006790:	24060024 	li	a2,36
  unsigned int ui, uiCount;

  //unsigned char pucBuffer[4];
  uiCount = sizeof(nand_device) / sizeof(struct device_type);
  dprintf("\n\nScanning NAND registered database ...  ");
a0006794:	3c04a001 	lui	a0,0xa001
a0006798:	0c002325 	jal	a0008c94 <dprintf>
a000679c:	24844cec 	addiu	a0,a0,19692
  for (ui = 0; ui < uiCount; ui++) {
    //dprintf("\n(Total:%d , Scan = %d)", uiCount, ui + 1);
    if ((nand_device[ui].id) == (id_chain)) {
a00067a0:	3c02a001 	lui	v0,0xa001
a00067a4:	8c520034 	lw	s2,52(v0)
a00067a8:	12500008 	beq	s2,s0,a00067cc <rtk_nand_probe+0x98>
a00067ac:	3c02a001 	lui	v0,0xa001
a00067b0:	24420058 	addiu	v0,v0,88
a00067b4:	24110001 	li	s1,1
#endif /*  */
      break;
    }

    else {
      if ((ui + 1) == uiCount)
a00067b8:	2404000e 	li	a0,14
  unsigned int ui, uiCount;

  //unsigned char pucBuffer[4];
  uiCount = sizeof(nand_device) / sizeof(struct device_type);
  dprintf("\n\nScanning NAND registered database ...  ");
  for (ui = 0; ui < uiCount; ui++) {
a00067bc:	2403000f 	li	v1,15
    //dprintf("\n(Total:%d , Scan = %d)", uiCount, ui + 1);
    if ((nand_device[ui].id) == (id_chain)) {
a00067c0:	8c520000 	lw	s2,0(v0)
a00067c4:	16500043 	bne	s2,s0,a00068d4 <rtk_nand_probe+0x1a0>
a00067c8:	00000000 	nop
           nand_device[ui].name, nand_device[ui].id,
           nand_device[ui].chipsize, nand_device[ui].PageSize,
           nand_device[ui].BlockSize);

#else /*  */
      dprintf("\n=> Found registed NAND Flash, info as below:\n");
a00067cc:	3c04a001 	lui	a0,0xa001
a00067d0:	0c002325 	jal	a0008c94 <dprintf>
a00067d4:	24844d18 	addiu	a0,a0,19736
      dprintf("1.Chip_name= %s\n", nand_device[ui].name);
a00067d8:	00118080 	sll	s0,s1,0x2
a00067dc:	00111140 	sll	v0,s1,0x5
a00067e0:	02028021 	addu	s0,s0,v0
a00067e4:	3c02a001 	lui	v0,0xa001
a00067e8:	24420030 	addiu	v0,v0,48
a00067ec:	02028021 	addu	s0,s0,v0
a00067f0:	3c04a001 	lui	a0,0xa001
a00067f4:	24844d48 	addiu	a0,a0,19784
a00067f8:	0c002325 	jal	a0008c94 <dprintf>
a00067fc:	8e050000 	lw	a1,0(s0)
      dprintf("2.ID= 0x%x\n", nand_device[ui].id);
a0006800:	3c04a001 	lui	a0,0xa001
a0006804:	24844d5c 	addiu	a0,a0,19804
a0006808:	0c002325 	jal	a0008c94 <dprintf>
a000680c:	02402821 	move	a1,s2
      dprintf("3.Chip_size= %d MB\n", nand_device[ui].size);
a0006810:	3c04a001 	lui	a0,0xa001
a0006814:	24844d68 	addiu	a0,a0,19816
a0006818:	0c002325 	jal	a0008c94 <dprintf>
a000681c:	8e050008 	lw	a1,8(s0)
      dprintf("4.Block_cnt= %d \n", nand_device[ui].BlockCnt);
a0006820:	3c04a001 	lui	a0,0xa001
a0006824:	24844d7c 	addiu	a0,a0,19836
a0006828:	0c002325 	jal	a0008c94 <dprintf>
a000682c:	8e050014 	lw	a1,20(s0)
      dprintf("5.Block_size= %d KB\n", nand_device[ui].BlockSize / 0x400);
a0006830:	8e120018 	lw	s2,24(s0)
a0006834:	3c04a001 	lui	a0,0xa001
a0006838:	24844d90 	addiu	a0,a0,19856
a000683c:	0c002325 	jal	a0008c94 <dprintf>
a0006840:	00122a82 	srl	a1,s2,0xa
      dprintf("6.Page_size= %d Bytes\n", nand_device[ui].PageSize);
a0006844:	96130010 	lhu	s3,16(s0)
a0006848:	3c04a001 	lui	a0,0xa001
a000684c:	24844da8 	addiu	a0,a0,19880
a0006850:	0c002325 	jal	a0008c94 <dprintf>
a0006854:	02602821 	move	a1,s3
      dprintf("7.OobSize= %d KB\n", nand_device[ui].OobSize);
a0006858:	3c04a001 	lui	a0,0xa001
a000685c:	24844dc0 	addiu	a0,a0,19904
a0006860:	0c002325 	jal	a0008c94 <dprintf>
a0006864:	9605001c 	lhu	a1,28(s0)

	  /*debug cl add from patch, global va init*/
	  nand_select=ui;
a0006868:	3c02a001 	lui	v0,0xa001
a000686c:	ac517520 	sw	s1,29984(v0)
	  block_size= nand_device[ui].BlockSize;
a0006870:	3c02a001 	lui	v0,0xa001
a0006874:	ac527524 	sw	s2,29988(v0)
	  chip_size=nand_device[ui].chipsize;
a0006878:	8e11000c 	lw	s1,12(s0)
a000687c:	3c02a002 	lui	v0,0xa002
a0006880:	ac518880 	sw	s1,-30592(v0)
	  block_shift = shift_value(nand_device[ui].BlockSize) -1 ;
a0006884:	0c000fa7 	jal	a0003e9c <shift_value>
a0006888:	02402021 	move	a0,s2
a000688c:	2442ffff 	addiu	v0,v0,-1
a0006890:	3c03a002 	lui	v1,0xa002
a0006894:	ac628870 	sw	v0,-30608(v1)
	  page_shift = shift_value(nand_device[ui].PageSize) -1;
a0006898:	0c000fa7 	jal	a0003e9c <shift_value>
a000689c:	02602021 	move	a0,s3
a00068a0:	2442ffff 	addiu	v0,v0,-1
a00068a4:	3c03a002 	lui	v1,0xa002
a00068a8:	ac628878 	sw	v0,-30600(v1)
	  isLastPage = nand_device[ui].isLastPage;
a00068ac:	9203001f 	lbu	v1,31(s0)
a00068b0:	3c02a002 	lui	v0,0xa002
a00068b4:	ac43887c 	sw	v1,-30596(v0)
	  pagemask = (nand_device[ui].chipsize/nand_device[ui].PageSize) -1;
a00068b8:	0233001b 	divu	zero,s1,s3
a00068bc:	026001f4 	teq	s3,zero,0x7
a00068c0:	00008812 	mflo	s1
a00068c4:	2631ffff 	addiu	s1,s1,-1
a00068c8:	3c02a002 	lui	v0,0xa002
#endif /*  */
      break;
a00068cc:	08001a3f 	j	a00068fc <rtk_nand_probe+0x1c8>
a00068d0:	ac518874 	sw	s1,-30604(v0)
    }

    else {
      if ((ui + 1) == uiCount)
a00068d4:	16240007 	bne	s1,a0,a00068f4 <rtk_nand_probe+0x1c0>
a00068d8:	26310001 	addiu	s1,s1,1
a00068dc:	2631ffff 	addiu	s1,s1,-1
	  {
        dprintf("\nNo registered NAND Flash found!\n");
a00068e0:	3c04a001 	lui	a0,0xa001
a00068e4:	0c002325 	jal	a0008c94 <dprintf>
a00068e8:	24844dd4 	addiu	a0,a0,19924
a00068ec:	08001a3b 	j	a00068ec <rtk_nand_probe+0x1b8>
a00068f0:	00000000 	nop
  unsigned int ui, uiCount;

  //unsigned char pucBuffer[4];
  uiCount = sizeof(nand_device) / sizeof(struct device_type);
  dprintf("\n\nScanning NAND registered database ...  ");
  for (ui = 0; ui < uiCount; ui++) {
a00068f4:	1623ffb2 	bne	s1,v1,a00067c0 <rtk_nand_probe+0x8c>
a00068f8:	24420024 	addiu	v0,v0,36

 //JSW 20140227:Aggressive parameter (based on K9F2G08R0A and LX 200MHZ=5ns)
  //rtk_writel(ECC_enable | CE_TWP(5) | CE_TWH(5) | CE_TRR(5) | CE_TH(7) | CE_TS(5), NACR);//less error
  //rtk_writel(ECC_enable | CE_TWP(15) | CE_TWH(15) | CE_TRR(15) | CE_TH(15) | CE_TS(1), NACR); //more error
  //rtk_writel(ECC_enable | CE_TWP(3) | CE_TWH(3) | CE_TRR(3) | CE_TH(3) | CE_TS(3), NACR);//more error
   rtk_writel(ECC_enable | CE_TWP(4) | CE_TWH(4) | CE_TRR(5) | CE_TH(5) | CE_TS(3), NACR);//Aggressive parameter
a00068fc:	3c02b801 	lui	v0,0xb801
a0006900:	3443a004 	ori	v1,v0,0xa004
a0006904:	3c044004 	lui	a0,0x4004
a0006908:	34844553 	ori	a0,a0,0x4553
a000690c:	ac640000 	sw	a0,0(v1)
//  dprintf("\n========================================= \n");
//   dprintf("\nhw_srtap=0x%X\n",rtk_readl(0xb8000008));
   //debug cl
//   dprintf("\nNASR=0x%X\n",rtk_readl(NASR)); //should be clear ? to check
   //debug cl
  rtk_writel(0x0000000f, NASR); //clear NAND flash status register
a0006910:	3442a028 	ori	v0,v0,0xa028
a0006914:	2403000f 	li	v1,15
a0006918:	ac430000 	sw	v1,0(v0)
    REG32(0xa0601fc4) = 0x3c1bb800;     //j=2033


  }
#endif /*  */
}
a000691c:	8fbf0024 	lw	ra,36(sp)
a0006920:	8fb30020 	lw	s3,32(sp)
a0006924:	8fb2001c 	lw	s2,28(sp)
a0006928:	8fb10018 	lw	s1,24(sp)
a000692c:	8fb00014 	lw	s0,20(sp)
a0006930:	03e00008 	jr	ra
a0006934:	27bd0028 	addiu	sp,sp,40

a0006938 <nand_write_ecc_ob>:
	//printf("out rx:%x\r\n",rc);
	return rc;

}
int nand_write_ecc_ob (unsigned int to, unsigned int len, unsigned char *data_buf, unsigned char *oob_buf)
{
a0006938:	27bdff88 	addiu	sp,sp,-120
a000693c:	afbf0074 	sw	ra,116(sp)
a0006940:	afbe0070 	sw	s8,112(sp)
a0006944:	afb7006c 	sw	s7,108(sp)
a0006948:	afb60068 	sw	s6,104(sp)
a000694c:	afb50064 	sw	s5,100(sp)
a0006950:	afb40060 	sw	s4,96(sp)
a0006954:	afb3005c 	sw	s3,92(sp)
a0006958:	afb20058 	sw	s2,88(sp)
a000695c:	afb10054 	sw	s1,84(sp)
a0006960:	afb00050 	sw	s0,80(sp)
a0006964:	afa5007c 	sw	a1,124(sp)
a0006968:	afa60080 	sw	a2,128(sp)
a000696c:	afa70084 	sw	a3,132(sp)
	unsigned int rsv_block = 0;

	//printf("%s-%d: to %d, len %d oob:%x\n\r",__FUNCTION__,__LINE__,to,len,oob_buf);
{
        unsigned int offset=0, aa=0;
		i = (to >> block_shift);//virtual block index
a0006970:	3c02a002 	lui	v0,0xa002
a0006974:	8c428870 	lw	v0,-30608(v0)
        aa = to & ~(block_size - 1);
a0006978:	3c03a001 	lui	v1,0xa001
a000697c:	8c637524 	lw	v1,29988(v1)
a0006980:	00031823 	negu	v1,v1
a0006984:	00641824 	and	v1,v1,a0
        offset = to - aa;		
a0006988:	00442806 	srlv	a1,a0,v0
a000698c:	3c06a001 	lui	a2,0xa001
a0006990:	8cc6796c 	lw	a2,31084(a2)
a0006994:	00052880 	sll	a1,a1,0x2
a0006998:	00c52821 	addu	a1,a2,a1
a000699c:	8ca50000 	lw	a1,0(a1)
a00069a0:	00451004 	sllv	v0,a1,v0
a00069a4:	00822021 	addu	a0,a0,v0
		to = (bbt_v2r[i].block_r << block_shift) + offset;//real block index, addr.
a00069a8:	00832823 	subu	a1,a0,v1
		//printf("%s: blockr:%x to:%x offset %x\n\r",__FUNCTION__,bbt_v2r[i].block_r, to, offset);
}

	if ((to + len) > chip_size) {
a00069ac:	8fa2007c 	lw	v0,124(sp)
a00069b0:	00a21821 	addu	v1,a1,v0
a00069b4:	3c02a002 	lui	v0,0xa002
a00069b8:	8c428880 	lw	v0,-30592(v0)
a00069bc:	0043102b 	sltu	v0,v0,v1
a00069c0:	10400005 	beqz	v0,a00069d8 <nand_write_ecc_ob+0xa0>
a00069c4:	3c04a001 	lui	a0,0xa001
		printf("nand_write_ecc: Attempt write beyond end of device\n\r");
a00069c8:	0c002325 	jal	a0008c94 <dprintf>
a00069cc:	24844df8 	addiu	a0,a0,19960
		return FAIL;
a00069d0:	08001bd7 	j	a0006f5c <nand_write_ecc_ob+0x624>
a00069d4:	2402ffff 	li	v0,-1
	}

	if ((to & (page_size-1)) ||(len & (page_size-1))) {
a00069d8:	8fa4007c 	lw	a0,124(sp)
a00069dc:	00a41825 	or	v1,a1,a0
a00069e0:	3c02a001 	lui	v0,0xa001
a00069e4:	8c427544 	lw	v0,30020(v0)
a00069e8:	2442ffff 	addiu	v0,v0,-1
a00069ec:	00621024 	and	v0,v1,v0
a00069f0:	10400007 	beqz	v0,a0006a10 <nand_write_ecc_ob+0xd8>
a00069f4:	3c03a001 	lui	v1,0xa001
		printf("nand_write_ecc: Attempt to write not page aligned data, to = 0x%08X, len = %d\n",to,len);
a00069f8:	3c04a001 	lui	a0,0xa001
a00069fc:	24844e30 	addiu	a0,a0,20016
a0006a00:	0c002325 	jal	a0008c94 <dprintf>
a0006a04:	8fa6007c 	lw	a2,124(sp)
		return FAIL;
a0006a08:	08001bd7 	j	a0006f5c <nand_write_ecc_ob+0x624>
a0006a0c:	2402ffff 	li	v0,-1
	}

	realpage = (int)(to >> page_shift);
	chipnr = chipnr_remap = 0;
	old_page = page = realpage & pagemask;
a0006a10:	3c02a002 	lui	v0,0xa002
a0006a14:	8c548878 	lw	s4,-30600(v0)
a0006a18:	02852806 	srlv	a1,a1,s4
a0006a1c:	3c02a002 	lui	v0,0xa002
a0006a20:	8c428874 	lw	v0,-30604(v0)
a0006a24:	00a2a024 	and	s4,a1,v0
	page_offset = page & (ppb-1);
a0006a28:	3c02a001 	lui	v0,0xa001
a0006a2c:	8c42754c 	lw	v0,30028(v0)
	block = page/ppb;
a0006a30:	0282001b 	divu	zero,s4,v0
a0006a34:	004001f4 	teq	v0,zero,0x7
a0006a38:	00008012 	mflo	s0
//ccwei 111116
//	rsv_block = RESERVED_AREA/block_size;


	
	if ( numchips == 1 && block != write_block ){
a0006a3c:	8c637534 	lw	v1,30004(v1)
a0006a40:	12030007 	beq	s0,v1,a0006a60 <nand_write_ecc_ob+0x128>
a0006a44:	3c03a001 	lui	v1,0xa001
		//printf("@@@\r\n");
		write_block = block;
a0006a48:	ac707534 	sw	s0,30004(v1)
		write_remap_block = 0xFFFFFFFF;
a0006a4c:	2404ffff 	li	a0,-1
a0006a50:	3c03a001 	lui	v1,0xa001
a0006a54:	ac647538 	sw	a0,30008(v1)
		write_has_check_bbt = 0;
a0006a58:	3c03a002 	lui	v1,0xa002
a0006a5c:	ac60888c 	sw	zero,-30580(v1)
	}
	
	data_len = oob_len = 0;

	//dprintf("----------page: %x-->%x\r\n",page,&data_buf[data_len]);
	while ( data_len < len) {
a0006a60:	8fa3007c 	lw	v1,124(sp)
a0006a64:	1060013c 	beqz	v1,a0006f58 <nand_write_ecc_ob+0x620>
a0006a68:	02809821 	move	s3,s4
	}

	realpage = (int)(to >> page_shift);
	chipnr = chipnr_remap = 0;
	old_page = page = realpage & pagemask;
	page_offset = page & (ppb-1);
a0006a6c:	2442ffff 	addiu	v0,v0,-1
a0006a70:	02821024 	and	v0,s4,v0
	block = page/ppb;
a0006a74:	0000a821 	move	s5,zero
a0006a78:	0000b021 	move	s6,zero
a0006a7c:	0000b821 	move	s7,zero
			//printf("[%s] wirte page %x, len %x, data_buf = 0x%p\n\r",__func__, realpage, len , data_buf);
			goto SKIP_BBT_CHECK;
		}
*/		
		if (numchips == 1){
			if ( (page>=block*ppb) && (page<(block+1)*ppb) && write_has_check_bbt==1 )
a0006a80:	3c11a001 	lui	s1,0xa001
						write_remap_block = block = bbt[i].remap_block;
				}
			}else
				break;
		}
		write_has_check_bbt = 1;
a0006a84:	24040001 	li	a0,1
a0006a88:	afa4001c 	sw	a0,28(sp)
		}

		for ( i=0; i<RBA; i++){
			if ( bbt[i].bad_block != BB_INIT ){
				if ( block == bbt[i].bad_block ){
						write_remap_block = block = bbt[i].remap_block;
a0006a8c:	3c1ea001 	lui	s8,0xa001

		//if( (page % ppb) == 0) printf(".");
		//printf("page: %x-->%x\r\n",page,&data_buf[data_len]);

		//dprintf("page: %x-->%x\r\n",page,&data_buf[data_len]);
		rc = rtk_write_ecc_page_a ( page, &data_buf[data_len], &oob_buf[oob_len], page_size);
a0006a90:	3c12a001 	lui	s2,0xa001
				printf("[%s] wirte page %x, len %x, data_buf = 0x%p\n\r",__func__, realpage, len , data_buf);
				return -1;		
			}
*/			
			if(rc == -1){
				printf ("%s: write_ecc_page:  write failed\n\r", __FUNCTION__);
a0006a94:	3c03a001 	lui	v1,0xa001
a0006a98:	24634e80 	addiu	v1,v1,20096
a0006a9c:	afa30030 	sw	v1,48(sp)
a0006aa0:	3c03a001 	lui	v1,0xa001
a0006aa4:	24630380 	addiu	v1,v1,896
a0006aa8:	afa30034 	sw	v1,52(sp)
				rtk_write_ecc_page_a ( block_remap*ppb+backup_offset, &data_buf[data_len], &oob_buf[oob_len], page_size);
				//printf("[%s] write failure page = %d to %d\n", __FUNCTION__, page, block_remap*ppb+backup_offset);

				if(!NAND_ADDR_CYCLE)
				#ifdef SWAP_2K_DATA
					NfSpareBuf[BBI_SWAP_OFFSET] = 0x00;
a0006aac:	3c03a002 	lui	v1,0xa002
a0006ab0:	2463a268 	addiu	v1,v1,-23960
a0006ab4:	afa30020 	sw	v1,32(sp)
				backup_offset = page&(ppb-1);
				rtk_erase_block_a(block_remap*ppb);
				//printf("[%s] Start to Backup old_page from %d to %d\n\r", __FUNCTION__, block*ppb, block*ppb+backup_offset-1);

				for ( i=0; i<backup_offset; i++){
					rtk_read_ecc_page_a(block*ppb+i ,&NfDataBuf ,&NfSpareBuf ,page_size);
a0006ab8:	3c03a002 	lui	v1,0xa002
a0006abc:	24639a04 	addiu	v1,v1,-26108
a0006ac0:	afa30038 	sw	v1,56(sp)
			//printf("[%s] wirte page %x, len %x, data_buf = 0x%p\n\r",__func__, realpage, len , data_buf);
			goto SKIP_BBT_CHECK;
		}
*/		
		if (numchips == 1){
			if ( (page>=block*ppb) && (page<(block+1)*ppb) && write_has_check_bbt==1 )
a0006ac4:	8e23754c 	lw	v1,30028(s1)
a0006ac8:	72032002 	mul	a0,s0,v1
a0006acc:	0284202b 	sltu	a0,s4,a0
a0006ad0:	14800005 	bnez	a0,a0006ae8 <nand_write_ecc_ob+0x1b0>
a0006ad4:	26040001 	addiu	a0,s0,1
a0006ad8:	70831802 	mul	v1,a0,v1
a0006adc:	0283a02b 	sltu	s4,s4,v1
a0006ae0:	1680000d 	bnez	s4,a0006b18 <nand_write_ecc_ob+0x1e0>
a0006ae4:	3c05a002 	lui	a1,0xa002
				goto SKIP_BBT_CHECK;
		}

		for ( i=0; i<RBA; i++){
a0006ae8:	3c03a001 	lui	v1,0xa001
a0006aec:	8c677970 	lw	a3,31088(v1)
a0006af0:	10e0001a 	beqz	a3,a0006b5c <nand_write_ecc_ob+0x224>
a0006af4:	3c04a001 	lui	a0,0xa001
			if ( bbt[i].bad_block != BB_INIT ){
a0006af8:	8c867974 	lw	a2,31092(a0)
a0006afc:	94c40002 	lhu	a0,2(a2)
a0006b00:	3403fffe 	li	v1,0xfffe
a0006b04:	10830015 	beq	a0,v1,a0006b5c <nand_write_ecc_ob+0x224>
a0006b08:	24c30008 	addiu	v1,a2,8
a0006b0c:	00002821 	move	a1,zero
a0006b10:	08001acf 	j	a0006b3c <nand_write_ecc_ob+0x204>
a0006b14:	3408fffe 	li	t0,0xfffe
			//printf("[%s] wirte page %x, len %x, data_buf = 0x%p\n\r",__func__, realpage, len , data_buf);
			goto SKIP_BBT_CHECK;
		}
*/		
		if (numchips == 1){
			if ( (page>=block*ppb) && (page<(block+1)*ppb) && write_has_check_bbt==1 )
a0006b18:	8ca3888c 	lw	v1,-30580(a1)
a0006b1c:	24040001 	li	a0,1
a0006b20:	1464fff2 	bne	v1,a0,a0006aec <nand_write_ecc_ob+0x1b4>
a0006b24:	3c03a001 	lui	v1,0xa001
				break;
		}
		write_has_check_bbt = 1;
SKIP_BBT_CHECK:
		if ( numchips == 1 && write_has_check_bbt==1 ){
				if ( write_remap_block == 0xFFFFFFFF )
a0006b28:	08001adb 	j	a0006b6c <nand_write_ecc_ob+0x234>
a0006b2c:	8fd47538 	lw	s4,30008(s8)
			if ( (page>=block*ppb) && (page<(block+1)*ppb) && write_has_check_bbt==1 )
				goto SKIP_BBT_CHECK;
		}

		for ( i=0; i<RBA; i++){
			if ( bbt[i].bad_block != BB_INIT ){
a0006b30:	94640002 	lhu	a0,2(v1)
a0006b34:	10880009 	beq	a0,t0,a0006b5c <nand_write_ecc_ob+0x224>
a0006b38:	24630008 	addiu	v1,v1,8
				if ( block == bbt[i].bad_block ){
a0006b3c:	14900003 	bne	a0,s0,a0006b4c <nand_write_ecc_ob+0x214>
a0006b40:	00000000 	nop
						write_remap_block = block = bbt[i].remap_block;
a0006b44:	94d00006 	lhu	s0,6(a2)
a0006b48:	afd07538 	sw	s0,30008(s8)
		if (numchips == 1){
			if ( (page>=block*ppb) && (page<(block+1)*ppb) && write_has_check_bbt==1 )
				goto SKIP_BBT_CHECK;
		}

		for ( i=0; i<RBA; i++){
a0006b4c:	24a50001 	addiu	a1,a1,1
a0006b50:	00a7202b 	sltu	a0,a1,a3
a0006b54:	1480fff6 	bnez	a0,a0006b30 <nand_write_ecc_ob+0x1f8>
a0006b58:	00603021 	move	a2,v1
						write_remap_block = block = bbt[i].remap_block;
				}
			}else
				break;
		}
		write_has_check_bbt = 1;
a0006b5c:	8fa3001c 	lw	v1,28(sp)
a0006b60:	3c05a002 	lui	a1,0xa002
a0006b64:	aca3888c 	sw	v1,-30580(a1)
SKIP_BBT_CHECK:
		if ( numchips == 1 && write_has_check_bbt==1 ){
				if ( write_remap_block == 0xFFFFFFFF )
a0006b68:	8fd47538 	lw	s4,30008(s8)
a0006b6c:	2403ffff 	li	v1,-1
a0006b70:	16830005 	bne	s4,v1,a0006b88 <nand_write_ecc_ob+0x250>
a0006b74:	8e23754c 	lw	v1,30028(s1)
					page = block*ppb + page_offset;
a0006b78:	8e34754c 	lw	s4,30028(s1)
a0006b7c:	72141802 	mul	v1,s0,s4
a0006b80:	08001ae4 	j	a0006b90 <nand_write_ecc_ob+0x258>
a0006b84:	0062a021 	addu	s4,v1,v0
				else	
					page = write_remap_block*ppb + page_offset;
a0006b88:	72832002 	mul	a0,s4,v1
a0006b8c:	0082a021 	addu	s4,a0,v0

		//if( (page % ppb) == 0) printf(".");
		//printf("page: %x-->%x\r\n",page,&data_buf[data_len]);

		//dprintf("page: %x-->%x\r\n",page,&data_buf[data_len]);
		rc = rtk_write_ecc_page_a ( page, &data_buf[data_len], &oob_buf[oob_len], page_size);
a0006b90:	8fa50080 	lw	a1,128(sp)
a0006b94:	00b52821 	addu	a1,a1,s5
a0006b98:	afa50014 	sw	a1,20(sp)
a0006b9c:	afb60018 	sw	s6,24(sp)
a0006ba0:	8fa20084 	lw	v0,132(sp)
a0006ba4:	00561021 	addu	v0,v0,s6
a0006ba8:	afa20010 	sw	v0,16(sp)
a0006bac:	02802021 	move	a0,s4
a0006bb0:	00403021 	move	a2,v0
a0006bb4:	0c0011da 	jal	a0004768 <rtk_write_ecc_page_a>
a0006bb8:	8e477544 	lw	a3,30020(s2)

		if(rc<0){
a0006bbc:	044100cb 	bgez	v0,a0006eec <nand_write_ecc_ob+0x5b4>
a0006bc0:	8fa30080 	lw	v1,128(sp)
			if(block<(rsv_block-2)){
				printf("[%s] wirte page %x, len %x, data_buf = 0x%p\n\r",__func__, realpage, len , data_buf);
				return -1;		
			}
*/			
			if(rc == -1){
a0006bc4:	2403ffff 	li	v1,-1
a0006bc8:	144300e1 	bne	v0,v1,a0006f50 <nand_write_ecc_ob+0x618>
a0006bcc:	8fa40030 	lw	a0,48(sp)
				printf ("%s: write_ecc_page:  write failed\n\r", __FUNCTION__);
a0006bd0:	0c002325 	jal	a0008c94 <dprintf>
a0006bd4:	8fa50034 	lw	a1,52(sp)
				int block_remap = 0x12345678;
				/* update BBT */
			    if(check_BBT(page/ppb)==0)
a0006bd8:	8e22754c 	lw	v0,30028(s1)
a0006bdc:	0282001b 	divu	zero,s4,v0
a0006be0:	004001f4 	teq	v0,zero,0x7
a0006be4:	0c0010b8 	jal	a00042e0 <check_BBT>
a0006be8:	00002012 	mflo	a0
a0006bec:	14400037 	bnez	v0,a0006ccc <nand_write_ecc_ob+0x394>
a0006bf0:	3c02a001 	lui	v0,0xa001
			    {				
				    for( i=0; i<RBA; i++){
a0006bf4:	8c457970 	lw	a1,31088(v0)
a0006bf8:	10a00012 	beqz	a1,a0006c44 <nand_write_ecc_ob+0x30c>
a0006bfc:	3c03a001 	lui	v1,0xa001
					    if ( bbt[i].bad_block == BB_INIT && bbt[i].remap_block != RB_INIT){
a0006c00:	8c677974 	lw	a3,31092(v1)
a0006c04:	00001021 	move	v0,zero
a0006c08:	00001821 	move	v1,zero
a0006c0c:	3406fffe 	li	a2,0xfffe
a0006c10:	3408fffd 	li	t0,0xfffd
a0006c14:	000210c0 	sll	v0,v0,0x3
a0006c18:	00e22021 	addu	a0,a3,v0
a0006c1c:	94890002 	lhu	t1,2(a0)
a0006c20:	15260004 	bne	t1,a2,a0006c34 <nand_write_ecc_ob+0x2fc>
a0006c24:	00000000 	nop
a0006c28:	94890006 	lhu	t1,6(a0)
a0006c2c:	1528000c 	bne	t1,t0,a0006c60 <nand_write_ecc_ob+0x328>
a0006c30:	00000000 	nop
				printf ("%s: write_ecc_page:  write failed\n\r", __FUNCTION__);
				int block_remap = 0x12345678;
				/* update BBT */
			    if(check_BBT(page/ppb)==0)
			    {				
				    for( i=0; i<RBA; i++){
a0006c34:	24630001 	addiu	v1,v1,1
a0006c38:	0065202b 	sltu	a0,v1,a1
a0006c3c:	1480fff5 	bnez	a0,a0006c14 <nand_write_ecc_ob+0x2dc>
a0006c40:	00601021 	move	v0,v1
						    break;
					    }
				    }

				if ( block_remap == 0x12345678 ){
					printf("[%s] RBA do not have free remap block\n\r", __FUNCTION__);
a0006c44:	3c04a001 	lui	a0,0xa001
a0006c48:	24844ea4 	addiu	a0,a0,20132
a0006c4c:	3c05a001 	lui	a1,0xa001
a0006c50:	0c002325 	jal	a0008c94 <dprintf>
a0006c54:	24a50380 	addiu	a1,a1,896
					return FAIL;
a0006c58:	08001bd7 	j	a0006f5c <nand_write_ecc_ob+0x624>
a0006c5c:	2402ffff 	li	v0,-1
			    if(check_BBT(page/ppb)==0)
			    {				
				    for( i=0; i<RBA; i++){
					    if ( bbt[i].bad_block == BB_INIT && bbt[i].remap_block != RB_INIT){
						    err_chipnr = chipnr;
						    bbt[i].BB_die = err_chipnr;
a0006c60:	a4800000 	sh	zero,0(a0)
						    bbt[i].bad_block = page/ppb;
a0006c64:	3c04a001 	lui	a0,0xa001
a0006c68:	8c837974 	lw	v1,31092(a0)
a0006c6c:	00621821 	addu	v1,v1,v0
a0006c70:	8e24754c 	lw	a0,30028(s1)
a0006c74:	0284001b 	divu	zero,s4,a0
a0006c78:	008001f4 	teq	a0,zero,0x7
a0006c7c:	00002812 	mflo	a1
a0006c80:	a4650002 	sh	a1,2(v1)
						    err_chipnr_remap = bbt[i].RB_die;
						    block_remap = bbt[i].remap_block;
a0006c84:	3c04a001 	lui	a0,0xa001
a0006c88:	8c837974 	lw	v1,31092(a0)
a0006c8c:	00621021 	addu	v0,v1,v0
a0006c90:	94420006 	lhu	v0,6(v0)
				if ( block_remap == 0x12345678 ){
					printf("[%s] RBA do not have free remap block\n\r", __FUNCTION__);
					return FAIL;
				}
			
				dump_BBT();
a0006c94:	0c001392 	jal	a0004e48 <dump_BBT>
a0006c98:	afa20024 	sw	v0,36(sp)

				    if ( rtk_update_bbt(bbt)){
a0006c9c:	3c05a001 	lui	a1,0xa001
a0006ca0:	0c00154d 	jal	a0005534 <rtk_update_bbt>
a0006ca4:	8ca47974 	lw	a0,31092(a1)
a0006ca8:	1040000c 	beqz	v0,a0006cdc <nand_write_ecc_ob+0x3a4>
a0006cac:	8e24754c 	lw	a0,30028(s1)
					    printf("[%s] rtk_update_bbt() fails\n", __FUNCTION__);
a0006cb0:	3c04a001 	lui	a0,0xa001
a0006cb4:	24844ecc 	addiu	a0,a0,20172
a0006cb8:	3c05a001 	lui	a1,0xa001
a0006cbc:	0c002325 	jal	a0008c94 <dprintf>
a0006cc0:	24a50380 	addiu	a1,a1,896
					    return FAIL;
a0006cc4:	08001bd7 	j	a0006f5c <nand_write_ecc_ob+0x624>
a0006cc8:	2402ffff 	li	v0,-1
a0006ccc:	3c021234 	lui	v0,0x1234
a0006cd0:	34425678 	ori	v0,v0,0x5678
a0006cd4:	afa20024 	sw	v0,36(sp)
				    }
			    }

				backup_offset = page&(ppb-1);
a0006cd8:	8e24754c 	lw	a0,30028(s1)
a0006cdc:	2482ffff 	addiu	v0,a0,-1
a0006ce0:	02821024 	and	v0,s4,v0
a0006ce4:	afa20028 	sw	v0,40(sp)
a0006ce8:	afa2002c 	sw	v0,44(sp)
				rtk_erase_block_a(block_remap*ppb);
a0006cec:	8fa20024 	lw	v0,36(sp)
a0006cf0:	0c001048 	jal	a0004120 <rtk_erase_block_a>
a0006cf4:	70442002 	mul	a0,v0,a0
				//printf("[%s] Start to Backup old_page from %d to %d\n\r", __FUNCTION__, block*ppb, block*ppb+backup_offset-1);

				for ( i=0; i<backup_offset; i++){
a0006cf8:	8fa20028 	lw	v0,40(sp)
a0006cfc:	18400026 	blez	v0,a0006d98 <nand_write_ecc_ob+0x460>
a0006d00:	8e24754c 	lw	a0,30028(s1)
a0006d04:	afa0003c 	sw	zero,60(sp)
					if ( NfSpareBuf )
						reverse_to_Yaffs2Tags(&NfSpareBuf); //czyao
#endif
					if(!NAND_ADDR_CYCLE)
					#ifdef SWAP_2K_DATA
						NfSpareBuf[BBI_SWAP_OFFSET] = 0xff;
a0006d08:	afb30040 	sw	s3,64(sp)
a0006d0c:	afb60044 	sw	s6,68(sp)
a0006d10:	afb70048 	sw	s7,72(sp)
a0006d14:	8fb7002c 	lw	s7,44(sp)
a0006d18:	afb4002c 	sw	s4,44(sp)
a0006d1c:	afb5004c 	sw	s5,76(sp)
a0006d20:	0200a821 	move	s5,s0
a0006d24:	00008021 	move	s0,zero
a0006d28:	8fb60024 	lw	s6,36(sp)
a0006d2c:	8fb30020 	lw	s3,32(sp)
a0006d30:	8fb40038 	lw	s4,56(sp)
				backup_offset = page&(ppb-1);
				rtk_erase_block_a(block_remap*ppb);
				//printf("[%s] Start to Backup old_page from %d to %d\n\r", __FUNCTION__, block*ppb, block*ppb+backup_offset-1);

				for ( i=0; i<backup_offset; i++){
					rtk_read_ecc_page_a(block*ppb+i ,&NfDataBuf ,&NfSpareBuf ,page_size);
a0006d34:	8e24754c 	lw	a0,30028(s1)
a0006d38:	72a41002 	mul	v0,s5,a0
a0006d3c:	00502021 	addu	a0,v0,s0
a0006d40:	02802821 	move	a1,s4
a0006d44:	02603021 	move	a2,s3
a0006d48:	0c0012a2 	jal	a0004a88 <rtk_read_ecc_page_a>
a0006d4c:	8e477544 	lw	a3,30020(s2)
					if ( NfSpareBuf )
						reverse_to_Yaffs2Tags(&NfSpareBuf); //czyao
#endif
					if(!NAND_ADDR_CYCLE)
					#ifdef SWAP_2K_DATA
						NfSpareBuf[BBI_SWAP_OFFSET] = 0xff;
a0006d50:	2403ffff 	li	v1,-1
a0006d54:	a2630035 	sb	v1,53(s3)
					#else
						NfSpareBuf[0] = 0xff;
					#endif
					else
						NfSpareBuf[5] = 0xff;
					rtk_write_ecc_page_a(block_remap*ppb+i ,&NfDataBuf ,&NfSpareBuf ,page_size);
a0006d58:	8e24754c 	lw	a0,30028(s1)
a0006d5c:	72c41002 	mul	v0,s6,a0
a0006d60:	00502021 	addu	a0,v0,s0
a0006d64:	02802821 	move	a1,s4
a0006d68:	02603021 	move	a2,s3
a0006d6c:	0c0011da 	jal	a0004768 <rtk_write_ecc_page_a>
a0006d70:	8e477544 	lw	a3,30020(s2)

				backup_offset = page&(ppb-1);
				rtk_erase_block_a(block_remap*ppb);
				//printf("[%s] Start to Backup old_page from %d to %d\n\r", __FUNCTION__, block*ppb, block*ppb+backup_offset-1);

				for ( i=0; i<backup_offset; i++){
a0006d74:	26100001 	addiu	s0,s0,1
a0006d78:	0217102a 	slt	v0,s0,s7
a0006d7c:	1440ffee 	bnez	v0,a0006d38 <nand_write_ecc_ob+0x400>
a0006d80:	8e24754c 	lw	a0,30028(s1)
a0006d84:	8fb30040 	lw	s3,64(sp)
a0006d88:	8fb60044 	lw	s6,68(sp)
a0006d8c:	8fb70048 	lw	s7,72(sp)
a0006d90:	8fb4002c 	lw	s4,44(sp)
a0006d94:	8fb5004c 	lw	s5,76(sp)
					else
						NfSpareBuf[5] = 0xff;
					rtk_write_ecc_page_a(block_remap*ppb+i ,&NfDataBuf ,&NfSpareBuf ,page_size);
				}
				//Write the written failed page to new block
				rtk_write_ecc_page_a ( block_remap*ppb+backup_offset, &data_buf[data_len], &oob_buf[oob_len], page_size);
a0006d98:	8fa20024 	lw	v0,36(sp)
a0006d9c:	8fa30028 	lw	v1,40(sp)
a0006da0:	70442802 	mul	a1,v0,a0
a0006da4:	00a32021 	addu	a0,a1,v1
a0006da8:	8fa50014 	lw	a1,20(sp)
a0006dac:	8fa60010 	lw	a2,16(sp)
a0006db0:	0c0011da 	jal	a0004768 <rtk_write_ecc_page_a>
a0006db4:	8e477544 	lw	a3,30020(s2)
				//printf("[%s] write failure page = %d to %d\n", __FUNCTION__, page, block_remap*ppb+backup_offset);

				if(!NAND_ADDR_CYCLE)
				#ifdef SWAP_2K_DATA
					NfSpareBuf[BBI_SWAP_OFFSET] = 0x00;
a0006db8:	8fa20020 	lw	v0,32(sp)
a0006dbc:	a0400035 	sb	zero,53(v0)
					NfSpareBuf[0] = 0x00;
				#endif
				else
					NfSpareBuf[5] = 0x00;

				block = page/ppb;
a0006dc0:	8e22754c 	lw	v0,30028(s1)
a0006dc4:	0282001b 	divu	zero,s4,v0
a0006dc8:	004001f4 	teq	v0,zero,0x7
a0006dcc:	00001812 	mflo	v1
a0006dd0:	afa30010 	sw	v1,16(sp)

				if ( isLastPage){
a0006dd4:	3c04a002 	lui	a0,0xa002
a0006dd8:	8c82887c 	lw	v0,-30596(a0)
a0006ddc:	10400024 	beqz	v0,a0006e70 <nand_write_ecc_ob+0x538>
a0006de0:	00000000 	nop
					unsigned char *temp_buf = (unsigned char *)malloc(page_size);
a0006de4:	0c001f55 	jal	a0007d54 <malloc>
a0006de8:	8e447544 	lw	a0,30020(s2)
a0006dec:	00408021 	move	s0,v0
					memset(temp_buf,0xba,sizeof(char)*page_size);
a0006df0:	00402021 	move	a0,v0
a0006df4:	240500ba 	li	a1,186
a0006df8:	0c00203d 	jal	a00080f4 <memset>
a0006dfc:	8e467544 	lw	a2,30020(s2)
					rtk_erase_block_a(block*ppb);
a0006e00:	8e24754c 	lw	a0,30028(s1)
a0006e04:	8fa20010 	lw	v0,16(sp)
a0006e08:	0c001048 	jal	a0004120 <rtk_erase_block_a>
a0006e0c:	70442002 	mul	a0,v0,a0
					rtk_write_ecc_page_a(block*ppb+ppb-1,temp_buf ,&NfSpareBuf , page_size);
a0006e10:	8fa30010 	lw	v1,16(sp)
a0006e14:	24630001 	addiu	v1,v1,1
a0006e18:	afa30010 	sw	v1,16(sp)
a0006e1c:	8e24754c 	lw	a0,30028(s1)
a0006e20:	70642002 	mul	a0,v1,a0
a0006e24:	2484ffff 	addiu	a0,a0,-1
a0006e28:	02002821 	move	a1,s0
a0006e2c:	8fa60020 	lw	a2,32(sp)
a0006e30:	0c0011da 	jal	a0004768 <rtk_write_ecc_page_a>
a0006e34:	8e477544 	lw	a3,30020(s2)
					rtk_write_ecc_page_a(block*ppb+ppb-2,temp_buf ,&NfSpareBuf , page_size);
a0006e38:	8e24754c 	lw	a0,30028(s1)
a0006e3c:	8fa20010 	lw	v0,16(sp)
a0006e40:	70442002 	mul	a0,v0,a0
a0006e44:	2484fffe 	addiu	a0,a0,-2
a0006e48:	02002821 	move	a1,s0
a0006e4c:	8fa60020 	lw	a2,32(sp)
a0006e50:	0c0011da 	jal	a0004768 <rtk_write_ecc_page_a>
a0006e54:	8e477544 	lw	a3,30020(s2)
                    if(temp_buf)
a0006e58:	12000023 	beqz	s0,a0006ee8 <nand_write_ecc_ob+0x5b0>
a0006e5c:	00000000 	nop
 					    free(temp_buf);
a0006e60:	0c001f86 	jal	a0007e18 <free>
a0006e64:	02002021 	move	a0,s0
				return -1;
			}

		}

		if(data_buf)//add by alexchang 0524-2010
a0006e68:	08001bbb 	j	a0006eec <nand_write_ecc_ob+0x5b4>
a0006e6c:	8fa30080 	lw	v1,128(sp)
					rtk_write_ecc_page_a(block*ppb+ppb-1,temp_buf ,&NfSpareBuf , page_size);
					rtk_write_ecc_page_a(block*ppb+ppb-2,temp_buf ,&NfSpareBuf , page_size);
                    if(temp_buf)
 					    free(temp_buf);
				}else{
					unsigned char *temp_buf = (unsigned char *)malloc(page_size);
a0006e70:	0c001f55 	jal	a0007d54 <malloc>
a0006e74:	8e447544 	lw	a0,30020(s2)
a0006e78:	00408021 	move	s0,v0
					memset(temp_buf,0xba,sizeof(char)*page_size);
a0006e7c:	00402021 	move	a0,v0
a0006e80:	240500ba 	li	a1,186
a0006e84:	0c00203d 	jal	a00080f4 <memset>
a0006e88:	8e467544 	lw	a2,30020(s2)
					rtk_erase_block_a(block*ppb);
a0006e8c:	8e24754c 	lw	a0,30028(s1)
a0006e90:	8fa20010 	lw	v0,16(sp)
a0006e94:	0c001048 	jal	a0004120 <rtk_erase_block_a>
a0006e98:	70442002 	mul	a0,v0,a0
					rtk_write_ecc_page_a(block*ppb,temp_buf ,&NfSpareBuf , page_size);
a0006e9c:	8e24754c 	lw	a0,30028(s1)
a0006ea0:	8fa20010 	lw	v0,16(sp)
a0006ea4:	70442002 	mul	a0,v0,a0
a0006ea8:	02002821 	move	a1,s0
a0006eac:	8fa60020 	lw	a2,32(sp)
a0006eb0:	0c0011da 	jal	a0004768 <rtk_write_ecc_page_a>
a0006eb4:	8e477544 	lw	a3,30020(s2)
					rtk_write_ecc_page_a(block*ppb+1,temp_buf ,&NfSpareBuf , page_size);
a0006eb8:	8e24754c 	lw	a0,30028(s1)
a0006ebc:	8fa20010 	lw	v0,16(sp)
a0006ec0:	70442002 	mul	a0,v0,a0
a0006ec4:	24840001 	addiu	a0,a0,1
a0006ec8:	02002821 	move	a1,s0
a0006ecc:	8fa60020 	lw	a2,32(sp)
a0006ed0:	0c0011da 	jal	a0004768 <rtk_write_ecc_page_a>
a0006ed4:	8e477544 	lw	a3,30020(s2)
                    if(temp_buf)
a0006ed8:	12000004 	beqz	s0,a0006eec <nand_write_ecc_ob+0x5b4>
a0006edc:	8fa30080 	lw	v1,128(sp)
 					    free(temp_buf);
a0006ee0:	0c001f86 	jal	a0007e18 <free>
a0006ee4:	02002021 	move	a0,s0
				return -1;
			}

		}

		if(data_buf)//add by alexchang 0524-2010
a0006ee8:	8fa30080 	lw	v1,128(sp)
a0006eec:	10600003 	beqz	v1,a0006efc <nand_write_ecc_ob+0x5c4>
a0006ef0:	8fa40084 	lw	a0,132(sp)
			data_len += page_size;
a0006ef4:	8e577544 	lw	s7,30020(s2)
a0006ef8:	02b7b821 	addu	s7,s5,s7
		if(oob_buf) //add by alexchang 0524-2010
a0006efc:	10800004 	beqz	a0,a0006f10 <nand_write_ecc_ob+0x5d8>
a0006f00:	3c05a001 	lui	a1,0xa001
			oob_len += oob_size;
a0006f04:	8cb67548 	lw	s6,30024(a1)
a0006f08:	8fa20018 	lw	v0,24(sp)
a0006f0c:	0056b021 	addu	s6,v0,s6
		
		old_page++;
		page_offset = old_page & (ppb-1);
a0006f10:	8e30754c 	lw	s0,30028(s1)
		//printf("page_offset:%x old_page:%x  ppb:%x \r\n",page_offset,old_page,ppb);
		if ( data_len<len && !(old_page & pagemask)) {
a0006f14:	8fa3007c 	lw	v1,124(sp)
a0006f18:	02e3102b 	sltu	v0,s7,v1
a0006f1c:	1040000e 	beqz	v0,a0006f58 <nand_write_ecc_ob+0x620>
a0006f20:	02e0a821 	move	s5,s7
		if(data_buf)//add by alexchang 0524-2010
			data_len += page_size;
		if(oob_buf) //add by alexchang 0524-2010
			oob_len += oob_size;
		
		old_page++;
a0006f24:	26620001 	addiu	v0,s3,1
		page_offset = old_page & (ppb-1);
		//printf("page_offset:%x old_page:%x  ppb:%x \r\n",page_offset,old_page,ppb);
		if ( data_len<len && !(old_page & pagemask)) {
a0006f28:	3c03a002 	lui	v1,0xa002
a0006f2c:	8c738874 	lw	s3,-30604(v1)
a0006f30:	00539824 	and	s3,v0,s3
a0006f34:	0053980b 	movn	s3,v0,s3
			data_len += page_size;
		if(oob_buf) //add by alexchang 0524-2010
			oob_len += oob_size;
		
		old_page++;
		page_offset = old_page & (ppb-1);
a0006f38:	2603ffff 	addiu	v1,s0,-1
a0006f3c:	00431024 	and	v0,v0,v1
		//printf("page_offset:%x old_page:%x  ppb:%x \r\n",page_offset,old_page,ppb);
		if ( data_len<len && !(old_page & pagemask)) {
			old_page &= pagemask;
		}
		block = old_page/ppb;
a0006f40:	0270001b 	divu	zero,s3,s0
a0006f44:	020001f4 	teq	s0,zero,0x7
a0006f48:	08001ab1 	j	a0006ac4 <nand_write_ecc_ob+0x18c>
a0006f4c:	00008012 	mflo	s0
			oob_len += oob_size;
		
		old_page++;
		page_offset = old_page & (ppb-1);
		//printf("page_offset:%x old_page:%x  ppb:%x \r\n",page_offset,old_page,ppb);
		if ( data_len<len && !(old_page & pagemask)) {
a0006f50:	08001bd7 	j	a0006f5c <nand_write_ecc_ob+0x624>
a0006f54:	2402ffff 	li	v0,-1
a0006f58:	00001021 	move	v0,zero

	}

	return 0;

}
a0006f5c:	8fbf0074 	lw	ra,116(sp)
a0006f60:	8fbe0070 	lw	s8,112(sp)
a0006f64:	8fb7006c 	lw	s7,108(sp)
a0006f68:	8fb60068 	lw	s6,104(sp)
a0006f6c:	8fb50064 	lw	s5,100(sp)
a0006f70:	8fb40060 	lw	s4,96(sp)
a0006f74:	8fb3005c 	lw	s3,92(sp)
a0006f78:	8fb20058 	lw	s2,88(sp)
a0006f7c:	8fb10054 	lw	s1,84(sp)
a0006f80:	8fb00050 	lw	s0,80(sp)
a0006f84:	03e00008 	jr	ra
a0006f88:	27bd0078 	addiu	sp,sp,120

a0006f8c <nand_read_ecc_ob>:
 * data_buf:DRAM space for data
 * oob_buff:DRAM space for oob
 *
 * */
int nand_read_ecc_ob (unsigned int from, unsigned int len, unsigned char *data_buf, unsigned char *oob_buf)
{
a0006f8c:	27bdffb0 	addiu	sp,sp,-80
a0006f90:	afbf004c 	sw	ra,76(sp)
a0006f94:	afbe0048 	sw	s8,72(sp)
a0006f98:	afb70044 	sw	s7,68(sp)
a0006f9c:	afb60040 	sw	s6,64(sp)
a0006fa0:	afb5003c 	sw	s5,60(sp)
a0006fa4:	afb40038 	sw	s4,56(sp)
a0006fa8:	afb30034 	sw	s3,52(sp)
a0006fac:	afb20030 	sw	s2,48(sp)
a0006fb0:	afb1002c 	sw	s1,44(sp)
a0006fb4:	afb00028 	sw	s0,40(sp)
a0006fb8:	afa50054 	sw	a1,84(sp)
a0006fbc:	afa60058 	sw	a2,88(sp)
a0006fc0:	afa7005c 	sw	a3,92(sp)
	int i, old_page, page_offset, block;
	int chipnr, chipnr_remap;
	int numchips=1;
{
    unsigned int offset=0, aa=0;	
	i = (from >> block_shift); //virtual block index
a0006fc4:	3c02a002 	lui	v0,0xa002
a0006fc8:	8c428870 	lw	v0,-30608(v0)
	aa = from & ~(block_size -1);
a0006fcc:	3c03a001 	lui	v1,0xa001
a0006fd0:	8c637524 	lw	v1,29988(v1)
a0006fd4:	00031823 	negu	v1,v1
a0006fd8:	00641824 	and	v1,v1,a0
	offset = from - aa;
a0006fdc:	00442806 	srlv	a1,a0,v0
a0006fe0:	3c06a001 	lui	a2,0xa001
a0006fe4:	8cc6796c 	lw	a2,31084(a2)
a0006fe8:	00052880 	sll	a1,a1,0x2
a0006fec:	00c52821 	addu	a1,a2,a1
a0006ff0:	8ca50000 	lw	a1,0(a1)
a0006ff4:	00451004 	sllv	v0,a1,v0
a0006ff8:	00822021 	addu	a0,a0,v0
	from =  (bbt_v2r[i].block_r << block_shift) + offset;//real block index, addr.
a0006ffc:	00832023 	subu	a0,a0,v1
//printf("%s: blockr:%x from:%x offset %x len:%x\n\r",__FUNCTION__,bbt_v2r[i].block_r, from, offset,len);
}
	if ((from + len) > chip_size) {
a0007000:	8fa20054 	lw	v0,84(sp)
a0007004:	00821821 	addu	v1,a0,v0
a0007008:	3c02a002 	lui	v0,0xa002
a000700c:	8c428880 	lw	v0,-30592(v0)
a0007010:	0043102b 	sltu	v0,v0,v1
a0007014:	10400006 	beqz	v0,a0007030 <nand_read_ecc_ob+0xa4>
a0007018:	8fa20054 	lw	v0,84(sp)
		printf ("nand_read_ecc: Attempt read beyond end of device\n");
a000701c:	3c04a001 	lui	a0,0xa001
a0007020:	0c002325 	jal	a0008c94 <dprintf>
a0007024:	24844eec 	addiu	a0,a0,20204
		return FAIL;
a0007028:	08001d21 	j	a0007484 <nand_read_ecc_ob+0x4f8>
a000702c:	2412ffff 	li	s2,-1
	}

	if ((from & (page_size-1)) ||(len & (page_size-1))) {
a0007030:	00821825 	or	v1,a0,v0
a0007034:	3c02a001 	lui	v0,0xa001
a0007038:	8c427544 	lw	v0,30020(v0)
a000703c:	2442ffff 	addiu	v0,v0,-1
a0007040:	00621024 	and	v0,v1,v0
a0007044:	10400006 	beqz	v0,a0007060 <nand_read_ecc_ob+0xd4>
a0007048:	3c02a002 	lui	v0,0xa002
		printf("nand_read_ecc: Attempt to read not page aligned data\n");
a000704c:	3c04a001 	lui	a0,0xa001
a0007050:	0c002325 	jal	a0008c94 <dprintf>
a0007054:	24844f20 	addiu	a0,a0,20256
		return FAIL;
a0007058:	08001d21 	j	a0007484 <nand_read_ecc_ob+0x4f8>
a000705c:	2412ffff 	li	s2,-1

    //dprintf("[%s]:%d page_shift = %d\n",__func__,__LINE__,page_shift );
    //dprintf("[%s]:%d pagemask = 0x%x\n",__func__,__LINE__,pagemask);
	realpage = (int)(from >> page_shift);
	//chipnr = chipnr_remap = (int)(from >> this->chip_shift);
	old_page = page = realpage & pagemask;
a0007060:	8c548878 	lw	s4,-30600(v0)
a0007064:	02842006 	srlv	a0,a0,s4
a0007068:	3c02a002 	lui	v0,0xa002
a000706c:	8c428874 	lw	v0,-30604(v0)
a0007070:	0082a024 	and	s4,a0,v0
	page_offset = page & (ppb-1);
a0007074:	3c02a001 	lui	v0,0xa001
a0007078:	8c42754c 	lw	v0,30028(v0)
	block = page/ppb;
a000707c:	0282001b 	divu	zero,s4,v0
a0007080:	004001f4 	teq	v0,zero,0x7
a0007084:	00003012 	mflo	a2
	//printf("realpage:%x old_page:%x  page_offset:%x\r\n",realpage,old_page,page_offset);

	if (numchips==1 && block != read_block ){
a0007088:	3c03a001 	lui	v1,0xa001
a000708c:	8c63752c 	lw	v1,29996(v1)
a0007090:	10c30007 	beq	a2,v1,a00070b0 <nand_read_ecc_ob+0x124>
a0007094:	3c03a001 	lui	v1,0xa001
		read_block = block;
a0007098:	ac66752c 	sw	a2,29996(v1)
		read_remap_block = 0xFFFFFFFF;
a000709c:	2404ffff 	li	a0,-1
a00070a0:	3c03a001 	lui	v1,0xa001
a00070a4:	ac647530 	sw	a0,30000(v1)
		read_has_check_bbt = 0;
a00070a8:	3c03a002 	lui	v1,0xa002
a00070ac:	ac608888 	sw	zero,-30584(v1)
	}

	data_len = oob_len = 0;

	while(data_len<len){
a00070b0:	8fa30054 	lw	v1,84(sp)
a00070b4:	106000f3 	beqz	v1,a0007484 <nand_read_ecc_ob+0x4f8>
a00070b8:	00009021 	move	s2,zero

    //dprintf("[%s]:%d page_shift = %d\n",__func__,__LINE__,page_shift );
    //dprintf("[%s]:%d pagemask = 0x%x\n",__func__,__LINE__,pagemask);
	realpage = (int)(from >> page_shift);
	//chipnr = chipnr_remap = (int)(from >> this->chip_shift);
	old_page = page = realpage & pagemask;
a00070bc:	0280a821 	move	s5,s4
	page_offset = page & (ppb-1);
a00070c0:	2442ffff 	addiu	v0,v0,-1
a00070c4:	02821024 	and	v0,s4,v0
	block = page/ppb;
a00070c8:	0000b821 	move	s7,zero
a00070cc:	0000b021 	move	s6,zero
a00070d0:	0000f021 	move	s8,zero

	data_len = oob_len = 0;

	while(data_len<len){
		if( numchips==1){
			if ( (page>=block*ppb) && (page<(block+1)*ppb) && read_has_check_bbt==1 )
a00070d4:	3c11a001 	lui	s1,0xa001
					read_remap_block = block = bbt[i].remap_block;
				}
			}else
				break;
		}
		read_has_check_bbt = 1;
a00070d8:	24040001 	li	a0,1
a00070dc:	afa40018 	sw	a0,24(sp)
			if ( (page>=block*ppb) && (page<(block+1)*ppb) && read_has_check_bbt==1 )
				goto SKIP_BBT_CHECK;
		}

		for ( i=0; i<RBA; i++){
			if ( bbt[i].bad_block != BB_INIT ){
a00070e0:	3410fffe 	li	s0,0xfffe
		}else
			page = block*ppb + page_offset;  

		//if((page % ppb)==0)  printf("$");
	
		rc = rtk_read_ecc_page_a(page, &data_buf[data_len], &oob_buf[oob_len], page_size);
a00070e4:	3c13a001 	lui	s3,0xa001

			    }//check_BBT
			    
			    if(!NAND_ADDR_CYCLE)
			    #ifdef SWAP_2K_DATA
			        NfSpareBuf[BBI_SWAP_OFFSET] = 0x00;
a00070e8:	3c03a002 	lui	v1,0xa002
a00070ec:	2463a268 	addiu	v1,v1,-23960
a00070f0:	afa3001c 	sw	v1,28(sp)
				    rtk_write_ecc_page_a(block*ppb,temp_buf ,&NfSpareBuf , page_size);
				    rtk_write_ecc_page_a(block*ppb+1,temp_buf ,&NfSpareBuf , page_size);
					if(temp_buf)
					    free(temp_buf);
			    }
			    printf("%s: Un-correctable HW ECC Error at page=%d\n\r",__FUNCTION__, page);
a00070f4:	3c03a001 	lui	v1,0xa001
a00070f8:	24634f78 	addiu	v1,v1,20344
a00070fc:	afa30020 	sw	v1,32(sp)
a0007100:	3c03a001 	lui	v1,0xa001
a0007104:	246303a0 	addiu	v1,v1,928
a0007108:	afa30024 	sw	v1,36(sp)

	data_len = oob_len = 0;

	while(data_len<len){
		if( numchips==1){
			if ( (page>=block*ppb) && (page<(block+1)*ppb) && read_has_check_bbt==1 )
a000710c:	8e23754c 	lw	v1,30028(s1)
a0007110:	70c32002 	mul	a0,a2,v1
a0007114:	0284202b 	sltu	a0,s4,a0
a0007118:	14800005 	bnez	a0,a0007130 <nand_read_ecc_ob+0x1a4>
a000711c:	24c40001 	addiu	a0,a2,1
a0007120:	70831802 	mul	v1,a0,v1
a0007124:	0283a02b 	sltu	s4,s4,v1
a0007128:	1680000b 	bnez	s4,a0007158 <nand_read_ecc_ob+0x1cc>
a000712c:	3c04a002 	lui	a0,0xa002
				goto SKIP_BBT_CHECK;
		}

		for ( i=0; i<RBA; i++){
a0007130:	3c03a001 	lui	v1,0xa001
a0007134:	8c687970 	lw	t0,31088(v1)
a0007138:	11000019 	beqz	t0,a00071a0 <nand_read_ecc_ob+0x214>
a000713c:	3c04a001 	lui	a0,0xa001
			if ( bbt[i].bad_block != BB_INIT ){
a0007140:	8c837974 	lw	v1,31092(a0)
a0007144:	94650002 	lhu	a1,2(v1)
a0007148:	10b00015 	beq	a1,s0,a00071a0 <nand_read_ecc_ob+0x214>
a000714c:	24640008 	addiu	a0,v1,8
a0007150:	08001c5f 	j	a000717c <nand_read_ecc_ob+0x1f0>
a0007154:	00003821 	move	a3,zero

	data_len = oob_len = 0;

	while(data_len<len){
		if( numchips==1){
			if ( (page>=block*ppb) && (page<(block+1)*ppb) && read_has_check_bbt==1 )
a0007158:	8c838888 	lw	v1,-30584(a0)
a000715c:	24040001 	li	a0,1
a0007160:	1464fff4 	bne	v1,a0,a0007134 <nand_read_ecc_ob+0x1a8>
a0007164:	3c03a001 	lui	v1,0xa001
		read_has_check_bbt = 1;

SKIP_BBT_CHECK:

		if (  read_has_check_bbt==1 ){
			if ( read_remap_block == 0xFFFFFFFF )
a0007168:	08001c6c 	j	a00071b0 <nand_read_ecc_ob+0x224>
a000716c:	3c04a001 	lui	a0,0xa001
			if ( (page>=block*ppb) && (page<(block+1)*ppb) && read_has_check_bbt==1 )
				goto SKIP_BBT_CHECK;
		}

		for ( i=0; i<RBA; i++){
			if ( bbt[i].bad_block != BB_INIT ){
a0007170:	94850002 	lhu	a1,2(a0)
a0007174:	10b0000a 	beq	a1,s0,a00071a0 <nand_read_ecc_ob+0x214>
a0007178:	24840008 	addiu	a0,a0,8
				if ( block == bbt[i].bad_block ){
a000717c:	14a60004 	bne	a1,a2,a0007190 <nand_read_ecc_ob+0x204>
a0007180:	00000000 	nop
					read_remap_block = block = bbt[i].remap_block;
a0007184:	94660006 	lhu	a2,6(v1)
a0007188:	3c03a001 	lui	v1,0xa001
a000718c:	ac667530 	sw	a2,30000(v1)
		if( numchips==1){
			if ( (page>=block*ppb) && (page<(block+1)*ppb) && read_has_check_bbt==1 )
				goto SKIP_BBT_CHECK;
		}

		for ( i=0; i<RBA; i++){
a0007190:	24e70001 	addiu	a3,a3,1
a0007194:	00e8182b 	sltu	v1,a3,t0
a0007198:	1460fff5 	bnez	v1,a0007170 <nand_read_ecc_ob+0x1e4>
a000719c:	00801821 	move	v1,a0
					read_remap_block = block = bbt[i].remap_block;
				}
			}else
				break;
		}
		read_has_check_bbt = 1;
a00071a0:	8fa30018 	lw	v1,24(sp)
a00071a4:	3c04a002 	lui	a0,0xa002
a00071a8:	ac838888 	sw	v1,-30584(a0)

SKIP_BBT_CHECK:

		if (  read_has_check_bbt==1 ){
			if ( read_remap_block == 0xFFFFFFFF )
a00071ac:	3c04a001 	lui	a0,0xa001
a00071b0:	8c947530 	lw	s4,30000(a0)
a00071b4:	2403ffff 	li	v1,-1
a00071b8:	16830005 	bne	s4,v1,a00071d0 <nand_read_ecc_ob+0x244>
a00071bc:	8e23754c 	lw	v1,30028(s1)
				page = block*ppb + page_offset;
a00071c0:	8e34754c 	lw	s4,30028(s1)
a00071c4:	70d41802 	mul	v1,a2,s4
a00071c8:	08001c76 	j	a00071d8 <nand_read_ecc_ob+0x24c>
a00071cc:	0062a021 	addu	s4,v1,v0
			else	
				page = read_remap_block*ppb + page_offset;
a00071d0:	72832002 	mul	a0,s4,v1
a00071d4:	0082a021 	addu	s4,a0,v0
		}else
			page = block*ppb + page_offset;  

		//if((page % ppb)==0)  printf("$");
	
		rc = rtk_read_ecc_page_a(page, &data_buf[data_len], &oob_buf[oob_len], page_size);
a00071d8:	afb60010 	sw	s6,16(sp)
a00071dc:	02802021 	move	a0,s4
a00071e0:	8fa20058 	lw	v0,88(sp)
a00071e4:	00572821 	addu	a1,v0,s7
a00071e8:	8fa3005c 	lw	v1,92(sp)
a00071ec:	00763021 	addu	a2,v1,s6
a00071f0:	0c0012a2 	jal	a0004a88 <rtk_read_ecc_page_a>
a00071f4:	8e677544 	lw	a3,30020(s3)
		//dprintf("[%s]:%d rc = %d\n",__func__,__LINE__,rc);
		//while(1); //for safe sake

		if (rc < 0) {
a00071f8:	04410088 	bgez	v0,a000741c <nand_read_ecc_ob+0x490>
a00071fc:	00409021 	move	s2,v0
		    //dprintf("[%s]:%d for safe sake,how can read get good block to bad block now cancel\n",__func__,__LINE__);
		    //while(1); //for safe sake,how can read get good block to bad block
			if(rc==-1){
a0007200:	2402ffff 	li	v0,-1
a0007204:	1642007d 	bne	s2,v0,a00073fc <nand_read_ecc_ob+0x470>
a0007208:	8e22754c 	lw	v0,30028(s1)
				//printf("%s: page %d Un-correctable HW ECC\n\r", __FUNCTION__, page);
				//update BBT
				if(check_BBT(page/ppb)==0){
a000720c:	0282001b 	divu	zero,s4,v0
a0007210:	004001f4 	teq	v0,zero,0x7
a0007214:	0c0010b8 	jal	a00042e0 <check_BBT>
a0007218:	00002012 	mflo	a0
a000721c:	1440002d 	bnez	v0,a00072d4 <nand_read_ecc_ob+0x348>
a0007220:	8fa3001c 	lw	v1,28(sp)
				    for( i=0; i<RBA; i++){
a0007224:	3c02a001 	lui	v0,0xa001
a0007228:	8c467970 	lw	a2,31088(v0)
a000722c:	10c0001b 	beqz	a2,a000729c <nand_read_ecc_ob+0x310>
a0007230:	3c03a001 	lui	v1,0xa001
					    if ( bbt[i].bad_block == BB_INIT && bbt[i].remap_block != RB_INIT){
a0007234:	8c677974 	lw	a3,31092(v1)
a0007238:	00001021 	move	v0,zero
a000723c:	00001821 	move	v1,zero
a0007240:	3408fffd 	li	t0,0xfffd
a0007244:	000210c0 	sll	v0,v0,0x3
a0007248:	00e22021 	addu	a0,a3,v0
a000724c:	94850002 	lhu	a1,2(a0)
a0007250:	14b0000e 	bne	a1,s0,a000728c <nand_read_ecc_ob+0x300>
a0007254:	00000000 	nop
a0007258:	94850006 	lhu	a1,6(a0)
a000725c:	10a8000c 	beq	a1,t0,a0007290 <nand_read_ecc_ob+0x304>
a0007260:	24630001 	addiu	v1,v1,1
						    bbt[i].BB_die = numchips-1;
a0007264:	a4800000 	sh	zero,0(a0)
						    bbt[i].bad_block = page/ppb;
a0007268:	3c04a001 	lui	a0,0xa001
a000726c:	8c837974 	lw	v1,31092(a0)
a0007270:	00621021 	addu	v0,v1,v0
a0007274:	8e23754c 	lw	v1,30028(s1)
a0007278:	0283001b 	divu	zero,s4,v1
a000727c:	006001f4 	teq	v1,zero,0x7
a0007280:	00001812 	mflo	v1
						    break;
a0007284:	08001ca7 	j	a000729c <nand_read_ecc_ob+0x310>
a0007288:	a4430002 	sh	v1,2(v0)
		    //while(1); //for safe sake,how can read get good block to bad block
			if(rc==-1){
				//printf("%s: page %d Un-correctable HW ECC\n\r", __FUNCTION__, page);
				//update BBT
				if(check_BBT(page/ppb)==0){
				    for( i=0; i<RBA; i++){
a000728c:	24630001 	addiu	v1,v1,1
a0007290:	0066202b 	sltu	a0,v1,a2
a0007294:	1480ffeb 	bnez	a0,a0007244 <nand_read_ecc_ob+0x2b8>
a0007298:	00601021 	move	v0,v1
						    bbt[i].BB_die = numchips-1;
						    bbt[i].bad_block = page/ppb;
						    break;
					    }
				    }
					dump_BBT();
a000729c:	0c001392 	jal	a0004e48 <dump_BBT>
a00072a0:	00000000 	nop
					
					//if ( rtk_update_bbt ( &NfDataBuf, &NfSpareBuf, bbt) )
					if ( rtk_update_bbt (bbt) ){
a00072a4:	3c02a001 	lui	v0,0xa001
a00072a8:	0c00154d 	jal	a0005534 <rtk_update_bbt>
a00072ac:	8c447974 	lw	a0,31092(v0)
a00072b0:	10400008 	beqz	v0,a00072d4 <nand_read_ecc_ob+0x348>
a00072b4:	8fa3001c 	lw	v1,28(sp)
							printf("[%s] rtk_update_bbt() fails\n\r", __FUNCTION__);
a00072b8:	3c04a001 	lui	a0,0xa001
a00072bc:	24844f58 	addiu	a0,a0,20312
a00072c0:	3c05a001 	lui	a1,0xa001
a00072c4:	0c002325 	jal	a0008c94 <dprintf>
a00072c8:	24a503a0 	addiu	a1,a1,928
							return -1;
a00072cc:	08001d22 	j	a0007488 <nand_read_ecc_ob+0x4fc>
a00072d0:	02401021 	move	v0,s2

			    }//check_BBT
			    
			    if(!NAND_ADDR_CYCLE)
			    #ifdef SWAP_2K_DATA
			        NfSpareBuf[BBI_SWAP_OFFSET] = 0x00;
a00072d4:	a0600035 	sb	zero,53(v1)
					NfSpareBuf[0] = 0x00;
			    #endif
			    else
				    NfSpareBuf[5] = 0x00;

				block = page/ppb;
a00072d8:	8e32754c 	lw	s2,30028(s1)
a00072dc:	0292001b 	divu	zero,s4,s2
a00072e0:	024001f4 	teq	s2,zero,0x7

			    if ( isLastPage){
a00072e4:	3c03a002 	lui	v1,0xa002
a00072e8:	8c62887c 	lw	v0,-30596(v1)
a00072ec:	10400021 	beqz	v0,a0007374 <nand_read_ecc_ob+0x3e8>
a00072f0:	00009012 	mflo	s2
					unsigned char *temp_buf = (unsigned char *)malloc(page_size);
a00072f4:	0c001f55 	jal	a0007d54 <malloc>
a00072f8:	8e647544 	lw	a0,30020(s3)
a00072fc:	afa20014 	sw	v0,20(sp)
					memset(temp_buf,0xba,sizeof(char)*page_size);
a0007300:	00402021 	move	a0,v0
a0007304:	240500ba 	li	a1,186
a0007308:	0c00203d 	jal	a00080f4 <memset>
a000730c:	8e667544 	lw	a2,30020(s3)
					rtk_erase_block_a(block*ppb);
a0007310:	8e24754c 	lw	a0,30028(s1)
a0007314:	0c001048 	jal	a0004120 <rtk_erase_block_a>
a0007318:	72442002 	mul	a0,s2,a0
				    rtk_write_ecc_page_a(block*ppb+ppb-1,temp_buf ,&NfSpareBuf , page_size);
a000731c:	26520001 	addiu	s2,s2,1
a0007320:	8e24754c 	lw	a0,30028(s1)
a0007324:	72442002 	mul	a0,s2,a0
a0007328:	2484ffff 	addiu	a0,a0,-1
a000732c:	8fa50014 	lw	a1,20(sp)
a0007330:	8fa6001c 	lw	a2,28(sp)
a0007334:	0c0011da 	jal	a0004768 <rtk_write_ecc_page_a>
a0007338:	8e677544 	lw	a3,30020(s3)
				    rtk_write_ecc_page_a(block*ppb+ppb-2,temp_buf ,&NfSpareBuf , page_size);
a000733c:	8e22754c 	lw	v0,30028(s1)
a0007340:	72429002 	mul	s2,s2,v0
a0007344:	2644fffe 	addiu	a0,s2,-2
a0007348:	8fa50014 	lw	a1,20(sp)
a000734c:	8fa6001c 	lw	a2,28(sp)
a0007350:	0c0011da 	jal	a0004768 <rtk_write_ecc_page_a>
a0007354:	8e677544 	lw	a3,30020(s3)
					if(temp_buf)
a0007358:	8fa20014 	lw	v0,20(sp)
a000735c:	10400021 	beqz	v0,a00073e4 <nand_read_ecc_ob+0x458>
a0007360:	00000000 	nop
					    free(temp_buf);
a0007364:	0c001f86 	jal	a0007e18 <free>
a0007368:	00402021 	move	a0,v0
				    rtk_write_ecc_page_a(block*ppb,temp_buf ,&NfSpareBuf , page_size);
				    rtk_write_ecc_page_a(block*ppb+1,temp_buf ,&NfSpareBuf , page_size);
					if(temp_buf)
					    free(temp_buf);
			    }
			    printf("%s: Un-correctable HW ECC Error at page=%d\n\r",__FUNCTION__, page);
a000736c:	08001cfa 	j	a00073e8 <nand_read_ecc_ob+0x45c>
a0007370:	8fa40020 	lw	a0,32(sp)
				    rtk_write_ecc_page_a(block*ppb+ppb-1,temp_buf ,&NfSpareBuf , page_size);
				    rtk_write_ecc_page_a(block*ppb+ppb-2,temp_buf ,&NfSpareBuf , page_size);
					if(temp_buf)
					    free(temp_buf);
			    }else{
					unsigned char *temp_buf = (unsigned char *)malloc(page_size);
a0007374:	0c001f55 	jal	a0007d54 <malloc>
a0007378:	8e647544 	lw	a0,30020(s3)
a000737c:	afa20014 	sw	v0,20(sp)
					memset(temp_buf,0xba,sizeof(char)*page_size);
a0007380:	00402021 	move	a0,v0
a0007384:	240500ba 	li	a1,186
a0007388:	0c00203d 	jal	a00080f4 <memset>
a000738c:	8e667544 	lw	a2,30020(s3)
					rtk_erase_block_a(block*ppb);
a0007390:	8e24754c 	lw	a0,30028(s1)
a0007394:	0c001048 	jal	a0004120 <rtk_erase_block_a>
a0007398:	72442002 	mul	a0,s2,a0
				    rtk_write_ecc_page_a(block*ppb,temp_buf ,&NfSpareBuf , page_size);
a000739c:	8e24754c 	lw	a0,30028(s1)
a00073a0:	72442002 	mul	a0,s2,a0
a00073a4:	8fa50014 	lw	a1,20(sp)
a00073a8:	8fa6001c 	lw	a2,28(sp)
a00073ac:	0c0011da 	jal	a0004768 <rtk_write_ecc_page_a>
a00073b0:	8e677544 	lw	a3,30020(s3)
				    rtk_write_ecc_page_a(block*ppb+1,temp_buf ,&NfSpareBuf , page_size);
a00073b4:	8e24754c 	lw	a0,30028(s1)
a00073b8:	72442002 	mul	a0,s2,a0
a00073bc:	24840001 	addiu	a0,a0,1
a00073c0:	8fa50014 	lw	a1,20(sp)
a00073c4:	8fa6001c 	lw	a2,28(sp)
a00073c8:	0c0011da 	jal	a0004768 <rtk_write_ecc_page_a>
a00073cc:	8e677544 	lw	a3,30020(s3)
					if(temp_buf)
a00073d0:	8fa20014 	lw	v0,20(sp)
a00073d4:	10400004 	beqz	v0,a00073e8 <nand_read_ecc_ob+0x45c>
a00073d8:	8fa40020 	lw	a0,32(sp)
					    free(temp_buf);
a00073dc:	0c001f86 	jal	a0007e18 <free>
a00073e0:	00402021 	move	a0,v0
			    }
			    printf("%s: Un-correctable HW ECC Error at page=%d\n\r",__FUNCTION__, page);
a00073e4:	8fa40020 	lw	a0,32(sp)
a00073e8:	8fa50024 	lw	a1,36(sp)
a00073ec:	0c002325 	jal	a0008c94 <dprintf>
a00073f0:	02803021 	move	a2,s4
a00073f4:	08001d07 	j	a000741c <nand_read_ecc_ob+0x490>
a00073f8:	00009021 	move	s2,zero
				rc = 0;
		    }else{
				printf("%s: page %d failed\n", __FUNCTION__, page);
a00073fc:	3c04a001 	lui	a0,0xa001
a0007400:	24844fa8 	addiu	a0,a0,20392
a0007404:	3c05a001 	lui	a1,0xa001
a0007408:	24a503a0 	addiu	a1,a1,928
a000740c:	0c002325 	jal	a0008c94 <dprintf>
a0007410:	02803021 	move	a2,s4
				return -1;
a0007414:	08001d21 	j	a0007484 <nand_read_ecc_ob+0x4f8>
a0007418:	2412ffff 	li	s2,-1
			}
		}
		if(data_buf)//add by alexchang 0524-2010
a000741c:	8fa30058 	lw	v1,88(sp)
a0007420:	10600003 	beqz	v1,a0007430 <nand_read_ecc_ob+0x4a4>
a0007424:	8fa4005c 	lw	a0,92(sp)
		data_len += page_size;
a0007428:	8e7e7544 	lw	s8,30020(s3)
a000742c:	02fef021 	addu	s8,s7,s8

		if(oob_buf)//add by alexchang 0524-2010
a0007430:	10800004 	beqz	a0,a0007444 <nand_read_ecc_ob+0x4b8>
a0007434:	3c02a001 	lui	v0,0xa001
		oob_len += oob_size;
a0007438:	8c567548 	lw	s6,30024(v0)
a000743c:	8fa30010 	lw	v1,16(sp)
a0007440:	0076b021 	addu	s6,v1,s6
		
		old_page++;
		page_offset = old_page & (ppb-1);
a0007444:	8e23754c 	lw	v1,30028(s1)
		if ( data_len<len && !(old_page &  pagemask)) {
a0007448:	8fa40054 	lw	a0,84(sp)
a000744c:	03c4102b 	sltu	v0,s8,a0
a0007450:	1040000c 	beqz	v0,a0007484 <nand_read_ecc_ob+0x4f8>
a0007454:	03c0b821 	move	s7,s8
		data_len += page_size;

		if(oob_buf)//add by alexchang 0524-2010
		oob_len += oob_size;
		
		old_page++;
a0007458:	26a20001 	addiu	v0,s5,1
		page_offset = old_page & (ppb-1);
		if ( data_len<len && !(old_page &  pagemask)) {
a000745c:	3c04a002 	lui	a0,0xa002
a0007460:	8c958874 	lw	s5,-30604(a0)
a0007464:	0055a824 	and	s5,v0,s5
a0007468:	0055a80b 	movn	s5,v0,s5

		if(oob_buf)//add by alexchang 0524-2010
		oob_len += oob_size;
		
		old_page++;
		page_offset = old_page & (ppb-1);
a000746c:	2464ffff 	addiu	a0,v1,-1
a0007470:	00441024 	and	v0,v0,a0
		if ( data_len<len && !(old_page &  pagemask)) {
			old_page &= pagemask;
		}
		
		block = old_page/ppb;
a0007474:	02a3001b 	divu	zero,s5,v1
a0007478:	006001f4 	teq	v1,zero,0x7
a000747c:	08001c44 	j	a0007110 <nand_read_ecc_ob+0x184>
a0007480:	00003012 	mflo	a2
	}
    //while(1); //debug cl for safe sake
	//printf("out rx:%x\r\n",rc);
	return rc;

}
a0007484:	02401021 	move	v0,s2
a0007488:	8fbf004c 	lw	ra,76(sp)
a000748c:	8fbe0048 	lw	s8,72(sp)
a0007490:	8fb70044 	lw	s7,68(sp)
a0007494:	8fb60040 	lw	s6,64(sp)
a0007498:	8fb5003c 	lw	s5,60(sp)
a000749c:	8fb40038 	lw	s4,56(sp)
a00074a0:	8fb30034 	lw	s3,52(sp)
a00074a4:	8fb20030 	lw	s2,48(sp)
a00074a8:	8fb1002c 	lw	s1,44(sp)
a00074ac:	8fb00028 	lw	s0,40(sp)
a00074b0:	03e00008 	jr	ra
a00074b4:	27bd0050 	addiu	sp,sp,80

a00074b8 <nand_erase_nand>:

#endif  /*  */

 #ifdef CONFIG_RTK_NAND_BBT
int nand_erase_nand (unsigned int addr, unsigned int len)
{
a00074b8:	27bdffa8 	addiu	sp,sp,-88
a00074bc:	afbf0054 	sw	ra,84(sp)
a00074c0:	afbe0050 	sw	s8,80(sp)
a00074c4:	afb7004c 	sw	s7,76(sp)
a00074c8:	afb60048 	sw	s6,72(sp)
a00074cc:	afb50044 	sw	s5,68(sp)
a00074d0:	afb40040 	sw	s4,64(sp)
a00074d4:	afb3003c 	sw	s3,60(sp)
a00074d8:	afb20038 	sw	s2,56(sp)
a00074dc:	afb10034 	sw	s1,52(sp)
a00074e0:	afb00030 	sw	s0,48(sp)
a00074e4:	afa5005c 	sw	a1,92(sp)
	int err_chipnr = 0, err_chipnr_remap = 1;
	int numchips=1, page_offset=0;

	{
	unsigned int real_addr;
	i = (addr >> block_shift);
a00074e8:	3c02a002 	lui	v0,0xa002
a00074ec:	8c428870 	lw	v0,-30608(v0)
	
	real_addr = (bbt_v2r[i].block_r << block_shift);//real block index, addr.
a00074f0:	00441806 	srlv	v1,a0,v0
a00074f4:	3c04a001 	lui	a0,0xa001
a00074f8:	8c85796c 	lw	a1,31084(a0)
a00074fc:	00031880 	sll	v1,v1,0x2
a0007500:	00a31821 	addu	v1,a1,v1
a0007504:	8c630000 	lw	v1,0(v1)
a0007508:	00431804 	sllv	v1,v1,v0
a000750c:	afa30020 	sw	v1,32(sp)
	addr = real_addr;
	//printf("%s: blockr:%x addr:%x pagemask%x \n\r",__FUNCTION__,bbt_v2r[i].block_r, addr,pagemask);
	}
	realpage = (int) (addr >> page_shift);
a0007510:	3c02a002 	lui	v0,0xa002
a0007514:	8c538878 	lw	s3,-30600(v0)
	chipnr = chipnr_remap = 0;
	old_page = page = realpage & pagemask;
a0007518:	3c02a002 	lui	v0,0xa002
a000751c:	8c438874 	lw	v1,-30604(v0)
	page_offset = page & (ppb-1);
	block = page/ppb;
a0007520:	3c02a001 	lui	v0,0xa001
a0007524:	8c54754c 	lw	s4,30028(v0)

	if ((addr + len) > chip_size) {
a0007528:	3c02a002 	lui	v0,0xa002
a000752c:	8c428880 	lw	v0,-30592(v0)
a0007530:	8fa5005c 	lw	a1,92(sp)
a0007534:	8fa60020 	lw	a2,32(sp)
a0007538:	00a62021 	addu	a0,a1,a2
a000753c:	0044202b 	sltu	a0,v0,a0
a0007540:	14800005 	bnez	a0,a0007558 <nand_erase_nand+0xa0>
a0007544:	00000000 	nop
		printf("%s: Attempt erase beyond end of device add:%x len:%x cs:%x\n\r",__FUNCTION__,addr,len,chip_size);
		return FAIL;
	}
	
 	while (elen < len) {
a0007548:	14a000b4 	bnez	a1,a000781c <nand_erase_nand+0x364>
a000754c:	00009021 	move	s2,zero
		for ( i=0; i<RBA; i++){			
			if ( bbt[i].bad_block != BB_INIT ){
a0007550:	08001e27 	j	a000789c <nand_erase_nand+0x3e4>
a0007554:	00001021 	move	v0,zero
	old_page = page = realpage & pagemask;
	page_offset = page & (ppb-1);
	block = page/ppb;

	if ((addr + len) > chip_size) {
		printf("%s: Attempt erase beyond end of device add:%x len:%x cs:%x\n\r",__FUNCTION__,addr,len,chip_size);
a0007558:	afa20010 	sw	v0,16(sp)
a000755c:	3c04a001 	lui	a0,0xa001
a0007560:	24844fbc 	addiu	a0,a0,20412
a0007564:	3c05a001 	lui	a1,0xa001
a0007568:	24a503c8 	addiu	a1,a1,968
a000756c:	8fa60020 	lw	a2,32(sp)
a0007570:	0c002325 	jal	a0008c94 <dprintf>
a0007574:	8fa7005c 	lw	a3,92(sp)
		return FAIL;
a0007578:	08001e27 	j	a000789c <nand_erase_nand+0x3e4>
a000757c:	2402ffff 	li	v0,-1
	}
	
 	while (elen < len) {
		for ( i=0; i<RBA; i++){			
			if ( bbt[i].bad_block != BB_INIT ){
a0007580:	94430002 	lhu	v1,2(v0)
a0007584:	10700008 	beq	v1,s0,a00075a8 <nand_erase_nand+0xf0>
a0007588:	24420008 	addiu	v0,v0,8
				if ( block == bbt[i].bad_block ){
a000758c:	14740002 	bne	v1,s4,a0007598 <nand_erase_nand+0xe0>
a0007590:	00000000 	nop
					block = bbt[i].remap_block;
a0007594:	94b40006 	lhu	s4,6(a1)
		printf("%s: Attempt erase beyond end of device add:%x len:%x cs:%x\n\r",__FUNCTION__,addr,len,chip_size);
		return FAIL;
	}
	
 	while (elen < len) {
		for ( i=0; i<RBA; i++){			
a0007598:	24840001 	addiu	a0,a0,1
a000759c:	0086182b 	sltu	v1,a0,a2
a00075a0:	1460fff7 	bnez	v1,a0007580 <nand_erase_nand+0xc8>
a00075a4:	00402821 	move	a1,v0
				}			
			}else				
			break;		
		}

		page = block*ppb;
a00075a8:	8e35754c 	lw	s5,30028(s1)
a00075ac:	7295a802 	mul	s5,s4,s5
		//printf("Ready to Erase blk %x\n\r",page/ppb);
		
		rc = rtk_erase_block_a(page);
a00075b0:	0c001048 	jal	a0004120 <rtk_erase_block_a>
a00075b4:	02a02021 	move	a0,s5
			
		if (rc) {
a00075b8:	1040008a 	beqz	v0,a00077e4 <nand_erase_nand+0x32c>
a00075bc:	8ec37524 	lw	v1,29988(s6)
		    printf("%s: block erase failed at page address=0x%08x\n", __FUNCTION__, addr);
a00075c0:	8fa40028 	lw	a0,40(sp)
a00075c4:	8fa5002c 	lw	a1,44(sp)
a00075c8:	0c002325 	jal	a0008c94 <dprintf>
a00075cc:	8fa60020 	lw	a2,32(sp)
			int block_remap = 0x12345678;
            /* update BBT */
			if(check_BBT(page/ppb)==0)
a00075d0:	8e22754c 	lw	v0,30028(s1)
a00075d4:	02a2001b 	divu	zero,s5,v0
a00075d8:	004001f4 	teq	v0,zero,0x7
a00075dc:	0c0010b8 	jal	a00042e0 <check_BBT>
a00075e0:	00002012 	mflo	a0

                dump_BBT();

                if ( rtk_update_bbt(bbt)){
	                printf("[%s] rtk_update_bbt() fails\n", __FUNCTION__);
	                return FAIL;
a00075e4:	8fa30024 	lw	v1,36(sp)
			
		if (rc) {
		    printf("%s: block erase failed at page address=0x%08x\n", __FUNCTION__, addr);
			int block_remap = 0x12345678;
            /* update BBT */
			if(check_BBT(page/ppb)==0)
a00075e8:	14400038 	bnez	v0,a00076cc <nand_erase_nand+0x214>
a00075ec:	afa3001c 	sw	v1,28(sp)
			{				
                for( i=0; i<RBA; i++){
a00075f0:	3c04a001 	lui	a0,0xa001
a00075f4:	8c867970 	lw	a2,31088(a0)
a00075f8:	10c00020 	beqz	a2,a000767c <nand_erase_nand+0x1c4>
a00075fc:	8ee77974 	lw	a3,31092(s7)
	                if ( bbt[i].bad_block == BB_INIT && bbt[i].remap_block != RB_INIT){
a0007600:	03c01021 	move	v0,s8
a0007604:	03c01821 	move	v1,s8
a0007608:	000210c0 	sll	v0,v0,0x3
a000760c:	00e22021 	addu	a0,a3,v0
a0007610:	94850002 	lhu	a1,2(a0)
a0007614:	14b00015 	bne	a1,s0,a000766c <nand_erase_nand+0x1b4>
a0007618:	3408fffd 	li	t0,0xfffd
a000761c:	94850006 	lhu	a1,6(a0)
a0007620:	10a80013 	beq	a1,t0,a0007670 <nand_erase_nand+0x1b8>
a0007624:	24630001 	addiu	v1,v1,1
		                err_chipnr = chipnr;
		                bbt[i].BB_die = err_chipnr;
a0007628:	a4800000 	sh	zero,0(a0)
		                bbt[i].bad_block = page/ppb;
a000762c:	8ee37974 	lw	v1,31092(s7)
a0007630:	00621821 	addu	v1,v1,v0
a0007634:	8e24754c 	lw	a0,30028(s1)
a0007638:	02a4001b 	divu	zero,s5,a0
a000763c:	008001f4 	teq	a0,zero,0x7
a0007640:	0000a812 	mflo	s5
a0007644:	a4750002 	sh	s5,2(v1)
		                err_chipnr_remap = bbt[i].RB_die;
		                block_remap = bbt[i].remap_block;
a0007648:	8ee37974 	lw	v1,31092(s7)
a000764c:	00621021 	addu	v0,v1,v0
a0007650:	94420006 	lhu	v0,6(v0)
a0007654:	afa2001c 	sw	v0,28(sp)
		                break;
	                }
                }

                if( block_remap == 0x12345678 ){
a0007658:	8fa30024 	lw	v1,36(sp)
a000765c:	1443000e 	bne	v0,v1,a0007698 <nand_erase_nand+0x1e0>
a0007660:	3c04a001 	lui	a0,0xa001
	                 printf("[%s] RBA do not have free remap block\n\r", __FUNCTION__);
a0007664:	08001da1 	j	a0007684 <nand_erase_nand+0x1cc>
a0007668:	24844ea4 	addiu	a0,a0,20132
		    printf("%s: block erase failed at page address=0x%08x\n", __FUNCTION__, addr);
			int block_remap = 0x12345678;
            /* update BBT */
			if(check_BBT(page/ppb)==0)
			{				
                for( i=0; i<RBA; i++){
a000766c:	24630001 	addiu	v1,v1,1
a0007670:	0066202b 	sltu	a0,v1,a2
a0007674:	1480ffe4 	bnez	a0,a0007608 <nand_erase_nand+0x150>
a0007678:	00601021 	move	v0,v1
		                break;
	                }
                }

                if( block_remap == 0x12345678 ){
	                 printf("[%s] RBA do not have free remap block\n\r", __FUNCTION__);
a000767c:	3c04a001 	lui	a0,0xa001
a0007680:	24844ea4 	addiu	a0,a0,20132
a0007684:	3c05a001 	lui	a1,0xa001
a0007688:	0c002325 	jal	a0008c94 <dprintf>
a000768c:	24a503c8 	addiu	a1,a1,968
	                 return FAIL;
a0007690:	08001e27 	j	a000789c <nand_erase_nand+0x3e4>
a0007694:	2402ffff 	li	v0,-1
                }

                dump_BBT();
a0007698:	0c001392 	jal	a0004e48 <dump_BBT>
a000769c:	00000000 	nop

                if ( rtk_update_bbt(bbt)){
a00076a0:	0c00154d 	jal	a0005534 <rtk_update_bbt>
a00076a4:	8ee47974 	lw	a0,31092(s7)
a00076a8:	10400009 	beqz	v0,a00076d0 <nand_erase_nand+0x218>
a00076ac:	8fa40018 	lw	a0,24(sp)
	                printf("[%s] rtk_update_bbt() fails\n", __FUNCTION__);
a00076b0:	3c04a001 	lui	a0,0xa001
a00076b4:	24844ecc 	addiu	a0,a0,20172
a00076b8:	3c05a001 	lui	a1,0xa001
a00076bc:	0c002325 	jal	a0008c94 <dprintf>
a00076c0:	24a503c8 	addiu	a1,a1,968
	                return FAIL;
a00076c4:	08001e27 	j	a000789c <nand_erase_nand+0x3e4>
a00076c8:	2402ffff 	li	v0,-1
                }
			}
		
		     if(!NAND_ADDR_CYCLE)
		     #ifdef SWAP_2K_DATA
			     NfSpareBuf[BBI_SWAP_OFFSET] = 0x00;
a00076cc:	8fa40018 	lw	a0,24(sp)
a00076d0:	a0800035 	sb	zero,53(a0)
				NfSpareBuf[0] = 0x00;
			 #endif
		     else
			     NfSpareBuf[5] = 0x00;
		
		     if ( isLastPage){
a00076d4:	3c05a002 	lui	a1,0xa002
a00076d8:	8ca2887c 	lw	v0,-30596(a1)
a00076dc:	10400021 	beqz	v0,a0007764 <nand_erase_nand+0x2ac>
a00076e0:	3c03a001 	lui	v1,0xa001
				 unsigned char *temp_buf = (unsigned char *)malloc(page_size);
a00076e4:	3c06a001 	lui	a2,0xa001
a00076e8:	0c001f55 	jal	a0007d54 <malloc>
a00076ec:	8cc47544 	lw	a0,30020(a2)
a00076f0:	0040a821 	move	s5,v0
				 memset(temp_buf,0xba,sizeof(char)*page_size);
a00076f4:	00402021 	move	a0,v0
a00076f8:	240500ba 	li	a1,186
a00076fc:	3c08a001 	lui	t0,0xa001
a0007700:	0c00203d 	jal	a00080f4 <memset>
a0007704:	8d067544 	lw	a2,30020(t0)
			     rtk_write_ecc_page_a(block*ppb+ppb-1,temp_buf ,&NfSpareBuf , page_size);
a0007708:	26940001 	addiu	s4,s4,1
a000770c:	8e24754c 	lw	a0,30028(s1)
a0007710:	72842002 	mul	a0,s4,a0
a0007714:	2484ffff 	addiu	a0,a0,-1
a0007718:	02a02821 	move	a1,s5
a000771c:	8fa60018 	lw	a2,24(sp)
a0007720:	3c02a001 	lui	v0,0xa001
a0007724:	0c0011da 	jal	a0004768 <rtk_write_ecc_page_a>
a0007728:	8c477544 	lw	a3,30020(v0)
			     rtk_write_ecc_page_a(block*ppb+ppb-2,temp_buf ,&NfSpareBuf , page_size);
a000772c:	8e22754c 	lw	v0,30028(s1)
a0007730:	7282a002 	mul	s4,s4,v0
a0007734:	2684fffe 	addiu	a0,s4,-2
a0007738:	02a02821 	move	a1,s5
a000773c:	8fa60018 	lw	a2,24(sp)
a0007740:	3c02a001 	lui	v0,0xa001
a0007744:	0c0011da 	jal	a0004768 <rtk_write_ecc_page_a>
a0007748:	8c477544 	lw	a3,30020(v0)
	             if(temp_buf)
a000774c:	12a00020 	beqz	s5,a00077d0 <nand_erase_nand+0x318>
a0007750:	00000000 	nop
                     free(temp_buf);				 
a0007754:	0c001f86 	jal	a0007e18 <free>
a0007758:	02a02021 	move	a0,s5
				 if(temp_buf)
					 free(temp_buf);

		     }
			 //erase the remapping block!!
			 rc = rtk_erase_block_a(block_remap*ppb);
a000775c:	08001df5 	j	a00077d4 <nand_erase_nand+0x31c>
a0007760:	8e24754c 	lw	a0,30028(s1)
			     rtk_write_ecc_page_a(block*ppb+ppb-1,temp_buf ,&NfSpareBuf , page_size);
			     rtk_write_ecc_page_a(block*ppb+ppb-2,temp_buf ,&NfSpareBuf , page_size);
	             if(temp_buf)
                     free(temp_buf);				 
		     }else{
				 unsigned char *temp_buf = (unsigned char *)malloc(page_size);
a0007764:	0c001f55 	jal	a0007d54 <malloc>
a0007768:	8c647544 	lw	a0,30020(v1)
a000776c:	0040a821 	move	s5,v0
				 memset(temp_buf,0xba,sizeof(char)*page_size);
a0007770:	00402021 	move	a0,v0
a0007774:	240500ba 	li	a1,186
a0007778:	3c08a001 	lui	t0,0xa001
a000777c:	0c00203d 	jal	a00080f4 <memset>
a0007780:	8d067544 	lw	a2,30020(t0)
			     rtk_write_ecc_page_a(block*ppb,temp_buf ,&NfSpareBuf , page_size);
a0007784:	8e24754c 	lw	a0,30028(s1)
a0007788:	72842002 	mul	a0,s4,a0
a000778c:	02a02821 	move	a1,s5
a0007790:	8fa60018 	lw	a2,24(sp)
a0007794:	3c02a001 	lui	v0,0xa001
a0007798:	0c0011da 	jal	a0004768 <rtk_write_ecc_page_a>
a000779c:	8c477544 	lw	a3,30020(v0)
			     rtk_write_ecc_page_a(block*ppb+1,temp_buf ,&NfSpareBuf , page_size);
a00077a0:	8e24754c 	lw	a0,30028(s1)
a00077a4:	72842002 	mul	a0,s4,a0
a00077a8:	24840001 	addiu	a0,a0,1
a00077ac:	02a02821 	move	a1,s5
a00077b0:	8fa60018 	lw	a2,24(sp)
a00077b4:	3c02a001 	lui	v0,0xa001
a00077b8:	0c0011da 	jal	a0004768 <rtk_write_ecc_page_a>
a00077bc:	8c477544 	lw	a3,30020(v0)
				 if(temp_buf)
a00077c0:	12a00003 	beqz	s5,a00077d0 <nand_erase_nand+0x318>
a00077c4:	00000000 	nop
					 free(temp_buf);
a00077c8:	0c001f86 	jal	a0007e18 <free>
a00077cc:	02a02021 	move	a0,s5

		     }
			 //erase the remapping block!!
			 rc = rtk_erase_block_a(block_remap*ppb);
a00077d0:	8e24754c 	lw	a0,30028(s1)
a00077d4:	8fa2001c 	lw	v0,28(sp)
a00077d8:	0c001048 	jal	a0004120 <rtk_erase_block_a>
a00077dc:	70442002 	mul	a0,v0,a0
			 
		}
		
			
		elen += block_size;
a00077e0:	8ec37524 	lw	v1,29988(s6)
a00077e4:	02439021 	addu	s2,s2,v1

		old_page += ppb;
		
		if ( elen<len && !(old_page & pagemask)) {
a00077e8:	8fa4005c 	lw	a0,92(sp)
a00077ec:	0244182b 	sltu	v1,s2,a0
a00077f0:	1060002a 	beqz	v1,a000789c <nand_erase_nand+0x3e4>
a00077f4:	8e34754c 	lw	s4,30028(s1)
		}
		
			
		elen += block_size;

		old_page += ppb;
a00077f8:	02749821 	addu	s3,s3,s4
		
		if ( elen<len && !(old_page & pagemask)) {
a00077fc:	3c05a002 	lui	a1,0xa002
a0007800:	8ca28874 	lw	v0,-30604(a1)
a0007804:	02621024 	and	v0,s3,v0
a0007808:	0042980a 	movz	s3,v0,v0
			old_page &= pagemask;
		}

		block = old_page/ppb;
a000780c:	0274001b 	divu	zero,s3,s4
a0007810:	028001f4 	teq	s4,zero,0x7
a0007814:	08001e1e 	j	a0007878 <nand_erase_nand+0x3c0>
a0007818:	0000a012 	mflo	s4
	addr = real_addr;
	//printf("%s: blockr:%x addr:%x pagemask%x \n\r",__FUNCTION__,bbt_v2r[i].block_r, addr,pagemask);
	}
	realpage = (int) (addr >> page_shift);
	chipnr = chipnr_remap = 0;
	old_page = page = realpage & pagemask;
a000781c:	8fa20020 	lw	v0,32(sp)
a0007820:	02629806 	srlv	s3,v0,s3
a0007824:	02639824 	and	s3,s3,v1
	page_offset = page & (ppb-1);
	block = page/ppb;
a0007828:	0274001b 	divu	zero,s3,s4
a000782c:	028001f4 	teq	s4,zero,0x7
a0007830:	0000a012 	mflo	s4
		return FAIL;
	}
	
 	while (elen < len) {
		for ( i=0; i<RBA; i++){			
			if ( bbt[i].bad_block != BB_INIT ){
a0007834:	3c17a001 	lui	s7,0xa001
a0007838:	3410fffe 	li	s0,0xfffe
a000783c:	0000f021 	move	s8,zero
				}			
			}else				
			break;		
		}

		page = block*ppb;
a0007840:	3c11a001 	lui	s1,0xa001
		//printf("Ready to Erase blk %x\n\r",page/ppb);
		
		rc = rtk_erase_block_a(page);
			
		if (rc) {
		    printf("%s: block erase failed at page address=0x%08x\n", __FUNCTION__, addr);
a0007844:	3c02a001 	lui	v0,0xa001
a0007848:	24424ffc 	addiu	v0,v0,20476
a000784c:	afa20028 	sw	v0,40(sp)
a0007850:	3c02a001 	lui	v0,0xa001
a0007854:	244203c8 	addiu	v0,v0,968
a0007858:	afa2002c 	sw	v0,44(sp)
                }
			}
		
		     if(!NAND_ADDR_CYCLE)
		     #ifdef SWAP_2K_DATA
			     NfSpareBuf[BBI_SWAP_OFFSET] = 0x00;
a000785c:	3c02a002 	lui	v0,0xa002
a0007860:	2442a268 	addiu	v0,v0,-23960
a0007864:	afa20018 	sw	v0,24(sp)

                dump_BBT();

                if ( rtk_update_bbt(bbt)){
	                printf("[%s] rtk_update_bbt() fails\n", __FUNCTION__);
	                return FAIL;
a0007868:	3c021234 	lui	v0,0x1234
a000786c:	34425678 	ori	v0,v0,0x5678
a0007870:	afa20024 	sw	v0,36(sp)
			 rc = rtk_erase_block_a(block_remap*ppb);
			 
		}
		
			
		elen += block_size;
a0007874:	3c16a001 	lui	s6,0xa001
		printf("%s: Attempt erase beyond end of device add:%x len:%x cs:%x\n\r",__FUNCTION__,addr,len,chip_size);
		return FAIL;
	}
	
 	while (elen < len) {
		for ( i=0; i<RBA; i++){			
a0007878:	3c02a001 	lui	v0,0xa001
a000787c:	8c467970 	lw	a2,31088(v0)
a0007880:	10c0ff49 	beqz	a2,a00075a8 <nand_erase_nand+0xf0>
a0007884:	8ee57974 	lw	a1,31092(s7)
			if ( bbt[i].bad_block != BB_INIT ){
a0007888:	94a30002 	lhu	v1,2(a1)
a000788c:	1070ff46 	beq	v1,s0,a00075a8 <nand_erase_nand+0xf0>
a0007890:	24a20008 	addiu	v0,a1,8
a0007894:	08001d63 	j	a000758c <nand_erase_nand+0xd4>
a0007898:	03c02021 	move	a0,s8

		block = old_page/ppb;
	}

	return rc;
}  
a000789c:	8fbf0054 	lw	ra,84(sp)
a00078a0:	8fbe0050 	lw	s8,80(sp)
a00078a4:	8fb7004c 	lw	s7,76(sp)
a00078a8:	8fb60048 	lw	s6,72(sp)
a00078ac:	8fb50044 	lw	s5,68(sp)
a00078b0:	8fb40040 	lw	s4,64(sp)
a00078b4:	8fb3003c 	lw	s3,60(sp)
a00078b8:	8fb20038 	lw	s2,56(sp)
a00078bc:	8fb10034 	lw	s1,52(sp)
a00078c0:	8fb00030 	lw	s0,48(sp)
a00078c4:	03e00008 	jr	ra
a00078c8:	27bd0058 	addiu	sp,sp,88
a00078cc:	00000000 	nop

a00078d0 <init_icache>:
	#define KSEG0BASE                 0x80000000
	#define CONFIG_SYS_CACHELINE_SIZE 32

	unsigned int t;
	t=0;
	write_32bit_cp0_register_sel( 29,t, 0);  //CP0_ITagHi
a00078d0:	00001021 	move	v0,zero
a00078d4:	00424825 	or	t1,v0,v0
a00078d8:	4089e800 	mtc0	t1,c0_taghi
a00078dc:	00000040 	ssnop
a00078e0:	00000040 	ssnop
a00078e4:	00000040 	ssnop
a00078e8:	00000040 	ssnop
	write_32bit_cp0_register_sel( 28,t, 0);  //CP0_ITagLo
a00078ec:	00424825 	or	t1,v0,v0
a00078f0:	4089e000 	mtc0	t1,c0_taglo
a00078f4:	00000040 	ssnop
a00078f8:	00000040 	ssnop
a00078fc:	00000040 	ssnop
a0007900:	00000040 	ssnop
	unsigned long addr = KSEG0BASE;
	unsigned long aend = addr+(64<<10)-lsize;   //DCACHE=64K

	while (1) 
	{
		cache_op(Index_Store_Tag_I, addr);
a0007904:	3c028000 	lui	v0,0x8000
a0007908:	bc480000 	cache	0x8,0(v0)
		if (addr >= aend)
a000790c:	3c048000 	lui	a0,0x8000
a0007910:	3483ffe0 	ori	v1,a0,0xffe0
			break;
		addr += lsize;
a0007914:	24420020 	addiu	v0,v0,32
	unsigned long addr = KSEG0BASE;
	unsigned long aend = addr+(64<<10)-lsize;   //DCACHE=64K

	while (1) 
	{
		cache_op(Index_Store_Tag_I, addr);
a0007918:	bc480000 	cache	0x8,0(v0)
		if (addr >= aend)
a000791c:	1443fffe 	bne	v0,v1,a0007918 <init_icache+0x48>
a0007920:	24420020 	addiu	v0,v0,32
			break;
		addr += lsize;
	}

}
a0007924:	03e00008 	jr	ra
a0007928:	00000000 	nop

a000792c <init_dcache>:
	#define KSEG0BASE                 0x80000000
	#define CONFIG_SYS_CACHELINE_SIZE 32

	unsigned int t;
	t=0;
	write_32bit_cp0_register_sel( 29, t, 2);  //CP0_DTagHi
a000792c:	00001021 	move	v0,zero
a0007930:	00424825 	or	t1,v0,v0
a0007934:	4089e802 	mtc0	t1,c0_taghi1
a0007938:	00000040 	ssnop
a000793c:	00000040 	ssnop
a0007940:	00000040 	ssnop
a0007944:	00000040 	ssnop
	write_32bit_cp0_register_sel( 28, t, 2);  //CP0_DTagLo
a0007948:	00424825 	or	t1,v0,v0
a000794c:	4089e002 	mtc0	t1,c0_taglo1
a0007950:	00000040 	ssnop
a0007954:	00000040 	ssnop
a0007958:	00000040 	ssnop
a000795c:	00000040 	ssnop
	unsigned long addr = KSEG0BASE;
	unsigned long aend = addr+(32<<10)-lsize;   //DCACHE=32K

	while (1) 
	{
		cache_op(Index_Store_Tag_D, addr);
a0007960:	3c028000 	lui	v0,0x8000
a0007964:	bc490000 	cache	0x9,0(v0)
		if (addr >= aend)
a0007968:	3c048000 	lui	a0,0x8000
a000796c:	34837fe0 	ori	v1,a0,0x7fe0
			break;
		addr += lsize;
a0007970:	24420020 	addiu	v0,v0,32
	unsigned long addr = KSEG0BASE;
	unsigned long aend = addr+(32<<10)-lsize;   //DCACHE=32K

	while (1) 
	{
		cache_op(Index_Store_Tag_D, addr);
a0007974:	bc490000 	cache	0x9,0(v0)
		if (addr >= aend)
a0007978:	1443fffe 	bne	v0,v1,a0007974 <init_dcache+0x48>
a000797c:	24420020 	addiu	v0,v0,32
			break;
		addr += lsize;
	}

}
a0007980:	03e00008 	jr	ra
a0007984:	00000000 	nop

a0007988 <enable_flash_mapping>:
//============================================================================
enable_flash_mapping()
{
	REG32(0xb8001000)&=~(1<<18);
a0007988:	3c02b800 	lui	v0,0xb800
a000798c:	34421000 	ori	v0,v0,0x1000
a0007990:	8c440000 	lw	a0,0(v0)
a0007994:	3c03fffb 	lui	v1,0xfffb
a0007998:	3463ffff 	ori	v1,v1,0xffff
a000799c:	00831824 	and	v1,a0,v1
a00079a0:	ac430000 	sw	v1,0(v0)
}
a00079a4:	03e00008 	jr	ra
a00079a8:	00000000 	nop

a00079ac <init_cpu_config>:
init_cpu_config()
{
	unsigned int s;
#if 1	
	//setting K23, KU, MM
	s = read_32bit_cp0_register(CP0_CONFIG);
a00079ac:	40038000 	mfc0	v1,c0_config
	s &= ~((3<<28) | (3<<25) | (1<<18));
a00079b0:	3c02c9fb 	lui	v0,0xc9fb
a00079b4:	3442ffff 	ori	v0,v0,0xffff
a00079b8:	00621024 	and	v0,v1,v0
	s |=  ((3<<28) | (3<<25) | (1<<18));
	write_32bit_cp0_register(CP0_CONFIG, s);
a00079bc:	3c033604 	lui	v1,0x3604
a00079c0:	00431025 	or	v0,v0,v1
a00079c4:	40828000 	mtc0	v0,c0_config
a00079c8:	00000040 	ssnop
a00079cc:	00000040 	ssnop
a00079d0:	00000040 	ssnop
a00079d4:	00000040 	ssnop
	//set_cp0_config(0x07, 2); //2:uncache
	//set_cp0_config(0x07, 3); //3:cache
#endif

	
	s = read_32bit_cp0_register(CP0_STATUS);
a00079d8:	40036000 	mfc0	v1,c0_status
	s &= ~(ST0_CU1|ST0_CU2|ST0_CU3);
a00079dc:	3c021fff 	lui	v0,0x1fff
a00079e0:	3442ffff 	ori	v0,v0,0xffff
a00079e4:	00621024 	and	v0,v1,v0
	s |= ST0_CU0;
	write_32bit_cp0_register(CP0_STATUS, s);
a00079e8:	3c031000 	lui	v1,0x1000
a00079ec:	00431025 	or	v0,v0,v1
a00079f0:	40826000 	mtc0	v0,c0_status
a00079f4:	00000040 	ssnop
a00079f8:	00000040 	ssnop
a00079fc:	00000040 	ssnop
a0007a00:	00000040 	ssnop
a0007a04:	000000c0 	ehb
#endif
	

//	sys_init_icache();
//	sys_init_dcache();	
}
a0007a08:	03e00008 	jr	ra
a0007a0c:	00000000 	nop

a0007a10 <enable_GIC_mapping>:
//============================================================================

enable_GIC_mapping()
{
	//setting GIC base
	REG32(GCR_BASE_ADDR+0x0080)=Virtual2Physical(GIC_BASE_ADDR)|0x01;
a0007a10:	3c02bfbf 	lui	v0,0xbfbf
a0007a14:	34438080 	ori	v1,v0,0x8080
a0007a18:	3c041bdc 	lui	a0,0x1bdc
a0007a1c:	34840001 	ori	a0,a0,0x1
a0007a20:	ac640000 	sw	a0,0(v1)

	REG32(GCR_BASE_ADDR+0x0088)=Virtual2Physical(CPC_BASE_ADDR)|0x01;
a0007a24:	34428088 	ori	v0,v0,0x8088
a0007a28:	3c031bde 	lui	v1,0x1bde
a0007a2c:	34630001 	ori	v1,v1,0x1
a0007a30:	ac430000 	sw	v1,0(v0)


	//IP inverter
	REG32(GIC_BASE_ADDR+0x100)=0xffffffff;
a0007a34:	3c02bbdc 	lui	v0,0xbbdc
a0007a38:	34430100 	ori	v1,v0,0x100
a0007a3c:	2404ffff 	li	a0,-1
a0007a40:	ac640000 	sw	a0,0(v1)
	REG32(GIC_BASE_ADDR+0x104)=0x0003FFFF;	
a0007a44:	34420104 	ori	v0,v0,0x104
a0007a48:	3c030003 	lui	v1,0x3
a0007a4c:	3463ffff 	ori	v1,v1,0xffff
a0007a50:	ac430000 	sw	v1,0(v0)
	//map2pin
	//REG32(GIC_BASE_ADDR+0x500)=0x80000000;

	//map2vpe
	//REG32(GIC_BASE_ADDR+0x2000)=0x1;
}
a0007a54:	03e00008 	jr	ra
a0007a58:	00000000 	nop

a0007a5c <init_arch>:

//============================================================================
	
asmlinkage void init_arch(int argc, char **argv, char **envp, int *prom_vec)
{
a0007a5c:	27bdffe8 	addiu	sp,sp,-24
a0007a60:	afbf0014 	sw	ra,20(sp)
	//init_icache();
	//init_icache();		
	
	enable_flash_mapping();	
a0007a64:	0c001e62 	jal	a0007988 <enable_flash_mapping>
a0007a68:	00000000 	nop
	init_cpu_config();	
a0007a6c:	0c001e6b 	jal	a00079ac <init_cpu_config>
a0007a70:	00000000 	nop
	enable_GIC_mapping();
a0007a74:	0c001e84 	jal	a0007a10 <enable_GIC_mapping>
a0007a78:	00000000 	nop
#ifdef CONFIG_NAND_FLASH_BOOTING
	jmp=((int)start_kernel); //jump to un cache address
#else
	jmp=((int)start_kernel)& ~UNCACHE_MASK;
#endif
	jmp();
a0007a7c:	0c001f04 	jal	a0007c10 <start_kernel>
a0007a80:	00000000 	nop
}
a0007a84:	8fbf0014 	lw	ra,20(sp)
a0007a88:	03e00008 	jr	ra
a0007a8c:	27bd0018 	addiu	sp,sp,24

a0007a90 <flush_dcache_range>:
		if (addr == aend)
			break;
		addr += lsize;
	}
#endif
}
a0007a90:	03e00008 	jr	ra
a0007a94:	00000000 	nop

a0007a98 <flush_cache_range>:
		if (addr == aend)
			break;
		addr += lsize;
	}
#endif
}
a0007a98:	03e00008 	jr	ra
a0007a9c:	00000000 	nop

a0007aa0 <invalidate_dcache_range>:
		if (addr == aend)
			break;
		addr += lsize;
	}
#endif
}
a0007aa0:	03e00008 	jr	ra
a0007aa4:	00000000 	nop

a0007aa8 <invalidate_icache_range>:
		if (addr == aend)
			break;
		addr += lsize;
	}
#endif
}
a0007aa8:	03e00008 	jr	ra
a0007aac:	00000000 	nop

a0007ab0 <invalidate_cache>:
#ifndef CONFIG_NAND_FLASH_BOOTING
	#define START_ADDR 0x80000000
	invalidate_dcache_range(START_ADDR, START_ADDR+_DCACHE_SIZE);
	invalidate_icache_range(START_ADDR, START_ADDR+_ICACHE_SIZE);	
#endif
}
a0007ab0:	03e00008 	jr	ra
a0007ab4:	00000000 	nop

a0007ab8 <flush_cache>:
	flush_cache_range(START_ADDR, _DCACHE_SIZE);
	//flush_dcache_range(START_ADDR, START_ADDR+_DCACHE_SIZE);
#endif	
	//winfred_wang
	invalidate_cache();
}
a0007ab8:	03e00008 	jr	ra
a0007abc:	00000000 	nop

a0007ac0 <showBoardInfo>:
}

//-------------------------------------------------------
//show board info
void showBoardInfo(void)
{
a0007ac0:	27bdffc8 	addiu	sp,sp,-56
a0007ac4:	afbf0034 	sw	ra,52(sp)
a0007ac8:	afb10030 	sw	s1,48(sp)
a0007acc:	afb0002c 	sw	s0,44(sp)
	volatile int cpu_speed = 0;
a0007ad0:	afa00020 	sw	zero,32(sp)
a0007ad4:	40097801 	mfc0	t1,c0_ebase
	int cpu_num=read_32bit_cp0_register_sel(15, 1)&0x3f;
a0007ad8:	01298825 	or	s1,t1,t1
a0007adc:	3231003f 	andi	s1,s1,0x3f
#if 1//patch for ESD
        REG32(0xb800311c)=0xa5000000;	
a0007ae0:	3c10b800 	lui	s0,0xb800
a0007ae4:	3602311c 	ori	v0,s0,0x311c
a0007ae8:	3c03a500 	lui	v1,0xa500
a0007aec:	ac430000 	sw	v1,0(v0)
#endif
#if 1
	#define SYS_INT_STATUS 0xb8000004
	REG32(SYS_INT_STATUS)=(1<<1);  //clear wakeup interrupt	
a0007af0:	36020004 	ori	v0,s0,0x4
a0007af4:	24030002 	li	v1,2
a0007af8:	ac430000 	sw	v1,0(v0)
	REG32(SYS_INT_STATUS)=(1<<1);  //clear wakeup interrupt	
#endif

	//REG32(0xb8000010)|=0xffff800;
#ifdef CONFIG_NAND_FLASH_BOOTING 
	cpu_speed = check_cpu_speed();	
a0007afc:	0c003edc 	jal	a000fb70 <check_cpu_speed>
a0007b00:	ac430000 	sw	v1,0(v0)
a0007b04:	afa20020 	sw	v0,32(sp)
	cpu_speed = 450 + ((REG32(SYS_HW_STRAP) & 0x78000) >> 15) * 50;
a0007b08:	36100008 	ori	s0,s0,0x8
a0007b0c:	8e020000 	lw	v0,0(s0)
a0007b10:	3c030007 	lui	v1,0x7
a0007b14:	34638000 	ori	v1,v1,0x8000
a0007b18:	00431824 	and	v1,v0,v1
a0007b1c:	00031bc2 	srl	v1,v1,0xf
a0007b20:	00031040 	sll	v0,v1,0x1
a0007b24:	000318c0 	sll	v1,v1,0x3
a0007b28:	00431021 	addu	v0,v0,v1
a0007b2c:	00021880 	sll	v1,v0,0x2
a0007b30:	00431021 	addu	v0,v0,v1
a0007b34:	244201c2 	addiu	v0,v0,450
a0007b38:	afa20020 	sw	v0,32(sp)
#endif
#if defined(CONFIG_NAND_FLASH_BOOTING)
	#if defined(CONFIG_DDR2_SDRAM)
		prom_printf("DDR2:");
	#elif defined(CONFIG_DDR3_SDRAM)
		prom_printf("DDR3:");
a0007b3c:	3c04a001 	lui	a0,0xa001
a0007b40:	0c0023a7 	jal	a0008e9c <prom_printf>
a0007b44:	248450fc 	addiu	a0,a0,20732
	#elif defined(CONFIG_DDR2_64MB_16bit)
		prom_printf("64 MB\n");
	#elif defined(CONFIG_DDR2_128MB_16bit)
		prom_printf("128 MB\n");
	#elif defined(CONFIG_DDR3_128MB_16bit)
		prom_printf("128 MB\n");
a0007b48:	3c04a001 	lui	a0,0xa001
a0007b4c:	0c0023a7 	jal	a0008e9c <prom_printf>
a0007b50:	24845104 	addiu	a0,a0,20740

	#define POLLING_REG 0xb800006c
  	#define PATT_SLEEP  0x3333		
  	#define PATT_READY  0x5555
		
	prom_printf("%s",((*(volatile unsigned int *)(0xb8000008)) & (0x1<<22))?"Reboot Result from Watchdog Timeout!\n":" ");
a0007b54:	8e020000 	lw	v0,0(s0)
a0007b58:	7c420580 	ext	v0,v0,0x16,0x1
a0007b5c:	14400003 	bnez	v0,a0007b6c <showBoardInfo+0xac>
a0007b60:	3c05a001 	lui	a1,0xa001
a0007b64:	08001edd 	j	a0007b74 <showBoardInfo+0xb4>
a0007b68:	24a54d14 	addiu	a1,a1,19732
a0007b6c:	3c05a001 	lui	a1,0xa001
a0007b70:	24a5510c 	addiu	a1,a1,20748
a0007b74:	3c04a001 	lui	a0,0xa001
a0007b78:	0c0023a7 	jal	a0008e9c <prom_printf>
a0007b7c:	248442bc 	addiu	a0,a0,17084
	
	prom_printf("\n---Realtek RTL8198C boot code at %s %s (%dMHz) [C%d running][C%d %s]\n", BOOT_CODE_TIME,B_VERSION,  cpu_speed, cpu_num, 1-cpu_num, 
a0007b80:	8fa70020 	lw	a3,32(sp)
	(REG32(POLLING_REG)==PATT_SLEEP)  ? "sleep": 
a0007b84:	3c02b800 	lui	v0,0xb800
a0007b88:	3442006c 	ori	v0,v0,0x6c
a0007b8c:	8c430000 	lw	v1,0(v0)
  	#define PATT_SLEEP  0x3333		
  	#define PATT_READY  0x5555
		
	prom_printf("%s",((*(volatile unsigned int *)(0xb8000008)) & (0x1<<22))?"Reboot Result from Watchdog Timeout!\n":" ");
	
	prom_printf("\n---Realtek RTL8198C boot code at %s %s (%dMHz) [C%d running][C%d %s]\n", BOOT_CODE_TIME,B_VERSION,  cpu_speed, cpu_num, 1-cpu_num, 
a0007b90:	24023333 	li	v0,13107
a0007b94:	14620004 	bne	v1,v0,a0007ba8 <showBoardInfo+0xe8>
a0007b98:	3c02b800 	lui	v0,0xb800
a0007b9c:	3c03a001 	lui	v1,0xa001
a0007ba0:	08001ef3 	j	a0007bcc <showBoardInfo+0x10c>
a0007ba4:	24635134 	addiu	v1,v1,20788
	(REG32(POLLING_REG)==PATT_SLEEP)  ? "sleep": 
	(REG32(POLLING_REG)==PATT_READY)  ? "ready":	"miss"	);	
a0007ba8:	3442006c 	ori	v0,v0,0x6c
a0007bac:	8c430000 	lw	v1,0(v0)
  	#define PATT_SLEEP  0x3333		
  	#define PATT_READY  0x5555
		
	prom_printf("%s",((*(volatile unsigned int *)(0xb8000008)) & (0x1<<22))?"Reboot Result from Watchdog Timeout!\n":" ");
	
	prom_printf("\n---Realtek RTL8198C boot code at %s %s (%dMHz) [C%d running][C%d %s]\n", BOOT_CODE_TIME,B_VERSION,  cpu_speed, cpu_num, 1-cpu_num, 
a0007bb0:	24025555 	li	v0,21845
a0007bb4:	10620003 	beq	v1,v0,a0007bc4 <showBoardInfo+0x104>
a0007bb8:	3c03a001 	lui	v1,0xa001
a0007bbc:	08001ef3 	j	a0007bcc <showBoardInfo+0x10c>
a0007bc0:	2463513c 	addiu	v1,v1,20796
a0007bc4:	3c03a001 	lui	v1,0xa001
a0007bc8:	24635144 	addiu	v1,v1,20804
a0007bcc:	afb10010 	sw	s1,16(sp)
a0007bd0:	24020001 	li	v0,1
a0007bd4:	00518823 	subu	s1,v0,s1
a0007bd8:	afb10014 	sw	s1,20(sp)
a0007bdc:	afa30018 	sw	v1,24(sp)
a0007be0:	3c04a001 	lui	a0,0xa001
a0007be4:	2484514c 	addiu	a0,a0,20812
a0007be8:	3c05a001 	lui	a1,0xa001
a0007bec:	24a55194 	addiu	a1,a1,20884
a0007bf0:	3c06a001 	lui	a2,0xa001
a0007bf4:	0c0023a7 	jal	a0008e9c <prom_printf>
a0007bf8:	24c67550 	addiu	a2,a2,30032
	(REG32(POLLING_REG)==PATT_SLEEP)  ? "sleep": 
	(REG32(POLLING_REG)==PATT_READY)  ? "ready":	"miss"	);	

    //cpu_num=read_32bit_cp0_register_sel(15, 1)&0x3f;
	//prom_printf("cpu id=%x\n",cpu_num);	
}
a0007bfc:	8fbf0034 	lw	ra,52(sp)
a0007c00:	8fb10030 	lw	s1,48(sp)
a0007c04:	8fb0002c 	lw	s0,44(sp)
a0007c08:	03e00008 	jr	ra
a0007c0c:	27bd0038 	addiu	sp,sp,56

a0007c10 <start_kernel>:
	return 1;
}
#endif

void start_kernel(void)
{
a0007c10:	27bdffd0 	addiu	sp,sp,-48
a0007c14:	afbf002c 	sw	ra,44(sp)

	int ret;

	gCHKKEY_HIT = 0;
a0007c18:	3c02a002 	lui	v0,0xa002
a0007c1c:	ac408950 	sw	zero,-30384(v0)
	gCHKKEY_CNT = 0;
a0007c20:	3c02a002 	lui	v0,0xa002
a0007c24:	ac408954 	sw	zero,-30380(v0)

#ifdef CONFIG_NAND_FLASH_BOOTING 
    //for piggy.bin debug safe
    //debug cl because of no bss clear when use boot_test directly, global init.
#ifdef CONFIG_RTK_NAND_BBT
	read_has_check_bbt = 0;
a0007c28:	3c02a002 	lui	v0,0xa002
a0007c2c:	ac408888 	sw	zero,-30584(v0)
	write_has_check_bbt = 0;
a0007c30:	3c02a002 	lui	v0,0xa002
a0007c34:	ac40888c 	sw	zero,-30580(v0)
	erase_has_check_bbt = 0;
a0007c38:	3c02a002 	lui	v0,0xa002
a0007c3c:	ac408890 	sw	zero,-30576(v0)
	static_for_create_v2r_bbt = 0;
a0007c40:	3c02a002 	lui	v0,0xa002
a0007c44:	ac408884 	sw	zero,-30588(v0)
	RBA = 0;
a0007c48:	3c02a001 	lui	v0,0xa001
a0007c4c:	ac407970 	sw	zero,31088(v0)
	bbt = NULL;
a0007c50:	3c02a001 	lui	v0,0xa001
a0007c54:	ac407974 	sw	zero,31092(v0)
	bbt_v2r = NULL;
a0007c58:	3c02a001 	lui	v0,0xa001
a0007c5c:	ac40796c 	sw	zero,31084(v0)
#endif
	jump_to_test = 0;
a0007c60:	3c02a001 	lui	v0,0xa001

	IMG_HEADER_T header;
	SETTING_HEADER_T setting_header;

//-------------------------------------------------------
	setClkInitConsole();
a0007c64:	0c0036ad 	jal	a000dab4 <setClkInitConsole>
a0007c68:	ac407ac0 	sw	zero,31424(v0)

	initHeap();
a0007c6c:	0c0036c0 	jal	a000db00 <initHeap>
a0007c70:	00000000 	nop
		
	initInterrupt();
a0007c74:	0c0002f4 	jal	a0000bd0 <initInterrupt>
a0007c78:	00000000 	nop

	initFlash();
a0007c7c:	0c0036b5 	jal	a000dad4 <initFlash>
a0007c80:	00000000 	nop

#if defined(CONFIG_POST_ENABLE)
	ret = POSTRW_API();
#endif	

	showBoardInfo();
a0007c84:	0c001eb0 	jal	a0007ac0 <showBoardInfo>
a0007c88:	00000000 	nop
	if(ret == 0)
		return;
#endif

#ifdef CONFIG_BOOT_RESET_ENABLE	
	RTL_W32(RTL_GPIO_MUX4, (RTL_R32(RTL_GPIO_MUX4) | (RTL_GPIO_RESET_BTN_MUX))); 
a0007c8c:	3c02b800 	lui	v0,0xb800
a0007c90:	3443010c 	ori	v1,v0,0x10c
a0007c94:	8c650000 	lw	a1,0(v1)
a0007c98:	3c040180 	lui	a0,0x180
a0007c9c:	00a42025 	or	a0,a1,a0
a0007ca0:	ac640000 	sw	a0,0(v1)
	RTL_W32(RESET_PIN_IOBASE, (RTL_R32(RESET_PIN_IOBASE) & (~(1 << RESET_BTN_PIN))));
a0007ca4:	3444351c 	ori	a0,v0,0x351c
a0007ca8:	8c850000 	lw	a1,0(a0)
a0007cac:	3c03dfff 	lui	v1,0xdfff
a0007cb0:	3463ffff 	ori	v1,v1,0xffff
a0007cb4:	00a32824 	and	a1,a1,v1
a0007cb8:	ac850000 	sw	a1,0(a0)
	RTL_W32(RESET_PIN_DIRBASE, (RTL_R32(RESET_PIN_DIRBASE) & (~(1 << RESET_BTN_PIN))));
a0007cbc:	34423524 	ori	v0,v0,0x3524
a0007cc0:	8c440000 	lw	a0,0(v0)
a0007cc4:	00831824 	and	v1,a0,v1
a0007cc8:	ac430000 	sw	v1,0(v0)
	eth_startup(0); 
	sti();			
	tftpd_entry(1);
#endif

	return_addr=0;
a0007ccc:	3c02a001 	lui	v0,0xa001
a0007cd0:	ac407978 	sw	zero,31096(v0)
	ret=check_image	(&header,&setting_header);
a0007cd4:	27a40010 	addiu	a0,sp,16
a0007cd8:	0c0038a4 	jal	a000e290 <check_image>
a0007cdc:	27a50020 	addiu	a1,sp,32

#ifdef CONFIG_NAND_FLASH
 	#define MAX_MOUNT_ROOTFS_TIMES	5
	if(REG32(0xb8019004) > MAX_MOUNT_ROOTFS_TIMES){
a0007ce0:	3c03b801 	lui	v1,0xb801
a0007ce4:	34639004 	ori	v1,v1,0x9004
a0007ce8:	8c630000 	lw	v1,0(v1)
a0007cec:	2c630006 	sltiu	v1,v1,6
a0007cf0:	14600006 	bnez	v1,a0007d0c <start_kernel+0xfc>
a0007cf4:	00402021 	move	a0,v0
		REG32(0xb8019004) = 0;
a0007cf8:	3c02b801 	lui	v0,0xb801
a0007cfc:	34429004 	ori	v0,v0,0x9004
a0007d00:	ac400000 	sw	zero,0(v0)
a0007d04:	00001021 	move	v0,zero
		ret = 0;
	}
#endif
	doBooting(ret, return_addr, &header);
a0007d08:	00402021 	move	a0,v0
a0007d0c:	3c02a001 	lui	v0,0xa001
a0007d10:	8c457978 	lw	a1,31096(v0)
a0007d14:	0c003743 	jal	a000dd0c <doBooting>
a0007d18:	27a60010 	addiu	a2,sp,16
}
a0007d1c:	8fbf002c 	lw	ra,44(sp)
a0007d20:	03e00008 	jr	ra
a0007d24:	27bd0030 	addiu	sp,sp,48
	...

a0007d30 <i_alloc>:
        _heapstart is the first byte allocated to the heap.
        _heapend is the last.
*/
{
        /* initialize the allocator */
        frhd = (HEADER *) _heapstart;
a0007d30:	3c02a002 	lui	v0,0xa002
a0007d34:	ac4488a0 	sw	a0,-30560(v0)
        frhd->ptr = NULL;
a0007d38:	ac800000 	sw	zero,0(a0)
        frhd->size = (_heapend - _heapstart) / sizeof(HEADER);
a0007d3c:	00a42823 	subu	a1,a1,a0
a0007d40:	000528c2 	srl	a1,a1,0x3
a0007d44:	ac850004 	sw	a1,4(a0)
        memleft = frhd->size; /* initial size in 4-byte units */
a0007d48:	3c02a002 	lui	v0,0xa002
}
a0007d4c:	03e00008 	jr	ra
a0007d50:	ac4588a4 	sw	a1,-30556(v0)

a0007d54 <malloc>:
                enough. If block is larger than needed, break                           
                the block into two pieces and allocate the                              
                portion higher up in memory. Otherwise, just
                allocate the entire block.
        */
        for (prev=NULL,nxt=frhd; nxt; nxt = nxt->ptr)
a0007d54:	27bdffe8 	addiu	sp,sp,-24
a0007d58:	afbf0014 	sw	ra,20(sp)
a0007d5c:	3c02a002 	lui	v0,0xa002
a0007d60:	8c4288a0 	lw	v0,-30560(v0)
a0007d64:	10400027 	beqz	v0,a0007e04 <malloc+0xb0>
a0007d68:	24830007 	addiu	v1,a0,7
void * malloc(uint32 nbytes)                /* bytes to allocate */
{
        HEADER      *nxt, *prev;
        uint32      nunits;

        nunits = (nbytes+sizeof(HEADER)-1)
a0007d6c:	000318c2 	srl	v1,v1,0x3
a0007d70:	24630001 	addiu	v1,v1,1
                portion higher up in memory. Otherwise, just
                allocate the entire block.
        */
        for (prev=NULL,nxt=frhd; nxt; nxt = nxt->ptr)
        {
                if (nxt->size >= nunits) /* big enough */
a0007d74:	8c440004 	lw	a0,4(v0)
a0007d78:	0083282b 	sltu	a1,a0,v1
a0007d7c:	14a0001e 	bnez	a1,a0007df8 <malloc+0xa4>
a0007d80:	0064202b 	sltu	a0,v1,a0
a0007d84:	08001f67 	j	a0007d9c <malloc+0x48>
a0007d88:	00000000 	nop
a0007d8c:	8c440004 	lw	a0,4(v0)
a0007d90:	0083282b 	sltu	a1,a0,v1
a0007d94:	14a00018 	bnez	a1,a0007df8 <malloc+0xa4>
a0007d98:	0064202b 	sltu	a0,v1,a0
                {
                        if (nxt->size > nunits)
a0007d9c:	1080000c 	beqz	a0,a0007dd0 <malloc+0x7c>
a0007da0:	3c04a002 	lui	a0,0xa002
                                nxt->size = nunits;
                        }
#else
                        /* allocate head end */
                        {
                                HEADER  *seg = nxt + nunits;
a0007da4:	000320c0 	sll	a0,v1,0x3
a0007da8:	00442021 	addu	a0,v0,a0
                                if (prev==NULL) frhd = seg;
a0007dac:	3c05a002 	lui	a1,0xa002
a0007db0:	aca488a0 	sw	a0,-30560(a1)
                                else prev->ptr = seg;
                                seg->ptr = nxt->ptr;
a0007db4:	8c450000 	lw	a1,0(v0)
a0007db8:	ac850000 	sw	a1,0(a0)
                                seg->size = nxt->size - nunits;
a0007dbc:	8c450004 	lw	a1,4(v0)
a0007dc0:	00a32823 	subu	a1,a1,v1
a0007dc4:	ac850004 	sw	a1,4(a0)
                                
                                /* nxt now == ptr to alloc */
                                nxt->size = nunits;
a0007dc8:	08001f76 	j	a0007dd8 <malloc+0x84>
a0007dcc:	ac430004 	sw	v1,4(v0)
                        }
#endif
                        else
                        {
                                if (prev==NULL) frhd = nxt->ptr;
a0007dd0:	8c450000 	lw	a1,0(v0)
a0007dd4:	ac8588a0 	sw	a1,-30560(a0)
                                else prev->ptr = nxt->ptr;
                        }
                        memleft -= nunits;
a0007dd8:	3c04a002 	lui	a0,0xa002
a0007ddc:	8c8588a4 	lw	a1,-30556(a0)
a0007de0:	00a31823 	subu	v1,a1,v1
a0007de4:	ac8388a4 	sw	v1,-30556(a0)
                        */
                }
        }
        printf("\nAllocation Failed!");
        while(1);
}
a0007de8:	24420008 	addiu	v0,v0,8
a0007dec:	8fbf0014 	lw	ra,20(sp)
a0007df0:	03e00008 	jr	ra
a0007df4:	27bd0018 	addiu	sp,sp,24
                enough. If block is larger than needed, break                           
                the block into two pieces and allocate the                              
                portion higher up in memory. Otherwise, just
                allocate the entire block.
        */
        for (prev=NULL,nxt=frhd; nxt; nxt = nxt->ptr)
a0007df8:	8c420000 	lw	v0,0(v0)
a0007dfc:	1440ffe3 	bnez	v0,a0007d8c <malloc+0x38>
a0007e00:	00000000 	nop
                                Return a pointer past the header to                                     
                                the actual space requested.
                        */
                }
        }
        printf("\nAllocation Failed!");
a0007e04:	3c04a001 	lui	a0,0xa001
a0007e08:	0c002325 	jal	a0008c94 <dprintf>
a0007e0c:	248451ac 	addiu	a0,a0,20908
a0007e10:	08001f84 	j	a0007e10 <malloc+0xbc>
a0007e14:	00000000 	nop

a0007e18 <free>:
            free() or malloc(), otherwise free list will be null.
*/
{
        HEADER  *nxt, *prev, *f;
        
        ASSERT_CSP(ap);
a0007e18:	27bdffe8 	addiu	sp,sp,-24
a0007e1c:	afbf0014 	sw	ra,20(sp)
a0007e20:	14800006 	bnez	a0,a0007e3c <free+0x24>
a0007e24:	3c03a002 	lui	v1,0xa002
a0007e28:	3c04a001 	lui	a0,0xa001
a0007e2c:	0c002325 	jal	a0008c94 <dprintf>
a0007e30:	2484462c 	addiu	a0,a0,17964
a0007e34:	08001f8d 	j	a0007e34 <free+0x1c>
a0007e38:	00000000 	nop
        ASSERT_CSP(frhd);
a0007e3c:	8c6588a0 	lw	a1,-30560(v1)
a0007e40:	14a00006 	bnez	a1,a0007e5c <free+0x44>
a0007e44:	3c03a002 	lui	v1,0xa002
a0007e48:	3c04a001 	lui	a0,0xa001
a0007e4c:	0c002325 	jal	a0008c94 <dprintf>
a0007e50:	2484462c 	addiu	a0,a0,17964
a0007e54:	08001f95 	j	a0007e54 <free+0x3c>
a0007e58:	00000000 	nop

        f = (HEADER *)ap - 1;
a0007e5c:	2484fff8 	addiu	a0,a0,-8
        /* pt to header of block being returned */
        memleft += f->size;
a0007e60:	8c870004 	lw	a3,4(a0)
a0007e64:	8c6688a4 	lw	a2,-30556(v1)
a0007e68:	00c73021 	addu	a2,a2,a3
a0007e6c:	ac6688a4 	sw	a2,-30556(v1)
        /*
                Note: frhd is never NULL unless i_alloc() was                           
                    never called to initialize package.
        */
        if (frhd > f)
a0007e70:	0085182b 	sltu	v1,a0,a1
a0007e74:	1460000a 	bnez	v1,a0007ea0 <free+0x88>
a0007e78:	00a4182b 	sltu	v1,a1,a0
                points past the block, make a new entry and
                link it.  If next pointer + its size points to the                              
                block form one contiguous block.
        */
        nxt = frhd;
        for (nxt=frhd; nxt && nxt < f; prev=nxt,nxt=nxt->ptr)
a0007e7c:	1060002f 	beqz	v1,a0007f3c <free+0x124>
a0007e80:	00000000 	nop
        {
                if (nxt+nxt->size == f)
a0007e84:	8ca20004 	lw	v0,4(a1)
a0007e88:	000218c0 	sll	v1,v0,0x3
a0007e8c:	00a31821 	addu	v1,a1,v1
a0007e90:	14830023 	bne	a0,v1,a0007f20 <free+0x108>
a0007e94:	00471021 	addu	v0,v0,a3
                {
                        /* they are contiguous */
                        nxt->size += f->size;   
a0007e98:	08001fbd 	j	a0007ef4 <free+0xdc>
a0007e9c:	aca20004 	sw	v0,4(a1)
        /*
                free queue head is higher up in memory 
                than returnee 
        */
                nxt = frhd;                     /* old head */
                frhd = f;                       /* new head */
a0007ea0:	3c02a002 	lui	v0,0xa002
a0007ea4:	ac4488a0 	sw	a0,-30560(v0)
                prev = f + f->size;     /* right after new head */

                if (prev==nxt) /* old and new are contiguous */
a0007ea8:	000710c0 	sll	v0,a3,0x3
a0007eac:	00821021 	addu	v0,a0,v0
a0007eb0:	14a20007 	bne	a1,v0,a0007ed0 <free+0xb8>
a0007eb4:	00000000 	nop
                {
                        f->size += nxt->size;
a0007eb8:	8ca20004 	lw	v0,4(a1)
a0007ebc:	00473821 	addu	a3,v0,a3
a0007ec0:	ac870004 	sw	a3,4(a0)
                        f->ptr = nxt->ptr;      /* contiguate */
a0007ec4:	8ca20000 	lw	v0,0(a1)
a0007ec8:	08001fdc 	j	a0007f70 <free+0x158>
a0007ecc:	ac820000 	sw	v0,0(a0)
                }
                else f->ptr = nxt;
a0007ed0:	08001fdc 	j	a0007f70 <free+0x158>
a0007ed4:	ac850000 	sw	a1,0(a0)
                block form one contiguous block.
        */
        nxt = frhd;
        for (nxt=frhd; nxt && nxt < f; prev=nxt,nxt=nxt->ptr)
        {
                if (nxt+nxt->size == f)
a0007ed8:	8c620004 	lw	v0,4(v1)
a0007edc:	000228c0 	sll	a1,v0,0x3
a0007ee0:	00652821 	addu	a1,v1,a1
a0007ee4:	1485000e 	bne	a0,a1,a0007f20 <free+0x108>
a0007ee8:	00602821 	move	a1,v1
                {
                        /* they are contiguous */
                        nxt->size += f->size;   
a0007eec:	00471021 	addu	v0,v0,a3
a0007ef0:	aca20004 	sw	v0,4(a1)
                        /* form one block */
                        f = nxt + nxt->size;
                        if (f==nxt->ptr)
a0007ef4:	8ca30000 	lw	v1,0(a1)
a0007ef8:	000220c0 	sll	a0,v0,0x3
a0007efc:	00a42021 	addu	a0,a1,a0
a0007f00:	1464001c 	bne	v1,a0,a0007f74 <free+0x15c>
a0007f04:	8fbf0014 	lw	ra,20(sp)
                                continue this checking since if the                                     
                                block following this free one was                                               
                                free, the two would have been                                           
                                made one already.
                        */
                                nxt->size += f->size;
a0007f08:	8c640004 	lw	a0,4(v1)
a0007f0c:	00441021 	addu	v0,v0,a0
a0007f10:	aca20004 	sw	v0,4(a1)
                                nxt->ptr = f->ptr;
a0007f14:	8c620000 	lw	v0,0(v1)
a0007f18:	08001fdc 	j	a0007f70 <free+0x158>
a0007f1c:	aca20000 	sw	v0,0(a1)
                points past the block, make a new entry and
                link it.  If next pointer + its size points to the                              
                block form one contiguous block.
        */
        nxt = frhd;
        for (nxt=frhd; nxt && nxt < f; prev=nxt,nxt=nxt->ptr)
a0007f20:	8ca30000 	lw	v1,0(a1)
a0007f24:	10600003 	beqz	v1,a0007f34 <free+0x11c>
a0007f28:	0064302b 	sltu	a2,v1,a0
a0007f2c:	14c0ffea 	bnez	a2,a0007ed8 <free+0xc0>
a0007f30:	00000000 	nop
a0007f34:	00a01021 	move	v0,a1
a0007f38:	00602821 	move	a1,v1
                the end of the queue was reached. If at end, just                       
                link to the end of the queue.  Therefore, 'nxt' is                      
                either NULL or points to a block higher up in                           
                memory than the one being returned.
        */                                              
        prev->ptr = f;  /* link to queue */
a0007f3c:	ac440000 	sw	a0,0(v0)
        prev = f + f->size;     /* right after space to free */
a0007f40:	8c830004 	lw	v1,4(a0)
a0007f44:	000310c0 	sll	v0,v1,0x3
a0007f48:	00821021 	addu	v0,a0,v0
        if (prev == nxt)        /* f and nxt are contiguous */
a0007f4c:	14450007 	bne	v0,a1,a0007f6c <free+0x154>
a0007f50:	00000000 	nop
        {
                f->size += nxt->size;
a0007f54:	8c450004 	lw	a1,4(v0)
a0007f58:	00a31821 	addu	v1,a1,v1
a0007f5c:	ac830004 	sw	v1,4(a0)
                /* form a larger contiguous block */
                f->ptr = nxt->ptr;
a0007f60:	8c420000 	lw	v0,0(v0)
a0007f64:	08001fdc 	j	a0007f70 <free+0x158>
a0007f68:	ac820000 	sw	v0,0(a0)
        }
        else f->ptr = nxt;
a0007f6c:	ac850000 	sw	a1,0(a0)
        return;
}
a0007f70:	8fbf0014 	lw	ra,20(sp)
a0007f74:	03e00008 	jr	ra
a0007f78:	27bd0018 	addiu	sp,sp,24
a0007f7c:	00000000 	nop

a0007f80 <serial_outc>:




void serial_outc(char c)
{
a0007f80:	7c042420 	seb	a0,a0
a0007f84:	24020001 	li	v0,1
#if 1	
		i++;
		if (i >=6540)
			break;
#endif		
		if 	(rtl_inb(UART_LSR) & 0x60)
a0007f88:	3c05b800 	lui	a1,0xb800
a0007f8c:	34a52014 	ori	a1,a1,0x2014
#if 1
    while (1)
	{
#if 1	
		i++;
		if (i >=6540)
a0007f90:	08001fe8 	j	a0007fa0 <serial_outc+0x20>
a0007f94:	2406198c 	li	a2,6540
a0007f98:	10460006 	beq	v0,a2,a0007fb4 <serial_outc+0x34>
a0007f9c:	308300ff 	andi	v1,a0,0xff
			break;
#endif		
		if 	(rtl_inb(UART_LSR) & 0x60)
a0007fa0:	90a30000 	lbu	v1,0(a1)
a0007fa4:	30630060 	andi	v1,v1,0x60
a0007fa8:	1060fffb 	beqz	v1,a0007f98 <serial_outc+0x18>
a0007fac:	24420001 	addiu	v0,v0,1
			break;	
	}
#endif

	//for(i=0; i<0xff00;i++);
 	rtl_outb(UART_THR, c);  
a0007fb0:	308300ff 	andi	v1,a0,0xff
a0007fb4:	3c02b800 	lui	v0,0xb800
a0007fb8:	34422000 	ori	v0,v0,0x2000
a0007fbc:	a0430000 	sb	v1,0(v0)
		  
	if (c == 0x0a)
a0007fc0:	2402000a 	li	v0,10
a0007fc4:	14820004 	bne	a0,v0,a0007fd8 <serial_outc+0x58>
a0007fc8:	2403000d 	li	v1,13
		rtl_outb(UART_THR, 0x0d);  
a0007fcc:	3c02b800 	lui	v0,0xb800
a0007fd0:	34422000 	ori	v0,v0,0x2000
a0007fd4:	a0430000 	sb	v1,0(v0)
a0007fd8:	03e00008 	jr	ra
a0007fdc:	00000000 	nop

a0007fe0 <serial_inc>:
#if defined(CONFIG_TFTP_COMMAND)
	tickStart=get_timer_jiffies();
#endif
    while (1)
	{
		if 	(rtl_inb(UART_LSR) & 0x1)
a0007fe0:	3c03b800 	lui	v1,0xb800
a0007fe4:	34632014 	ori	v1,v1,0x2014
a0007fe8:	90620000 	lbu	v0,0(v1)
a0007fec:	30420001 	andi	v0,v0,0x1
a0007ff0:	1040fffd 	beqz	v0,a0007fe8 <serial_inc+0x8>
a0007ff4:	3c02b800 	lui	v0,0xb800
        if(time_after((get_timer_jiffies()),(tickStart+18000)))
		//if((get_timer_jiffies() - tickStart) > 18000) //3min=18000  1min=6000
		    autoreboot();
#endif
	}	
	i=rtl_inb(UART_RBR);
a0007ff8:	34422000 	ori	v0,v0,0x2000
a0007ffc:	90420000 	lbu	v0,0(v0)
	return (i & 0xff);
	// ----------------------------------------------------
	// above is UART0, and below is SC16IS7x0 
	// ----------------------------------------------------
	
}
a0008000:	03e00008 	jr	ra
a0008004:	7c021420 	seb	v0,v0

a0008008 <isspace>:

int isspace(char ch)
{
a0008008:	7c042420 	seb	a0,a0
    return (unsigned int)(ch - 9) < 5u  ||  ch == ' ';	
a000800c:	2483fff7 	addiu	v1,a0,-9
a0008010:	2c630005 	sltiu	v1,v1,5
a0008014:	14600003 	bnez	v1,a0008024 <isspace+0x1c>
a0008018:	24020001 	li	v0,1
a000801c:	38820020 	xori	v0,a0,0x20
a0008020:	2c420001 	sltiu	v0,v0,1
}
a0008024:	03e00008 	jr	ra
a0008028:	00000000 	nop
a000802c:	00000000 	nop

a0008030 <strcpy>:
#if 1
char * strcpy(char * dest,const char *src)
{
	char *tmp = dest;

	while ((*dest++ = *src++) != '\0')
a0008030:	00801021 	move	v0,a0
a0008034:	00801821 	move	v1,a0
a0008038:	80a40000 	lb	a0,0(a1)
a000803c:	a0640000 	sb	a0,0(v1)
a0008040:	24630001 	addiu	v1,v1,1
a0008044:	1480fffc 	bnez	a0,a0008038 <strcpy+0x8>
a0008048:	24a50001 	addiu	a1,a1,1
		/* nothing */;
	return tmp;
}
a000804c:	03e00008 	jr	ra
a0008050:	00000000 	nop

a0008054 <strcmp>:
int strcmp(const char * cs,const char * ct)
{
	register signed char __res;

	while (1) {
		if ((__res = *cs - *ct++) != 0 || !*cs++)
a0008054:	80830000 	lb	v1,0(a0)
a0008058:	90a20000 	lbu	v0,0(a1)
a000805c:	00621023 	subu	v0,v1,v0
a0008060:	7c021420 	seb	v0,v0
a0008064:	14400003 	bnez	v0,a0008074 <strcmp+0x20>
a0008068:	24a50001 	addiu	a1,a1,1
a000806c:	1460fff9 	bnez	v1,a0008054 <strcmp>
a0008070:	24840001 	addiu	a0,a0,1
			break;
	}

	return __res;
}
a0008074:	03e00008 	jr	ra
a0008078:	00000000 	nop

a000807c <strchr>:
}
#endif

char * strchr(const char * s, int c)
{
	for(; *s != (char) c; ++s)
a000807c:	80830000 	lb	v1,0(a0)
a0008080:	7c052c20 	seb	a1,a1
a0008084:	1065000c 	beq	v1,a1,a00080b8 <strchr+0x3c>
a0008088:	00801021 	move	v0,a0
		if (*s == '\0')
a000808c:	14600007 	bnez	v1,a00080ac <strchr+0x30>
a0008090:	24420001 	addiu	v0,v0,1
a0008094:	2442ffff 	addiu	v0,v0,-1
}
#endif

char * strchr(const char * s, int c)
{
	for(; *s != (char) c; ++s)
a0008098:	03e00008 	jr	ra
a000809c:	00001021 	move	v0,zero
		if (*s == '\0')
a00080a0:	10600007 	beqz	v1,a00080c0 <strchr+0x44>
a00080a4:	00000000 	nop
}
#endif

char * strchr(const char * s, int c)
{
	for(; *s != (char) c; ++s)
a00080a8:	24420001 	addiu	v0,v0,1
a00080ac:	80430000 	lb	v1,0(v0)
a00080b0:	1465fffb 	bne	v1,a1,a00080a0 <strchr+0x24>
a00080b4:	00000000 	nop
a00080b8:	03e00008 	jr	ra
a00080bc:	00000000 	nop
a00080c0:	00001021 	move	v0,zero
		if (*s == '\0')
			return NULL;
	return (char *) s;
}
a00080c4:	03e00008 	jr	ra
a00080c8:	00000000 	nop

a00080cc <strlen>:
#endif
size_t strlen(const char * s)
{
	const char *sc;

	for (sc = s; *sc != '\0'; ++sc)
a00080cc:	80830000 	lb	v1,0(a0)
a00080d0:	10600006 	beqz	v1,a00080ec <strlen+0x20>
a00080d4:	00801021 	move	v0,a0
a00080d8:	24420001 	addiu	v0,v0,1
a00080dc:	80430000 	lb	v1,0(v0)
a00080e0:	1460fffe 	bnez	v1,a00080dc <strlen+0x10>
a00080e4:	24420001 	addiu	v0,v0,1
a00080e8:	2442ffff 	addiu	v0,v0,-1
		/* nothing */;
	return sc - s;
}
a00080ec:	03e00008 	jr	ra
a00080f0:	00441023 	subu	v0,v0,a0

a00080f4 <memset>:

void * memset(void * s,int c, size_t count)
{
	char *xs = (char *) s;

	while (count--)
a00080f4:	10c00006 	beqz	a2,a0008110 <memset+0x1c>
a00080f8:	00801021 	move	v0,a0
}
#endif

void * memset(void * s,int c, size_t count)
{
	char *xs = (char *) s;
a00080fc:	00801821 	move	v1,a0

	while (count--)
		*xs++ = c;
a0008100:	a0650000 	sb	a1,0(v1)
a0008104:	24c6ffff 	addiu	a2,a2,-1

void * memset(void * s,int c, size_t count)
{
	char *xs = (char *) s;

	while (count--)
a0008108:	14c0fffd 	bnez	a2,a0008100 <memset+0xc>
a000810c:	24630001 	addiu	v1,v1,1
		*xs++ = c;

	return s;
}
a0008110:	03e00008 	jr	ra
a0008114:	00000000 	nop

a0008118 <memcpy>:
#endif
void * memcpy(void * dest,const void *src,size_t count)
{
	char *tmp = (char *) dest, *s = (char *) src;

	while (count--)
a0008118:	10c00008 	beqz	a2,a000813c <memcpy+0x24>
a000811c:	00801021 	move	v0,a0
a0008120:	00001821 	move	v1,zero
		*tmp++ = *s++;
a0008124:	00432021 	addu	a0,v0,v1
a0008128:	00a33821 	addu	a3,a1,v1
a000812c:	90e70000 	lbu	a3,0(a3)
a0008130:	24630001 	addiu	v1,v1,1
#endif
void * memcpy(void * dest,const void *src,size_t count)
{
	char *tmp = (char *) dest, *s = (char *) src;

	while (count--)
a0008134:	1466fffb 	bne	v1,a2,a0008124 <memcpy+0xc>
a0008138:	a0870000 	sb	a3,0(a0)
		*tmp++ = *s++;

	return dest;
}
a000813c:	03e00008 	jr	ra
a0008140:	00000000 	nop

a0008144 <memcmp>:
int memcmp(const void * cs,const void * ct,size_t count)
{
	const unsigned char *su1, *su2;
	signed char res = 0;

	for( su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
a0008144:	10c00007 	beqz	a2,a0008164 <memcmp+0x20>
a0008148:	00001021 	move	v0,zero
		if ((res = *su1 - *su2) != 0)
a000814c:	90830000 	lbu	v1,0(a0)
a0008150:	90a20000 	lbu	v0,0(a1)
a0008154:	00621023 	subu	v0,v1,v0
a0008158:	7c021420 	seb	v0,v0
a000815c:	1040000a 	beqz	v0,a0008188 <memcmp+0x44>
a0008160:	00001821 	move	v1,zero
a0008164:	03e00008 	jr	ra
a0008168:	00000000 	nop
a000816c:	00a31021 	addu	v0,a1,v1
a0008170:	90e70001 	lbu	a3,1(a3)
a0008174:	90420001 	lbu	v0,1(v0)
a0008178:	00e21023 	subu	v0,a3,v0
a000817c:	7c021420 	seb	v0,v0
a0008180:	1440fff8 	bnez	v0,a0008164 <memcmp+0x20>
a0008184:	24630001 	addiu	v1,v1,1
int memcmp(const void * cs,const void * ct,size_t count)
{
	const unsigned char *su1, *su2;
	signed char res = 0;

	for( su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
a0008188:	24c6ffff 	addiu	a2,a2,-1
a000818c:	14c0fff7 	bnez	a2,a000816c <memcmp+0x28>
a0008190:	00833821 	addu	a3,a0,v1
		if ((res = *su1 - *su2) != 0)
			break;
	return res;
}
a0008194:	03e00008 	jr	ra
a0008198:	00000000 	nop

a000819c <strstr>:
#endif
char * strstr(const char * s1,const char * s2)
{
	int l1, l2;

	l2 = strlen(s2);
a000819c:	27bdffd8 	addiu	sp,sp,-40
a00081a0:	afbf0024 	sw	ra,36(sp)
a00081a4:	afb40020 	sw	s4,32(sp)
a00081a8:	afb3001c 	sw	s3,28(sp)
a00081ac:	afb20018 	sw	s2,24(sp)
a00081b0:	afb10014 	sw	s1,20(sp)
a00081b4:	afb00010 	sw	s0,16(sp)
a00081b8:	00808021 	move	s0,a0
a00081bc:	00a09021 	move	s2,a1
a00081c0:	0c002033 	jal	a00080cc <strlen>
a00081c4:	00a02021 	move	a0,a1
a00081c8:	00408821 	move	s1,v0
	if (!l2)
a00081cc:	10400011 	beqz	v0,a0008214 <strstr+0x78>
a00081d0:	0040a021 	move	s4,v0
		return (char *) s1;
	l1 = strlen(s1);
a00081d4:	0c002033 	jal	a00080cc <strlen>
a00081d8:	02002021 	move	a0,s0
a00081dc:	00409821 	move	s3,v0
	while (l1 >= l2) {
a00081e0:	0051102a 	slt	v0,v0,s1
a00081e4:	1440000a 	bnez	v0,a0008210 <strstr+0x74>
a00081e8:	00000000 	nop
		l1--;
		if (!memcmp(s1,s2,l2))
a00081ec:	02002021 	move	a0,s0
a00081f0:	02402821 	move	a1,s2
a00081f4:	0c002051 	jal	a0008144 <memcmp>
a00081f8:	02203021 	move	a2,s1
a00081fc:	10400005 	beqz	v0,a0008214 <strstr+0x78>
a0008200:	2673ffff 	addiu	s3,s3,-1

	l2 = strlen(s2);
	if (!l2)
		return (char *) s1;
	l1 = strlen(s1);
	while (l1 >= l2) {
a0008204:	0274102a 	slt	v0,s3,s4
a0008208:	1040fff8 	beqz	v0,a00081ec <strstr+0x50>
a000820c:	26100001 	addiu	s0,s0,1
		l1--;
		if (!memcmp(s1,s2,l2))
			return (char *) s1;
		s1++;
a0008210:	00008021 	move	s0,zero
	}
	return NULL;
}
a0008214:	02001021 	move	v0,s0
a0008218:	8fbf0024 	lw	ra,36(sp)
a000821c:	8fb40020 	lw	s4,32(sp)
a0008220:	8fb3001c 	lw	s3,28(sp)
a0008224:	8fb20018 	lw	s2,24(sp)
a0008228:	8fb10014 	lw	s1,20(sp)
a000822c:	8fb00010 	lw	s0,16(sp)
a0008230:	03e00008 	jr	ra
a0008234:	27bd0028 	addiu	sp,sp,40
	...

a0008240 <strtol>:
#include <limits.h>


#define ABS_LONG_MIN 2147483648UL
long int strtol(const char *nptr, char **endptr, int base)
{
a0008240:	27bdffd8 	addiu	sp,sp,-40
a0008244:	afbf0024 	sw	ra,36(sp)
a0008248:	afb40020 	sw	s4,32(sp)
a000824c:	afb3001c 	sw	s3,28(sp)
a0008250:	afb20018 	sw	s2,24(sp)
a0008254:	afb10014 	sw	s1,20(sp)
a0008258:	afb00010 	sw	s0,16(sp)
a000825c:	00808021 	move	s0,a0
a0008260:	00a09821 	move	s3,a1
a0008264:	00c0a021 	move	s4,a2
  int neg=0;
  unsigned long int v;

  while(isspace(*nptr)) nptr++;
a0008268:	82110000 	lb	s1,0(s0)
a000826c:	0c002002 	jal	a0008008 <isspace>
a0008270:	02202021 	move	a0,s1
a0008274:	1440fffc 	bnez	v0,a0008268 <strtol+0x28>
a0008278:	26100001 	addiu	s0,s0,1
a000827c:	2610ffff 	addiu	s0,s0,-1

  if (*nptr == '-') { neg=-1; ++nptr; }
a0008280:	2402002d 	li	v0,45
a0008284:	16220003 	bne	s1,v0,a0008294 <strtol+0x54>
a0008288:	00009021 	move	s2,zero
a000828c:	26100001 	addiu	s0,s0,1
a0008290:	2412ffff 	li	s2,-1
  v=strtoul(nptr,endptr,base);
a0008294:	02002021 	move	a0,s0
a0008298:	02602821 	move	a1,s3
a000829c:	0c0020c4 	jal	a0008310 <strtoul>
a00082a0:	02803021 	move	a2,s4
  if (v>=ABS_LONG_MIN) {
a00082a4:	0441000c 	bgez	v0,a00082d8 <strtol+0x98>
a00082a8:	00021823 	negu	v1,v0
    if (v==ABS_LONG_MIN && neg) {
a00082ac:	3c048000 	lui	a0,0x8000
a00082b0:	14440005 	bne	v0,a0,a00082c8 <strtol+0x88>
a00082b4:	00000000 	nop
a00082b8:	12400009 	beqz	s2,a00082e0 <strtol+0xa0>
a00082bc:	8fbf0024 	lw	ra,36(sp)
    }
   // errno=ERANGE;
    return (neg?LONG_MIN:LONG_MAX);
  }
  return (neg?-v:v);
}
a00082c0:	080020bc 	j	a00082f0 <strtol+0xb0>
a00082c4:	8fb40020 	lw	s4,32(sp)
    if (v==ABS_LONG_MIN && neg) {
      //errno=0;
      return v;
    }
   // errno=ERANGE;
    return (neg?LONG_MIN:LONG_MAX);
a00082c8:	12400005 	beqz	s2,a00082e0 <strtol+0xa0>
a00082cc:	3c028000 	lui	v0,0x8000
  }
  return (neg?-v:v);
}
a00082d0:	080020bb 	j	a00082ec <strtol+0xac>
a00082d4:	8fbf0024 	lw	ra,36(sp)
      return v;
    }
   // errno=ERANGE;
    return (neg?LONG_MIN:LONG_MAX);
  }
  return (neg?-v:v);
a00082d8:	080020ba 	j	a00082e8 <strtol+0xa8>
a00082dc:	0072100b 	movn	v0,v1,s2
a00082e0:	3c027fff 	lui	v0,0x7fff
a00082e4:	3442ffff 	ori	v0,v0,0xffff
}
a00082e8:	8fbf0024 	lw	ra,36(sp)
a00082ec:	8fb40020 	lw	s4,32(sp)
a00082f0:	8fb3001c 	lw	s3,28(sp)
a00082f4:	8fb20018 	lw	s2,24(sp)
a00082f8:	8fb10014 	lw	s1,20(sp)
a00082fc:	8fb00010 	lw	s0,16(sp)
a0008300:	03e00008 	jr	ra
a0008304:	27bd0028 	addiu	sp,sp,40
	...

a0008310 <strtoul>:

#include <limits.h>

unsigned long int strtoul(const char *nptr, char **endptr, int base)
{
a0008310:	27bdffd8 	addiu	sp,sp,-40
a0008314:	afbf0024 	sw	ra,36(sp)
a0008318:	afb30020 	sw	s3,32(sp)
a000831c:	afb2001c 	sw	s2,28(sp)
a0008320:	afb10018 	sw	s1,24(sp)
a0008324:	afb00014 	sw	s0,20(sp)
a0008328:	00808021 	move	s0,a0
a000832c:	00a09821 	move	s3,a1
a0008330:	00c08821 	move	s1,a2
  unsigned long int v=0;

  while(isspace(*nptr)) ++nptr;
a0008334:	82120000 	lb	s2,0(s0)
a0008338:	0c002002 	jal	a0008008 <isspace>
a000833c:	02402021 	move	a0,s2
a0008340:	1440fffc 	bnez	v0,a0008334 <strtoul+0x24>
a0008344:	26100001 	addiu	s0,s0,1
a0008348:	2610ffff 	addiu	s0,s0,-1
  if (*nptr == '+') ++nptr;
a000834c:	26020001 	addiu	v0,s0,1
a0008350:	3a52002b 	xori	s2,s2,0x2b
a0008354:	0052800a 	movz	s0,v0,s2
  if (base==16 && nptr[0]=='0') goto skip0x;
a0008358:	24020010 	li	v0,16
a000835c:	16220006 	bne	s1,v0,a0008378 <strtoul+0x68>
a0008360:	24020030 	li	v0,48
a0008364:	82030000 	lb	v1,0(s0)
a0008368:	14620012 	bne	v1,v0,a00083b4 <strtoul+0xa4>
a000836c:	00000000 	nop
  if (!base) {
    if (*nptr=='0') {
      base=8;
skip0x:
      if (nptr[1]=='x'||nptr[1]=='X') {
a0008370:	080020e5 	j	a0008394 <strtoul+0x84>
a0008374:	82020001 	lb	v0,1(s0)
  unsigned long int v=0;

  while(isspace(*nptr)) ++nptr;
  if (*nptr == '+') ++nptr;
  if (base==16 && nptr[0]=='0') goto skip0x;
  if (!base) {
a0008378:	1620000d 	bnez	s1,a00083b0 <strtoul+0xa0>
a000837c:	00000000 	nop
    if (*nptr=='0') {
a0008380:	82030000 	lb	v1,0(s0)
a0008384:	1462000b 	bne	v1,v0,a00083b4 <strtoul+0xa4>
a0008388:	2411000a 	li	s1,10
a000838c:	24110008 	li	s1,8
      base=8;
skip0x:
      if (nptr[1]=='x'||nptr[1]=='X') {
a0008390:	82020001 	lb	v0,1(s0)
a0008394:	24030078 	li	v1,120
a0008398:	10430003 	beq	v0,v1,a00083a8 <strtoul+0x98>
a000839c:	24030058 	li	v1,88
a00083a0:	14430003 	bne	v0,v1,a00083b0 <strtoul+0xa0>
a00083a4:	00000000 	nop
	nptr+=2;
a00083a8:	26100002 	addiu	s0,s0,2
a00083ac:	24110010 	li	s1,16
	base=16;
      }
    } else
      base=10;
  }
  while(*nptr) {
a00083b0:	82030000 	lb	v1,0(s0)
a00083b4:	00001021 	move	v0,zero
a00083b8:	1060001f 	beqz	v1,a0008438 <strtoul+0x128>
a00083bc:	240600ff 	li	a2,255
    register unsigned char c=*nptr;
a00083c0:	306300ff 	andi	v1,v1,0xff
    c=(c>='a'?c-'a'+10:c>='A'?c-'A'+10:c<='9'?c-'0':0xff);
a00083c4:	2c640061 	sltiu	a0,v1,97
a00083c8:	14800004 	bnez	a0,a00083dc <strtoul+0xcc>
a00083cc:	00000000 	nop
a00083d0:	2463ffa9 	addiu	v1,v1,-87
a00083d4:	08002101 	j	a0008404 <strtoul+0xf4>
a00083d8:	306400ff 	andi	a0,v1,0xff
a00083dc:	2c640041 	sltiu	a0,v1,65
a00083e0:	14800004 	bnez	a0,a00083f4 <strtoul+0xe4>
a00083e4:	2c65003a 	sltiu	a1,v1,58
a00083e8:	2463ffc9 	addiu	v1,v1,-55
a00083ec:	08002101 	j	a0008404 <strtoul+0xf4>
a00083f0:	306400ff 	andi	a0,v1,0xff
a00083f4:	10a00003 	beqz	a1,a0008404 <strtoul+0xf4>
a00083f8:	00c02021 	move	a0,a2
a00083fc:	2463ffd0 	addiu	v1,v1,-48
a0008400:	306400ff 	andi	a0,v1,0xff
    if (c>=base) break;
a0008404:	0091182a 	slt	v1,a0,s1
a0008408:	1060000b 	beqz	v1,a0008438 <strtoul+0x128>
a000840c:	00000000 	nop
    {
      register unsigned long int w=v*base;
a0008410:	70511802 	mul	v1,v0,s1
      if (w<v) {
a0008414:	0062102b 	sltu	v0,v1,v0
a0008418:	10400003 	beqz	v0,a0008428 <strtoul+0x118>
a000841c:	26100001 	addiu	s0,s0,1
a0008420:	08002111 	j	a0008444 <strtoul+0x134>
a0008424:	2402ffff 	li	v0,-1
	//errno=ERANGE;
	return ULONG_MAX;
      }
      v=w+c;
a0008428:	00831021 	addu	v0,a0,v1
	base=16;
      }
    } else
      base=10;
  }
  while(*nptr) {
a000842c:	82030000 	lb	v1,0(s0)
a0008430:	1460ffe3 	bnez	v1,a00083c0 <strtoul+0xb0>
a0008434:	00000000 	nop
      }
      v=w+c;
    }
    ++nptr;
  }
  if (endptr) *endptr=(char *)nptr;
a0008438:	12600003 	beqz	s3,a0008448 <strtoul+0x138>
a000843c:	8fbf0024 	lw	ra,36(sp)
a0008440:	ae700000 	sw	s0,0(s3)
  //errno=0;	/* in case v==ULONG_MAX, ugh! */
  return v;
}
a0008444:	8fbf0024 	lw	ra,36(sp)
a0008448:	8fb30020 	lw	s3,32(sp)
a000844c:	8fb2001c 	lw	s2,28(sp)
a0008450:	8fb10018 	lw	s1,24(sp)
a0008454:	8fb00014 	lw	s0,20(sp)
a0008458:	03e00008 	jr	ra
a000845c:	27bd0028 	addiu	sp,sp,40

a0008460 <StrUpr>:
char* StrUpr( char* string ){
	char*		p ;
	const int	det = 'a' - 'A';

	p = string ;
	while( *p ){
a0008460:	80850000 	lb	a1,0(a0)
a0008464:	10a0000d 	beqz	a1,a000849c <StrUpr+0x3c>
a0008468:	00801021 	move	v0,a0
a000846c:	00801821 	move	v1,a0
		if( *p >= 'a'  &&  *p <= 'z' ){
a0008470:	30a500ff 	andi	a1,a1,0xff
a0008474:	24a6ff9f 	addiu	a2,a1,-97
a0008478:	30c600ff 	andi	a2,a2,0xff
a000847c:	2cc6001a 	sltiu	a2,a2,26
a0008480:	10c00002 	beqz	a2,a000848c <StrUpr+0x2c>
a0008484:	24a5ffe0 	addiu	a1,a1,-32
			*p -= det ;
a0008488:	a0650000 	sb	a1,0(v1)
		}
		p++ ;
a000848c:	24630001 	addiu	v1,v1,1
char* StrUpr( char* string ){
	char*		p ;
	const int	det = 'a' - 'A';

	p = string ;
	while( *p ){
a0008490:	80650000 	lb	a1,0(v1)
a0008494:	14a0fff7 	bnez	a1,a0008474 <StrUpr+0x14>
a0008498:	30a500ff 	andi	a1,a1,0xff
			*p -= det ;
		}
		p++ ;
	}
	return string ;
}
a000849c:	03e00008 	jr	ra
a00084a0:	00000000 	nop

a00084a4 <GetArgc>:
;			argument number
;   Destroy:
---------------------------------------------------------------------------
*/
int GetArgc( const char* string )
{
a00084a4:	00003021 	move	a2,zero
	int			argc;
	char*		p ;

	argc = 0 ;
	p = (char* )string ;
	while( *p )
a00084a8:	08002138 	j	a00084e0 <GetArgc+0x3c>
a00084ac:	24050020 	li	a1,32
	{
		if( *p != ' '  &&  *p )
a00084b0:	1065000a 	beq	v1,a1,a00084dc <GetArgc+0x38>
a00084b4:	00000000 	nop
		{
			argc++ ;
a00084b8:	24c60001 	addiu	a2,a2,1
			while( *p != ' '  &&  *p ) p++ ;
a00084bc:	24840001 	addiu	a0,a0,1
a00084c0:	80830000 	lb	v1,0(a0)
a00084c4:	10650007 	beq	v1,a1,a00084e4 <GetArgc+0x40>
a00084c8:	00000000 	nop
a00084cc:	1460fffc 	bnez	v1,a00084c0 <GetArgc+0x1c>
a00084d0:	24840001 	addiu	a0,a0,1
a00084d4:	08002139 	j	a00084e4 <GetArgc+0x40>
a00084d8:	2484ffff 	addiu	a0,a0,-1
			continue ;
		}
		p++ ;
a00084dc:	24840001 	addiu	a0,a0,1
	int			argc;
	char*		p ;

	argc = 0 ;
	p = (char* )string ;
	while( *p )
a00084e0:	80830000 	lb	v1,0(a0)
a00084e4:	1460fff2 	bnez	v1,a00084b0 <GetArgc+0xc>
a00084e8:	24020013 	li	v0,19
a00084ec:	28c30014 	slti	v1,a2,20
		}
		p++ ;
	}
	if (argc >= MAX_ARGV) argc = MAX_ARGV - 1;
	return argc ;
}
a00084f0:	03e00008 	jr	ra
a00084f4:	00c3100b 	movn	v0,a2,v1

a00084f8 <Hex2Val>:
	unsigned long				sum,csum;
	register unsigned char		c,HexValue;

	sum = csum = 0;
	ptrb = HexStr;
	while(c=*ptrb++)
a00084f8:	08002159 	j	a0008564 <Hex2Val+0x6c>
a00084fc:	00003021 	move	a2,zero
	{
		if( c>='0' && c<='9')		HexValue = c - '0';
a0008500:	2443ffd0 	addiu	v1,v0,-48
a0008504:	306300ff 	andi	v1,v1,0xff
a0008508:	2c67000a 	sltiu	a3,v1,10
a000850c:	14e00010 	bnez	a3,a0008550 <Hex2Val+0x58>
a0008510:	00000000 	nop
		else if( c>='a' && c<='f')	HexValue = c - 'a' + 10;
a0008514:	2443ff9f 	addiu	v1,v0,-97
a0008518:	306300ff 	andi	v1,v1,0xff
a000851c:	2c630006 	sltiu	v1,v1,6
a0008520:	10600004 	beqz	v1,a0008534 <Hex2Val+0x3c>
a0008524:	00000000 	nop
a0008528:	2442ffa9 	addiu	v0,v0,-87
a000852c:	08002154 	j	a0008550 <Hex2Val+0x58>
a0008530:	304300ff 	andi	v1,v0,0xff
		else if( c>='A' && c<='F')  HexValue = c - 'A' + 10;
a0008534:	2443ffbf 	addiu	v1,v0,-65
a0008538:	306300ff 	andi	v1,v1,0xff
a000853c:	2c630006 	sltiu	v1,v1,6
a0008540:	1060000e 	beqz	v1,a000857c <Hex2Val+0x84>
a0008544:	00000000 	nop
a0008548:	2442ffc9 	addiu	v0,v0,-55
a000854c:	304300ff 	andi	v1,v0,0xff
		else return FALSE;				// character invalid
		sum = csum*16 + HexValue;
a0008550:	00061100 	sll	v0,a2,0x4
a0008554:	00621821 	addu	v1,v1,v0
		if(sum < csum) return FALSE;	// value overlow
a0008558:	0066302b 	sltu	a2,v1,a2
a000855c:	14c00007 	bnez	a2,a000857c <Hex2Val+0x84>
a0008560:	00603021 	move	a2,v1
	unsigned long				sum,csum;
	register unsigned char		c,HexValue;

	sum = csum = 0;
	ptrb = HexStr;
	while(c=*ptrb++)
a0008564:	90820000 	lbu	v0,0(a0)
a0008568:	1440ffe5 	bnez	v0,a0008500 <Hex2Val+0x8>
a000856c:	24840001 	addiu	a0,a0,1
		else return FALSE;				// character invalid
		sum = csum*16 + HexValue;
		if(sum < csum) return FALSE;	// value overlow
		csum = sum;
	}
	*PVal = csum;
a0008570:	aca60000 	sw	a2,0(a1)
	return TRUE;
a0008574:	03e00008 	jr	ra
a0008578:	24020001 	li	v0,1
}
a000857c:	03e00008 	jr	ra
a0008580:	00001021 	move	v0,zero

a0008584 <GetArgv>:
;			argument string end by zero character
;   Destroy:
---------------------------------------------------------------------------
*/
char** GetArgv(const char* string)
{
a0008584:	27bdffe0 	addiu	sp,sp,-32
a0008588:	afbf001c 	sw	ra,28(sp)
a000858c:	afb10018 	sw	s1,24(sp)
a0008590:	afb00014 	sw	s0,20(sp)
a0008594:	00808821 	move	s1,a0
	char*			p ;
	int				n;

	n = 0 ;
	memset( ArgvArray, 0, MAX_ARGV*sizeof(char *) );
a0008598:	3c10a002 	lui	s0,0xa002
a000859c:	261088b0 	addiu	s0,s0,-30544
a00085a0:	02002021 	move	a0,s0
a00085a4:	00002821 	move	a1,zero
a00085a8:	0c00203d 	jal	a00080f4 <memset>
a00085ac:	24060050 	li	a2,80
;			argument string array, argv[0], argv[1],...
;			argument string end by zero character
;   Destroy:
---------------------------------------------------------------------------
*/
char** GetArgv(const char* string)
a00085b0:	3c04a002 	lui	a0,0xa002
a00085b4:	24848900 	addiu	a0,a0,-30464
	int				n;

	n = 0 ;
	memset( ArgvArray, 0, MAX_ARGV*sizeof(char *) );
	p = (char* )string ;
	while( *p )
a00085b8:	0800218a 	j	a0008628 <GetArgv+0xa4>
a00085bc:	24030020 	li	v1,32
	{
		ArgvArray[n] = p ;
a00085c0:	ae110000 	sw	s1,0(s0)
		while( *p != ' '  &&  *p ) p++ ;
a00085c4:	82220000 	lb	v0,0(s1)
a00085c8:	1043000a 	beq	v0,v1,a00085f4 <GetArgv+0x70>
a00085cc:	00000000 	nop
a00085d0:	10400008 	beqz	v0,a00085f4 <GetArgv+0x70>
a00085d4:	00000000 	nop
a00085d8:	26310001 	addiu	s1,s1,1
a00085dc:	82220000 	lb	v0,0(s1)
a00085e0:	10430004 	beq	v0,v1,a00085f4 <GetArgv+0x70>
a00085e4:	00000000 	nop
a00085e8:	1440fffc 	bnez	v0,a00085dc <GetArgv+0x58>
a00085ec:	26310001 	addiu	s1,s1,1
a00085f0:	2631ffff 	addiu	s1,s1,-1
		*p++ = '\0';
a00085f4:	a2200000 	sb	zero,0(s1)
a00085f8:	26310001 	addiu	s1,s1,1
		while( *p == ' '  &&  *p ) p++ ;
a00085fc:	82220000 	lb	v0,0(s1)
a0008600:	14430006 	bne	v0,v1,a000861c <GetArgv+0x98>
a0008604:	00000000 	nop
a0008608:	26310001 	addiu	s1,s1,1
a000860c:	82220000 	lb	v0,0(s1)
a0008610:	1043fffe 	beq	v0,v1,a000860c <GetArgv+0x88>
a0008614:	26310001 	addiu	s1,s1,1
a0008618:	2631ffff 	addiu	s1,s1,-1
a000861c:	26100004 	addiu	s0,s0,4
		n++ ;
		if (n == MAX_ARGV) break;
a0008620:	12040004 	beq	s0,a0,a0008634 <GetArgv+0xb0>
a0008624:	3c02a002 	lui	v0,0xa002
	int				n;

	n = 0 ;
	memset( ArgvArray, 0, MAX_ARGV*sizeof(char *) );
	p = (char* )string ;
	while( *p )
a0008628:	82220000 	lb	v0,0(s1)
a000862c:	1440ffe4 	bnez	v0,a00085c0 <GetArgv+0x3c>
a0008630:	3c02a002 	lui	v0,0xa002
		while( *p == ' '  &&  *p ) p++ ;
		n++ ;
		if (n == MAX_ARGV) break;
	}
	return (char** )&ArgvArray ;
}
a0008634:	244288b0 	addiu	v0,v0,-30544
a0008638:	8fbf001c 	lw	ra,28(sp)
a000863c:	8fb10018 	lw	s1,24(sp)
a0008640:	8fb00014 	lw	s0,20(sp)
a0008644:	03e00008 	jr	ra
a0008648:	27bd0020 	addiu	sp,sp,32

a000864c <GetLine>:
unsigned char history_cmd[HISTORY_CMD_ELN][ MAX_MONITOR_BUFFER +1 ]={0};
int hist_save_idx=0;
int hist_see_idx=0;
#endif
void GetLine( char * buffer, const unsigned int size, int EchoFlag )
{
a000864c:	27bdffc8 	addiu	sp,sp,-56
a0008650:	afbf0034 	sw	ra,52(sp)
a0008654:	afbe0030 	sw	s8,48(sp)
a0008658:	afb7002c 	sw	s7,44(sp)
a000865c:	afb60028 	sw	s6,40(sp)
a0008660:	afb50024 	sw	s5,36(sp)
a0008664:	afb40020 	sw	s4,32(sp)
a0008668:	afb3001c 	sw	s3,28(sp)
a000866c:	afb20018 	sw	s2,24(sp)
a0008670:	afb10014 	sw	s1,20(sp)
a0008674:	afb00010 	sw	s0,16(sp)
a0008678:	afa40038 	sw	a0,56(sp)
a000867c:	00a0b021 	move	s6,a1
	int		c;
	char*		p = buffer ;
	unsigned int	n = 0L ;
	int		i ;

	while( n < size )
a0008680:	10a0003a 	beqz	a1,a000876c <GetLine+0x120>
a0008684:	00c0a821 	move	s5,a2
a0008688:	00809821 	move	s3,a0
a000868c:	00009021 	move	s2,zero
	{
		c = GetChar() ;
		if( c == -1 )
a0008690:	2417ffff 	li	s7,-1
		}

#endif
		    break ;
		}
		else if ((ch == KEYCODE_BS) || (ch == KEYCODE_CTRL_BS))
a0008694:	24140008 	li	s4,8
		}
		else if( ch == KEYCODE_TAB )
		{
		    for( i=0 ; i < TAB ; i++ )
		    {
			    *p++ = ' ' ;
a0008698:	241e0020 	li	s8,32
	unsigned int	n = 0L ;
	int		i ;

	while( n < size )
	{
		c = GetChar() ;
a000869c:	0c001ff8 	jal	a0007fe0 <serial_inc>
a00086a0:	00000000 	nop
		if( c == -1 )
a00086a4:	1057002e 	beq	v0,s7,a0008760 <GetLine+0x114>
a00086a8:	7c022420 	seb	a0,v0
		{
		    continue;
		}
		ch = c;
		//dprintf("%x ",ch);
		if( ch == KEYCODE_LF )
a00086ac:	2402000a 	li	v0,10
a00086b0:	1082002e 	beq	a0,v0,a000876c <GetLine+0x120>
a00086b4:	2402000d 	li	v0,13
		    *--p = 0 ;
		    n-- ;
		    #endif // USE_LF
		    break ;
		}
		else if( ch == KEYCODE_CR )
a00086b8:	14820003 	bne	a0,v0,a00086c8 <GetLine+0x7c>
a00086bc:	00000000 	nop
			(hist_save_idx >= HISTORY_CMD_ELN-1) ? hist_save_idx=0 : hist_save_idx++;
			hist_see_idx=hist_save_idx;
		}

#endif
		    break ;
a00086c0:	080021db 	j	a000876c <GetLine+0x120>
a00086c4:	a2600000 	sb	zero,0(s3)
		}
		else if ((ch == KEYCODE_BS) || (ch == KEYCODE_CTRL_BS))
a00086c8:	10940003 	beq	a0,s4,a00086d8 <GetLine+0x8c>
a00086cc:	2402007f 	li	v0,127
a00086d0:	1482000f 	bne	a0,v0,a0008710 <GetLine+0xc4>
a00086d4:	24020009 	li	v0,9
		{
		    if( p != buffer )
a00086d8:	8fa20038 	lw	v0,56(sp)
a00086dc:	12620021 	beq	s3,v0,a0008764 <GetLine+0x118>
a00086e0:	0256102b 	sltu	v0,s2,s6
		    {
			    p-- ;
a00086e4:	2673ffff 	addiu	s3,s3,-1
			    n-- ;
							if(EchoFlag)
a00086e8:	12a0001d 	beqz	s5,a0008760 <GetLine+0x114>
a00086ec:	2652ffff 	addiu	s2,s2,-1
							{
								PutChar(KEYCODE_BS);
a00086f0:	0c001fe0 	jal	a0007f80 <serial_outc>
a00086f4:	02802021 	move	a0,s4
								PutChar(' ');
a00086f8:	0c001fe0 	jal	a0007f80 <serial_outc>
a00086fc:	24040020 	li	a0,32
								PutChar(KEYCODE_BS);
a0008700:	0c001fe0 	jal	a0007f80 <serial_outc>
a0008704:	02802021 	move	a0,s4
	int		c;
	char*		p = buffer ;
	unsigned int	n = 0L ;
	int		i ;

	while( n < size )
a0008708:	080021d9 	j	a0008764 <GetLine+0x118>
a000870c:	0256102b 	sltu	v0,s2,s6
								PutChar(' ');
								PutChar(KEYCODE_BS);
							}
		    }
		}
		else if( ch == KEYCODE_TAB )
a0008710:	1482000d 	bne	a0,v0,a0008748 <GetLine+0xfc>
a0008714:	02608021 	move	s0,s3
a0008718:	00008821 	move	s1,zero
		{
		    for( i=0 ; i < TAB ; i++ )
		    {
			    *p++ = ' ' ;
a000871c:	a21e0000 	sb	s8,0(s0)
			    n++ ;
							if(EchoFlag) PutChar(' ');
a0008720:	12a00003 	beqz	s5,a0008730 <GetLine+0xe4>
a0008724:	26100001 	addiu	s0,s0,1
a0008728:	0c001fe0 	jal	a0007f80 <serial_outc>
a000872c:	24040020 	li	a0,32
							}
		    }
		}
		else if( ch == KEYCODE_TAB )
		{
		    for( i=0 ; i < TAB ; i++ )
a0008730:	26310001 	addiu	s1,s1,1
a0008734:	1634fff9 	bne	s1,s4,a000871c <GetLine+0xd0>
a0008738:	00000000 	nop
a000873c:	26730008 	addiu	s3,s3,8
a0008740:	080021d8 	j	a0008760 <GetLine+0x114>
a0008744:	26520008 	addiu	s2,s2,8
			
		}
#endif
		else
		{
		    *p++ = ch ;
a0008748:	a2640000 	sb	a0,0(s3)
a000874c:	26730001 	addiu	s3,s3,1
		    n++ ;
					if(EchoFlag) PutChar(ch);
a0008750:	12a00003 	beqz	s5,a0008760 <GetLine+0x114>
a0008754:	26520001 	addiu	s2,s2,1
a0008758:	0c001fe0 	jal	a0007f80 <serial_outc>
a000875c:	00000000 	nop
	int		c;
	char*		p = buffer ;
	unsigned int	n = 0L ;
	int		i ;

	while( n < size )
a0008760:	0256102b 	sltu	v0,s2,s6
a0008764:	1440ffcd 	bnez	v0,a000869c <GetLine+0x50>
a0008768:	00000000 	nop
		    *p++ = ch ;
		    n++ ;
					if(EchoFlag) PutChar(ch);
		}
	}
}
a000876c:	8fbf0034 	lw	ra,52(sp)
a0008770:	8fbe0030 	lw	s8,48(sp)
a0008774:	8fb7002c 	lw	s7,44(sp)
a0008778:	8fb60028 	lw	s6,40(sp)
a000877c:	8fb50024 	lw	s5,36(sp)
a0008780:	8fb40020 	lw	s4,32(sp)
a0008784:	8fb3001c 	lw	s3,28(sp)
a0008788:	8fb20018 	lw	s2,24(sp)
a000878c:	8fb10014 	lw	s1,20(sp)
a0008790:	8fb00010 	lw	s0,16(sp)
a0008794:	03e00008 	jr	ra
a0008798:	27bd0038 	addiu	sp,sp,56
a000879c:	00000000 	nop

a00087a0 <strcasecmp>:
/**************************************************************************
STRCASECMP (not entirely correct, but this will do for our purposes)
**************************************************************************/
int strcasecmp(char *a, char *b)
{
	while (*a && *b && (*a & ~0x20) == (*b & ~0x20)) {a++; b++; }
a00087a0:	80820000 	lb	v0,0(a0)
a00087a4:	10400013 	beqz	v0,a00087f4 <strcasecmp+0x54>
a00087a8:	2403ffdf 	li	v1,-33
a00087ac:	80a30000 	lb	v1,0(a1)
a00087b0:	1060000f 	beqz	v1,a00087f0 <strcasecmp+0x50>
a00087b4:	00621826 	xor	v1,v1,v0
a00087b8:	2406ffdf 	li	a2,-33
a00087bc:	00661824 	and	v1,v1,a2
a00087c0:	1460000c 	bnez	v1,a00087f4 <strcasecmp+0x54>
a00087c4:	2403ffdf 	li	v1,-33
a00087c8:	24840001 	addiu	a0,a0,1
a00087cc:	80820000 	lb	v0,0(a0)
a00087d0:	10400007 	beqz	v0,a00087f0 <strcasecmp+0x50>
a00087d4:	24a50001 	addiu	a1,a1,1
a00087d8:	80a30000 	lb	v1,0(a1)
a00087dc:	10600004 	beqz	v1,a00087f0 <strcasecmp+0x50>
a00087e0:	00621826 	xor	v1,v1,v0
a00087e4:	00661824 	and	v1,v1,a2
a00087e8:	1060fff8 	beqz	v1,a00087cc <strcasecmp+0x2c>
a00087ec:	24840001 	addiu	a0,a0,1
a00087f0:	2403ffdf 	li	v1,-33
a00087f4:	00431024 	and	v0,v0,v1
a00087f8:	90a40000 	lbu	a0,0(a1)
a00087fc:	00831824 	and	v1,a0,v1
a0008800:	7c031c20 	seb	v1,v1
	return((*a & ~0x20) - (*b & ~0x20));
}
a0008804:	03e00008 	jr	ra
a0008808:	00431023 	subu	v0,v0,v1

a000880c <getdec>:
}


int getdec(char **ptr)
{
	char *p = *ptr;
a000880c:	8c830000 	lw	v1,0(a0)
	int ret=0;
	if ((*p < '0') || (*p > '9')) return(-1);
a0008810:	80650000 	lb	a1,0(v1)
a0008814:	24a6ffd0 	addiu	a2,a1,-48
a0008818:	30c600ff 	andi	a2,a2,0xff
a000881c:	2cc6000a 	sltiu	a2,a2,10
a0008820:	14c00003 	bnez	a2,a0008830 <getdec+0x24>
a0008824:	00001021 	move	v0,zero
a0008828:	03e00008 	jr	ra
a000882c:	2402ffff 	li	v0,-1
	while ((*p >= '0') && (*p <= '9')) {
		ret = ret*10 + (*p - '0');
a0008830:	00023040 	sll	a2,v0,0x1
a0008834:	000210c0 	sll	v0,v0,0x3
a0008838:	00c21021 	addu	v0,a2,v0
a000883c:	00451021 	addu	v0,v0,a1
		p++;
a0008840:	24630001 	addiu	v1,v1,1
int getdec(char **ptr)
{
	char *p = *ptr;
	int ret=0;
	if ((*p < '0') || (*p > '9')) return(-1);
	while ((*p >= '0') && (*p <= '9')) {
a0008844:	80650000 	lb	a1,0(v1)
a0008848:	24a6ffd0 	addiu	a2,a1,-48
a000884c:	30c600ff 	andi	a2,a2,0xff
a0008850:	2cc6000a 	sltiu	a2,a2,10
a0008854:	14c0fff6 	bnez	a2,a0008830 <getdec+0x24>
a0008858:	2442ffd0 	addiu	v0,v0,-48
		ret = ret*10 + (*p - '0');
		p++;
	}
	*ptr = p;
	return(ret);
}
a000885c:	03e00008 	jr	ra
a0008860:	ac830000 	sw	v1,0(a0)

a0008864 <delay_ms>:
   preTime = get_timer_jiffies();
   while ( get_timer_jiffies()-preTime <  time_sec*100 );
}
//-----------------------------------------
void delay_ms(unsigned int time_ms)
{
a0008864:	27bdffe0 	addiu	sp,sp,-32
a0008868:	afbf001c 	sw	ra,28(sp)
a000886c:	afb10018 	sw	s1,24(sp)
a0008870:	afb00014 	sw	s0,20(sp)
	
   unsigned int preTime;
   
   preTime = get_timer_jiffies();
a0008874:	0c0038ec 	jal	a000e3b0 <get_timer_jiffies>
a0008878:	00808821 	move	s1,a0
a000887c:	00408021 	move	s0,v0
   while ( get_timer_jiffies()-preTime <  time_ms/10 );
a0008880:	3c02cccc 	lui	v0,0xcccc
a0008884:	3442cccd 	ori	v0,v0,0xcccd
a0008888:	02220019 	multu	s1,v0
a000888c:	00008810 	mfhi	s1
a0008890:	001188c2 	srl	s1,s1,0x3
a0008894:	0c0038ec 	jal	a000e3b0 <get_timer_jiffies>
a0008898:	00000000 	nop
a000889c:	00501023 	subu	v0,v0,s0
a00088a0:	0051102b 	sltu	v0,v0,s1
a00088a4:	1440fffb 	bnez	v0,a0008894 <delay_ms+0x30>
a00088a8:	8fbf001c 	lw	ra,28(sp)
}
a00088ac:	8fb10018 	lw	s1,24(sp)
a00088b0:	8fb00014 	lw	s0,20(sp)
a00088b4:	03e00008 	jr	ra
a00088b8:	27bd0020 	addiu	sp,sp,32

a00088bc <delay_sec>:
   preTime = get_timer_jiffies();
   while ( get_timer_jiffies()-preTime <  time_ms/10 );
}
//-----------------------------------------
void delay_sec(unsigned int time_sec)
{
a00088bc:	27bdffe0 	addiu	sp,sp,-32
a00088c0:	afbf001c 	sw	ra,28(sp)
a00088c4:	afb20018 	sw	s2,24(sp)
a00088c8:	afb10014 	sw	s1,20(sp)
a00088cc:	afb00010 	sw	s0,16(sp)
   unsigned int preTime;
   
   preTime = get_timer_jiffies();
a00088d0:	0c0038ec 	jal	a000e3b0 <get_timer_jiffies>
a00088d4:	00809021 	move	s2,a0
a00088d8:	00408021 	move	s0,v0
   while ( get_timer_jiffies()-preTime <  time_sec*100 );
a00088dc:	00128880 	sll	s1,s2,0x2
a00088e0:	00129100 	sll	s2,s2,0x4
a00088e4:	02329021 	addu	s2,s1,s2
a00088e8:	00128880 	sll	s1,s2,0x2
a00088ec:	02518821 	addu	s1,s2,s1
a00088f0:	0c0038ec 	jal	a000e3b0 <get_timer_jiffies>
a00088f4:	00000000 	nop
a00088f8:	00501023 	subu	v0,v0,s0
a00088fc:	0051102b 	sltu	v0,v0,s1
a0008900:	1440fffb 	bnez	v0,a00088f0 <delay_sec+0x34>
a0008904:	8fbf001c 	lw	ra,28(sp)
}
a0008908:	8fb20018 	lw	s2,24(sp)
a000890c:	8fb10014 	lw	s1,20(sp)
a0008910:	8fb00010 	lw	s0,16(sp)
a0008914:	03e00008 	jr	ra
a0008918:	27bd0020 	addiu	sp,sp,32

a000891c <delay>:



//-----------------------------------------
void delay(unsigned int time_ms)
{
a000891c:	27bdffe0 	addiu	sp,sp,-32
a0008920:	afbf001c 	sw	ra,28(sp)
a0008924:	afb10018 	sw	s1,24(sp)
a0008928:	afb00014 	sw	s0,20(sp)
   unsigned int preTime;
   
   preTime = get_timer_jiffies();
a000892c:	0c0038ec 	jal	a000e3b0 <get_timer_jiffies>
a0008930:	00808821 	move	s1,a0
a0008934:	00408021 	move	s0,v0
   while ( get_timer_jiffies()-preTime <  time_ms/10 );
a0008938:	3c02cccc 	lui	v0,0xcccc
a000893c:	3442cccd 	ori	v0,v0,0xcccd
a0008940:	02220019 	multu	s1,v0
a0008944:	00008810 	mfhi	s1
a0008948:	001188c2 	srl	s1,s1,0x3
a000894c:	0c0038ec 	jal	a000e3b0 <get_timer_jiffies>
a0008950:	00000000 	nop
a0008954:	00501023 	subu	v0,v0,s0
a0008958:	0051102b 	sltu	v0,v0,s1
a000895c:	1440fffb 	bnez	v0,a000894c <delay+0x30>
a0008960:	8fbf001c 	lw	ra,28(sp)
}
a0008964:	8fb10018 	lw	s1,24(sp)
a0008968:	8fb00014 	lw	s0,20(sp)
a000896c:	03e00008 	jr	ra
a0008970:	27bd0020 	addiu	sp,sp,32

a0008974 <twiddle>:
**************************************************************************/

static int twiddle_count;

void twiddle(void)
{
a0008974:	27bdffe8 	addiu	sp,sp,-24
a0008978:	afbf0014 	sw	ra,20(sp)
	static const char tiddles[]="-\\|/";
	putchar(tiddles[(twiddle_count++)&3]);
a000897c:	3c02a002 	lui	v0,0xa002
a0008980:	8c438900 	lw	v1,-30464(v0)
a0008984:	30650003 	andi	a1,v1,0x3
a0008988:	3c04a001 	lui	a0,0xa001
a000898c:	248403f0 	addiu	a0,a0,1008
a0008990:	00a42021 	addu	a0,a1,a0
a0008994:	80840000 	lb	a0,0(a0)
a0008998:	24630001 	addiu	v1,v1,1
a000899c:	0c001fe0 	jal	a0007f80 <serial_outc>
a00089a0:	ac438900 	sw	v1,-30464(v0)
	putchar('\b');
a00089a4:	0c001fe0 	jal	a0007f80 <serial_outc>
a00089a8:	24040008 	li	a0,8
}
a00089ac:	8fbf0014 	lw	ra,20(sp)
a00089b0:	03e00008 	jr	ra
a00089b4:	27bd0018 	addiu	sp,sp,24

a00089b8 <vsprintf>:
int vsprintf(char *buf, const char *fmt, const int *dp)
{
	char *p, *s;

	s = buf;
	for ( ; *fmt != '\0'; ++fmt) {
a00089b8:	27bdffa8 	addiu	sp,sp,-88
a00089bc:	afbf0054 	sw	ra,84(sp)
a00089c0:	afbe0050 	sw	s8,80(sp)
a00089c4:	afb7004c 	sw	s7,76(sp)
a00089c8:	afb60048 	sw	s6,72(sp)
a00089cc:	afb50044 	sw	s5,68(sp)
a00089d0:	afb40040 	sw	s4,64(sp)
a00089d4:	afb3003c 	sw	s3,60(sp)
a00089d8:	afb20038 	sw	s2,56(sp)
a00089dc:	afb10034 	sw	s1,52(sp)
a00089e0:	afb00030 	sw	s0,48(sp)
a00089e4:	0080a021 	move	s4,a0
a00089e8:	00a09021 	move	s2,a1
a00089ec:	00c0b821 	move	s7,a2
a00089f0:	80a40000 	lb	a0,0(a1)
a00089f4:	10800098 	beqz	a0,a0008c58 <vsprintf+0x2a0>
a00089f8:	02808821 	move	s1,s4
		if (*fmt != '%') {
a00089fc:	24150025 	li	s5,37
			else if (*fmt == 'c')
				*q++ = *dp++;
			else
				*q++ = *fmt;
			/* now output the saved string */
			for (p = tmp; p < q; ++p)
a0008a00:	27be0010 	addiu	s8,sp,16
				if (alt) {
					*q++ = '0';
					*q++ = 'X' | ncase;
				}
				for ( ; shift >= 0; shift -= 4)
					*q++ = "0123456789ABCDEF"[(h >> shift) & 0xF] | ncase;
a0008a04:	3c16a001 	lui	s6,0xa001
a0008a08:	26d651c0 	addiu	s6,s6,20928
					*q++ = '-';
					i = -i;
				}
				p = q;		/* save beginning of digits */
				do {
					*q++ = '0' + (i % 10);
a0008a0c:	3c026666 	lui	v0,0x6666
a0008a10:	34426667 	ori	v0,v0,0x6667
a0008a14:	afa20028 	sw	v0,40(sp)
{
	char *p, *s;

	s = buf;
	for ( ; *fmt != '\0'; ++fmt) {
		if (*fmt != '%') {
a0008a18:	1095000a 	beq	a0,s5,a0008a44 <vsprintf+0x8c>
a0008a1c:	24020073 	li	v0,115
			buf ? *s++ = *fmt : putchar(*fmt);
a0008a20:	12800004 	beqz	s4,a0008a34 <vsprintf+0x7c>
a0008a24:	00000000 	nop
a0008a28:	a2240000 	sb	a0,0(s1)
a0008a2c:	08002312 	j	a0008c48 <vsprintf+0x290>
a0008a30:	26310001 	addiu	s1,s1,1
a0008a34:	0c001fe0 	jal	a0007f80 <serial_outc>
a0008a38:	26520001 	addiu	s2,s2,1
int vsprintf(char *buf, const char *fmt, const int *dp)
{
	char *p, *s;

	s = buf;
	for ( ; *fmt != '\0'; ++fmt) {
a0008a3c:	08002314 	j	a0008c50 <vsprintf+0x298>
a0008a40:	82440000 	lb	a0,0(s2)
		if (*fmt != '%') {
			buf ? *s++ = *fmt : putchar(*fmt);
			continue;
		}
		if (*++fmt == 's') {
a0008a44:	26520001 	addiu	s2,s2,1
a0008a48:	82430000 	lb	v1,0(s2)
a0008a4c:	14620012 	bne	v1,v0,a0008a98 <vsprintf+0xe0>
a0008a50:	00002021 	move	a0,zero
			for (p = (char *)*dp++; *p != '\0'; p++)
a0008a54:	8ef00000 	lw	s0,0(s7)
a0008a58:	82040000 	lb	a0,0(s0)
a0008a5c:	1080007a 	beqz	a0,a0008c48 <vsprintf+0x290>
a0008a60:	26f70004 	addiu	s7,s7,4
				buf ? *s++ = *p : putchar(*p);
a0008a64:	12800004 	beqz	s4,a0008a78 <vsprintf+0xc0>
a0008a68:	00000000 	nop
a0008a6c:	a2240000 	sb	a0,0(s1)
a0008a70:	080022a0 	j	a0008a80 <vsprintf+0xc8>
a0008a74:	26310001 	addiu	s1,s1,1
a0008a78:	0c001fe0 	jal	a0007f80 <serial_outc>
a0008a7c:	00000000 	nop
		if (*fmt != '%') {
			buf ? *s++ = *fmt : putchar(*fmt);
			continue;
		}
		if (*++fmt == 's') {
			for (p = (char *)*dp++; *p != '\0'; p++)
a0008a80:	26100001 	addiu	s0,s0,1
a0008a84:	82040000 	lb	a0,0(s0)
a0008a88:	1480fff6 	bnez	a0,a0008a64 <vsprintf+0xac>
a0008a8c:	00000000 	nop
int vsprintf(char *buf, const char *fmt, const int *dp)
{
	char *p, *s;

	s = buf;
	for ( ; *fmt != '\0'; ++fmt) {
a0008a90:	08002313 	j	a0008c4c <vsprintf+0x294>
a0008a94:	26520001 	addiu	s2,s2,1
			char tmp[20], *q = tmp;
			int alt = 0;
			int shift = 28;

#if 1   //wei patch for %02x
			if ((*fmt  >= '0') && (*fmt  <= '9'))
a0008a98:	306300ff 	andi	v1,v1,0xff
a0008a9c:	2465ffd0 	addiu	a1,v1,-48
a0008aa0:	30a500ff 	andi	a1,a1,0xff
a0008aa4:	2ca5000a 	sltiu	a1,a1,10
a0008aa8:	10a0000f 	beqz	a1,a0008ae8 <vsprintf+0x130>
a0008aac:	2402001c 	li	v0,28
			{
				int width;
				unsigned char fch = *fmt;
		                for (width=0; (fch>='0') && (fch<='9'); fch=*++fmt)
		                {    width = width * 10 + fch - '0';
a0008ab0:	00041040 	sll	v0,a0,0x1
a0008ab4:	000420c0 	sll	a0,a0,0x3
a0008ab8:	00442021 	addu	a0,v0,a0
a0008abc:	00831821 	addu	v1,a0,v1
a0008ac0:	2464ffd0 	addiu	a0,v1,-48
#if 1   //wei patch for %02x
			if ((*fmt  >= '0') && (*fmt  <= '9'))
			{
				int width;
				unsigned char fch = *fmt;
		                for (width=0; (fch>='0') && (fch<='9'); fch=*++fmt)
a0008ac4:	26520001 	addiu	s2,s2,1
a0008ac8:	92430000 	lbu	v1,0(s2)
a0008acc:	2462ffd0 	addiu	v0,v1,-48
a0008ad0:	304200ff 	andi	v0,v0,0xff
a0008ad4:	2c42000a 	sltiu	v0,v0,10
a0008ad8:	1440fff6 	bnez	v0,a0008ab4 <vsprintf+0xfc>
a0008adc:	00041040 	sll	v0,a0,0x1
		                {    width = width * 10 + fch - '0';
		                }
				  shift=(width-1)*4;
a0008ae0:	2482ffff 	addiu	v0,a0,-1
a0008ae4:	00021080 	sll	v0,v0,0x2

			/*
			 * Before each format q points to tmp buffer
			 * After each format q points past end of item
			 */
			if ((*fmt == 'x')||(*fmt == 'X')) {
a0008ae8:	82460000 	lb	a2,0(s2)
a0008aec:	24030078 	li	v1,120
a0008af0:	10c30003 	beq	a2,v1,a0008b00 <vsprintf+0x148>
a0008af4:	24050058 	li	a1,88
a0008af8:	14c50012 	bne	a2,a1,a0008b44 <vsprintf+0x18c>
a0008afc:	00000000 	nop
				/* With x86 gcc, sizeof(long) == sizeof(int) */
				const long *lp = (const long *)dp;
				long h = *lp++;
a0008b00:	8ee40000 	lw	a0,0(s7)
a0008b04:	26e50004 	addiu	a1,s7,4
				int ncase = (*fmt & 0x20);
a0008b08:	30c60020 	andi	a2,a2,0x20
				dp = (const int *)lp;
				if (alt) {
					*q++ = '0';
					*q++ = 'X' | ncase;
				}
				for ( ; shift >= 0; shift -= 4)
a0008b0c:	03c09821 	move	s3,s8
a0008b10:	0440004d 	bltz	v0,a0008c48 <vsprintf+0x290>
a0008b14:	00a0b821 	move	s7,a1
					*q++ = "0123456789ABCDEF"[(h >> shift) & 0xF] | ncase;
a0008b18:	00441807 	srav	v1,a0,v0
a0008b1c:	3063000f 	andi	v1,v1,0xf
a0008b20:	00761821 	addu	v1,v1,s6
a0008b24:	90630000 	lbu	v1,0(v1)
a0008b28:	00661825 	or	v1,v1,a2
a0008b2c:	a2630000 	sb	v1,0(s3)
				dp = (const int *)lp;
				if (alt) {
					*q++ = '0';
					*q++ = 'X' | ncase;
				}
				for ( ; shift >= 0; shift -= 4)
a0008b30:	2442fffc 	addiu	v0,v0,-4
a0008b34:	0441fff8 	bgez	v0,a0008b18 <vsprintf+0x160>
a0008b38:	26730001 	addiu	s3,s3,1
a0008b3c:	08002302 	j	a0008c08 <vsprintf+0x250>
a0008b40:	00a0b821 	move	s7,a1
					*q++ = "0123456789ABCDEF"[(h >> shift) & 0xF] | ncase;
			}
			else if (*fmt == 'd') {
a0008b44:	24020064 	li	v0,100
a0008b48:	14c20028 	bne	a2,v0,a0008bec <vsprintf+0x234>
a0008b4c:	24020063 	li	v0,99
				int i = *dp++;
a0008b50:	8ee20000 	lw	v0,0(s7)
a0008b54:	26f70004 	addiu	s7,s7,4
				char *r;
				if (i < 0) {
a0008b58:	04410005 	bgez	v0,a0008b70 <vsprintf+0x1b8>
a0008b5c:	03c02021 	move	a0,s8
					*q++ = '-';
a0008b60:	2403002d 	li	v1,45
a0008b64:	a3a30010 	sb	v1,16(sp)
					i = -i;
a0008b68:	00021023 	negu	v0,v0
a0008b6c:	27a40011 	addiu	a0,sp,17
a0008b70:	00809821 	move	s3,a0
				}
				p = q;		/* save beginning of digits */
				do {
					*q++ = '0' + (i % 10);
a0008b74:	8fa50028 	lw	a1,40(sp)
a0008b78:	00450018 	mult	v0,a1
a0008b7c:	00001810 	mfhi	v1
a0008b80:	00031883 	sra	v1,v1,0x2
a0008b84:	00022fc3 	sra	a1,v0,0x1f
a0008b88:	00651823 	subu	v1,v1,a1
a0008b8c:	00033040 	sll	a2,v1,0x1
a0008b90:	000328c0 	sll	a1,v1,0x3
a0008b94:	00c52821 	addu	a1,a2,a1
a0008b98:	00451023 	subu	v0,v0,a1
a0008b9c:	24420030 	addiu	v0,v0,48
a0008ba0:	a2620000 	sb	v0,0(s3)
a0008ba4:	26730001 	addiu	s3,s3,1
					i /= 10;
				} while (i);
a0008ba8:	1460fff2 	bnez	v1,a0008b74 <vsprintf+0x1bc>
a0008bac:	00601021 	move	v0,v1
				/* reverse digits, stop in middle */
				r = q;		/* don't alter q */
				while (--r > p) {
a0008bb0:	2662ffff 	addiu	v0,s3,-1
a0008bb4:	0082182b 	sltu	v1,a0,v0
a0008bb8:	10600013 	beqz	v1,a0008c08 <vsprintf+0x250>
a0008bbc:	00000000 	nop
					i = *r;
a0008bc0:	80430000 	lb	v1,0(v0)
					*r = *p;
a0008bc4:	90850000 	lbu	a1,0(a0)
a0008bc8:	a0450000 	sb	a1,0(v0)
					*p++ = i;
a0008bcc:	a0830000 	sb	v1,0(a0)
a0008bd0:	24840001 	addiu	a0,a0,1
					*q++ = '0' + (i % 10);
					i /= 10;
				} while (i);
				/* reverse digits, stop in middle */
				r = q;		/* don't alter q */
				while (--r > p) {
a0008bd4:	2442ffff 	addiu	v0,v0,-1
a0008bd8:	0082182b 	sltu	v1,a0,v0
a0008bdc:	1460fff8 	bnez	v1,a0008bc0 <vsprintf+0x208>
a0008be0:	00000000 	nop
			else if (*fmt == 'c')
				*q++ = *dp++;
			else
				*q++ = *fmt;
			/* now output the saved string */
			for (p = tmp; p < q; ++p)
a0008be4:	08002303 	j	a0008c0c <vsprintf+0x254>
a0008be8:	03d3102b 	sltu	v0,s8,s3
				for (r = p + ETH_ALEN; p < r; ++p)
					q += SprintF(q, "%hhX:", *p);
				--q;
			}
#endif			
			else if (*fmt == 'c')
a0008bec:	14c20005 	bne	a2,v0,a0008c04 <vsprintf+0x24c>
a0008bf0:	27b30011 	addiu	s3,sp,17
				*q++ = *dp++;
a0008bf4:	8ee20000 	lw	v0,0(s7)
a0008bf8:	a3a20010 	sb	v0,16(sp)
a0008bfc:	08002302 	j	a0008c08 <vsprintf+0x250>
a0008c00:	26f70004 	addiu	s7,s7,4
			else
				*q++ = *fmt;
a0008c04:	a3a60010 	sb	a2,16(sp)
			/* now output the saved string */
			for (p = tmp; p < q; ++p)
a0008c08:	03d3102b 	sltu	v0,s8,s3
a0008c0c:	1040000e 	beqz	v0,a0008c48 <vsprintf+0x290>
a0008c10:	00000000 	nop
a0008c14:	03c08021 	move	s0,s8
				buf ? *s++ = *p : putchar(*p);
a0008c18:	12800005 	beqz	s4,a0008c30 <vsprintf+0x278>
a0008c1c:	00000000 	nop
a0008c20:	92020000 	lbu	v0,0(s0)
a0008c24:	a2220000 	sb	v0,0(s1)
a0008c28:	0800230e 	j	a0008c38 <vsprintf+0x280>
a0008c2c:	26310001 	addiu	s1,s1,1
a0008c30:	0c001fe0 	jal	a0007f80 <serial_outc>
a0008c34:	82040000 	lb	a0,0(s0)
			else if (*fmt == 'c')
				*q++ = *dp++;
			else
				*q++ = *fmt;
			/* now output the saved string */
			for (p = tmp; p < q; ++p)
a0008c38:	26100001 	addiu	s0,s0,1
a0008c3c:	0213102b 	sltu	v0,s0,s3
a0008c40:	1440fff5 	bnez	v0,a0008c18 <vsprintf+0x260>
a0008c44:	00000000 	nop
int vsprintf(char *buf, const char *fmt, const int *dp)
{
	char *p, *s;

	s = buf;
	for ( ; *fmt != '\0'; ++fmt) {
a0008c48:	26520001 	addiu	s2,s2,1
a0008c4c:	82440000 	lb	a0,0(s2)
a0008c50:	1480ff71 	bnez	a0,a0008a18 <vsprintf+0x60>
a0008c54:	00000000 	nop
			/* now output the saved string */
			for (p = tmp; p < q; ++p)
				buf ? *s++ = *p : putchar(*p);
		}
	}
	if (buf)
a0008c58:	12800002 	beqz	s4,a0008c64 <vsprintf+0x2ac>
a0008c5c:	02341023 	subu	v0,s1,s4
		*s = '\0';
a0008c60:	a2200000 	sb	zero,0(s1)
	return (s - buf);
}
a0008c64:	8fbf0054 	lw	ra,84(sp)
a0008c68:	8fbe0050 	lw	s8,80(sp)
a0008c6c:	8fb7004c 	lw	s7,76(sp)
a0008c70:	8fb60048 	lw	s6,72(sp)
a0008c74:	8fb50044 	lw	s5,68(sp)
a0008c78:	8fb40040 	lw	s4,64(sp)
a0008c7c:	8fb3003c 	lw	s3,60(sp)
a0008c80:	8fb20038 	lw	s2,56(sp)
a0008c84:	8fb10034 	lw	s1,52(sp)
a0008c88:	8fb00030 	lw	s0,48(sp)
a0008c8c:	03e00008 	jr	ra
a0008c90:	27bd0058 	addiu	sp,sp,88

a0008c94 <dprintf>:
*/
#include <stdarg.h>


int dprintf(char *fmt, ...)
{
a0008c94:	27bdffe8 	addiu	sp,sp,-24
a0008c98:	afbf0014 	sw	ra,20(sp)
a0008c9c:	afa5001c 	sw	a1,28(sp)
a0008ca0:	afa60020 	sw	a2,32(sp)
a0008ca4:	afa70024 	sw	a3,36(sp)
a0008ca8:	afa40018 	sw	a0,24(sp)
	(void)vsprintf(0, fmt, ((const int *)&fmt)+1);	
a0008cac:	00802821 	move	a1,a0
a0008cb0:	00002021 	move	a0,zero
a0008cb4:	0c00226e 	jal	a00089b8 <vsprintf>
a0008cb8:	27a6001c 	addiu	a2,sp,28
}
a0008cbc:	8fbf0014 	lw	ra,20(sp)
a0008cc0:	03e00008 	jr	ra
a0008cc4:	27bd0018 	addiu	sp,sp,24

a0008cc8 <ddump>:
//----------------------------------------------------------------
//----------------------------------------------------------------

void ddump(unsigned char * pData, int len)
{
a0008cc8:	27bdffc0 	addiu	sp,sp,-64
a0008ccc:	afbf003c 	sw	ra,60(sp)
a0008cd0:	afbe0038 	sw	s8,56(sp)
a0008cd4:	afb70034 	sw	s7,52(sp)
a0008cd8:	afb60030 	sw	s6,48(sp)
a0008cdc:	afb5002c 	sw	s5,44(sp)
a0008ce0:	afb40028 	sw	s4,40(sp)
a0008ce4:	afb30024 	sw	s3,36(sp)
a0008ce8:	afb20020 	sw	s2,32(sp)
a0008cec:	afb1001c 	sw	s1,28(sp)
a0008cf0:	afb00018 	sw	s0,24(sp)
a0008cf4:	0080b821 	move	s7,a0
a0008cf8:	afa50044 	sw	a1,68(sp)
	unsigned char *sbuf = pData;	
	int length=len;

	int i=0,j,offset;
	dprintf(" [Addr]   .0 .1 .2 .3 .4 .5 .6 .7 .8 .9 .A .B .C .D .E .F\r\n" );
a0008cfc:	3c04a001 	lui	a0,0xa001
a0008d00:	0c002325 	jal	a0008c94 <dprintf>
a0008d04:	248451d4 	addiu	a0,a0,20948

	while(i< length)
a0008d08:	8fa20044 	lw	v0,68(sp)
a0008d0c:	1840004d 	blez	v0,a0008e44 <ddump+0x17c>
a0008d10:	0000f021 	move	s8,zero
a0008d14:	afa20010 	sw	v0,16(sp)
			else			
				offset=length-i;
			

			for(j=0; j<offset; j++)
				dprintf("%02x ", sbuf[i+j]);	
a0008d18:	3c13a001 	lui	s3,0xa001
a0008d1c:	26735218 	addiu	s3,s3,21016

			for(j=0;j<16-offset;j++)	//a last line
			dprintf("   ");
a0008d20:	3c14a001 	lui	s4,0xa001
a0008d24:	269460dc 	addiu	s4,s4,24796
			for(j=0;  j<offset; j++)
			{	
				if( ' ' <= sbuf[i+j]  && sbuf[i+j] <= '~')
					dprintf("%c", sbuf[i+j]);
				else
					dprintf(".");
a0008d28:	3c15a001 	lui	s5,0xa001
a0008d2c:	26b56db8 	addiu	s5,s5,28088
			dprintf("    ");		//between byte and char
			
			for(j=0;  j<offset; j++)
			{	
				if( ' ' <= sbuf[i+j]  && sbuf[i+j] <= '~')
					dprintf("%c", sbuf[i+j]);
a0008d30:	3c16a001 	lui	s6,0xa001
a0008d34:	26d65220 	addiu	s6,s6,21024
	dprintf(" [Addr]   .0 .1 .2 .3 .4 .5 .6 .7 .8 .9 .A .B .C .D .E .F\r\n" );

	while(i< length)
	{		
			
			dprintf("%08X: ", (sbuf+i) );
a0008d38:	3c04a001 	lui	a0,0xa001
a0008d3c:	24845210 	addiu	a0,a0,21008
a0008d40:	0c002325 	jal	a0008c94 <dprintf>
a0008d44:	02e02821 	move	a1,s7

			if(i+16 < length)
a0008d48:	27de0010 	addiu	s8,s8,16
a0008d4c:	8fa30044 	lw	v1,68(sp)
a0008d50:	03c3102a 	slt	v0,s8,v1
a0008d54:	10400004 	beqz	v0,a0008d68 <ddump+0xa0>
a0008d58:	24120010 	li	s2,16
a0008d5c:	02e08021 	move	s0,s7
a0008d60:	0800235f 	j	a0008d7c <ddump+0xb4>
a0008d64:	00008821 	move	s1,zero
a0008d68:	8fb20010 	lw	s2,16(sp)
				offset=16;
			else			
				offset=length-i;
			

			for(j=0; j<offset; j++)
a0008d6c:	1e40fffb 	bgtz	s2,a0008d5c <ddump+0x94>
a0008d70:	24020010 	li	v0,16
				dprintf("%02x ", sbuf[i+j]);	

			for(j=0;j<16-offset;j++)	//a last line
a0008d74:	08002368 	j	a0008da0 <ddump+0xd8>
a0008d78:	00528823 	subu	s1,v0,s2
			else			
				offset=length-i;
			

			for(j=0; j<offset; j++)
				dprintf("%02x ", sbuf[i+j]);	
a0008d7c:	02602021 	move	a0,s3
a0008d80:	0c002325 	jal	a0008c94 <dprintf>
a0008d84:	92050000 	lbu	a1,0(s0)
				offset=16;
			else			
				offset=length-i;
			

			for(j=0; j<offset; j++)
a0008d88:	26310001 	addiu	s1,s1,1
a0008d8c:	0232102a 	slt	v0,s1,s2
a0008d90:	1440fffa 	bnez	v0,a0008d7c <ddump+0xb4>
a0008d94:	26100001 	addiu	s0,s0,1
				dprintf("%02x ", sbuf[i+j]);	

			for(j=0;j<16-offset;j++)	//a last line
a0008d98:	24020010 	li	v0,16
a0008d9c:	00528823 	subu	s1,v0,s2
a0008da0:	1a200008 	blez	s1,a0008dc4 <ddump+0xfc>
a0008da4:	3c04a001 	lui	a0,0xa001
a0008da8:	00008021 	move	s0,zero
			dprintf("   ");
a0008dac:	0c002325 	jal	a0008c94 <dprintf>
a0008db0:	02802021 	move	a0,s4
			

			for(j=0; j<offset; j++)
				dprintf("%02x ", sbuf[i+j]);	

			for(j=0;j<16-offset;j++)	//a last line
a0008db4:	26100001 	addiu	s0,s0,1
a0008db8:	0211102a 	slt	v0,s0,s1
a0008dbc:	1440fffb 	bnez	v0,a0008dac <ddump+0xe4>
a0008dc0:	3c04a001 	lui	a0,0xa001
			dprintf("   ");


			dprintf("    ");		//between byte and char
a0008dc4:	0c002325 	jal	a0008c94 <dprintf>
a0008dc8:	24844cb0 	addiu	a0,a0,19632
			
			for(j=0;  j<offset; j++)
a0008dcc:	1a400014 	blez	s2,a0008e20 <ddump+0x158>
a0008dd0:	3c04a001 	lui	a0,0xa001
a0008dd4:	02e08021 	move	s0,s7
a0008dd8:	00008821 	move	s1,zero
			{	
				if( ' ' <= sbuf[i+j]  && sbuf[i+j] <= '~')
a0008ddc:	92050000 	lbu	a1,0(s0)
a0008de0:	24a2ffe0 	addiu	v0,a1,-32
a0008de4:	304200ff 	andi	v0,v0,0xff
a0008de8:	2c42005f 	sltiu	v0,v0,95
a0008dec:	10400005 	beqz	v0,a0008e04 <ddump+0x13c>
a0008df0:	00000000 	nop
					dprintf("%c", sbuf[i+j]);
a0008df4:	0c002325 	jal	a0008c94 <dprintf>
a0008df8:	02c02021 	move	a0,s6
			dprintf("   ");


			dprintf("    ");		//between byte and char
			
			for(j=0;  j<offset; j++)
a0008dfc:	08002384 	j	a0008e10 <ddump+0x148>
a0008e00:	26310001 	addiu	s1,s1,1
			{	
				if( ' ' <= sbuf[i+j]  && sbuf[i+j] <= '~')
					dprintf("%c", sbuf[i+j]);
				else
					dprintf(".");
a0008e04:	0c002325 	jal	a0008c94 <dprintf>
a0008e08:	02a02021 	move	a0,s5
			dprintf("   ");


			dprintf("    ");		//between byte and char
			
			for(j=0;  j<offset; j++)
a0008e0c:	26310001 	addiu	s1,s1,1
a0008e10:	0232102a 	slt	v0,s1,s2
a0008e14:	1440fff1 	bnez	v0,a0008ddc <ddump+0x114>
a0008e18:	26100001 	addiu	s0,s0,1
				if( ' ' <= sbuf[i+j]  && sbuf[i+j] <= '~')
					dprintf("%c", sbuf[i+j]);
				else
					dprintf(".");
			}
			dprintf("\n\r");
a0008e1c:	3c04a001 	lui	a0,0xa001
a0008e20:	0c002325 	jal	a0008c94 <dprintf>
a0008e24:	24844b58 	addiu	a0,a0,19288
a0008e28:	8fa30010 	lw	v1,16(sp)
a0008e2c:	2463fff0 	addiu	v1,v1,-16
a0008e30:	afa30010 	sw	v1,16(sp)
	int length=len;

	int i=0,j,offset;
	dprintf(" [Addr]   .0 .1 .2 .3 .4 .5 .6 .7 .8 .9 .A .B .C .D .E .F\r\n" );

	while(i< length)
a0008e34:	8fa30044 	lw	v1,68(sp)
a0008e38:	03c3102a 	slt	v0,s8,v1
a0008e3c:	1440ffbe 	bnez	v0,a0008d38 <ddump+0x70>
a0008e40:	26f70010 	addiu	s7,s7,16

	//dprintf("\n\r");


	
}
a0008e44:	8fbf003c 	lw	ra,60(sp)
a0008e48:	8fbe0038 	lw	s8,56(sp)
a0008e4c:	8fb70034 	lw	s7,52(sp)
a0008e50:	8fb60030 	lw	s6,48(sp)
a0008e54:	8fb5002c 	lw	s5,44(sp)
a0008e58:	8fb40028 	lw	s4,40(sp)
a0008e5c:	8fb30024 	lw	s3,36(sp)
a0008e60:	8fb20020 	lw	s2,32(sp)
a0008e64:	8fb1001c 	lw	s1,28(sp)
a0008e68:	8fb00018 	lw	s0,24(sp)
a0008e6c:	03e00008 	jr	ra
a0008e70:	27bd0040 	addiu	sp,sp,64

a0008e74 <SprintF>:
{
	(void)vsprintf(0, fmt, ((const int *)&fmt)+1);	
}

int SprintF(char *buf, const char *fmt, ...)
{
a0008e74:	27bdffe8 	addiu	sp,sp,-24
a0008e78:	afbf0014 	sw	ra,20(sp)
a0008e7c:	afa60020 	sw	a2,32(sp)
a0008e80:	afa70024 	sw	a3,36(sp)
a0008e84:	afa5001c 	sw	a1,28(sp)
	return vsprintf(buf, fmt, ((const int *)&fmt)+1);
a0008e88:	0c00226e 	jal	a00089b8 <vsprintf>
a0008e8c:	27a60020 	addiu	a2,sp,32
}
a0008e90:	8fbf0014 	lw	ra,20(sp)
a0008e94:	03e00008 	jr	ra
a0008e98:	27bd0018 	addiu	sp,sp,24

a0008e9c <prom_printf>:
		*s = '\0';
	return (s - buf);
}

void prom_printf(const char *fmt, ...)
{
a0008e9c:	27bdffe8 	addiu	sp,sp,-24
a0008ea0:	afbf0014 	sw	ra,20(sp)
a0008ea4:	afa5001c 	sw	a1,28(sp)
a0008ea8:	afa60020 	sw	a2,32(sp)
a0008eac:	afa70024 	sw	a3,36(sp)
a0008eb0:	afa40018 	sw	a0,24(sp)
	(void)vsprintf(0, fmt, ((const int *)&fmt)+1);	
a0008eb4:	00802821 	move	a1,a0
a0008eb8:	00002021 	move	a0,zero
a0008ebc:	0c00226e 	jal	a00089b8 <vsprintf>
a0008ec0:	27a6001c 	addiu	a2,sp,28
}
a0008ec4:	8fbf0014 	lw	ra,20(sp)
a0008ec8:	03e00008 	jr	ra
a0008ecc:	27bd0018 	addiu	sp,sp,24

a0008ed0 <rtl8168_tx>:
//===============================================================================
void rtl8168_tx(unsigned char *content, unsigned int size, int portnum)
{
   unsigned int i;

   if ( (portnum == 0) || (portnum== 2) )
a0008ed0:	10c00004 	beqz	a2,a0008ee4 <rtl8168_tx+0x14>
a0008ed4:	3c04a053 	lui	a0,0xa053
a0008ed8:	24020002 	li	v0,2
a0008edc:	14c2001b 	bne	a2,v0,a0008f4c <rtl8168_tx+0x7c>
a0008ee0:	00000000 	nop
   {
      // Fill RX Descriptor
      WRITE_MEM32(RX1_DESC_ADDR + 0x08, htonl(PADDR(RX1_BUFF_ADDR)));  // RX Buffer Address
a0008ee4:	34820008 	ori	v0,a0,0x8
a0008ee8:	24035a00 	li	v1,23040
a0008eec:	ac430000 	sw	v1,0(v0)
      WRITE_MEM32(RX1_DESC_ADDR + 0x18, htonl(PADDR(RX1_BUFF_ADDR)));  // RX Buffer Address
a0008ef0:	34840018 	ori	a0,a0,0x18
a0008ef4:	ac830000 	sw	v1,0(a0)

      // Ensure Descriptor is updated
      READ_MEM32(RX1_DESC_ADDR + 0x8);
a0008ef8:	8c420000 	lw	v0,0(v0)

      // Enable TX/RX (This seems to trigger NIC prefetching RX descriptor)
      WRITE_MEM8(PCIE1_EP_MEM + ChipCmd, 0x0C);
a0008efc:	2403000c 	li	v1,12
a0008f00:	3c02b900 	lui	v0,0xb900
a0008f04:	34420037 	ori	v0,v0,0x37
a0008f08:	a0430000 	sb	v1,0(v0)

      #if 1
      // Fill Descriptor
      WRITE_MEM32(TX1_DESC_ADDR + 0x0, htonl(DescOwn | FirstFrag | LastFrag | RingEnd | size));
a0008f0c:	00051a02 	srl	v1,a1,0x8
a0008f10:	3063ff00 	andi	v1,v1,0xff00
a0008f14:	30a2ff00 	andi	v0,a1,0xff00
a0008f18:	00021200 	sll	v0,v0,0x8
a0008f1c:	00621825 	or	v1,v1,v0
a0008f20:	00051600 	sll	v0,a1,0x18
a0008f24:	00621825 	or	v1,v1,v0
a0008f28:	7ca21e00 	ext	v0,a1,0x18,0x4
a0008f2c:	344200f0 	ori	v0,v0,0xf0
a0008f30:	00621825 	or	v1,v1,v0
a0008f34:	3c02a052 	lui	v0,0xa052
a0008f38:	ac430000 	sw	v1,0(v0)
      WRITE_MEM32(TX1_DESC_ADDR + 0x8, htonl(PADDR((unsigned int) TX1_BUFF_ADDR)));
a0008f3c:	34420008 	ori	v0,v0,0x8
a0008f40:	24035800 	li	v1,22528
a0008f44:	ac430000 	sw	v1,0(v0)

      // Ensure Descriptor is updated
      READ_MEM32(TX1_DESC_ADDR + 0x8);
a0008f48:	8c420000 	lw	v0,0(v0)
      }
      #endif
   }

  #if (TEST_8196_PCIE_P1)
   if ( (portnum == 1) || (portnum== 2) )//PORT1
a0008f4c:	24c6ffff 	addiu	a2,a2,-1
a0008f50:	2cc60002 	sltiu	a2,a2,2
a0008f54:	10c0001b 	beqz	a2,a0008fc4 <rtl8168_tx+0xf4>
a0008f58:	3c04a063 	lui	a0,0xa063
   {
      // Fill RX Descriptor
      WRITE_MEM32(RX2_DESC_ADDR + 0x08, htonl(PADDR(RX2_BUFF_ADDR)));  // RX Buffer Address
a0008f5c:	34820008 	ori	v0,a0,0x8
a0008f60:	24036a00 	li	v1,27136
a0008f64:	ac430000 	sw	v1,0(v0)
      WRITE_MEM32(RX2_DESC_ADDR + 0x18, htonl(PADDR(RX2_BUFF_ADDR)));  // RX Buffer Address
a0008f68:	34840018 	ori	a0,a0,0x18
a0008f6c:	ac830000 	sw	v1,0(a0)

      // Ensure Descriptor is updated
      READ_MEM32(RX2_DESC_ADDR + 0x8);
a0008f70:	8c420000 	lw	v0,0(v0)

      // Enable TX/RX (This seems to trigger NIC prefetching RX descriptor)
      WRITE_MEM8(PCIE2_EP_MEM + ChipCmd, 0x0C);
a0008f74:	2403000c 	li	v1,12
a0008f78:	3c02ba00 	lui	v0,0xba00
a0008f7c:	34420037 	ori	v0,v0,0x37
a0008f80:	a0430000 	sb	v1,0(v0)

      #if 1
      // Fill Descriptor
      WRITE_MEM32(TX2_DESC_ADDR + 0x0, htonl(DescOwn | FirstFrag | LastFrag | RingEnd | size));
a0008f84:	00051a02 	srl	v1,a1,0x8
a0008f88:	3063ff00 	andi	v1,v1,0xff00
a0008f8c:	30a2ff00 	andi	v0,a1,0xff00
a0008f90:	00021200 	sll	v0,v0,0x8
a0008f94:	00621025 	or	v0,v1,v0
a0008f98:	00051e00 	sll	v1,a1,0x18
a0008f9c:	00431025 	or	v0,v0,v1
a0008fa0:	7ca51e00 	ext	a1,a1,0x18,0x4
a0008fa4:	34a500f0 	ori	a1,a1,0xf0
a0008fa8:	00452825 	or	a1,v0,a1
a0008fac:	3c02a062 	lui	v0,0xa062
a0008fb0:	ac450000 	sw	a1,0(v0)
      WRITE_MEM32(TX2_DESC_ADDR + 0x8, htonl(PADDR((unsigned int) TX2_BUFF_ADDR)));
a0008fb4:	34420008 	ori	v0,v0,0x8
a0008fb8:	24036800 	li	v1,26624
a0008fbc:	ac430000 	sw	v1,0(v0)

      // Ensure Descriptor is updated
      READ_MEM32(TX2_DESC_ADDR + 0x8);
a0008fc0:	8c420000 	lw	v0,0(v0)
a0008fc4:	03e00008 	jr	ra
a0008fc8:	00000000 	nop

a0008fcc <rtl8168_tx_trigger>:
   return 0;
}
//===============================================================================
void rtl8168_tx_trigger(int portnum)
{
	if ((portnum == 0) |(portnum== 2) )   //Port 0
a0008fcc:	10800004 	beqz	a0,a0008fe0 <rtl8168_tx_trigger+0x14>
a0008fd0:	24030040 	li	v1,64
a0008fd4:	24020002 	li	v0,2
a0008fd8:	14820004 	bne	a0,v0,a0008fec <rtl8168_tx_trigger+0x20>
a0008fdc:	00000000 	nop
	{		
		WRITE_MEM8(PCIE1_EP_MEM + TxPoll, 0x40);	// Indicate TX Packet
a0008fe0:	3c02b900 	lui	v0,0xb900
a0008fe4:	34420038 	ori	v0,v0,0x38
a0008fe8:	a0430000 	sb	v1,0(v0)
	}
  
	if ((portnum == 1) |(portnum == 2) )   //PORT1
a0008fec:	2484ffff 	addiu	a0,a0,-1
a0008ff0:	2c840002 	sltiu	a0,a0,2
a0008ff4:	10800004 	beqz	a0,a0009008 <rtl8168_tx_trigger+0x3c>
a0008ff8:	24030040 	li	v1,64
	{	     
	      WRITE_MEM8(PCIE2_EP_MEM + TxPoll, 0x40);	 // Indicate TX Packet
a0008ffc:	3c02ba00 	lui	v0,0xba00
a0009000:	34420038 	ori	v0,v0,0x38
a0009004:	a0430000 	sb	v1,0(v0)
a0009008:	03e00008 	jr	ra
a000900c:	00000000 	nop

a0009010 <PCIE_isr>:


volatile unsigned int grxok=0;
volatile unsigned int gtxok=0;
static void PCIE_isr(void)
{
a0009010:	27bdffe8 	addiu	sp,sp,-24
a0009014:	afbf0014 	sw	ra,20(sp)
a0009018:	afb00010 	sw	s0,16(sp)
		addr=PCIE2_EP_MEM;
	}


//	printf("PCIE ISR\n");	
	unsigned int r=READ_MEM16(addr + IntrStatus);
a000901c:	3c02b900 	lui	v0,0xb900
a0009020:	3442003e 	ori	v0,v0,0x3e
a0009024:	94500000 	lhu	s0,0(v0)
a0009028:	3210ffff 	andi	s0,s0,0xffff
	if((r==0) || (r==0xffff))
a000902c:	12000041 	beqz	s0,a0009134 <PCIE_isr+0x124>
a0009030:	3402ffff 	li	v0,0xffff
a0009034:	12020040 	beq	s0,v0,a0009138 <PCIE_isr+0x128>
a0009038:	8fbf0014 	lw	ra,20(sp)
		return 0;
	
	printf("\n=>ISR=%x \n", r);
a000903c:	3c04a001 	lui	a0,0xa001
a0009040:	24845224 	addiu	a0,a0,21028
a0009044:	0c002325 	jal	a0008c94 <dprintf>
a0009048:	02002821 	move	a1,s0

	if(r & RxOK)   // bit 0
a000904c:	32020001 	andi	v0,s0,0x1
a0009050:	10400008 	beqz	v0,a0009074 <PCIE_isr+0x64>
a0009054:	32020002 	andi	v0,s0,0x2
	{
		printf("RxOK\n");	
a0009058:	3c04a001 	lui	a0,0xa001
a000905c:	0c002325 	jal	a0008c94 <dprintf>
a0009060:	24845230 	addiu	a0,a0,21040
		grxok=1;
a0009064:	24030001 	li	v1,1
a0009068:	3c02a002 	lui	v0,0xa002
a000906c:	ac438910 	sw	v1,-30448(v0)
	}
	if(r &RxErr)   // bit 1
a0009070:	32020002 	andi	v0,s0,0x2
a0009074:	10400005 	beqz	v0,a000908c <PCIE_isr+0x7c>
a0009078:	32020004 	andi	v0,s0,0x4
	{
		printf("RxErr\n");	
a000907c:	3c04a001 	lui	a0,0xa001
a0009080:	0c002325 	jal	a0008c94 <dprintf>
a0009084:	24845238 	addiu	a0,a0,21048
	}
	if(r & TxOK)   //bit 2
a0009088:	32020004 	andi	v0,s0,0x4
a000908c:	10400008 	beqz	v0,a00090b0 <PCIE_isr+0xa0>
a0009090:	32020008 	andi	v0,s0,0x8
	{
		printf("TxOK\n");	
a0009094:	3c04a001 	lui	a0,0xa001
a0009098:	0c002325 	jal	a0008c94 <dprintf>
a000909c:	24845240 	addiu	a0,a0,21056
		gtxok=1;
a00090a0:	24030001 	li	v1,1
a00090a4:	3c02a002 	lui	v0,0xa002
a00090a8:	ac438914 	sw	v1,-30444(v0)
	}
	if(r &TxErr)  //bit 3
a00090ac:	32020008 	andi	v0,s0,0x8
a00090b0:	10400005 	beqz	v0,a00090c8 <PCIE_isr+0xb8>
a00090b4:	32020010 	andi	v0,s0,0x10
	{
		printf("TxErr\n");	
a00090b8:	3c04a001 	lui	a0,0xa001
a00090bc:	0c002325 	jal	a0008c94 <dprintf>
a00090c0:	24845248 	addiu	a0,a0,21064
	}
	
	if(r & RxDescUnavail)  //bit 4
a00090c4:	32020010 	andi	v0,s0,0x10
a00090c8:	10400005 	beqz	v0,a00090e0 <PCIE_isr+0xd0>
a00090cc:	32020020 	andi	v0,s0,0x20
	{
		printf("RxDescUnavail\n");	
a00090d0:	3c04a001 	lui	a0,0xa001
a00090d4:	0c002325 	jal	a0008c94 <dprintf>
a00090d8:	24845250 	addiu	a0,a0,21072
	}
	if(r &LinkChg)   //bit 5
a00090dc:	32020020 	andi	v0,s0,0x20
a00090e0:	10400005 	beqz	v0,a00090f8 <PCIE_isr+0xe8>
a00090e4:	32020040 	andi	v0,s0,0x40
	{
		printf("LinkChg\n");	
a00090e8:	3c04a001 	lui	a0,0xa001
a00090ec:	0c002325 	jal	a0008c94 <dprintf>
a00090f0:	24845260 	addiu	a0,a0,21088
	}
	if(r &RxFIFOOver)   //bit 6
a00090f4:	32020040 	andi	v0,s0,0x40
a00090f8:	10400004 	beqz	v0,a000910c <PCIE_isr+0xfc>
a00090fc:	00000000 	nop
	{
		printf("RxFIFOOver\n");	
a0009100:	3c04a001 	lui	a0,0xa001
a0009104:	0c002325 	jal	a0008c94 <dprintf>
a0009108:	2484526c 	addiu	a0,a0,21100
	}	
	if(r &TxDescUnavail)   //bit 7
a000910c:	32100080 	andi	s0,s0,0x80
a0009110:	12000005 	beqz	s0,a0009128 <PCIE_isr+0x118>
a0009114:	2403ffff 	li	v1,-1
	{
		printf("TxDescUnavail\n");	
a0009118:	3c04a001 	lui	a0,0xa001
a000911c:	0c002325 	jal	a0008c94 <dprintf>
a0009120:	24845278 	addiu	a0,a0,21112
	{
		printf("SYSErr\n");	
	}		
*/
	
	WRITE_MEM16(addr + IntrStatus, 0xffff);
a0009124:	2403ffff 	li	v1,-1
a0009128:	3c02b900 	lui	v0,0xb900
a000912c:	3442003e 	ori	v0,v0,0x3e
a0009130:	a4430000 	sh	v1,0(v0)
}
a0009134:	8fbf0014 	lw	ra,20(sp)
a0009138:	8fb00010 	lw	s0,16(sp)
a000913c:	03e00008 	jr	ra
a0009140:	27bd0018 	addiu	sp,sp,24

a0009144 <rtl8168_rx>:
//===============================================================================

 

int rtl8168_rx(unsigned char *content, unsigned int size, int portnum)
{
a0009144:	27bdffc8 	addiu	sp,sp,-56
a0009148:	afbf0034 	sw	ra,52(sp)
a000914c:	afb50030 	sw	s5,48(sp)
a0009150:	afb4002c 	sw	s4,44(sp)
a0009154:	afb30028 	sw	s3,40(sp)
a0009158:	afb20024 	sw	s2,36(sp)
a000915c:	afb10020 	sw	s1,32(sp)
a0009160:	afb0001c 	sw	s0,28(sp)
a0009164:	00809021 	move	s2,a0
a0009168:	00a08821 	move	s1,a1
a000916c:	00c09821 	move	s3,a2
 

   
   
  #if DBG	  
     prom_printf("\nTest Rx Bytes=%d\n",size); //OK   
a0009170:	3c04a001 	lui	a0,0xa001
a0009174:	0c0023a7 	jal	a0008e9c <prom_printf>
a0009178:	24845288 	addiu	a0,a0,21128
     prom_printf("P0 PCIE Error count: %d\n",P0_PCIE_error_count);
a000917c:	3c04a001 	lui	a0,0xa001
a0009180:	2484529c 	addiu	a0,a0,21148
a0009184:	0c0023a7 	jal	a0008e9c <prom_printf>
a0009188:	00002821 	move	a1,zero
  #if (TEST_8196_PCIE_P1) 
     prom_printf("P1 PCIE Error count: %d\n",P1_PCIE_error_count);
a000918c:	3c04a001 	lui	a0,0xa001
a0009190:	248452b8 	addiu	a0,a0,21176
a0009194:	0c0023a7 	jal	a0008e9c <prom_printf>
a0009198:	00002821 	move	a1,zero
  #endif
  #endif 
   
  
    if ((portnum == 0) || (portnum == 2) )
a000919c:	12600004 	beqz	s3,a00091b0 <rtl8168_rx+0x6c>
a00091a0:	3c03a053 	lui	v1,0xa053
a00091a4:	24020002 	li	v0,2
a00091a8:	16620055 	bne	s3,v0,a0009300 <rtl8168_rx+0x1bc>
a00091ac:	00000000 	nop
   {
      // Wait RX Packet   
		  //loop here when OWN bit=1 (means Memory is owned by PCIE IP)
		 //dprintf("Wait Rx own bit \n");
		  while ((READ_MEM32(RX1_DESC_ADDR) & htonl(DescOwn)) != 0)
a00091b0:	8c620000 	lw	v0,0(v1)
a00091b4:	30420080 	andi	v0,v0,0x80
a00091b8:	1440fffd 	bnez	v0,a00091b0 <rtl8168_rx+0x6c>
a00091bc:	00000000 	nop
		 //dprintf("got Rx own bit \n");
		 
      // Check RX Packet Content
      int i2;
	   
      for (i = 0; i < size; i++)        
a00091c0:	1220004f 	beqz	s1,a0009300 <rtl8168_rx+0x1bc>
a00091c4:	3c02a05a 	lui	v0,0xa05a
      {
      
         if (READ_MEM8(RX1_BUFF_ADDR + i) != content[i])
a00091c8:	90430000 	lbu	v1,0(v0)
a00091cc:	306300ff 	andi	v1,v1,0xff
a00091d0:	92420000 	lbu	v0,0(s2)
		   prom_printf("\nCheck last 4 Bytes,Rx(0x%x) content=%x\n",(0xa0630000+i-4),READ_MEM32(0xa0630000+i-4));
		   
		   
		 //#if 1 //for 2 port
		 		 	
		 	return -1; // RX Error
a00091d4:	00008021 	move	s0,zero
      int i2;
	   
      for (i = 0; i < size; i++)        
      {
      
         if (READ_MEM8(RX1_BUFF_ADDR + i) != content[i])
a00091d8:	10620045 	beq	v1,v0,a00092f0 <rtl8168_rx+0x1ac>
a00091dc:	3c05a05a 	lui	a1,0xa05a
a00091e0:	08002481 	j	a0009204 <rtl8168_rx+0xc0>
a00091e4:	3c03a05a 	lui	v1,0xa05a
a00091e8:	90640000 	lbu	a0,0(v1)
a00091ec:	308400ff 	andi	a0,a0,0xff
a00091f0:	02501021 	addu	v0,s2,s0
a00091f4:	90420000 	lbu	v0,0(v0)
a00091f8:	1082003e 	beq	a0,v0,a00092f4 <rtl8168_rx+0x1b0>
a00091fc:	26100001 	addiu	s0,s0,1
a0009200:	2610ffff 	addiu	s0,s0,-1
         {
           #if DBG//JSW:DEBUG_PRINT
		  P0_PCIE_error_count++;
		     		  
	         prom_printf("Compare Error, No: Port0, Size: %d, Offset: %d, Content: 0x%X, Expected: 0x%X \n",
	                     size, i, READ_MEM8(RX1_BUFF_ADDR + i), content[i]);
a0009204:	90670000 	lbu	a3,0(v1)
         if (READ_MEM8(RX1_BUFF_ADDR + i) != content[i])
         {
           #if DBG//JSW:DEBUG_PRINT
		  P0_PCIE_error_count++;
		     		  
	         prom_printf("Compare Error, No: Port0, Size: %d, Offset: %d, Content: 0x%X, Expected: 0x%X \n",
a0009208:	afa20010 	sw	v0,16(sp)
a000920c:	3c04a001 	lui	a0,0xa001
a0009210:	248452d4 	addiu	a0,a0,21204
a0009214:	02202821 	move	a1,s1
a0009218:	02003021 	move	a2,s0
a000921c:	0c0023a7 	jal	a0008e9c <prom_printf>
a0009220:	30e700ff 	andi	a3,a3,0xff
a0009224:	3c13a05a 	lui	s3,0xa05a
a0009228:	36710001 	ori	s1,s3,0x1
a000922c:	02118821 	addu	s1,s0,s1
a0009230:	02509021 	addu	s2,s2,s0
}
//===============================================================================

 

int rtl8168_rx(unsigned char *content, unsigned int size, int portnum)
a0009234:	36730005 	ori	s3,s3,0x5
a0009238:	02139821 	addu	s3,s0,s3
	         prom_printf("Compare Error, No: Port0, Size: %d, Offset: %d, Content: 0x%X, Expected: 0x%X \n",
	                     size, i, READ_MEM8(RX1_BUFF_ADDR + i), content[i]);
		   
		   for (i2=1;i2<=4;i2++)
		   {
		   	 prom_printf("\nOffset(%d),Content:%x,Expected:%x\n",(i+i2),READ_MEM8(RX1_BUFF_ADDR + i+i2),content[i+i2]);
a000923c:	3c145fa6 	lui	s4,0x5fa6
a0009240:	3c15a001 	lui	s5,0xa001
a0009244:	26b55324 	addiu	s5,s5,21284
a0009248:	92260000 	lbu	a2,0(s1)
a000924c:	02a02021 	move	a0,s5
a0009250:	02342821 	addu	a1,s1,s4
a0009254:	30c600ff 	andi	a2,a2,0xff
a0009258:	0c0023a7 	jal	a0008e9c <prom_printf>
a000925c:	92470001 	lbu	a3,1(s2)
a0009260:	26310001 	addiu	s1,s1,1
		  P0_PCIE_error_count++;
		     		  
	         prom_printf("Compare Error, No: Port0, Size: %d, Offset: %d, Content: 0x%X, Expected: 0x%X \n",
	                     size, i, READ_MEM8(RX1_BUFF_ADDR + i), content[i]);
		   
		   for (i2=1;i2<=4;i2++)
a0009264:	1633fff8 	bne	s1,s3,a0009248 <rtl8168_rx+0x104>
a0009268:	26520001 	addiu	s2,s2,1

		   }
		   
		  
		   //prom_printf("\ncontent=%x\n",&content);
		   prom_printf("\n==================================\n");
a000926c:	3c11a001 	lui	s1,0xa001
a0009270:	0c0023a7 	jal	a0008e9c <prom_printf>
a0009274:	26245348 	addiu	a0,s1,21320
		   prom_printf("\nOK Tx(0x%x) content=%x\n",(0xa0420000+i),READ_MEM32(0xa0420000+i));
a0009278:	3c05a042 	lui	a1,0xa042
a000927c:	02052821 	addu	a1,s0,a1
a0009280:	8ca60000 	lw	a2,0(a1)
a0009284:	3c04a001 	lui	a0,0xa001
a0009288:	0c0023a7 	jal	a0008e9c <prom_printf>
a000928c:	24845370 	addiu	a0,a0,21360
		   prom_printf("\nFail Rx(0x%x) content=%x\n",(0xa0630000+i),READ_MEM32(0xa0630000+i));
a0009290:	3c05a063 	lui	a1,0xa063
a0009294:	02052821 	addu	a1,s0,a1
a0009298:	8ca60000 	lw	a2,0(a1)
a000929c:	3c04a001 	lui	a0,0xa001
a00092a0:	0c0023a7 	jal	a0008e9c <prom_printf>
a00092a4:	2484538c 	addiu	a0,a0,21388
		   prom_printf("\n==================================\n");
a00092a8:	0c0023a7 	jal	a0008e9c <prom_printf>
a00092ac:	26245348 	addiu	a0,s1,21320

		
		   prom_printf("\nCheck last 4 Bytes,Tx(0x%x) content=%x\n",(0xa0420000+i-4),READ_MEM32(0xa0420000+i-4));
a00092b0:	3c05a041 	lui	a1,0xa041
a00092b4:	34a5fffc 	ori	a1,a1,0xfffc
a00092b8:	02052821 	addu	a1,s0,a1
a00092bc:	8ca60000 	lw	a2,0(a1)
a00092c0:	3c04a001 	lui	a0,0xa001
a00092c4:	0c0023a7 	jal	a0008e9c <prom_printf>
a00092c8:	248453a8 	addiu	a0,a0,21416
		   prom_printf("\nCheck last 4 Bytes,Rx(0x%x) content=%x\n",(0xa0630000+i-4),READ_MEM32(0xa0630000+i-4));
a00092cc:	3c05a062 	lui	a1,0xa062
a00092d0:	34a5fffc 	ori	a1,a1,0xfffc
a00092d4:	02052821 	addu	a1,s0,a1
a00092d8:	8ca60000 	lw	a2,0(a1)
a00092dc:	3c04a001 	lui	a0,0xa001
a00092e0:	0c0023a7 	jal	a0008e9c <prom_printf>
a00092e4:	248453d4 	addiu	a0,a0,21460
		   
		   
		 //#if 1 //for 2 port
		 		 	
		 	return -1; // RX Error
a00092e8:	0800251c 	j	a0009470 <rtl8168_rx+0x32c>
a00092ec:	2402ffff 	li	v0,-1
		 //dprintf("got Rx own bit \n");
		 
      // Check RX Packet Content
      int i2;
	   
      for (i = 0; i < size; i++)        
a00092f0:	26100001 	addiu	s0,s0,1
a00092f4:	0211102b 	sltu	v0,s0,s1
a00092f8:	1440ffbb 	bnez	v0,a00091e8 <rtl8168_rx+0xa4>
a00092fc:	02051821 	addu	v1,s0,a1
         }
      }
   }
//-------------------------------------------------
  #if (TEST_8196_PCIE_P1)
    if( (portnum == 1) || (portnum == 2) )//PORT1
a0009300:	2673ffff 	addiu	s3,s3,-1
a0009304:	2e730002 	sltiu	s3,s3,2
a0009308:	12600059 	beqz	s3,a0009470 <rtl8168_rx+0x32c>
a000930c:	00001021 	move	v0,zero
				   break;
			    }
	      }		 	 
	    
	#else
		  while ((READ_MEM32(RX2_DESC_ADDR) & htonl(DescOwn)) != 0);
a0009310:	3c03a063 	lui	v1,0xa063
a0009314:	8c620000 	lw	v0,0(v1)
a0009318:	30420080 	andi	v0,v0,0x80
a000931c:	1440fffd 	bnez	v0,a0009314 <rtl8168_rx+0x1d0>
a0009320:	00000000 	nop
#endif
       #endif

       int i3;
      // Check RX Packet Content
        for (i = 0; i < size; i++)        
a0009324:	12200051 	beqz	s1,a000946c <rtl8168_rx+0x328>
a0009328:	3c02a06a 	lui	v0,0xa06a
      {
      
         if (READ_MEM8(RX2_BUFF_ADDR + i) != content[i])
a000932c:	90430000 	lbu	v1,0(v0)
a0009330:	306300ff 	andi	v1,v1,0xff
a0009334:	92420000 	lbu	v0,0(s2)
		   prom_printf("\n================================================\n");

		   prom_printf("\nCheck last 4 Bytes,Tx(0x%x) content=%x\n",(0xa0820000+i-4),READ_MEM32(0xa0820000+i-4));
		   prom_printf("\nCheck last 4 Bytes,Rx(0x%x) content=%x\n",(0xa0a30000+i-4),READ_MEM32(0xa0a30000+i-4));
		   prom_printf("\n================================================\n");
		   return -1;
a0009338:	00008021 	move	s0,zero
       int i3;
      // Check RX Packet Content
        for (i = 0; i < size; i++)        
      {
      
         if (READ_MEM8(RX2_BUFF_ADDR + i) != content[i])
a000933c:	10620047 	beq	v1,v0,a000945c <rtl8168_rx+0x318>
a0009340:	3c05a06a 	lui	a1,0xa06a
a0009344:	080024da 	j	a0009368 <rtl8168_rx+0x224>
a0009348:	3c03a06a 	lui	v1,0xa06a
a000934c:	90640000 	lbu	a0,0(v1)
a0009350:	308400ff 	andi	a0,a0,0xff
a0009354:	02501021 	addu	v0,s2,s0
a0009358:	90420000 	lbu	v0,0(v0)
a000935c:	10820040 	beq	a0,v0,a0009460 <rtl8168_rx+0x31c>
a0009360:	26100001 	addiu	s0,s0,1
a0009364:	2610ffff 	addiu	s0,s0,-1
         {
           #if DBG//JSW:DEBUG_PRINT
		   P1_PCIE_error_count++;	
		  
	         prom_printf("Compare Error, No: Port1, Size: %d, Offset: %d, Content: 0x%X, Expected: 0x%X\n",
	                     size, i, READ_MEM8(RX2_BUFF_ADDR + i), content[i]);
a0009368:	90670000 	lbu	a3,0(v1)
         if (READ_MEM8(RX2_BUFF_ADDR + i) != content[i])
         {
           #if DBG//JSW:DEBUG_PRINT
		   P1_PCIE_error_count++;	
		  
	         prom_printf("Compare Error, No: Port1, Size: %d, Offset: %d, Content: 0x%X, Expected: 0x%X\n",
a000936c:	afa20010 	sw	v0,16(sp)
a0009370:	3c04a001 	lui	a0,0xa001
a0009374:	24845400 	addiu	a0,a0,21504
a0009378:	02202821 	move	a1,s1
a000937c:	02003021 	move	a2,s0
a0009380:	0c0023a7 	jal	a0008e9c <prom_printf>
a0009384:	30e700ff 	andi	a3,a3,0xff
a0009388:	3c13a06a 	lui	s3,0xa06a
a000938c:	36710001 	ori	s1,s3,0x1
a0009390:	02118821 	addu	s1,s0,s1
a0009394:	02509021 	addu	s2,s2,s0
}
//===============================================================================

 

int rtl8168_rx(unsigned char *content, unsigned int size, int portnum)
a0009398:	36730005 	ori	s3,s3,0x5
a000939c:	02139821 	addu	s3,s0,s3
	         prom_printf("Compare Error, No: Port1, Size: %d, Offset: %d, Content: 0x%X, Expected: 0x%X\n",
	                     size, i, READ_MEM8(RX2_BUFF_ADDR + i), content[i]);
		   //prom_printf("PCIE Mac LoopBack Compare Error!!! \n");
		   for (i3=1;i3<=4;i3++)
		   {
		   	 prom_printf("\nOffset(%d),Content:%x,Expected:%x\n",(i+i3),READ_MEM8(RX2_BUFF_ADDR + i+i3),content[i+i3]);
a00093a0:	3c145f96 	lui	s4,0x5f96
a00093a4:	3c15a001 	lui	s5,0xa001
a00093a8:	26b55324 	addiu	s5,s5,21284
a00093ac:	92260000 	lbu	a2,0(s1)
a00093b0:	02a02021 	move	a0,s5
a00093b4:	02342821 	addu	a1,s1,s4
a00093b8:	30c600ff 	andi	a2,a2,0xff
a00093bc:	0c0023a7 	jal	a0008e9c <prom_printf>
a00093c0:	92470001 	lbu	a3,1(s2)
a00093c4:	26310001 	addiu	s1,s1,1
		   P1_PCIE_error_count++;	
		  
	         prom_printf("Compare Error, No: Port1, Size: %d, Offset: %d, Content: 0x%X, Expected: 0x%X\n",
	                     size, i, READ_MEM8(RX2_BUFF_ADDR + i), content[i]);
		   //prom_printf("PCIE Mac LoopBack Compare Error!!! \n");
		   for (i3=1;i3<=4;i3++)
a00093c8:	1633fff8 	bne	s1,s3,a00093ac <rtl8168_rx+0x268>
a00093cc:	26520001 	addiu	s2,s2,1
		   }
		   		   
			  
  		   
		   //prom_printf("\ncontent=%x\n",&content);
		   prom_printf("\n================================================\n");
a00093d0:	3c11a001 	lui	s1,0xa001
a00093d4:	0c0023a7 	jal	a0008e9c <prom_printf>
a00093d8:	26245450 	addiu	a0,s1,21584
		   prom_printf("\nOK Tx(0x%x) content=%x\n",(0xa0820000+i),READ_MEM32(0xa0820000+i));
a00093dc:	3c05a082 	lui	a1,0xa082
a00093e0:	02052821 	addu	a1,s0,a1
a00093e4:	8ca60000 	lw	a2,0(a1)
a00093e8:	3c04a001 	lui	a0,0xa001
a00093ec:	0c0023a7 	jal	a0008e9c <prom_printf>
a00093f0:	24845370 	addiu	a0,a0,21360
		   prom_printf("\nFail Rx(0x%x) content=%x\n",(0xa0a30000+i),READ_MEM32(0xa0a30000+i));
a00093f4:	3c05a0a3 	lui	a1,0xa0a3
a00093f8:	02052821 	addu	a1,s0,a1
a00093fc:	8ca60000 	lw	a2,0(a1)
a0009400:	3c04a001 	lui	a0,0xa001
a0009404:	0c0023a7 	jal	a0008e9c <prom_printf>
a0009408:	2484538c 	addiu	a0,a0,21388
		   prom_printf("\n================================================\n");
a000940c:	0c0023a7 	jal	a0008e9c <prom_printf>
a0009410:	26245450 	addiu	a0,s1,21584

		   prom_printf("\nCheck last 4 Bytes,Tx(0x%x) content=%x\n",(0xa0820000+i-4),READ_MEM32(0xa0820000+i-4));
a0009414:	3c05a081 	lui	a1,0xa081
a0009418:	34a5fffc 	ori	a1,a1,0xfffc
a000941c:	02052821 	addu	a1,s0,a1
a0009420:	8ca60000 	lw	a2,0(a1)
a0009424:	3c04a001 	lui	a0,0xa001
a0009428:	0c0023a7 	jal	a0008e9c <prom_printf>
a000942c:	248453a8 	addiu	a0,a0,21416
		   prom_printf("\nCheck last 4 Bytes,Rx(0x%x) content=%x\n",(0xa0a30000+i-4),READ_MEM32(0xa0a30000+i-4));
a0009430:	3c05a0a2 	lui	a1,0xa0a2
a0009434:	34a5fffc 	ori	a1,a1,0xfffc
a0009438:	02052821 	addu	a1,s0,a1
a000943c:	8ca60000 	lw	a2,0(a1)
a0009440:	3c04a001 	lui	a0,0xa001
a0009444:	0c0023a7 	jal	a0008e9c <prom_printf>
a0009448:	248453d4 	addiu	a0,a0,21460
		   prom_printf("\n================================================\n");
a000944c:	0c0023a7 	jal	a0008e9c <prom_printf>
a0009450:	26245450 	addiu	a0,s1,21584
		   return -1;
a0009454:	0800251c 	j	a0009470 <rtl8168_rx+0x32c>
a0009458:	2402ffff 	li	v0,-1
#endif
       #endif

       int i3;
      // Check RX Packet Content
        for (i = 0; i < size; i++)        
a000945c:	26100001 	addiu	s0,s0,1
a0009460:	0211102b 	sltu	v0,s0,s1
a0009464:	1440ffb9 	bnez	v0,a000934c <rtl8168_rx+0x208>
a0009468:	02051821 	addu	v1,s0,a1
a000946c:	00001021 	move	v0,zero
      }
   }
 #endif

   return 0;
}
a0009470:	8fbf0034 	lw	ra,52(sp)
a0009474:	8fb50030 	lw	s5,48(sp)
a0009478:	8fb4002c 	lw	s4,44(sp)
a000947c:	8fb30028 	lw	s3,40(sp)
a0009480:	8fb20024 	lw	s2,36(sp)
a0009484:	8fb10020 	lw	s1,32(sp)
a0009488:	8fb0001c 	lw	s0,28(sp)
a000948c:	03e00008 	jr	ra
a0009490:	27bd0038 	addiu	sp,sp,56

a0009494 <EnIRQ>:
#define NULL 0
struct irqaction irq_PCIE = {PCIE_isr, (unsigned long)NULL, (unsigned long)PCIE_IRQ_NO,"PCIE", (void *)NULL, (struct irqaction *)NULL};   


void EnIRQ(int portnum, int enableirq)
{
a0009494:	27bdffe8 	addiu	sp,sp,-24
a0009498:	afbf0014 	sw	ra,20(sp)
	unsigned int addr;
	if(portnum==0)
a000949c:	3c02ba00 	lui	v0,0xba00
a00094a0:	3c03b900 	lui	v1,0xb900
	{
		addr=PCIE2_EP_MEM;
	}

	
	if(enableirq)
a00094a4:	10a00017 	beqz	a1,a0009504 <EnIRQ+0x70>
a00094a8:	0064100a 	movz	v0,v1,a0
	{

		WRITE_MEM16(addr + IntrMask, 0xffff);
a00094ac:	2442003c 	addiu	v0,v0,60
a00094b0:	2403ffff 	li	v1,-1
a00094b4:	a4430000 	sh	v1,0(v0)

		
		int irraddr=IRR_REG+PCIE_IRR_NO*4;		
	  	REG32(irraddr) = (REG32(irraddr) &~(0x0f<<PCIE_IRR_OFFSET)) | (4<<PCIE_IRR_OFFSET);	
a00094b8:	3c02b800 	lui	v0,0xb800
a00094bc:	34423010 	ori	v0,v0,0x3010
a00094c0:	8c440000 	lw	a0,0(v0)
a00094c4:	3c03ff0f 	lui	v1,0xff0f
a00094c8:	3463ffff 	ori	v1,v1,0xffff
a00094cc:	00831824 	and	v1,a0,v1
a00094d0:	3c040040 	lui	a0,0x40
a00094d4:	00641825 	or	v1,v1,a0
a00094d8:	ac430000 	sw	v1,0(v0)
		request_IRQ(PCIE_IRQ_NO, &irq_PCIE, NULL); 
a00094dc:	24040015 	li	a0,21
a00094e0:	3c05a001 	lui	a1,0xa001
a00094e4:	24a57560 	addiu	a1,a1,30048
a00094e8:	0c000274 	jal	a00009d0 <request_IRQ>
a00094ec:	00003021 	move	a2,zero
		dprintf("Enable PCIE ISR \n");
a00094f0:	3c04a001 	lui	a0,0xa001
a00094f4:	0c002325 	jal	a0008c94 <dprintf>
a00094f8:	24845484 	addiu	a0,a0,21636
		WRITE_MEM16(addr + IntrMask, 0);
		free_IRQ(PCIE_IRQ_NO);
		dprintf("Disable PCIE ISR\r\n");

	}
}
a00094fc:	08002549 	j	a0009524 <EnIRQ+0x90>
a0009500:	8fbf0014 	lw	ra,20(sp)
		request_IRQ(PCIE_IRQ_NO, &irq_PCIE, NULL); 
		dprintf("Enable PCIE ISR \n");
	}
	else
	{
		WRITE_MEM16(addr + IntrMask, 0);
a0009504:	2442003c 	addiu	v0,v0,60
a0009508:	a4400000 	sh	zero,0(v0)
		free_IRQ(PCIE_IRQ_NO);
a000950c:	0c000289 	jal	a0000a24 <free_IRQ>
a0009510:	24040015 	li	a0,21
		dprintf("Disable PCIE ISR\r\n");
a0009514:	3c04a001 	lui	a0,0xa001
a0009518:	0c002325 	jal	a0008c94 <dprintf>
a000951c:	24845498 	addiu	a0,a0,21656

	}
}
a0009520:	8fbf0014 	lw	ra,20(sp)
a0009524:	03e00008 	jr	ra
a0009528:	27bd0018 	addiu	sp,sp,24

a000952c <rtl8168_init>:

	
}
//===============================================================================
void rtl8168_init(int portnum, int en_loopback)
{
a000952c:	27bdffe0 	addiu	sp,sp,-32
a0009530:	afbf001c 	sw	ra,28(sp)
a0009534:	afb10018 	sw	s1,24(sp)
a0009538:	afb00014 	sw	s0,20(sp)
a000953c:	00808021 	move	s0,a0
   int i;

   if( (portnum == 0) || (portnum == 2) )
a0009540:	10800004 	beqz	a0,a0009554 <rtl8168_init+0x28>
a0009544:	00a08821 	move	s1,a1
a0009548:	24020002 	li	v0,2
a000954c:	14820088 	bne	a0,v0,a0009770 <rtl8168_init+0x244>
a0009550:	00000000 	nop
   {
      // 0. Set PCIE RootComplex
      WRITE_MEM32(PCIE1_RC_CFG + 0x04, 0x00100007);
a0009554:	3c04b8b0 	lui	a0,0xb8b0
a0009558:	34820004 	ori	v0,a0,0x4
a000955c:	3c030010 	lui	v1,0x10
a0009560:	34630007 	ori	v1,v1,0x7
a0009564:	ac430000 	sw	v1,0(v0)
      WRITE_MEM8(PCIE1_RC_CFG + 0x78, (READ_MEM8(PCIE1_EP_CFG + 0x78) & (~0xE0)) | MAX_PAYLOAD_SIZE_128B);  // Set MAX_PAYLOAD_SIZE to 128B,default
a0009568:	3c02b8b1 	lui	v0,0xb8b1
a000956c:	34430078 	ori	v1,v0,0x78
a0009570:	90650000 	lbu	a1,0(v1)
a0009574:	30a5001f 	andi	a1,a1,0x1f
a0009578:	34840078 	ori	a0,a0,0x78
a000957c:	a0850000 	sb	a1,0(a0)
      //WRITE_MEM8(PCIE1_RC_CFG + 0x78, (READ_MEM8(PCIE1_EP_CFG + 0x78) & (~0xE0)) | MAX_PAYLOAD_SIZE_256B);  // Set MAX_PAYLOAD_SIZE to 256B

      // 1. Set 8111C EP
      WRITE_MEM32(PCIE1_EP_CFG + 0x04, 0x00180007);  // Mem, IO Enable
a0009580:	34440004 	ori	a0,v0,0x4
a0009584:	3c050018 	lui	a1,0x18
a0009588:	34a50007 	ori	a1,a1,0x7
a000958c:	ac850000 	sw	a1,0(a0)
      WRITE_MEM32(PCIE1_EP_CFG + 0x10, (PCIE1_EP_IO | 0x00000001) & 0x1FFFFFFF);  // Set BAR
a0009590:	34440010 	ori	a0,v0,0x10
a0009594:	3c0518c0 	lui	a1,0x18c0
a0009598:	34a50001 	ori	a1,a1,0x1
a000959c:	ac850000 	sw	a1,0(a0)
      WRITE_MEM32(PCIE1_EP_CFG + 0x18, (PCIE1_EP_MEM | 0x00000004) & 0x1FFFFFFF);  // Set BAR
a00095a0:	34440018 	ori	a0,v0,0x18
a00095a4:	3c051900 	lui	a1,0x1900
a00095a8:	34a50004 	ori	a1,a1,0x4
a00095ac:	ac850000 	sw	a1,0(a0)

      WRITE_MEM8(PCIE1_EP_CFG + 0x78, (READ_MEM8(PCIE1_EP_CFG + 0x78) & (~0xE0)) | MAX_PAYLOAD_SIZE_128B);  // Set MAX_PAYLOAD_SIZE to 128B
a00095b0:	90640000 	lbu	a0,0(v1)
a00095b4:	3084001f 	andi	a0,a0,0x1f
a00095b8:	a0640000 	sb	a0,0(v1)
     // WRITE_MEM8(PCIE1_EP_CFG + 0x79, (READ_MEM8(PCIE1_EP_CFG + 0x79) & (~0x70)) | MAX_READ_REQSIZE_128B);  // Set MAX_REQ_SIZE to 128B 
      WRITE_MEM8(PCIE1_EP_CFG + 0x79, (READ_MEM8(PCIE1_EP_CFG + 0x79) & (~0x70)) | MAX_READ_REQSIZE_256B);  // Set MAX_REQ_SIZE to 256B,default
a00095bc:	34420079 	ori	v0,v0,0x79
a00095c0:	90430000 	lbu	v1,0(v0)
a00095c4:	2404ff8f 	li	a0,-113
a00095c8:	00831824 	and	v1,a0,v1
a00095cc:	34630010 	ori	v1,v1,0x10
a00095d0:	306300ff 	andi	v1,v1,0xff
a00095d4:	a0430000 	sb	v1,0(v0)

      // 2. Reset EP
      WRITE_MEM8(PCIE1_EP_MEM + ChipCmd, 0x10);
a00095d8:	24030010 	li	v1,16
a00095dc:	3c02b900 	lui	v0,0xb900
a00095e0:	34420037 	ori	v0,v0,0x37
a00095e4:	a0430000 	sb	v1,0(v0)

      // 3. Set MAC Loopback & Disable TX CRC & TxDMA Size
      if(en_loopback)      WRITE_MEM32(PCIE1_EP_MEM + TxConfig, (READ_MEM32(PCIE1_EP_MEM + TxConfig) & (~0x700)) | TxDMA1KB | TxMACLoopBack | (1 << 16));  //wei del
a00095e8:	1220000c 	beqz	s1,a000961c <rtl8168_init+0xf0>
a00095ec:	3c02b900 	lui	v0,0xb900
a00095f0:	34420040 	ori	v0,v0,0x40
a00095f4:	8c440000 	lw	a0,0(v0)
a00095f8:	3c03fffc 	lui	v1,0xfffc
a00095fc:	3463f8ff 	ori	v1,v1,0xf8ff
a0009600:	00832024 	and	a0,a0,v1
a0009604:	3c030003 	lui	v1,0x3
a0009608:	34630600 	ori	v1,v1,0x600
a000960c:	00831825 	or	v1,a0,v1
a0009610:	ac430000 	sw	v1,0(v0)
     else 				     WRITE_MEM32(PCIE1_EP_MEM + TxConfig, (READ_MEM32(PCIE1_EP_MEM + TxConfig) & (~0x700)) | TxDMA1KB |  (0 << 16));
	  
      // Enable Runt & Error Accept of RX Config
      WRITE_MEM32(PCIE1_EP_MEM + RxConfig, (READ_MEM32(PCIE1_EP_MEM + RxConfig) & (~0x700)) | RxDMA512B | AcceptErr | AcceptRunt | (1 << 7));
a0009614:	0800258e 	j	a0009638 <rtl8168_init+0x10c>
a0009618:	3c02b900 	lui	v0,0xb900
      // 2. Reset EP
      WRITE_MEM8(PCIE1_EP_MEM + ChipCmd, 0x10);

      // 3. Set MAC Loopback & Disable TX CRC & TxDMA Size
      if(en_loopback)      WRITE_MEM32(PCIE1_EP_MEM + TxConfig, (READ_MEM32(PCIE1_EP_MEM + TxConfig) & (~0x700)) | TxDMA1KB | TxMACLoopBack | (1 << 16));  //wei del
     else 				     WRITE_MEM32(PCIE1_EP_MEM + TxConfig, (READ_MEM32(PCIE1_EP_MEM + TxConfig) & (~0x700)) | TxDMA1KB |  (0 << 16));
a000961c:	34420040 	ori	v0,v0,0x40
a0009620:	8c440000 	lw	a0,0(v0)
a0009624:	2403f8ff 	li	v1,-1793
a0009628:	00831824 	and	v1,a0,v1
a000962c:	34630600 	ori	v1,v1,0x600
a0009630:	ac430000 	sw	v1,0(v0)
	  
      // Enable Runt & Error Accept of RX Config
      WRITE_MEM32(PCIE1_EP_MEM + RxConfig, (READ_MEM32(PCIE1_EP_MEM + RxConfig) & (~0x700)) | RxDMA512B | AcceptErr | AcceptRunt | (1 << 7));
a0009634:	3c02b900 	lui	v0,0xb900
a0009638:	34430044 	ori	v1,v0,0x44
a000963c:	8c650000 	lw	a1,0(v1)
a0009640:	2404f84f 	li	a0,-1969
a0009644:	00a42024 	and	a0,a1,a0
a0009648:	348405b0 	ori	a0,a0,0x5b0
a000964c:	ac640000 	sw	a0,0(v1)

      // 4. Set TX/RX Desciptor Starting Address
      WRITE_MEM32(PCIE1_EP_MEM + TxDescStartAddrLow, PADDR(TX1_DESC_ADDR));
a0009650:	34430020 	ori	v1,v0,0x20
a0009654:	3c040052 	lui	a0,0x52
a0009658:	ac640000 	sw	a0,0(v1)
      WRITE_MEM32(PCIE1_EP_MEM + TxDescStartAddrHigh, 0);
a000965c:	34430024 	ori	v1,v0,0x24
a0009660:	ac600000 	sw	zero,0(v1)
      WRITE_MEM32(PCIE1_EP_MEM + RxDescAddrLow, PADDR(RX1_DESC_ADDR));
a0009664:	344300e4 	ori	v1,v0,0xe4
a0009668:	3c040053 	lui	a0,0x53
a000966c:	ac640000 	sw	a0,0(v1)
      WRITE_MEM32(PCIE1_EP_MEM + RxDescAddrHigh, 0);
a0009670:	344200e8 	ori	v0,v0,0xe8
a0009674:	ac400000 	sw	zero,0(v0)
a0009678:	3c02a052 	lui	v0,0xa052
static __inline void *memset(void *s, int c, int size)
{
   unsigned char *__s = (unsigned char *) s;
   unsigned char __c = (unsigned char) c;

   while (size--)
a000967c:	3c03a052 	lui	v1,0xa052
a0009680:	34630400 	ori	v1,v1,0x400
      *__s++ = __c;
a0009684:	a0400000 	sb	zero,0(v0)
a0009688:	24420001 	addiu	v0,v0,1
static __inline void *memset(void *s, int c, int size)
{
   unsigned char *__s = (unsigned char *) s;
   unsigned char __c = (unsigned char) c;

   while (size--)
a000968c:	1443fffd 	bne	v0,v1,a0009684 <rtl8168_init+0x158>
a0009690:	00000000 	nop
      memset((unsigned char *) TX1_DESC_ADDR, 0x0, NUM_TX_DESC * TX1_DESC_SIZE);

      for (i = 0; i < NUM_TX_DESC; i++)
      {
         if(i == (NUM_TX_DESC - 1))
            WRITE_MEM32(TX1_DESC_ADDR + TX1_DESC_SIZE * i, htonl(PADDR(RingEnd)));
a0009694:	080025ae 	j	a00096b8 <rtl8168_init+0x18c>
a0009698:	00001021 	move	v0,zero
      // 5. Set TX Ring - Descriptor Assigned to CPU
      memset((unsigned char *) TX1_DESC_ADDR, 0x0, NUM_TX_DESC * TX1_DESC_SIZE);

      for (i = 0; i < NUM_TX_DESC; i++)
      {
         if(i == (NUM_TX_DESC - 1))
a000969c:	14430008 	bne	v0,v1,a00096c0 <rtl8168_init+0x194>
a00096a0:	00000000 	nop
            WRITE_MEM32(TX1_DESC_ADDR + TX1_DESC_SIZE * i, htonl(PADDR(RingEnd)));
a00096a4:	3c02a052 	lui	v0,0xa052
a00096a8:	344203f0 	ori	v0,v0,0x3f0
a00096ac:	ac400000 	sw	zero,0(v0)
a00096b0:	080025b4 	j	a00096d0 <rtl8168_init+0x1a4>
a00096b4:	3c02a053 	lui	v0,0xa053
      WRITE_MEM32(PCIE1_EP_MEM + RxDescAddrHigh, 0);

      // 5. Set TX Ring - Descriptor Assigned to CPU
      memset((unsigned char *) TX1_DESC_ADDR, 0x0, NUM_TX_DESC * TX1_DESC_SIZE);

      for (i = 0; i < NUM_TX_DESC; i++)
a00096b8:	24040040 	li	a0,64
      {
         if(i == (NUM_TX_DESC - 1))
a00096bc:	2403003f 	li	v1,63
      WRITE_MEM32(PCIE1_EP_MEM + RxDescAddrHigh, 0);

      // 5. Set TX Ring - Descriptor Assigned to CPU
      memset((unsigned char *) TX1_DESC_ADDR, 0x0, NUM_TX_DESC * TX1_DESC_SIZE);

      for (i = 0; i < NUM_TX_DESC; i++)
a00096c0:	24420001 	addiu	v0,v0,1
a00096c4:	1444fff5 	bne	v0,a0,a000969c <rtl8168_init+0x170>
a00096c8:	00000000 	nop
a00096cc:	3c02a053 	lui	v0,0xa053
static __inline void *memset(void *s, int c, int size)
{
   unsigned char *__s = (unsigned char *) s;
   unsigned char __c = (unsigned char) c;

   while (size--)
a00096d0:	3c03a053 	lui	v1,0xa053
a00096d4:	34630400 	ori	v1,v1,0x400
      *__s++ = __c;
a00096d8:	a0400000 	sb	zero,0(v0)
a00096dc:	24420001 	addiu	v0,v0,1
static __inline void *memset(void *s, int c, int size)
{
   unsigned char *__s = (unsigned char *) s;
   unsigned char __c = (unsigned char) c;

   while (size--)
a00096e0:	1443fffd 	bne	v0,v1,a00096d8 <rtl8168_init+0x1ac>
a00096e4:	00000000 	nop
      for (i = 0; i < NUM_RX_DESC; i++)
      {
         if(i == (NUM_RX_DESC - 1))
            WRITE_MEM32(RX1_DESC_ADDR + RX1_DESC_SIZE * i, htonl(DescOwn | RingEnd | RX1_BUFF_SIZE));
         else
            WRITE_MEM32(RX1_DESC_ADDR + RX1_DESC_SIZE * i, htonl(DescOwn | RX1_BUFF_SIZE));
a00096e8:	080025d4 	j	a0009750 <rtl8168_init+0x224>
a00096ec:	3c030010 	lui	v1,0x10
static __inline void *memset(void *s, int c, int size)
{
   unsigned char *__s = (unsigned char *) s;
   unsigned char __c = (unsigned char) c;

   while (size--)
a00096f0:	24420010 	addiu	v0,v0,16
      // 6. Set RX Ring - Descriptor Assigned to NIC
      memset((unsigned char *) RX1_DESC_ADDR, 0x0, NUM_RX_DESC * RX1_DESC_SIZE);

      for (i = 0; i < NUM_RX_DESC; i++)
      {
         if(i == (NUM_RX_DESC - 1))
a00096f4:	144300ab 	bne	v0,v1,a00099a4 <rtl8168_init+0x478>
a00096f8:	00000000 	nop
            WRITE_MEM32(RX1_DESC_ADDR + RX1_DESC_SIZE * i, htonl(DescOwn | RingEnd | RX1_BUFF_SIZE));
a00096fc:	3c02a053 	lui	v0,0xa053
a0009700:	344303f0 	ori	v1,v0,0x3f0
a0009704:	3c040010 	lui	a0,0x10
a0009708:	348400c0 	ori	a0,a0,0xc0
a000970c:	ac640000 	sw	a0,0(v1)
         else
            WRITE_MEM32(RX1_DESC_ADDR + RX1_DESC_SIZE * i, htonl(DescOwn | RX1_BUFF_SIZE));
      }

      tx1_desc_addr = (unsigned char *) TX1_DESC_ADDR;
a0009710:	3c04a052 	lui	a0,0xa052
a0009714:	3c03a001 	lui	v1,0xa001
a0009718:	ac647984 	sw	a0,31108(v1)
      tx1_buff_addr = (unsigned char *) TX1_BUFF_ADDR;
a000971c:	3c04a058 	lui	a0,0xa058
a0009720:	3c03a001 	lui	v1,0xa001
a0009724:	ac647988 	sw	a0,31112(v1)
      rx1_desc_addr = (unsigned char *) RX1_DESC_ADDR;
a0009728:	3c03a001 	lui	v1,0xa001
a000972c:	ac62798c 	sw	v0,31116(v1)
      rx1_buff_addr = (unsigned char *) RX1_BUFF_ADDR;
a0009730:	3c03a05a 	lui	v1,0xa05a
a0009734:	3c02a001 	lui	v0,0xa001
a0009738:	ac4379a0 	sw	v1,31136(v0)
	  
#if USING_INTERRUPT
	EnIRQ(0, 1);
a000973c:	00002021 	move	a0,zero
a0009740:	0c002525 	jal	a0009494 <EnIRQ>
a0009744:	24050001 	li	a1,1

   //else  
	//------------------------------------------------------------------	
   
   #if (TEST_8196_PCIE_P1)
   if ( (portnum == 1) || (portnum== 2) )//PORT1
a0009748:	080025dd 	j	a0009774 <rtl8168_init+0x248>
a000974c:	2610ffff 	addiu	s0,s0,-1
      for (i = 0; i < NUM_RX_DESC; i++)
      {
         if(i == (NUM_RX_DESC - 1))
            WRITE_MEM32(RX1_DESC_ADDR + RX1_DESC_SIZE * i, htonl(DescOwn | RingEnd | RX1_BUFF_SIZE));
         else
            WRITE_MEM32(RX1_DESC_ADDR + RX1_DESC_SIZE * i, htonl(DescOwn | RX1_BUFF_SIZE));
a0009750:	34630080 	ori	v1,v1,0x80
a0009754:	3c02a053 	lui	v0,0xa053
a0009758:	ac430000 	sw	v1,0(v0)
      // 6. Set RX Ring - Descriptor Assigned to NIC
      memset((unsigned char *) RX1_DESC_ADDR, 0x0, NUM_RX_DESC * RX1_DESC_SIZE);

      for (i = 0; i < NUM_RX_DESC; i++)
      {
         if(i == (NUM_RX_DESC - 1))
a000975c:	3c03a053 	lui	v1,0xa053
a0009760:	346303f0 	ori	v1,v1,0x3f0
            WRITE_MEM32(RX1_DESC_ADDR + RX1_DESC_SIZE * i, htonl(DescOwn | RingEnd | RX1_BUFF_SIZE));
         else
            WRITE_MEM32(RX1_DESC_ADDR + RX1_DESC_SIZE * i, htonl(DescOwn | RX1_BUFF_SIZE));
a0009764:	3c040010 	lui	a0,0x10
a0009768:	080025bc 	j	a00096f0 <rtl8168_init+0x1c4>
a000976c:	34840080 	ori	a0,a0,0x80

   //else  
	//------------------------------------------------------------------	
   
   #if (TEST_8196_PCIE_P1)
   if ( (portnum == 1) || (portnum== 2) )//PORT1
a0009770:	2610ffff 	addiu	s0,s0,-1
a0009774:	2e100002 	sltiu	s0,s0,2
a0009778:	1200008e 	beqz	s0,a00099b4 <rtl8168_init+0x488>
a000977c:	8fbf001c 	lw	ra,28(sp)
   {
      // 0. Set PCIE RootComplex
      WRITE_MEM32(PCIE2_RC_CFG + 0x04, 0x00100007);
a0009780:	3c04b8b2 	lui	a0,0xb8b2
a0009784:	34820004 	ori	v0,a0,0x4
a0009788:	3c030010 	lui	v1,0x10
a000978c:	34630007 	ori	v1,v1,0x7
a0009790:	ac430000 	sw	v1,0(v0)
      WRITE_MEM8(PCIE2_RC_CFG + 0x78, (READ_MEM8(PCIE2_EP_CFG + 0x78) & (~0xE0)) | MAX_PAYLOAD_SIZE_128B);  // Set MAX_PAYLOAD_SIZE to 128B
a0009794:	3c02b8b3 	lui	v0,0xb8b3
a0009798:	34430078 	ori	v1,v0,0x78
a000979c:	90650000 	lbu	a1,0(v1)
a00097a0:	30a5001f 	andi	a1,a1,0x1f
a00097a4:	34840078 	ori	a0,a0,0x78
a00097a8:	a0850000 	sb	a1,0(a0)

      // 1. Set 8111C EP
      WRITE_MEM32(PCIE2_EP_CFG + 0x04, 0x00180007);  // Mem, IO Enable
a00097ac:	34440004 	ori	a0,v0,0x4
a00097b0:	3c050018 	lui	a1,0x18
a00097b4:	34a50007 	ori	a1,a1,0x7
a00097b8:	ac850000 	sw	a1,0(a0)
      WRITE_MEM32(PCIE2_EP_CFG + 0x10, (PCIE2_EP_IO | 0x00000001) & 0x1FFFFFFF);  // Set BAR
a00097bc:	34440010 	ori	a0,v0,0x10
a00097c0:	3c0518e0 	lui	a1,0x18e0
a00097c4:	34a50001 	ori	a1,a1,0x1
a00097c8:	ac850000 	sw	a1,0(a0)
      WRITE_MEM32(PCIE2_EP_CFG + 0x18, (PCIE2_EP_MEM | 0x00000004) & 0x1FFFFFFF);  // Set BAR
a00097cc:	34440018 	ori	a0,v0,0x18
a00097d0:	3c051a00 	lui	a1,0x1a00
a00097d4:	34a50004 	ori	a1,a1,0x4
a00097d8:	ac850000 	sw	a1,0(a0)

      WRITE_MEM8(PCIE2_EP_CFG + 0x78, (READ_MEM8(PCIE2_EP_CFG + 0x78) & (~0xE0)) | MAX_PAYLOAD_SIZE_128B);  // Set MAX_PAYLOAD_SIZE to 128B
a00097dc:	90640000 	lbu	a0,0(v1)
a00097e0:	3084001f 	andi	a0,a0,0x1f
a00097e4:	a0640000 	sb	a0,0(v1)
      WRITE_MEM8(PCIE2_EP_CFG + 0x79, (READ_MEM8(PCIE2_EP_CFG + 0x79) & (~0x70)) | MAX_READ_REQSIZE_256B);  // Set MAX_REQ_SIZE to 128B
a00097e8:	34420079 	ori	v0,v0,0x79
a00097ec:	90430000 	lbu	v1,0(v0)
a00097f0:	2404ff8f 	li	a0,-113
a00097f4:	00831824 	and	v1,a0,v1
a00097f8:	34630010 	ori	v1,v1,0x10
a00097fc:	306300ff 	andi	v1,v1,0xff
a0009800:	a0430000 	sb	v1,0(v0)

      // 2. Reset EP
      WRITE_MEM8(PCIE2_EP_MEM + ChipCmd, 0x10);
a0009804:	24030010 	li	v1,16
a0009808:	3c02ba00 	lui	v0,0xba00
a000980c:	34420037 	ori	v0,v0,0x37
a0009810:	a0430000 	sb	v1,0(v0)

      // 3. Set MAC Loopback & Disable TX CRC & TxDMA Size
     if(en_loopback)      	WRITE_MEM32(PCIE2_EP_MEM + TxConfig, (READ_MEM32(PCIE2_EP_MEM + TxConfig) & (~0x700)) | TxDMA1KB | TxMACLoopBack | (1 << 16));
a0009814:	1220000c 	beqz	s1,a0009848 <rtl8168_init+0x31c>
a0009818:	3c02ba00 	lui	v0,0xba00
a000981c:	34420040 	ori	v0,v0,0x40
a0009820:	8c440000 	lw	a0,0(v0)
a0009824:	3c03fffc 	lui	v1,0xfffc
a0009828:	3463f8ff 	ori	v1,v1,0xf8ff
a000982c:	00832024 	and	a0,a0,v1
a0009830:	3c030003 	lui	v1,0x3
a0009834:	34630600 	ori	v1,v1,0x600
a0009838:	00831825 	or	v1,a0,v1
a000983c:	ac430000 	sw	v1,0(v0)
	else  				WRITE_MEM32(PCIE2_EP_MEM + TxConfig, (READ_MEM32(PCIE2_EP_MEM + TxConfig) & (~0x700)) | TxDMA1KB |  (1 << 16));
	
      // Enable Runt & Error Accept of RX Config
      WRITE_MEM32(PCIE2_EP_MEM + RxConfig, (READ_MEM32(PCIE2_EP_MEM + RxConfig) & (~0x700)) | RxDMA512B | AcceptErr | AcceptRunt | (1 << 7));
a0009840:	0800261c 	j	a0009870 <rtl8168_init+0x344>
a0009844:	3c02ba00 	lui	v0,0xba00
      // 2. Reset EP
      WRITE_MEM8(PCIE2_EP_MEM + ChipCmd, 0x10);

      // 3. Set MAC Loopback & Disable TX CRC & TxDMA Size
     if(en_loopback)      	WRITE_MEM32(PCIE2_EP_MEM + TxConfig, (READ_MEM32(PCIE2_EP_MEM + TxConfig) & (~0x700)) | TxDMA1KB | TxMACLoopBack | (1 << 16));
	else  				WRITE_MEM32(PCIE2_EP_MEM + TxConfig, (READ_MEM32(PCIE2_EP_MEM + TxConfig) & (~0x700)) | TxDMA1KB |  (1 << 16));
a0009848:	34420040 	ori	v0,v0,0x40
a000984c:	8c440000 	lw	a0,0(v0)
a0009850:	3c03fffe 	lui	v1,0xfffe
a0009854:	3463f8ff 	ori	v1,v1,0xf8ff
a0009858:	00832024 	and	a0,a0,v1
a000985c:	3c030001 	lui	v1,0x1
a0009860:	34630600 	ori	v1,v1,0x600
a0009864:	00831825 	or	v1,a0,v1
a0009868:	ac430000 	sw	v1,0(v0)
	
      // Enable Runt & Error Accept of RX Config
      WRITE_MEM32(PCIE2_EP_MEM + RxConfig, (READ_MEM32(PCIE2_EP_MEM + RxConfig) & (~0x700)) | RxDMA512B | AcceptErr | AcceptRunt | (1 << 7));
a000986c:	3c02ba00 	lui	v0,0xba00
a0009870:	34430044 	ori	v1,v0,0x44
a0009874:	8c650000 	lw	a1,0(v1)
a0009878:	2404f84f 	li	a0,-1969
a000987c:	00a42024 	and	a0,a1,a0
a0009880:	348405b0 	ori	a0,a0,0x5b0
a0009884:	ac640000 	sw	a0,0(v1)

      // 4. Set TX/RX Desciptor Starting Address
      WRITE_MEM32(PCIE2_EP_MEM + TxDescStartAddrLow, PADDR(TX2_DESC_ADDR));
a0009888:	34430020 	ori	v1,v0,0x20
a000988c:	3c040062 	lui	a0,0x62
a0009890:	ac640000 	sw	a0,0(v1)
      WRITE_MEM32(PCIE2_EP_MEM + TxDescStartAddrHigh, 0);
a0009894:	34430024 	ori	v1,v0,0x24
a0009898:	ac600000 	sw	zero,0(v1)
      WRITE_MEM32(PCIE2_EP_MEM + RxDescAddrLow, PADDR(RX2_DESC_ADDR));
a000989c:	344300e4 	ori	v1,v0,0xe4
a00098a0:	3c040063 	lui	a0,0x63
a00098a4:	ac640000 	sw	a0,0(v1)
      WRITE_MEM32(PCIE2_EP_MEM + RxDescAddrHigh, 0);
a00098a8:	344200e8 	ori	v0,v0,0xe8
a00098ac:	ac400000 	sw	zero,0(v0)
a00098b0:	3c02a062 	lui	v0,0xa062
static __inline void *memset(void *s, int c, int size)
{
   unsigned char *__s = (unsigned char *) s;
   unsigned char __c = (unsigned char) c;

   while (size--)
a00098b4:	3c03a062 	lui	v1,0xa062
a00098b8:	34630400 	ori	v1,v1,0x400
      *__s++ = __c;
a00098bc:	a0400000 	sb	zero,0(v0)
a00098c0:	24420001 	addiu	v0,v0,1
static __inline void *memset(void *s, int c, int size)
{
   unsigned char *__s = (unsigned char *) s;
   unsigned char __c = (unsigned char) c;

   while (size--)
a00098c4:	1443fffd 	bne	v0,v1,a00098bc <rtl8168_init+0x390>
a00098c8:	00000000 	nop
      memset((unsigned char *) TX2_DESC_ADDR, 0x0, NUM_TX_DESC * TX2_DESC_SIZE);

      for (i = 0; i < NUM_TX_DESC; i++)
      {
         if(i == (NUM_TX_DESC - 1))
            WRITE_MEM32(TX2_DESC_ADDR + TX2_DESC_SIZE * i, htonl(PADDR(RingEnd)));
a00098cc:	0800263c 	j	a00098f0 <rtl8168_init+0x3c4>
a00098d0:	00001021 	move	v0,zero
      // 5. Set TX Ring - Descriptor Assigned to CPU
      memset((unsigned char *) TX2_DESC_ADDR, 0x0, NUM_TX_DESC * TX2_DESC_SIZE);

      for (i = 0; i < NUM_TX_DESC; i++)
      {
         if(i == (NUM_TX_DESC - 1))
a00098d4:	14430008 	bne	v0,v1,a00098f8 <rtl8168_init+0x3cc>
a00098d8:	00000000 	nop
            WRITE_MEM32(TX2_DESC_ADDR + TX2_DESC_SIZE * i, htonl(PADDR(RingEnd)));
a00098dc:	3c02a062 	lui	v0,0xa062
a00098e0:	344203f0 	ori	v0,v0,0x3f0
a00098e4:	ac400000 	sw	zero,0(v0)
a00098e8:	08002642 	j	a0009908 <rtl8168_init+0x3dc>
a00098ec:	3c02a063 	lui	v0,0xa063
      WRITE_MEM32(PCIE2_EP_MEM + RxDescAddrHigh, 0);

      // 5. Set TX Ring - Descriptor Assigned to CPU
      memset((unsigned char *) TX2_DESC_ADDR, 0x0, NUM_TX_DESC * TX2_DESC_SIZE);

      for (i = 0; i < NUM_TX_DESC; i++)
a00098f0:	24040040 	li	a0,64
      {
         if(i == (NUM_TX_DESC - 1))
a00098f4:	2403003f 	li	v1,63
      WRITE_MEM32(PCIE2_EP_MEM + RxDescAddrHigh, 0);

      // 5. Set TX Ring - Descriptor Assigned to CPU
      memset((unsigned char *) TX2_DESC_ADDR, 0x0, NUM_TX_DESC * TX2_DESC_SIZE);

      for (i = 0; i < NUM_TX_DESC; i++)
a00098f8:	24420001 	addiu	v0,v0,1
a00098fc:	1444fff5 	bne	v0,a0,a00098d4 <rtl8168_init+0x3a8>
a0009900:	00000000 	nop
a0009904:	3c02a063 	lui	v0,0xa063
static __inline void *memset(void *s, int c, int size)
{
   unsigned char *__s = (unsigned char *) s;
   unsigned char __c = (unsigned char) c;

   while (size--)
a0009908:	3c03a063 	lui	v1,0xa063
a000990c:	34630400 	ori	v1,v1,0x400
      *__s++ = __c;
a0009910:	a0400000 	sb	zero,0(v0)
a0009914:	24420001 	addiu	v0,v0,1
static __inline void *memset(void *s, int c, int size)
{
   unsigned char *__s = (unsigned char *) s;
   unsigned char __c = (unsigned char) c;

   while (size--)
a0009918:	1443fffd 	bne	v0,v1,a0009910 <rtl8168_init+0x3e4>
a000991c:	00000000 	nop
      for (i = 0; i < NUM_RX_DESC; i++)
      {
         if(i == (NUM_RX_DESC - 1))
            WRITE_MEM32(RX2_DESC_ADDR + RX2_DESC_SIZE * i, htonl(DescOwn | RingEnd | RX2_BUFF_SIZE));
         else
            WRITE_MEM32(RX2_DESC_ADDR + RX2_DESC_SIZE * i, htonl(DescOwn | RX2_BUFF_SIZE));
a0009920:	0800265e 	j	a0009978 <rtl8168_init+0x44c>
a0009924:	3c030010 	lui	v1,0x10
static __inline void *memset(void *s, int c, int size)
{
   unsigned char *__s = (unsigned char *) s;
   unsigned char __c = (unsigned char) c;

   while (size--)
a0009928:	24420010 	addiu	v0,v0,16
      // 6. Set RX Ring - Descriptor Assigned to NIC
      memset((unsigned char *) RX2_DESC_ADDR, 0x0, NUM_RX_DESC * RX2_DESC_SIZE);

      for (i = 0; i < NUM_RX_DESC; i++)
      {
         if(i == (NUM_RX_DESC - 1))
a000992c:	1443001a 	bne	v0,v1,a0009998 <rtl8168_init+0x46c>
a0009930:	00000000 	nop
            WRITE_MEM32(RX2_DESC_ADDR + RX2_DESC_SIZE * i, htonl(DescOwn | RingEnd | RX2_BUFF_SIZE));
a0009934:	3c02a063 	lui	v0,0xa063
a0009938:	344303f0 	ori	v1,v0,0x3f0
a000993c:	3c040010 	lui	a0,0x10
a0009940:	348400c0 	ori	a0,a0,0xc0
a0009944:	ac640000 	sw	a0,0(v1)
         else
            WRITE_MEM32(RX2_DESC_ADDR + RX2_DESC_SIZE * i, htonl(DescOwn | RX2_BUFF_SIZE));
      }

      tx2_desc_addr = (unsigned char *) TX2_DESC_ADDR;
a0009948:	3c04a062 	lui	a0,0xa062
a000994c:	3c03a001 	lui	v1,0xa001
a0009950:	ac647998 	sw	a0,31128(v1)
      tx2_buff_addr = (unsigned char *) TX2_BUFF_ADDR;
a0009954:	3c04a068 	lui	a0,0xa068
a0009958:	3c03a001 	lui	v1,0xa001
a000995c:	ac647994 	sw	a0,31124(v1)
      rx2_desc_addr = (unsigned char *) RX2_DESC_ADDR;
a0009960:	3c03a001 	lui	v1,0xa001
a0009964:	ac627990 	sw	v0,31120(v1)
      rx2_buff_addr = (unsigned char *) RX2_BUFF_ADDR;
a0009968:	3c03a06a 	lui	v1,0xa06a
a000996c:	3c02a001 	lui	v0,0xa001
a0009970:	0800266c 	j	a00099b0 <rtl8168_init+0x484>
a0009974:	ac43799c 	sw	v1,31132(v0)
      for (i = 0; i < NUM_RX_DESC; i++)
      {
         if(i == (NUM_RX_DESC - 1))
            WRITE_MEM32(RX2_DESC_ADDR + RX2_DESC_SIZE * i, htonl(DescOwn | RingEnd | RX2_BUFF_SIZE));
         else
            WRITE_MEM32(RX2_DESC_ADDR + RX2_DESC_SIZE * i, htonl(DescOwn | RX2_BUFF_SIZE));
a0009978:	34630080 	ori	v1,v1,0x80
a000997c:	3c02a063 	lui	v0,0xa063
a0009980:	ac430000 	sw	v1,0(v0)
      // 6. Set RX Ring - Descriptor Assigned to NIC
      memset((unsigned char *) RX2_DESC_ADDR, 0x0, NUM_RX_DESC * RX2_DESC_SIZE);

      for (i = 0; i < NUM_RX_DESC; i++)
      {
         if(i == (NUM_RX_DESC - 1))
a0009984:	3c03a063 	lui	v1,0xa063
a0009988:	346303f0 	ori	v1,v1,0x3f0
            WRITE_MEM32(RX2_DESC_ADDR + RX2_DESC_SIZE * i, htonl(DescOwn | RingEnd | RX2_BUFF_SIZE));
         else
            WRITE_MEM32(RX2_DESC_ADDR + RX2_DESC_SIZE * i, htonl(DescOwn | RX2_BUFF_SIZE));
a000998c:	3c040010 	lui	a0,0x10
a0009990:	0800264a 	j	a0009928 <rtl8168_init+0x3fc>
a0009994:	34840080 	ori	a0,a0,0x80
a0009998:	ac440000 	sw	a0,0(v0)
static __inline void *memset(void *s, int c, int size)
{
   unsigned char *__s = (unsigned char *) s;
   unsigned char __c = (unsigned char) c;

   while (size--)
a000999c:	0800264b 	j	a000992c <rtl8168_init+0x400>
a00099a0:	24420010 	addiu	v0,v0,16
      for (i = 0; i < NUM_RX_DESC; i++)
      {
         if(i == (NUM_RX_DESC - 1))
            WRITE_MEM32(RX1_DESC_ADDR + RX1_DESC_SIZE * i, htonl(DescOwn | RingEnd | RX1_BUFF_SIZE));
         else
            WRITE_MEM32(RX1_DESC_ADDR + RX1_DESC_SIZE * i, htonl(DescOwn | RX1_BUFF_SIZE));
a00099a4:	ac440000 	sw	a0,0(v0)
static __inline void *memset(void *s, int c, int size)
{
   unsigned char *__s = (unsigned char *) s;
   unsigned char __c = (unsigned char) c;

   while (size--)
a00099a8:	080025bd 	j	a00096f4 <rtl8168_init+0x1c8>
a00099ac:	24420010 	addiu	v0,v0,16
      rx2_desc_addr = (unsigned char *) RX2_DESC_ADDR;
      rx2_buff_addr = (unsigned char *) RX2_BUFF_ADDR;
   }
  #endif
	//------------------------------------------------------------------------   
}
a00099b0:	8fbf001c 	lw	ra,28(sp)
a00099b4:	8fb10018 	lw	s1,24(sp)
a00099b8:	8fb00014 	lw	s0,20(sp)
a00099bc:	03e00008 	jr	ra
a00099c0:	27bd0020 	addiu	sp,sp,32

a00099c4 <example>:
#endif

//===============================================================================
//unsigned short example();
unsigned short example(int portnum, int quietmode)     // 0:port 0, 1:port 1,  2:port 0 and port 1, rc=0, fail, rc=1 pass
{
a00099c4:	27bdffd8 	addiu	sp,sp,-40
a00099c8:	afbf0024 	sw	ra,36(sp)
a00099cc:	afb40020 	sw	s4,32(sp)
a00099d0:	afb3001c 	sw	s3,28(sp)
a00099d4:	afb20018 	sw	s2,24(sp)
a00099d8:	afb10014 	sw	s1,20(sp)
a00099dc:	afb00010 	sw	s0,16(sp)
a00099e0:	00808821 	move	s1,a0
   /* Get Random Data Length */
   #if PCIE_Test_With_8102E
          length1 = rand2() & 0x5ff; // limit to1535 ,OK for 8102E FT2
  	   //length1 = rand2() & 0x700; // limit to 1972 ,OK with 8102E
   #else
        length1 = rand2() & 0xfff; // limit to 64~4095
a00099e4:	0c00390b 	jal	a000e42c <rand2>
a00099e8:	00a09821 	move	s3,a1
a00099ec:	30420fff 	andi	v0,v0,0xfff
        //length1 = 1024 ; // fixed to 4092 ,error
	 //dprintf("Len=%x \n", length1);
   #endif   
   length1 = (length1 < 64) ? 64 : length1; 
a00099f0:	28500040 	slti	s0,v0,64
a00099f4:	24030040 	li	v1,64
a00099f8:	0050180a 	movz	v1,v0,s0
//-----------------------------------------------

   /* Set MAC */
  if ( (portnum == 0) || (portnum== 2) )//PORT1
a00099fc:	12200004 	beqz	s1,a0009a10 <example+0x4c>
a0009a00:	00608021 	move	s0,v1
a0009a04:	24020002 	li	v0,2
a0009a08:	16220013 	bne	s1,v0,a0009a58 <example+0x94>
a0009a0c:	2632ffff 	addiu	s2,s1,-1
  {

   rx1_str[0] = 0x00;
a0009a10:	3c02a058 	lui	v0,0xa058
a0009a14:	a0400000 	sb	zero,0(v0)
   rx1_str[1] = 0x11;
a0009a18:	34430001 	ori	v1,v0,0x1
a0009a1c:	24040011 	li	a0,17
a0009a20:	a0640000 	sb	a0,0(v1)
   rx1_str[2] = 0x22;
a0009a24:	34430002 	ori	v1,v0,0x2
a0009a28:	24040022 	li	a0,34
a0009a2c:	a0640000 	sb	a0,0(v1)
   rx1_str[3] = 0x33;
a0009a30:	34430003 	ori	v1,v0,0x3
a0009a34:	24040033 	li	a0,51
a0009a38:	a0640000 	sb	a0,0(v1)
   rx1_str[4] = 0x44;
a0009a3c:	34430004 	ori	v1,v0,0x4
a0009a40:	24040044 	li	a0,68
a0009a44:	a0640000 	sb	a0,0(v1)
   rx1_str[5] = 0x55;
a0009a48:	34420005 	ori	v0,v0,0x5
a0009a4c:	24030055 	li	v1,85
a0009a50:	a0430000 	sb	v1,0(v0)

   
  }
	
    #if (TEST_8196_PCIE_P1)
	  if ( (portnum == 1) || (portnum== 2) )//PORT1
a0009a54:	2632ffff 	addiu	s2,s1,-1
a0009a58:	2e430002 	sltiu	v1,s2,2
a0009a5c:	10600013 	beqz	v1,a0009aac <example+0xe8>
a0009a60:	00001021 	move	v0,zero
	   {
	   	   //prom_printf("\nTest PCIE P1 \n");
		   rx2_str[0] = 0x00;
a0009a64:	3c02a068 	lui	v0,0xa068
a0009a68:	a0400000 	sb	zero,0(v0)
		   rx2_str[1] = 0x11;
a0009a6c:	34430001 	ori	v1,v0,0x1
a0009a70:	24040011 	li	a0,17
a0009a74:	a0640000 	sb	a0,0(v1)
		   rx2_str[2] = 0x22;
a0009a78:	34430002 	ori	v1,v0,0x2
a0009a7c:	24040022 	li	a0,34
a0009a80:	a0640000 	sb	a0,0(v1)
		   rx2_str[3] = 0x33;
a0009a84:	34430003 	ori	v1,v0,0x3
a0009a88:	24040033 	li	a0,51
a0009a8c:	a0640000 	sb	a0,0(v1)
		   rx2_str[4] = 0x44;
a0009a90:	34430004 	ori	v1,v0,0x4
a0009a94:	24040044 	li	a0,68
a0009a98:	a0640000 	sb	a0,0(v1)
		   rx2_str[5] = 0x55;
a0009a9c:	34420005 	ori	v0,v0,0x5
a0009aa0:	24030055 	li	v1,85
a0009aa4:	a0430000 	sb	v1,0(v0)
a0009aa8:	00001021 	move	v0,zero
   
   /* Set Sequential Data */   
   for (i = 6; i < length1; i++)  //wei add
	
   {
            rx1_str[i] = (i - 6) & 0xFF; //default
a0009aac:	3c06a058 	lui	a2,0xa058
a0009ab0:	34c60006 	ori	a2,a2,0x6
        //   rx1_str[i] = ((i - 6) & 0xFF)|0x10;//JSW 20090214: test for PCIE_MacLoopBack ,bit4 always 1

		 
	 #if (TEST_8196_PCIE_P1)
	  if ( (portnum == 1) || (portnum== 2) )//PORT1
a0009ab4:	2e450002 	sltiu	a1,s2,2
	   {
     		 rx2_str[i] = (i - 6) & 0xFF;	
a0009ab8:	3c07a068 	lui	a3,0xa068
a0009abc:	34e70006 	ori	a3,a3,0x6
		   rx2_str[0] = 0x00;
		   rx2_str[1] = 0x11;
		   rx2_str[2] = 0x22;
		   rx2_str[3] = 0x33;
		   rx2_str[4] = 0x44;
		   rx2_str[5] = 0x55;
a0009ac0:	304300ff 	andi	v1,v0,0xff
   
   /* Set Sequential Data */   
   for (i = 6; i < length1; i++)  //wei add
	
   {
            rx1_str[i] = (i - 6) & 0xFF; //default
a0009ac4:	00462021 	addu	a0,v0,a2
        //   rx1_str[i] = ((i - 6) & 0xFF)|0x10;//JSW 20090214: test for PCIE_MacLoopBack ,bit4 always 1

		 
	 #if (TEST_8196_PCIE_P1)
	  if ( (portnum == 1) || (portnum== 2) )//PORT1
a0009ac8:	10a00003 	beqz	a1,a0009ad8 <example+0x114>
a0009acc:	a0830000 	sb	v1,0(a0)
	   {
     		 rx2_str[i] = (i - 6) & 0xFF;	
a0009ad0:	00472021 	addu	a0,v0,a3
a0009ad4:	a0830000 	sb	v1,0(a0)
a0009ad8:	24420001 	addiu	v0,v0,1
//-----------------------------------------------


   
   /* Set Sequential Data */   
   for (i = 6; i < length1; i++)  //wei add
a0009adc:	24430006 	addiu	v1,v0,6
a0009ae0:	0070182a 	slt	v1,v1,s0
a0009ae4:	1460fff6 	bnez	v1,a0009ac0 <example+0xfc>
a0009ae8:	00000000 	nop
   /*
    * READ ID Test:
    * Read 8111C Vendor/Device ID
    */
 
   if ( (portnum == 0) || (portnum== 2) )
a0009aec:	12200005 	beqz	s1,a0009b04 <example+0x140>
a0009af0:	3c02b8b1 	lui	v0,0xb8b1
a0009af4:	24020002 	li	v0,2
a0009af8:	1622002b 	bne	s1,v0,a0009ba8 <example+0x1e4>
a0009afc:	2e420002 	sltiu	v0,s2,2
   {
	  if ((READ_MEM32(PCIE1_EP_CFG) == 0x816810EC) |(READ_MEM32(PCIE1_EP_CFG) == 0x819210EC)|\
a0009b00:	3c02b8b1 	lui	v0,0xb8b1
a0009b04:	8c430000 	lw	v1,0(v0)
a0009b08:	8c440000 	lw	a0,0(v0)
		(READ_MEM32(PCIE1_EP_CFG) == 0x813610EC) )//  //
a0009b0c:	8c450000 	lw	a1,0(v0)
    * Read 8111C Vendor/Device ID
    */
 
   if ( (portnum == 0) || (portnum== 2) )
   {
	  if ((READ_MEM32(PCIE1_EP_CFG) == 0x816810EC) |(READ_MEM32(PCIE1_EP_CFG) == 0x819210EC)|\
a0009b10:	3c028168 	lui	v0,0x8168
a0009b14:	344210ec 	ori	v0,v0,0x10ec
a0009b18:	10620009 	beq	v1,v0,a0009b40 <example+0x17c>
a0009b1c:	3c14a001 	lui	s4,0xa001
a0009b20:	3c028192 	lui	v0,0x8192
a0009b24:	344210ec 	ori	v0,v0,0x10ec
a0009b28:	10820005 	beq	a0,v0,a0009b40 <example+0x17c>
a0009b2c:	00000000 	nop
a0009b30:	3c028136 	lui	v0,0x8136
a0009b34:	344210ec 	ori	v0,v0,0x10ec
a0009b38:	14a2000f 	bne	a1,v0,a0009b78 <example+0x1b4>
a0009b3c:	00000000 	nop
		(READ_MEM32(PCIE1_EP_CFG) == 0x813610EC) )//  //
	   {
	      // Successful 	     
	       #if DBG
		      dprintf("\n======================================\n");
a0009b40:	0c002325 	jal	a0008c94 <dprintf>
a0009b44:	268454ac 	addiu	a0,s4,21676
		      dprintf("\nRead 8111/8192/8102 ID PASS !");	      
a0009b48:	3c04a001 	lui	a0,0xa001
a0009b4c:	0c002325 	jal	a0008c94 <dprintf>
a0009b50:	248454d8 	addiu	a0,a0,21720
		      dprintf("\n=>PASS,PCIE P0's ID (0xb8b10000)=%x\n",READ_MEM32(PCIE1_EP_CFG)); 
a0009b54:	3c02b8b1 	lui	v0,0xb8b1
a0009b58:	8c450000 	lw	a1,0(v0)
a0009b5c:	3c04a001 	lui	a0,0xa001
a0009b60:	0c002325 	jal	a0008c94 <dprintf>
a0009b64:	248454f8 	addiu	a0,a0,21752
		      dprintf("\n======================================\n");
a0009b68:	0c002325 	jal	a0008c94 <dprintf>
a0009b6c:	268454ac 	addiu	a0,s4,21676
   }
//---------------------------------------------------------------------------------------------

 //Auto-test PCIE Port1 by recognize Bond_Option	
 #if (TEST_8196_PCIE_P1)	
	if ( (portnum == 1) || (portnum== 2) )//PORT1
a0009b70:	080026ea 	j	a0009ba8 <example+0x1e4>
a0009b74:	2e420002 	sltiu	v0,s2,2
	   {

	      // Failed 
	     
	      #if DBG
		      dprintf("\nRead 8111/8192/8102 ID Fail ! \n");				
a0009b78:	3c04a001 	lui	a0,0xa001
a0009b7c:	0c002325 	jal	a0008c94 <dprintf>
a0009b80:	24845520 	addiu	a0,a0,21792
	      #endif
		  
		  if(quietmode==0)
a0009b84:	1660006b 	bnez	s3,a0009d34 <example+0x370>
a0009b88:	00001021 	move	v0,zero
		 dprintf("\n=>Fail,PCIE P0's ID (0xb8b10000)=%x\n",READ_MEM32(PCIE1_EP_CFG)); 	
a0009b8c:	3c02b8b1 	lui	v0,0xb8b1
a0009b90:	8c450000 	lw	a1,0(v0)
a0009b94:	3c04a001 	lui	a0,0xa001
a0009b98:	0c002325 	jal	a0008c94 <dprintf>
a0009b9c:	24845544 	addiu	a0,a0,21828
a0009ba0:	0800274d 	j	a0009d34 <example+0x370>
a0009ba4:	00001021 	move	v0,zero
   }
//---------------------------------------------------------------------------------------------

 //Auto-test PCIE Port1 by recognize Bond_Option	
 #if (TEST_8196_PCIE_P1)	
	if ( (portnum == 1) || (portnum== 2) )//PORT1
a0009ba8:	10400028 	beqz	v0,a0009c4c <example+0x288>
a0009bac:	02202021 	move	a0,s1
	 {
	   if ((READ_MEM32(PCIE2_EP_CFG) == 0x816810EC) |(READ_MEM32(PCIE2_EP_CFG) == 0x819210EC)|\
a0009bb0:	3c02b8b3 	lui	v0,0xb8b3
a0009bb4:	8c430000 	lw	v1,0(v0)
a0009bb8:	8c440000 	lw	a0,0(v0)
			(READ_MEM32(PCIE2_EP_CFG) == 0x813610EC) )//  //
a0009bbc:	8c450000 	lw	a1,0(v0)

 //Auto-test PCIE Port1 by recognize Bond_Option	
 #if (TEST_8196_PCIE_P1)	
	if ( (portnum == 1) || (portnum== 2) )//PORT1
	 {
	   if ((READ_MEM32(PCIE2_EP_CFG) == 0x816810EC) |(READ_MEM32(PCIE2_EP_CFG) == 0x819210EC)|\
a0009bc0:	3c028168 	lui	v0,0x8168
a0009bc4:	344210ec 	ori	v0,v0,0x10ec
a0009bc8:	10620008 	beq	v1,v0,a0009bec <example+0x228>
a0009bcc:	3c14a001 	lui	s4,0xa001
a0009bd0:	3c028192 	lui	v0,0x8192
a0009bd4:	344210ec 	ori	v0,v0,0x10ec
a0009bd8:	10820004 	beq	a0,v0,a0009bec <example+0x228>
a0009bdc:	3c028136 	lui	v0,0x8136
a0009be0:	344210ec 	ori	v0,v0,0x10ec
a0009be4:	14a2000f 	bne	a1,v0,a0009c24 <example+0x260>
a0009be8:	00000000 	nop
			(READ_MEM32(PCIE2_EP_CFG) == 0x813610EC) )//  //
	   {
	      // Successful 

	       #if DBG
		      dprintf("\n======================================\n");
a0009bec:	0c002325 	jal	a0008c94 <dprintf>
a0009bf0:	268454ac 	addiu	a0,s4,21676
		      dprintf("\nRead 8111/8192/8102 ID PASS !");		
a0009bf4:	3c04a001 	lui	a0,0xa001
a0009bf8:	0c002325 	jal	a0008c94 <dprintf>
a0009bfc:	248454d8 	addiu	a0,a0,21720
		      dprintf("\n=>PASS,PCIE P1's ID (0xb8b30000)=%x\n",READ_MEM32(PCIE2_EP_CFG)); 	
a0009c00:	3c02b8b3 	lui	v0,0xb8b3
a0009c04:	8c450000 	lw	a1,0(v0)
a0009c08:	3c04a001 	lui	a0,0xa001
a0009c0c:	0c002325 	jal	a0008c94 <dprintf>
a0009c10:	2484556c 	addiu	a0,a0,21868
		      dprintf("\n======================================\n");
a0009c14:	0c002325 	jal	a0008c94 <dprintf>
a0009c18:	268454ac 	addiu	a0,s4,21676
	    * MAC Loopback Test:
	    * TX 1 Packet and then RX compare
	    */

	  /*"2"=test P1 and P0  , "1"=test P1 , "0"= test P0  */
	   rtl8168_init(portnum, en_loopback ); 
a0009c1c:	08002713 	j	a0009c4c <example+0x288>
a0009c20:	02202021 	move	a0,s1
	   else
	   {
	      // Failed 
	      
	       #if DBG
		      dprintf("\nRead 8111/8192/8102 ID Fail !\n");		     
a0009c24:	3c04a001 	lui	a0,0xa001
a0009c28:	0c002325 	jal	a0008c94 <dprintf>
a0009c2c:	24845594 	addiu	a0,a0,21908
		      dprintf("\n=>Fail,PCIE P1's ID (0xb8b30000)=%x\n",READ_MEM32(PCIE2_EP_CFG)); 	
a0009c30:	3c02b8b3 	lui	v0,0xb8b3
a0009c34:	8c450000 	lw	a1,0(v0)
a0009c38:	3c04a001 	lui	a0,0xa001
a0009c3c:	0c002325 	jal	a0008c94 <dprintf>
a0009c40:	248455b4 	addiu	a0,a0,21940
			
	      #endif
			return 0;
a0009c44:	0800274d 	j	a0009d34 <example+0x370>
a0009c48:	00001021 	move	v0,zero
	    * MAC Loopback Test:
	    * TX 1 Packet and then RX compare
	    */

	  /*"2"=test P1 and P0  , "1"=test P1 , "0"= test P0  */
	   rtl8168_init(portnum, en_loopback ); 
a0009c4c:	0c00254b 	jal	a000952c <rtl8168_init>
a0009c50:	24050001 	li	a1,1
      for (i = 0; i < 64; i++)  //wei add
            rx1_str[i] = tx_buffer[i]; 
            
#endif    	  
	   //-------------------------------------------------------------------	
	  if ( (portnum == 0) || (portnum== 2) )
a0009c54:	12200003 	beqz	s1,a0009c64 <example+0x2a0>
a0009c58:	24020002 	li	v0,2
a0009c5c:	16220006 	bne	s1,v0,a0009c78 <example+0x2b4>
a0009c60:	2e420002 	sltiu	v0,s2,2
	  {
	  	 rtl8168_tx(rx1_str, length1, portnum);
a0009c64:	3c04a058 	lui	a0,0xa058
a0009c68:	02002821 	move	a1,s0
a0009c6c:	0c0023b4 	jal	a0008ed0 <rtl8168_tx>
a0009c70:	02203021 	move	a2,s1
	  }
	   //-------------------------------------------------------------------
	    #if (TEST_8196_PCIE_P1)
		if ( (portnum == 1) || (portnum== 2) )
a0009c74:	2e420002 	sltiu	v0,s2,2
a0009c78:	10400004 	beqz	v0,a0009c8c <example+0x2c8>
a0009c7c:	3c04a068 	lui	a0,0xa068
	   	  {
	 	  	rtl8168_tx(rx2_str, length1, portnum);
a0009c80:	02002821 	move	a1,s0
a0009c84:	0c0023b4 	jal	a0008ed0 <rtl8168_tx>
a0009c88:	02203021 	move	a2,s1
	   	  }
	   #endif
	   //-------------------------------------------------------------------
	   rtl8168_tx_trigger(portnum);
a0009c8c:	0c0023f3 	jal	a0008fcc <rtl8168_tx_trigger>
a0009c90:	02202021 	move	a0,s1
	   //-------------------------------------------------------------------
	  if ( (portnum == 0) || (portnum== 2) )
a0009c94:	12200003 	beqz	s1,a0009ca4 <example+0x2e0>
a0009c98:	24020002 	li	v0,2
a0009c9c:	16220011 	bne	s1,v0,a0009ce4 <example+0x320>
a0009ca0:	00000000 	nop
	   {
		   if (rtl8168_rx(rx1_str, length1, portnum) == 0)   //"0"==compare OK,"-1"=fail
a0009ca4:	3c04a058 	lui	a0,0xa058
a0009ca8:	02002821 	move	a1,s0
a0009cac:	0c002451 	jal	a0009144 <rtl8168_rx>
a0009cb0:	02203021 	move	a2,s1
a0009cb4:	14400006 	bnez	v0,a0009cd0 <example+0x30c>
a0009cb8:	00000000 	nop
		   {		      
			// if(quietmode==0)
			  dprintf("PCIE_P0 => PASS !\n");		
a0009cbc:	3c04a001 	lui	a0,0xa001
a0009cc0:	0c002325 	jal	a0008c94 <dprintf>
a0009cc4:	248455dc 	addiu	a0,a0,21980
				return 0;
		   }
	   }	
	   //-------------------------------------------------------------------
	    #if (TEST_8196_PCIE_P1)		   	  
  		 if ( (portnum == 1) || (portnum== 2) )
a0009cc8:	0800273a 	j	a0009ce8 <example+0x324>
a0009ccc:	2e520002 	sltiu	s2,s2,2
			  dprintf("PCIE_P0 => PASS !\n");		
		   }
		   else
		   {		      
			 //if(quietmode==0)			      
    			      dprintf("PCIE_P0 => Fail ! \n");			
a0009cd0:	3c04a001 	lui	a0,0xa001
a0009cd4:	0c002325 	jal	a0008c94 <dprintf>
a0009cd8:	248455f0 	addiu	a0,a0,22000

				return 0;
a0009cdc:	0800274d 	j	a0009d34 <example+0x370>
a0009ce0:	00001021 	move	v0,zero
		   }
	   }	
	   //-------------------------------------------------------------------
	    #if (TEST_8196_PCIE_P1)		   	  
  		 if ( (portnum == 1) || (portnum== 2) )
a0009ce4:	2e520002 	sltiu	s2,s2,2
a0009ce8:	12400012 	beqz	s2,a0009d34 <example+0x370>
a0009cec:	24020001 	li	v0,1
	   	  {
			  if (rtl8168_rx(rx2_str, length1, portnum) == 0)   //"0"==compare OK,"-1"=fail
a0009cf0:	3c04a068 	lui	a0,0xa068
a0009cf4:	02002821 	move	a1,s0
a0009cf8:	0c002451 	jal	a0009144 <rtl8168_rx>
a0009cfc:	02203021 	move	a2,s1
a0009d00:	14400007 	bnez	v0,a0009d20 <example+0x35c>
a0009d04:	3c04a001 	lui	a0,0xa001
			   {		
			 	if(quietmode==0)			   
a0009d08:	16600009 	bnez	s3,a0009d30 <example+0x36c>
a0009d0c:	3c04a001 	lui	a0,0xa001
				 	dprintf("PCIE_P1 => PASS !\n");				
a0009d10:	0c002325 	jal	a0008c94 <dprintf>
a0009d14:	24845604 	addiu	a0,a0,22020
a0009d18:	0800274d 	j	a0009d34 <example+0x370>
a0009d1c:	24020001 	li	v0,1
			   }
			   else
			   { 
			   	//if(quietmode==0)
					dprintf("PCIE_P1 => Fail !\n");					
a0009d20:	0c002325 	jal	a0008c94 <dprintf>
a0009d24:	24845618 	addiu	a0,a0,22040
					return 0;
a0009d28:	0800274d 	j	a0009d34 <example+0x370>
a0009d2c:	00001021 	move	v0,zero
a0009d30:	24020001 	li	v0,1

		  return 1;
	

	
}
a0009d34:	8fbf0024 	lw	ra,36(sp)
a0009d38:	8fb40020 	lw	s4,32(sp)
a0009d3c:	8fb3001c 	lw	s3,28(sp)
a0009d40:	8fb20018 	lw	s2,24(sp)
a0009d44:	8fb10014 	lw	s1,20(sp)
a0009d48:	8fb00010 	lw	s0,16(sp)
a0009d4c:	03e00008 	jr	ra
a0009d50:	27bd0028 	addiu	sp,sp,40
	...

a0009d60 <CmdCore1Wakeup>:
  		#define PATT_SLEEP  0x3333		
  		#define PATT_READY  0x5555

	//Let Core 1 wakeup
	#define GIC_WAKEUP_IRQ 43
	REG32(GIC_BASE_ADDR+0x2000+GIC_WAKEUP_IRQ*0x20)=2;  //map2vpe
a0009d60:	3c02bbdc 	lui	v0,0xbbdc
a0009d64:	34432560 	ori	v1,v0,0x2560
a0009d68:	24040002 	li	a0,2
a0009d6c:	ac640000 	sw	a0,0(v1)
	REG32(GIC_BASE_ADDR+0x184)=0x800;  //trg edge type 
a0009d70:	34430184 	ori	v1,v0,0x184
a0009d74:	24040800 	li	a0,2048
a0009d78:	ac640000 	sw	a0,0(v1)
		
	REG32(GIC_BASE_ADDR+0x280)=0x80000000 | GIC_WAKEUP_IRQ;  //sw int
a0009d7c:	34420280 	ori	v0,v0,0x280
a0009d80:	3c048000 	lui	a0,0x8000
a0009d84:	3484002b 	ori	a0,a0,0x2b
a0009d88:	ac440000 	sw	a0,0(v0)
//	delay_ms(10);
	REG32(GIC_BASE_ADDR+0x280)=0x00000000 | GIC_WAKEUP_IRQ;	
a0009d8c:	2404002b 	li	a0,43
a0009d90:	ac440000 	sw	a0,0(v0)
	REG32(GIC_BASE_ADDR+0x184)=0x0;  //trg edge type 
a0009d94:	ac600000 	sw	zero,0(v1)
a0009d98:	24020063 	li	v0,99
#if 1
	int i=100;
	while(i--)
	{
		if(REG32(POLLING_REG)!=PATT_SLEEP)
a0009d9c:	3c05b800 	lui	a1,0xb800
a0009da0:	34a5006c 	ori	a1,a1,0x6c
a0009da4:	24043333 	li	a0,13107
a0009da8:	8ca30000 	lw	v1,0(a1)
a0009dac:	14640005 	bne	v1,a0,a0009dc4 <CmdCore1Wakeup+0x64>
a0009db0:	00000000 	nop
//	delay_ms(10);
	REG32(GIC_BASE_ADDR+0x280)=0x00000000 | GIC_WAKEUP_IRQ;	
	REG32(GIC_BASE_ADDR+0x184)=0x0;  //trg edge type 
#if 1
	int i=100;
	while(i--)
a0009db4:	10400003 	beqz	v0,a0009dc4 <CmdCore1Wakeup+0x64>
a0009db8:	00000000 	nop
a0009dbc:	0800276a 	j	a0009da8 <CmdCore1Wakeup+0x48>
a0009dc0:	2442ffff 	addiu	v0,v0,-1
#endif

#ifdef _verbose
	printf("Core 1 cannot Wakeup, ret=%x\n", REG32(POLLING_REG));
#endif
}
a0009dc4:	03e00008 	jr	ra
a0009dc8:	00000000 	nop

a0009dcc <SPEED_isr>:
}
//==============================================================


static void SPEED_isr(void)
{
a0009dcc:	27bdffe0 	addiu	sp,sp,-32
a0009dd0:	afbf001c 	sw	ra,28(sp)
a0009dd4:	afb10018 	sw	s1,24(sp)
a0009dd8:	afb00014 	sw	s0,20(sp)
	unsigned int isr=REG32(GISR_REG);
a0009ddc:	3c02b800 	lui	v0,0xb800
a0009de0:	34433004 	ori	v1,v0,0x3004
a0009de4:	8c700000 	lw	s0,0(v1)
	unsigned int cpu_status=REG32(SYS_INT_STATUS);
a0009de8:	34420004 	ori	v0,v0,0x4
a0009dec:	8c510000 	lw	s1,0(v0)
	
	dprintf("=>CPU Wake-up interrupt happen! GISR=%08x \n", isr);
a0009df0:	3c04a001 	lui	a0,0xa001
a0009df4:	24845634 	addiu	a0,a0,22068
a0009df8:	0c002325 	jal	a0008c94 <dprintf>
a0009dfc:	02002821 	move	a1,s0

	if( (isr & (1<<27))==0)   //check isr==1
a0009e00:	7e0206c0 	ext	v0,s0,0x1b,0x1
a0009e04:	14400008 	bnez	v0,a0009e28 <SPEED_isr+0x5c>
a0009e08:	32220002 	andi	v0,s1,0x2
	{	dprintf("Check Fail, GISR=%x bit %d is not 1\n", isr, 27);
a0009e0c:	3c04a001 	lui	a0,0xa001
a0009e10:	24845660 	addiu	a0,a0,22112
a0009e14:	02002821 	move	a1,s0
a0009e18:	0c002325 	jal	a0008c94 <dprintf>
a0009e1c:	2406001b 	li	a2,27
a0009e20:	08002788 	j	a0009e20 <SPEED_isr+0x54>
a0009e24:	00000000 	nop
		while(1) ;
	}

	if((cpu_status & (1<<1))==0)  //check source==1
a0009e28:	14400008 	bnez	v0,a0009e4c <SPEED_isr+0x80>
a0009e2c:	24030002 	li	v1,2
	{	dprintf("Fail, Source=%x bit %d is not 1 \n", cpu_status, 1);
a0009e30:	3c04a001 	lui	a0,0xa001
a0009e34:	24845688 	addiu	a0,a0,22152
a0009e38:	02202821 	move	a1,s1
a0009e3c:	0c002325 	jal	a0008c94 <dprintf>
a0009e40:	24060001 	li	a2,1
a0009e44:	08002791 	j	a0009e44 <SPEED_isr+0x78>
a0009e48:	00000000 	nop
		while(1) ;
	}
		
	REG32(SYS_INT_STATUS)=(1<<1);  //enable cpu wakeup interrupt mask
a0009e4c:	3c02b800 	lui	v0,0xb800
a0009e50:	34420004 	ori	v0,v0,0x4
a0009e54:	ac430000 	sw	v1,0(v0)
//	REG32(GISR_REG)=1<<SPEED_IRQ_NO;	//write to clear, but cannot clear


//	REG32(GIMR_REG)= REG32(GIMR_REG) & ~(1<<SPEED_IRQ_NO);	//so, disable interrupt		
}
a0009e58:	8fbf001c 	lw	ra,28(sp)
a0009e5c:	8fb10018 	lw	s1,24(sp)
a0009e60:	8fb00014 	lw	s0,20(sp)
a0009e64:	03e00008 	jr	ra
a0009e68:	27bd0020 	addiu	sp,sp,32

a0009e6c <SettingM2xClk>:
extern unsigned long glexra_clock;

//---------------------------------------------------------------------------

int SettingM2xClk(int clk_sel)
{
a0009e6c:	27bdffe8 	addiu	sp,sp,-24
a0009e70:	afbf0014 	sw	ra,20(sp)
	int	tmp=REG32(SYS_HW_STRAP) & ~(CK_M2X_FREQ_SEL);
a0009e74:	3c02b800 	lui	v0,0xb800
a0009e78:	34430008 	ori	v1,v0,0x8
a0009e7c:	8c660000 	lw	a2,0(v1)
	
		#if 1  //lock bus			
			REG32(SYS_LX_CTRL) |= (1<<2) ;	  //lock bus arb2
a0009e80:	34420014 	ori	v0,v0,0x14
a0009e84:	8c430000 	lw	v1,0(v0)
a0009e88:	34630004 	ori	v1,v1,0x4
a0009e8c:	ac430000 	sw	v1,0(v0)
			while( (REG32(SYS_BIST_DONE)&(1<<0))==0)  ; //wait bit to 1, is mean lock ok	
a0009e90:	3c05b800 	lui	a1,0xb800
a0009e94:	34a50020 	ori	a1,a1,0x20
a0009e98:	8ca30000 	lw	v1,0(a1)
a0009e9c:	30630001 	andi	v1,v1,0x1
a0009ea0:	1060fffd 	beqz	v1,a0009e98 <SettingM2xClk+0x2c>
a0009ea4:	3c02b800 	lui	v0,0xb800

			REG32(SYS_LX_CTRL) |= (1<<3) ;	  //lock bus arb4
a0009ea8:	34420014 	ori	v0,v0,0x14
a0009eac:	8c430000 	lw	v1,0(v0)
a0009eb0:	34630008 	ori	v1,v1,0x8
a0009eb4:	ac430000 	sw	v1,0(v0)
			while( (REG32(SYS_BIST_DONE)&(1<<1))==0)  ; //wait bit to 1, is mean lock ok		
a0009eb8:	3c05b800 	lui	a1,0xb800
a0009ebc:	34a50020 	ori	a1,a1,0x20
a0009ec0:	8ca30000 	lw	v1,0(a1)
a0009ec4:	30630002 	andi	v1,v1,0x2
a0009ec8:	1060fffd 	beqz	v1,a0009ec0 <SettingM2xClk+0x54>
a0009ecc:	3c02b800 	lui	v0,0xb800

			REG32(SYS_LX_CTRL) |= (1<<4) ;	  //lock bus arb6
a0009ed0:	34420014 	ori	v0,v0,0x14
a0009ed4:	8c430000 	lw	v1,0(v0)
a0009ed8:	34630010 	ori	v1,v1,0x10
a0009edc:	ac430000 	sw	v1,0(v0)
			while( (REG32(SYS_BIST_DONE)&(1<<2))==0)  ; //wait bit to 1, is mean lock ok		
a0009ee0:	3c05b800 	lui	a1,0xb800
a0009ee4:	34a50020 	ori	a1,a1,0x20
a0009ee8:	8ca30000 	lw	v1,0(a1)
a0009eec:	30630004 	andi	v1,v1,0x4
a0009ef0:	1060fffd 	beqz	v1,a0009ee8 <SettingM2xClk+0x7c>
a0009ef4:	00041280 	sll	v0,a0,0xa

			//add check transaction dram empty .
		#endif

	
	REG32(SYS_HW_STRAP)= tmp | (clk_sel) <<CK_M2X_FREQ_SEL_OFFSET ;
a0009ef8:	240383ff 	li	v1,-31745
a0009efc:	00c31824 	and	v1,a2,v1
a0009f00:	00431825 	or	v1,v0,v1
a0009f04:	3c02b800 	lui	v0,0xb800
a0009f08:	34420008 	ori	v0,v0,0x8
a0009f0c:	ac430000 	sw	v1,0(v0)
		
		#if 1   //check m2xusable and unlock bus
			while( (REG32(SYS_BIST_DONE)&(1<<18))==0)  ;   //wait to 1, mean m2x is usable
a0009f10:	3c06b800 	lui	a2,0xb800
a0009f14:	34c60020 	ori	a2,a2,0x20
a0009f18:	3c050004 	lui	a1,0x4
a0009f1c:	8cc30000 	lw	v1,0(a2)
a0009f20:	00651824 	and	v1,v1,a1
a0009f24:	1060fffd 	beqz	v1,a0009f1c <SettingM2xClk+0xb0>
a0009f28:	3c02b800 	lui	v0,0xb800
	
			REG32(SYS_LX_CTRL) &= ~(1<<2);	//unlock
a0009f2c:	34420014 	ori	v0,v0,0x14
a0009f30:	8c450000 	lw	a1,0(v0)
a0009f34:	2403fffb 	li	v1,-5
a0009f38:	00a31824 	and	v1,a1,v1
a0009f3c:	ac430000 	sw	v1,0(v0)
			while( (REG32(SYS_BIST_DONE)&(1<<0))==(1<<0)) ;  //wait bit to 0  unlock
a0009f40:	3c05b800 	lui	a1,0xb800
a0009f44:	34a50020 	ori	a1,a1,0x20
a0009f48:	8ca30000 	lw	v1,0(a1)
a0009f4c:	30630001 	andi	v1,v1,0x1
a0009f50:	1460fffd 	bnez	v1,a0009f48 <SettingM2xClk+0xdc>
a0009f54:	3c02b800 	lui	v0,0xb800

			REG32(SYS_LX_CTRL) &= ~(1<<3);	//unlock
a0009f58:	34420014 	ori	v0,v0,0x14
a0009f5c:	8c450000 	lw	a1,0(v0)
a0009f60:	2403fff7 	li	v1,-9
a0009f64:	00a31824 	and	v1,a1,v1
a0009f68:	ac430000 	sw	v1,0(v0)
			while( (REG32(SYS_BIST_DONE)&(1<<1))==(1<<1)) ;  //wait bit to 0  unlock
a0009f6c:	3c05b800 	lui	a1,0xb800
a0009f70:	34a50020 	ori	a1,a1,0x20
a0009f74:	8ca30000 	lw	v1,0(a1)
a0009f78:	30630002 	andi	v1,v1,0x2
a0009f7c:	1460fffd 	bnez	v1,a0009f74 <SettingM2xClk+0x108>
a0009f80:	3c02b800 	lui	v0,0xb800

			REG32(SYS_LX_CTRL) &= ~(1<<4);	//unlock
a0009f84:	34420014 	ori	v0,v0,0x14
a0009f88:	8c450000 	lw	a1,0(v0)
a0009f8c:	2403ffef 	li	v1,-17
a0009f90:	00a31824 	and	v1,a1,v1
a0009f94:	ac430000 	sw	v1,0(v0)
			while( (REG32(SYS_BIST_DONE)&(1<<2))==(1<<2)) ;  //wait bit to 0  unlock	
a0009f98:	3c05b800 	lui	a1,0xb800
a0009f9c:	34a50020 	ori	a1,a1,0x20
a0009fa0:	8ca30000 	lw	v1,0(a1)
a0009fa4:	30630004 	andi	v1,v1,0x4
a0009fa8:	1460fffd 	bnez	v1,a0009fa0 <SettingM2xClk+0x134>
a0009fac:	3c02a001 	lui	v0,0xa001
	{
		console_init(glexra_clock);
		timer_init(glexra_clock);
	}
#endif		
	dprintf("Change M2x clock freq=%d \n", m2x_clksel_table[clk_sel] );
a0009fb0:	00042080 	sll	a0,a0,0x2
a0009fb4:	24420440 	addiu	v0,v0,1088
a0009fb8:	00821021 	addu	v0,a0,v0
a0009fbc:	3c04a001 	lui	a0,0xa001
a0009fc0:	248456ac 	addiu	a0,a0,22188
a0009fc4:	0c002325 	jal	a0008c94 <dprintf>
a0009fc8:	8c450000 	lw	a1,0(v0)
}
a0009fcc:	8fbf0014 	lw	ra,20(sp)
a0009fd0:	03e00008 	jr	ra
a0009fd4:	27bd0018 	addiu	sp,sp,24

a0009fd8 <LetCPUDoSomething>:

struct irqaction irq_SPEED = {SPEED_isr, (unsigned long)NULL, (unsigned long)SPEED_IRQ_NO,"SPEED", (void *)NULL, (struct irqaction *)NULL};   

//---------------------------------------------------------------------------
int LetCPUDoSomething()
{
a0009fd8:	27bdfbe8 	addiu	sp,sp,-1048
a0009fdc:	afbf0414 	sw	ra,1044(sp)
      	{
		dprintf("FAIL! ,summation 1 to 100=%d \n",sum);
		while(1) {};
	  }

	p=(unsigned int)buf|0xa0000000;
a0009fe0:	27a70010 	addiu	a3,sp,16
a0009fe4:	3c02a000 	lui	v0,0xa000
a0009fe8:	00e23825 	or	a3,a3,v0
a0009fec:	00e02821 	move	a1,a3
a0009ff0:	00e01821 	move	v1,a3
a0009ff4:	00001021 	move	v0,zero
	for(i=0; i<256; i++)
a0009ff8:	24040100 	li	a0,256
		p[i]=i;
a0009ffc:	ac620000 	sw	v0,0(v1)
		dprintf("FAIL! ,summation 1 to 100=%d \n",sum);
		while(1) {};
	  }

	p=(unsigned int)buf|0xa0000000;
	for(i=0; i<256; i++)
a000a000:	24420001 	addiu	v0,v0,1
a000a004:	1444fffd 	bne	v0,a0,a0009ffc <LetCPUDoSomething+0x24>
a000a008:	24630004 	addiu	v1,v1,4
		p[i]=i;

	for(i=0; i<256;i++)
		if(p[i]!=i)
a000a00c:	8ca60000 	lw	a2,0(a1)
a000a010:	24050001 	li	a1,1
a000a014:	10c00003 	beqz	a2,a000a024 <LetCPUDoSomething+0x4c>
a000a018:	24020100 	li	v0,256
a000a01c:	0800280d 	j	a000a034 <LetCPUDoSomething+0x5c>
a000a020:	00002821 	move	a1,zero
a000a024:	8ce60004 	lw	a2,4(a3)
a000a028:	10c50007 	beq	a2,a1,a000a048 <LetCPUDoSomething+0x70>
a000a02c:	24a50001 	addiu	a1,a1,1
a000a030:	24a5ffff 	addiu	a1,a1,-1
		{	dprintf("FAIL! idx=%x val=%x\n",i,p[i]);
a000a034:	3c04a001 	lui	a0,0xa001
a000a038:	0c002325 	jal	a0008c94 <dprintf>
a000a03c:	248456c8 	addiu	a0,a0,22216
a000a040:	08002810 	j	a000a040 <LetCPUDoSomething+0x68>
a000a044:	00000000 	nop

	p=(unsigned int)buf|0xa0000000;
	for(i=0; i<256; i++)
		p[i]=i;

	for(i=0; i<256;i++)
a000a048:	14a2fff6 	bne	a1,v0,a000a024 <LetCPUDoSomething+0x4c>
a000a04c:	24e70004 	addiu	a3,a3,4
		if(p[i]!=i)
		{	dprintf("FAIL! idx=%x val=%x\n",i,p[i]);
			while(1) {};
		}

}
a000a050:	8fbf0414 	lw	ra,1044(sp)
a000a054:	03e00008 	jr	ra
a000a058:	27bd0418 	addiu	sp,sp,1048

a000a05c <HS0_Control>:
}

//=================================================================================

void HS0_Control(unsigned int ocp, unsigned int lx, unsigned int mx, unsigned int sleep)
{
a000a05c:	27bdffd8 	addiu	sp,sp,-40
a000a060:	afbf0024 	sw	ra,36(sp)
a000a064:	afb40020 	sw	s4,32(sp)
a000a068:	afb3001c 	sw	s3,28(sp)
a000a06c:	afb20018 	sw	s2,24(sp)
a000a070:	afb10014 	sw	s1,20(sp)
a000a074:	afb00010 	sw	s0,16(sp)
a000a078:	00808821 	move	s1,a0
a000a07c:	00c08021 	move	s0,a2
a000a080:	00e09821 	move	s3,a3
	#define GET_BITVAL(v,bitpos,pat) ((v& ((unsigned int)pat<<bitpos))>>bitpos)
	#define RANG5  0x1f
	#define RANG4  0x0f


	if(lx==0)	lx=200;
a000a084:	241400c8 	li	s4,200
	if(mx==0)
a000a088:	14c0000b 	bnez	a2,a000a0b8 <HS0_Control+0x5c>
a000a08c:	00a5a00b 	movn	s4,a1,a1
	{
		unsigned int m2x_freq_sel=GET_BITVAL(REG32(SYS_HW_STRAP), CK_M2X_FREQ_SEL_OFFSET, RANG5);
a000a090:	3c02b800 	lui	v0,0xb800
a000a094:	34420008 	ori	v0,v0,0x8
a000a098:	8c430000 	lw	v1,0(v0)
		mx=(m2x_clksel_table[m2x_freq_sel])/2;
a000a09c:	7c632280 	ext	v1,v1,0xa,0x5
a000a0a0:	00031880 	sll	v1,v1,0x2
a000a0a4:	3c02a001 	lui	v0,0xa001
a000a0a8:	24420440 	addiu	v0,v0,1088
a000a0ac:	00621021 	addu	v0,v1,v0
a000a0b0:	8c500000 	lw	s0,0(v0)
a000a0b4:	00108042 	srl	s0,s0,0x1
	}
 	if(ocp==0)
a000a0b8:	1620000d 	bnez	s1,a000a0f0 <HS0_Control+0x94>
a000a0bc:	0290102b 	sltu	v0,s4,s0
 	{
		unsigned int cpu_freq_sel=GET_BITVAL(REG32(SYS_HW_STRAP), ST_CPU_FREQ_SEL_OFFSET, RANG4);
a000a0c0:	3c02b800 	lui	v0,0xb800
a000a0c4:	34420008 	ori	v0,v0,0x8
a000a0c8:	8c420000 	lw	v0,0(v0)
		ocp=cpu_clksel_table[cpu_freq_sel];
a000a0cc:	3c030007 	lui	v1,0x7
a000a0d0:	34638000 	ori	v1,v1,0x8000
a000a0d4:	00431824 	and	v1,v0,v1
a000a0d8:	00031b42 	srl	v1,v1,0xd
a000a0dc:	3c02a001 	lui	v0,0xa001
a000a0e0:	24420400 	addiu	v0,v0,1024
a000a0e4:	00621021 	addu	v0,v1,v0
a000a0e8:	8c510000 	lw	s1,0(v0)

	
	#define SYS_HS0_CTRL 0xb80000a0
	#define BIT(x)	(1 << x)	
	unsigned int v=0;
	if(lx<mx)		{	v|=BIT(0)| BIT(1) |BIT(2);   	printf("Lx<Mx\n");		}
a000a0ec:	0290102b 	sltu	v0,s4,s0
a000a0f0:	10400005 	beqz	v0,a000a108 <HS0_Control+0xac>
a000a0f4:	00009021 	move	s2,zero
a000a0f8:	3c04a001 	lui	a0,0xa001
a000a0fc:	0c002325 	jal	a0008c94 <dprintf>
a000a100:	248456e0 	addiu	a0,a0,22240
a000a104:	24120007 	li	s2,7
	if(ocp<mx)		{	v|=BIT(3);					printf("Ocp<Mx\n");	}
a000a108:	0230802b 	sltu	s0,s1,s0
a000a10c:	12000005 	beqz	s0,a000a124 <HS0_Control+0xc8>
a000a110:	00000000 	nop
a000a114:	36520008 	ori	s2,s2,0x8
a000a118:	3c04a001 	lui	a0,0xa001
a000a11c:	0c002325 	jal	a0008c94 <dprintf>
a000a120:	248456e8 	addiu	a0,a0,22248
	if(ocp<lx)		{	v|=BIT(4);					printf("Ocp<Lx\n");	}
a000a124:	0234882b 	sltu	s1,s1,s4
a000a128:	12200006 	beqz	s1,a000a144 <HS0_Control+0xe8>
a000a12c:	3c02b800 	lui	v0,0xb800
a000a130:	36520010 	ori	s2,s2,0x10
a000a134:	3c04a001 	lui	a0,0xa001
a000a138:	0c002325 	jal	a0008c94 <dprintf>
a000a13c:	248456f0 	addiu	a0,a0,22256

	
	//REG32(SYS_HS0_CTRL) = v;
	REG32(SYS_HS0_CTRL) |= v;
a000a140:	3c02b800 	lui	v0,0xb800
a000a144:	344200a0 	ori	v0,v0,0xa0
a000a148:	8c430000 	lw	v1,0(v0)
a000a14c:	02439025 	or	s2,s2,v1
a000a150:	ac520000 	sw	s2,0(v0)
	


	if(sleep)
a000a154:	12600012 	beqz	s3,a000a1a0 <HS0_Control+0x144>
a000a158:	3c02b800 	lui	v0,0xb800
	{	
		#if 1			
			//printf("llx0\n");
			REG32(SYS_LX_CTRL) |= (1<<2) ;	  //lock bus arb2
a000a15c:	34420014 	ori	v0,v0,0x14
a000a160:	8c430000 	lw	v1,0(v0)
a000a164:	34630004 	ori	v1,v1,0x4
a000a168:	ac430000 	sw	v1,0(v0)
			while( (REG32(SYS_LX_CTRL)&(1<<12))==0)  {}; //wait bit to 1, is mean lock ok	
a000a16c:	00401821 	move	v1,v0
a000a170:	8c620000 	lw	v0,0(v1)
a000a174:	30421000 	andi	v0,v0,0x1000
a000a178:	1040fffd 	beqz	v0,a000a170 <HS0_Control+0x114>
a000a17c:	00000000 	nop
			//REG32(SYS_BIST_CTRL) |= (1<<4) ;	  //lock bus arb6
			//while( (REG32(SYS_BIST_DONE)&(1<<2))==0)  {}; //wait bit to 1, is mean lock ok				
		#endif
		
		//__asm__ volatile("sleep");	 //need 10 usec to guaretee
		__asm__ volatile("nop");
a000a180:	00000000 	nop


		#if 1
			//printf("ulx0\n");	
			REG32(SYS_LX_CTRL) &= ~(1<<2);	//unlock
a000a184:	3c02b800 	lui	v0,0xb800
a000a188:	34420014 	ori	v0,v0,0x14
a000a18c:	8c440000 	lw	a0,0(v0)
a000a190:	2403fffb 	li	v1,-5
a000a194:	00831824 	and	v1,a0,v1
a000a198:	ac430000 	sw	v1,0(v0)
			while( (REG32(SYS_LX_CTRL)&(1<<12))==(1<<0)) {};  //wait bit to 0  unlock
a000a19c:	8c420000 	lw	v0,0(v0)
			//while( (REG32(SYS_BIST_DONE)&(1<<2))==(1<<2)) {};  //wait bit to 0  unlock				
		#endif
	}
			//printf("done\n");

}
a000a1a0:	8fbf0024 	lw	ra,36(sp)
a000a1a4:	8fb40020 	lw	s4,32(sp)
a000a1a8:	8fb3001c 	lw	s3,28(sp)
a000a1ac:	8fb20018 	lw	s2,24(sp)
a000a1b0:	8fb10014 	lw	s1,20(sp)
a000a1b4:	8fb00010 	lw	s0,16(sp)
a000a1b8:	03e00008 	jr	ra
a000a1bc:	27bd0028 	addiu	sp,sp,40

a000a1c0 <ShowStrapMsg>:
#define printf dprintf


//=================================================================================
void ShowStrapMsg()
{
a000a1c0:	27bdffa0 	addiu	sp,sp,-96
a000a1c4:	afbf005c 	sw	ra,92(sp)
a000a1c8:	afb50058 	sw	s5,88(sp)
a000a1cc:	afb40054 	sw	s4,84(sp)
a000a1d0:	afb30050 	sw	s3,80(sp)
a000a1d4:	afb2004c 	sw	s2,76(sp)
a000a1d8:	afb10048 	sw	s1,72(sp)
a000a1dc:	afb00044 	sw	s0,68(sp)
	const unsigned char *boot_type_tab[]={ {"SPI3B"}, {"SPI4B"}, {"NFBI"}, {"NAND"}, {"ROM01"}, {"ROM02"}, {"ROM03"}, {"auto"} };
a000a1e0:	3c02a001 	lui	v0,0xa001
a000a1e4:	244256f8 	addiu	v0,v0,22264
a000a1e8:	afa20018 	sw	v0,24(sp)
a000a1ec:	3c02a001 	lui	v0,0xa001
a000a1f0:	24425700 	addiu	v0,v0,22272
a000a1f4:	afa2001c 	sw	v0,28(sp)
a000a1f8:	3c02a001 	lui	v0,0xa001
a000a1fc:	24425708 	addiu	v0,v0,22280
a000a200:	afa20020 	sw	v0,32(sp)
a000a204:	3c02a001 	lui	v0,0xa001
a000a208:	24425710 	addiu	v0,v0,22288
a000a20c:	afa20024 	sw	v0,36(sp)
a000a210:	3c02a001 	lui	v0,0xa001
a000a214:	24425718 	addiu	v0,v0,22296
a000a218:	afa20028 	sw	v0,40(sp)
a000a21c:	3c02a001 	lui	v0,0xa001
a000a220:	24425720 	addiu	v0,v0,22304
a000a224:	afa2002c 	sw	v0,44(sp)
a000a228:	3c02a001 	lui	v0,0xa001
a000a22c:	24425728 	addiu	v0,v0,22312
a000a230:	afa20030 	sw	v0,48(sp)
a000a234:	3c02a001 	lui	v0,0xa001
a000a238:	24425730 	addiu	v0,v0,22320
a000a23c:	afa20034 	sw	v0,52(sp)
	const unsigned char *dram_type_tab[]={  {"DDR2"}, {"DDR3"} };
a000a240:	3c02a001 	lui	v0,0xa001
a000a244:	24425738 	addiu	v0,v0,22328
a000a248:	afa20038 	sw	v0,56(sp)
a000a24c:	3c02a001 	lui	v0,0xa001
a000a250:	24425740 	addiu	v0,v0,22336
a000a254:	afa2003c 	sw	v0,60(sp)
	#define RANG2 3
	#define RANG3  7
	#define RANG4 0xf	
	#define RANG5 0x1f
	
	unsigned int v=REG32(SYS_HW_STRAP);
a000a258:	3c02b800 	lui	v0,0xb800
a000a25c:	34420008 	ori	v0,v0,0x8
a000a260:	8c500000 	lw	s0,0(v0)

	unsigned int bootsel=GET_BITVAL(v, 0, RANG3);
a000a264:	32110007 	andi	s1,s0,0x7
	unsigned int dramtype=GET_BITVAL(v, 3, RANG1);
a000a268:	7e1200c0 	ext	s2,s0,0x3,0x1
	

	
	unsigned int ck_m2x_freq_sel=GET_BITVAL(v, 10, RANG5);
a000a26c:	7e152280 	ext	s5,s0,0xa,0x5
	unsigned int ck_cpu_freq_sel=GET_BITVAL(v, 15, RANG4);
a000a270:	3c130007 	lui	s3,0x7
a000a274:	36738000 	ori	s3,s3,0x8000
a000a278:	02139824 	and	s3,s0,s3
a000a27c:	00139bc2 	srl	s3,s3,0xf
	unsigned int ck_cpu_div_sel=GET_BITVAL(v, 19, RANG2);
a000a280:	7e140cc0 	ext	s4,s0,0x13,0x2



	
	printf("---------------------\n");
a000a284:	3c04a001 	lui	a0,0xa001
a000a288:	0c002325 	jal	a0008c94 <dprintf>
a000a28c:	24845748 	addiu	a0,a0,22344
	printf("HW_STRAP_VAL= 0x%08x \n", v);
a000a290:	3c04a001 	lui	a0,0xa001
a000a294:	24845760 	addiu	a0,a0,22368
a000a298:	0c002325 	jal	a0008c94 <dprintf>
a000a29c:	02002821 	move	a1,s0
	printf("[02:00] ST_BOOTPINSEL= 0x%x  \n", bootsel);		
a000a2a0:	3c04a001 	lui	a0,0xa001
a000a2a4:	24845778 	addiu	a0,a0,22392
a000a2a8:	0c002325 	jal	a0008c94 <dprintf>
a000a2ac:	02202821 	move	a1,s1
	printf("[03:03] ST_DRAMTYPE= 0x%x      	\n", 	dramtype);	
a000a2b0:	3c04a001 	lui	a0,0xa001
a000a2b4:	24845798 	addiu	a0,a0,22424
a000a2b8:	0c002325 	jal	a0008c94 <dprintf>
a000a2bc:	02402821 	move	a1,s2

	printf("[04:04] clklx_from_clkm= 0x%x \n",  	GET_BITVAL(v, 4, RANG1)  );	
a000a2c0:	3c04a001 	lui	a0,0xa001
a000a2c4:	248457bc 	addiu	a0,a0,22460
a000a2c8:	0c002325 	jal	a0008c94 <dprintf>
a000a2cc:	7e050100 	ext	a1,s0,0x4,0x1
	printf("[05:05] disable_ext_reset= 0x%x \n",  	GET_BITVAL(v, 5, RANG1)  );	
a000a2d0:	3c04a001 	lui	a0,0xa001
a000a2d4:	248457dc 	addiu	a0,a0,22492
a000a2d8:	0c002325 	jal	a0008c94 <dprintf>
a000a2dc:	7e050140 	ext	a1,s0,0x5,0x1
	printf("[06:06] ext_phy_mode= 0x%x \n",  	GET_BITVAL(v, 6, RANG1)  );		
a000a2e0:	3c04a001 	lui	a0,0xa001
a000a2e4:	24845800 	addiu	a0,a0,22528
a000a2e8:	0c002325 	jal	a0008c94 <dprintf>
a000a2ec:	7e050180 	ext	a1,s0,0x6,0x1


	printf("[14:10] CK_M2X_FREQ_SEL= 0x%x \n", ck_m2x_freq_sel);	
a000a2f0:	3c04a001 	lui	a0,0xa001
a000a2f4:	24845820 	addiu	a0,a0,22560
a000a2f8:	0c002325 	jal	a0008c94 <dprintf>
a000a2fc:	02a02821 	move	a1,s5
	printf("[18:15] ST_CPU_FREQ_SEL= 0x%x \n", ck_cpu_freq_sel);
a000a300:	3c04a001 	lui	a0,0xa001
a000a304:	24845840 	addiu	a0,a0,22592
a000a308:	0c002325 	jal	a0008c94 <dprintf>
a000a30c:	02602821 	move	a1,s3
	
	printf("[20:19] ST_CPU_FREQDIV_SEL= 0x%x \n", ck_cpu_div_sel);
a000a310:	3c04a001 	lui	a0,0xa001
a000a314:	24845860 	addiu	a0,a0,22624
a000a318:	0c002325 	jal	a0008c94 <dprintf>
a000a31c:	02802821 	move	a1,s4

	printf("[21:21] clklx_from_halfoc= 0x%x \n",  	GET_BITVAL(v, 21, RANG1)  );	
a000a320:	3c04a001 	lui	a0,0xa001
a000a324:	24845884 	addiu	a0,a0,22660
a000a328:	0c002325 	jal	a0008c94 <dprintf>
a000a32c:	7e050540 	ext	a1,s0,0x15,0x1
	
	printf("[22:22] ever_reboot_once= 0x%x \n", 	GET_BITVAL(v, 22, RANG1)  );	
a000a330:	3c04a001 	lui	a0,0xa001
a000a334:	248458a8 	addiu	a0,a0,22696
a000a338:	0c002325 	jal	a0008c94 <dprintf>
a000a33c:	7e050580 	ext	a1,s0,0x16,0x1
	printf("[23:23] clkoc_from_clkm= 0x%x \n", 	GET_BITVAL(v, 23, RANG1)  );			
a000a340:	3c04a001 	lui	a0,0xa001
a000a344:	248458cc 	addiu	a0,a0,22732
a000a348:	0c002325 	jal	a0008c94 <dprintf>
a000a34c:	7e0505c0 	ext	a1,s0,0x17,0x1
	printf("[24:24] sel_40m= 0x%x \n", 	GET_BITVAL(v, 24, RANG1)  );		
a000a350:	3c04a001 	lui	a0,0xa001
a000a354:	248458ec 	addiu	a0,a0,22764
a000a358:	0c002325 	jal	a0008c94 <dprintf>
a000a35c:	7e050600 	ext	a1,s0,0x18,0x1

	printf("\n");
a000a360:	3c04a001 	lui	a0,0xa001
a000a364:	0c002325 	jal	a0008c94 <dprintf>
a000a368:	248457b8 	addiu	a0,a0,22456
	printf("%s mode, %s Ram,  CPU=%d MHz, Mem2x=%d MHz, \n", 
a000a36c:	00118880 	sll	s1,s1,0x2
a000a370:	27a20018 	addiu	v0,sp,24
a000a374:	00518821 	addu	s1,v0,s1
a000a378:	8e250000 	lw	a1,0(s1)
a000a37c:	00129080 	sll	s2,s2,0x2
a000a380:	00521021 	addu	v0,v0,s2
a000a384:	8c460020 	lw	a2,32(v0)
a000a388:	00139880 	sll	s3,s3,0x2
a000a38c:	3c02a001 	lui	v0,0xa001
a000a390:	24420400 	addiu	v0,v0,1024
a000a394:	02629821 	addu	s3,s3,v0
a000a398:	0014a080 	sll	s4,s4,0x2
a000a39c:	3c02a001 	lui	v0,0xa001
a000a3a0:	24427580 	addiu	v0,v0,30080
a000a3a4:	0282a021 	addu	s4,s4,v0
a000a3a8:	8e670000 	lw	a3,0(s3)
a000a3ac:	8e820000 	lw	v0,0(s4)
a000a3b0:	00e2001b 	divu	zero,a3,v0
a000a3b4:	004001f4 	teq	v0,zero,0x7
a000a3b8:	00003812 	mflo	a3
a000a3bc:	0015a880 	sll	s5,s5,0x2
a000a3c0:	3c02a001 	lui	v0,0xa001
a000a3c4:	24420440 	addiu	v0,v0,1088
a000a3c8:	02a2a821 	addu	s5,s5,v0
a000a3cc:	8ea20000 	lw	v0,0(s5)
a000a3d0:	afa20010 	sw	v0,16(sp)
a000a3d4:	3c04a001 	lui	a0,0xa001
a000a3d8:	0c002325 	jal	a0008c94 <dprintf>
a000a3dc:	24845904 	addiu	a0,a0,22788
						dram_type_tab[dramtype],
						cpu_clksel_table[ck_cpu_freq_sel]/cpu_clkdiv_table[ck_cpu_div_sel] ,
						m2x_clksel_table[ck_m2x_freq_sel]
						);
					
}
a000a3e0:	8fbf005c 	lw	ra,92(sp)
a000a3e4:	8fb50058 	lw	s5,88(sp)
a000a3e8:	8fb40054 	lw	s4,84(sp)
a000a3ec:	8fb30050 	lw	s3,80(sp)
a000a3f0:	8fb2004c 	lw	s2,76(sp)
a000a3f4:	8fb10048 	lw	s1,72(sp)
a000a3f8:	8fb00044 	lw	s0,68(sp)
a000a3fc:	03e00008 	jr	ra
a000a400:	27bd0060 	addiu	sp,sp,96

a000a404 <Cmd_AllBistTest>:
}
		
		
//=============================================================================
int Cmd_AllBistTest(int argc, char* argv[])
{
a000a404:	27bdffd0 	addiu	sp,sp,-48
a000a408:	afbf002c 	sw	ra,44(sp)
a000a40c:	afb60028 	sw	s6,40(sp)
a000a410:	afb50024 	sw	s5,36(sp)
a000a414:	afb40020 	sw	s4,32(sp)
a000a418:	afb3001c 	sw	s3,28(sp)
a000a41c:	afb20018 	sw	s2,24(sp)
a000a420:	afb10014 	sw	s1,20(sp)
a000a424:	afb00010 	sw	s0,16(sp)
	#define HS0_DRF_FAIL4    0xb80002bc
	#define HS0_DRF_FAIL5    0xb80002c0
	#define HS0_DRF_FAIL6    0xb80002c4


	printf( "========================\n");
a000a428:	3c13a001 	lui	s3,0xa001
a000a42c:	0c002325 	jal	a0008c94 <dprintf>
a000a430:	26645934 	addiu	a0,s3,22836
	printf( "Mode 1 BIST : cpu1 mbr \n");
a000a434:	3c04a001 	lui	a0,0xa001
a000a438:	0c002325 	jal	a0008c94 <dprintf>
a000a43c:	24845950 	addiu	a0,a0,22864
	REG32(HS0_BIST_CTRL) = 0;
a000a440:	3c10b800 	lui	s0,0xb800
a000a444:	36110208 	ori	s1,s0,0x208
a000a448:	ae200000 	sw	zero,0(s1)
		printf( "W:HS0_BIST_CTRL=%08x \n", REG32(HS0_BIST_CTRL) );
a000a44c:	8e250000 	lw	a1,0(s1)
a000a450:	3c12a001 	lui	s2,0xa001
a000a454:	0c002325 	jal	a0008c94 <dprintf>
a000a458:	2644596c 	addiu	a0,s2,22892

#if 0		
	REG32(HS0_BIST_CTRL) |=  (0x7f);
#else
	REG32(HS0_BIST_CTRL) |=  (0x7c);  //skip mbr0, mbr1
a000a45c:	8e220000 	lw	v0,0(s1)
a000a460:	3442007c 	ori	v0,v0,0x7c
a000a464:	ae220000 	sw	v0,0(s1)
#endif
		printf( "W:HS0_BIST_CTRL=%08x \n", REG32(HS0_BIST_CTRL) );
a000a468:	8e250000 	lw	a1,0(s1)
a000a46c:	0c002325 	jal	a0008c94 <dprintf>
a000a470:	2644596c 	addiu	a0,s2,22892
	
	REG32(HS0_BIST_CTRL2) = 0;
a000a474:	3611020c 	ori	s1,s0,0x20c
a000a478:	ae200000 	sw	zero,0(s1)
		printf( "W:HS0_BIST_CTRL2=%08x \n", REG32(HS0_BIST_CTRL2) );
a000a47c:	8e250000 	lw	a1,0(s1)
a000a480:	3c12a001 	lui	s2,0xa001
a000a484:	0c002325 	jal	a0008c94 <dprintf>
a000a488:	26445984 	addiu	a0,s2,22916
		
	REG32(HS0_BIST_CTRL2) |=  (0x1e0103ff);
a000a48c:	8e230000 	lw	v1,0(s1)
a000a490:	3c021e01 	lui	v0,0x1e01
a000a494:	344203ff 	ori	v0,v0,0x3ff
a000a498:	00621025 	or	v0,v1,v0
a000a49c:	ae220000 	sw	v0,0(s1)
		printf( "W:HS0_BIST_CTRL2=%08x \n", REG32(HS0_BIST_CTRL2) );
a000a4a0:	8e250000 	lw	a1,0(s1)
a000a4a4:	0c002325 	jal	a0008c94 <dprintf>
a000a4a8:	26445984 	addiu	a0,s2,22916
	

	delay_ms(10);
a000a4ac:	0c002219 	jal	a0008864 <delay_ms>
a000a4b0:	2404000a 	li	a0,10

	printf( "\n");
a000a4b4:	3c04a001 	lui	a0,0xa001
a000a4b8:	0c002325 	jal	a0008c94 <dprintf>
a000a4bc:	248457b8 	addiu	a0,a0,22456
	printf( "R:HS0_BIST DONE=%08x \n",  REG32(HS0_BIST_DONE) );
a000a4c0:	36110218 	ori	s1,s0,0x218
a000a4c4:	8e250000 	lw	a1,0(s1)
a000a4c8:	3c04a001 	lui	a0,0xa001
a000a4cc:	0c002325 	jal	a0008c94 <dprintf>
a000a4d0:	2484599c 	addiu	a0,a0,22940
	printf( "R:HS0_BIST FAIL1=%08x \n", REG32(HS0_BIST_FAIL1) );
a000a4d4:	36020230 	ori	v0,s0,0x230
a000a4d8:	8c450000 	lw	a1,0(v0)
a000a4dc:	3c04a001 	lui	a0,0xa001
a000a4e0:	0c002325 	jal	a0008c94 <dprintf>
a000a4e4:	248459b4 	addiu	a0,a0,22964
	printf( "R:HS0_BIST FAIL2=%08x \n", REG32(HS0_BIST_FAIL2) );
a000a4e8:	36020234 	ori	v0,s0,0x234
a000a4ec:	8c450000 	lw	a1,0(v0)
a000a4f0:	3c04a001 	lui	a0,0xa001
a000a4f4:	0c002325 	jal	a0008c94 <dprintf>
a000a4f8:	248459cc 	addiu	a0,a0,22988
	printf( "R:HS0_BIST FAIL3=%08x \n", REG32(HS0_BIST_FAIL3) );
a000a4fc:	36020238 	ori	v0,s0,0x238
a000a500:	8c450000 	lw	a1,0(v0)
a000a504:	3c04a001 	lui	a0,0xa001
a000a508:	0c002325 	jal	a0008c94 <dprintf>
a000a50c:	248459e4 	addiu	a0,a0,23012
	printf( "R:HS0_BIST FAIL4=%08x \n", REG32(HS0_BIST_FAIL4) );
a000a510:	3602023c 	ori	v0,s0,0x23c
a000a514:	8c450000 	lw	a1,0(v0)
a000a518:	3c04a001 	lui	a0,0xa001
a000a51c:	0c002325 	jal	a0008c94 <dprintf>
a000a520:	248459fc 	addiu	a0,a0,23036
	printf( "R:HS0_BIST FAIL5=%08x \n", REG32(HS0_BIST_FAIL5) );
a000a524:	36020240 	ori	v0,s0,0x240
a000a528:	8c450000 	lw	a1,0(v0)
a000a52c:	3c04a001 	lui	a0,0xa001
a000a530:	0c002325 	jal	a0008c94 <dprintf>
a000a534:	24845a14 	addiu	a0,a0,23060
		  (REG32(HS0_BIST_FAIL5)==0)  )
		  { printf( " ==>BIST PASS \n"); }	 
#endif		
	//============================================
	
	printf( "========================\n");
a000a538:	0c002325 	jal	a0008c94 <dprintf>
a000a53c:	26645934 	addiu	a0,s3,22836
	printf( "Mode 2 BIST : L2,SRAM,ROM,CPU2 \n");
a000a540:	3c04a001 	lui	a0,0xa001
a000a544:	0c002325 	jal	a0008c94 <dprintf>
a000a548:	24845a2c 	addiu	a0,a0,23084

	printf( "R:HS0_BIST FAIL6=%08x \n", REG32(HS0_BIST_FAIL6));
a000a54c:	36100244 	ori	s0,s0,0x244
a000a550:	8e050000 	lw	a1,0(s0)
a000a554:	3c04a001 	lui	a0,0xa001
a000a558:	0c002325 	jal	a0008c94 <dprintf>
a000a55c:	24845a50 	addiu	a0,a0,23120

	if ( (REG32(HS0_BIST_DONE)&(0x79<<10)) != (0x79<<10)) { printf( " ==>DONE FAIL \n"); }	
a000a560:	8e230000 	lw	v1,0(s1)
a000a564:	3c020001 	lui	v0,0x1
a000a568:	3442e400 	ori	v0,v0,0xe400
a000a56c:	00621824 	and	v1,v1,v0
a000a570:	10620005 	beq	v1,v0,a000a588 <Cmd_AllBistTest+0x184>
a000a574:	3c02b800 	lui	v0,0xb800
a000a578:	3c04a001 	lui	a0,0xa001
a000a57c:	0c002325 	jal	a0008c94 <dprintf>
a000a580:	24845a68 	addiu	a0,a0,23144
	if (  REG32(HS0_BIST_FAIL6) != 0) { printf( " ==>FAIL FAIL \n"); }	
a000a584:	3c02b800 	lui	v0,0xb800
a000a588:	34420244 	ori	v0,v0,0x244
a000a58c:	8c420000 	lw	v0,0(v0)
a000a590:	10400005 	beqz	v0,a000a5a8 <Cmd_AllBistTest+0x1a4>
a000a594:	3c02b800 	lui	v0,0xb800
a000a598:	3c04a001 	lui	a0,0xa001
a000a59c:	0c002325 	jal	a0008c94 <dprintf>
a000a5a0:	24845a78 	addiu	a0,a0,23160

	if ((( REG32(HS0_BIST_DONE)&(0x79<<10)) == (0x79<<10)) && 
a000a5a4:	3c02b800 	lui	v0,0xb800
a000a5a8:	34420218 	ori	v0,v0,0x218
a000a5ac:	8c430000 	lw	v1,0(v0)
a000a5b0:	3c020001 	lui	v0,0x1
a000a5b4:	3442e400 	ori	v0,v0,0xe400
a000a5b8:	00621824 	and	v1,v1,v0
a000a5bc:	1462000a 	bne	v1,v0,a000a5e8 <Cmd_AllBistTest+0x1e4>
a000a5c0:	3c02b800 	lui	v0,0xb800
		 ( REG32(HS0_BIST_FAIL6) == 0) )
a000a5c4:	34420244 	ori	v0,v0,0x244
a000a5c8:	8c420000 	lw	v0,0(v0)
	printf( "R:HS0_BIST FAIL6=%08x \n", REG32(HS0_BIST_FAIL6));

	if ( (REG32(HS0_BIST_DONE)&(0x79<<10)) != (0x79<<10)) { printf( " ==>DONE FAIL \n"); }	
	if (  REG32(HS0_BIST_FAIL6) != 0) { printf( " ==>FAIL FAIL \n"); }	

	if ((( REG32(HS0_BIST_DONE)&(0x79<<10)) == (0x79<<10)) && 
a000a5cc:	14400006 	bnez	v0,a000a5e8 <Cmd_AllBistTest+0x1e4>
a000a5d0:	00000000 	nop
		 ( REG32(HS0_BIST_FAIL6) == 0) )
	{ printf( " ==>BIST PASS \n"); }
a000a5d4:	3c04a001 	lui	a0,0xa001
a000a5d8:	0c002325 	jal	a0008c94 <dprintf>
a000a5dc:	24845a88 	addiu	a0,a0,23176
	printf( "R:HS0_BIST FAIL6=%08x \n", REG32(HS0_BIST_FAIL6));

	if ( (REG32(HS0_BIST_DONE)&(0x79<<10)) != (0x79<<10)) { printf( " ==>DONE FAIL \n"); }	
	if (  REG32(HS0_BIST_FAIL6) != 0) { printf( " ==>FAIL FAIL \n"); }	

	if ((( REG32(HS0_BIST_DONE)&(0x79<<10)) == (0x79<<10)) && 
a000a5e0:	0800297e 	j	a000a5f8 <Cmd_AllBistTest+0x1f4>
a000a5e4:	00008821 	move	s1,zero
		 ( REG32(HS0_BIST_FAIL6) == 0) )
	{ printf( " ==>BIST PASS \n"); }
	else
	{ printf( " ==>BIST FAIL \n"); err++; }		
a000a5e8:	3c04a001 	lui	a0,0xa001
a000a5ec:	0c002325 	jal	a0008c94 <dprintf>
a000a5f0:	24845a98 	addiu	a0,a0,23192
a000a5f4:	24110001 	li	s1,1
	//============================================
	printf( "========================\n");
a000a5f8:	3c04a001 	lui	a0,0xa001
a000a5fc:	0c002325 	jal	a0008c94 <dprintf>
a000a600:	24845934 	addiu	a0,a0,22836
	printf( "Mode 3 BIST : NAND,FFT,SATA, PCS ROM, PCS RAM, USB3, OTG, PCIE(ep10),VOIP\n");
a000a604:	3c04a001 	lui	a0,0xa001
a000a608:	0c002325 	jal	a0008c94 <dprintf>
a000a60c:	24845aa8 	addiu	a0,a0,23208
	REG32(BIST_CTRL) = 0;
a000a610:	3c13b800 	lui	s3,0xb800
a000a614:	36700200 	ori	s0,s3,0x200
a000a618:	ae000000 	sw	zero,0(s0)
		printf( "W:BIST_CTRL=%08x \n", REG32(BIST_CTRL));
a000a61c:	8e050000 	lw	a1,0(s0)
a000a620:	3c12a001 	lui	s2,0xa001
a000a624:	0c002325 	jal	a0008c94 <dprintf>
a000a628:	26445af4 	addiu	a0,s2,23284
			
	REG32(BIST_CTRL) |=  (0x01);
a000a62c:	8e020000 	lw	v0,0(s0)
a000a630:	34420001 	ori	v0,v0,0x1
a000a634:	ae020000 	sw	v0,0(s0)
		printf( "W:BIST_CTRL=%08x \n", REG32(BIST_CTRL));
a000a638:	8e050000 	lw	a1,0(s0)
a000a63c:	0c002325 	jal	a0008c94 <dprintf>
a000a640:	26445af4 	addiu	a0,s2,23284

	REG32(BIST_CTRL) |= (0x03ff0001);
a000a644:	8e030000 	lw	v1,0(s0)
a000a648:	3c0203ff 	lui	v0,0x3ff
a000a64c:	34420001 	ori	v0,v0,0x1
a000a650:	00621025 	or	v0,v1,v0
a000a654:	ae020000 	sw	v0,0(s0)
		printf( "W:BIST_CTRL=%08x \n", REG32(BIST_CTRL   )); 
a000a658:	8e050000 	lw	a1,0(s0)
a000a65c:	0c002325 	jal	a0008c94 <dprintf>
a000a660:	26445af4 	addiu	a0,s2,23284

	delay_ms(10);
a000a664:	0c002219 	jal	a0008864 <delay_ms>
a000a668:	2404000a 	li	a0,10
	printf( "\n");
a000a66c:	3c04a001 	lui	a0,0xa001
a000a670:	0c002325 	jal	a0008c94 <dprintf>
a000a674:	248457b8 	addiu	a0,a0,22456
	printf( "R:BIST DONE=%08x \n", REG32(BIST_DONE));
a000a678:	36700210 	ori	s0,s3,0x210
a000a67c:	8e050000 	lw	a1,0(s0)
a000a680:	3c04a001 	lui	a0,0xa001
a000a684:	0c002325 	jal	a0008c94 <dprintf>
a000a688:	24845b08 	addiu	a0,a0,23304
	printf( "R:BIST FAIL=%08x \n", REG32(BIST_FAIL));
a000a68c:	36730220 	ori	s3,s3,0x220
a000a690:	8e650000 	lw	a1,0(s3)
a000a694:	3c04a001 	lui	a0,0xa001
a000a698:	0c002325 	jal	a0008c94 <dprintf>
a000a69c:	24845b1c 	addiu	a0,a0,23324


	
	if ( (REG32(BIST_DONE) == 0xffff3fff) && 
a000a6a0:	8e030000 	lw	v1,0(s0)
a000a6a4:	3c02ffff 	lui	v0,0xffff
a000a6a8:	34423fff 	ori	v0,v0,0x3fff
a000a6ac:	14620009 	bne	v1,v0,a000a6d4 <Cmd_AllBistTest+0x2d0>
a000a6b0:	00000000 	nop
		( REG32(BIST_FAIL) == 0x00000000)) { printf( " ==>BIST PASS \n"); }	 
a000a6b4:	8e620000 	lw	v0,0(s3)
	printf( "R:BIST DONE=%08x \n", REG32(BIST_DONE));
	printf( "R:BIST FAIL=%08x \n", REG32(BIST_FAIL));


	
	if ( (REG32(BIST_DONE) == 0xffff3fff) && 
a000a6b8:	14400006 	bnez	v0,a000a6d4 <Cmd_AllBistTest+0x2d0>
a000a6bc:	00000000 	nop
		( REG32(BIST_FAIL) == 0x00000000)) { printf( " ==>BIST PASS \n"); }	 
a000a6c0:	3c04a001 	lui	a0,0xa001
a000a6c4:	0c002325 	jal	a0008c94 <dprintf>
a000a6c8:	24845a88 	addiu	a0,a0,23176
	printf( "R:BIST DONE=%08x \n", REG32(BIST_DONE));
	printf( "R:BIST FAIL=%08x \n", REG32(BIST_FAIL));


	
	if ( (REG32(BIST_DONE) == 0xffff3fff) && 
a000a6cc:	080029cc 	j	a000a730 <Cmd_AllBistTest+0x32c>
a000a6d0:	3c04a001 	lui	a0,0xa001
		( REG32(BIST_FAIL) == 0x00000000)) { printf( " ==>BIST PASS \n"); }	 
	else 								   
	{ 	printf( " ==>BIST FAIL \n"); err++;
a000a6d4:	3c04a001 	lui	a0,0xa001
a000a6d8:	0c002325 	jal	a0008c94 <dprintf>
a000a6dc:	24845a98 	addiu	a0,a0,23192
a000a6e0:	26310001 	addiu	s1,s1,1
		if ( REG32(BIST_DONE) != 0xffff3fff) { printf( " ==>DONE FAIL \n"); }
a000a6e4:	3c02b800 	lui	v0,0xb800
a000a6e8:	34420210 	ori	v0,v0,0x210
a000a6ec:	8c430000 	lw	v1,0(v0)
a000a6f0:	3c02ffff 	lui	v0,0xffff
a000a6f4:	34423fff 	ori	v0,v0,0x3fff
a000a6f8:	10620005 	beq	v1,v0,a000a710 <Cmd_AllBistTest+0x30c>
a000a6fc:	3c02b800 	lui	v0,0xb800
a000a700:	3c04a001 	lui	a0,0xa001
a000a704:	0c002325 	jal	a0008c94 <dprintf>
a000a708:	24845a68 	addiu	a0,a0,23144
		if ( REG32(BIST_FAIL) != 0x00000000) { printf( " ==>FAIL FAIL \n"); }	
a000a70c:	3c02b800 	lui	v0,0xb800
a000a710:	34420220 	ori	v0,v0,0x220
a000a714:	8c420000 	lw	v0,0(v0)
a000a718:	10400004 	beqz	v0,a000a72c <Cmd_AllBistTest+0x328>
a000a71c:	00000000 	nop
a000a720:	3c04a001 	lui	a0,0xa001
a000a724:	0c002325 	jal	a0008c94 <dprintf>
a000a728:	24845a78 	addiu	a0,a0,23160
	}	
		
	//============================================
	printf( "============================== \n");
a000a72c:	3c04a001 	lui	a0,0xa001
a000a730:	0c002325 	jal	a0008c94 <dprintf>
a000a734:	24845b30 	addiu	a0,a0,23344
	printf( "Mode 4 BIST :switch\n");
a000a738:	3c04a001 	lui	a0,0xa001
a000a73c:	0c002325 	jal	a0008c94 <dprintf>
a000a740:	24845b54 	addiu	a0,a0,23380
	REG32(BIST_CTRL) = 0;
a000a744:	3c13b800 	lui	s3,0xb800
a000a748:	36700200 	ori	s0,s3,0x200
a000a74c:	ae000000 	sw	zero,0(s0)
		printf( "W:BIST_CTRL=%08x \n", REG32(BIST_CTRL) );	
a000a750:	8e050000 	lw	a1,0(s0)
a000a754:	3c12a001 	lui	s2,0xa001
a000a758:	0c002325 	jal	a0008c94 <dprintf>
a000a75c:	26445af4 	addiu	a0,s2,23284
	REG32(BIST_CTRL) |=  (0x01);
a000a760:	8e020000 	lw	v0,0(s0)
a000a764:	34420001 	ori	v0,v0,0x1
a000a768:	ae020000 	sw	v0,0(s0)
		printf( "W:BIST_CTRL=%08x \n", REG32(BIST_CTRL) );
a000a76c:	8e050000 	lw	a1,0(s0)
a000a770:	0c002325 	jal	a0008c94 <dprintf>
a000a774:	26445af4 	addiu	a0,s2,23284
	REG32(BIST_CTRL) |=  (1<<26);
a000a778:	8e030000 	lw	v1,0(s0)
a000a77c:	3c020400 	lui	v0,0x400
a000a780:	00621025 	or	v0,v1,v0
a000a784:	ae020000 	sw	v0,0(s0)
		printf( "W:BIST_CTRL=%08x \n", REG32(BIST_CTRL) );
a000a788:	8e050000 	lw	a1,0(s0)
a000a78c:	0c002325 	jal	a0008c94 <dprintf>
a000a790:	26445af4 	addiu	a0,s2,23284
	    
	delay_ms(10);  
a000a794:	0c002219 	jal	a0008864 <delay_ms>
a000a798:	2404000a 	li	a0,10
	printf( "\n");
a000a79c:	3c04a001 	lui	a0,0xa001
a000a7a0:	0c002325 	jal	a0008c94 <dprintf>
a000a7a4:	248457b8 	addiu	a0,a0,22456
	printf( "R:BIST DONE=%08x \n", REG32(BIST_DONE));
a000a7a8:	36700210 	ori	s0,s3,0x210
a000a7ac:	8e050000 	lw	a1,0(s0)
a000a7b0:	3c04a001 	lui	a0,0xa001
a000a7b4:	0c002325 	jal	a0008c94 <dprintf>
a000a7b8:	24845b08 	addiu	a0,a0,23304
	printf( "R:BIST FAIL=%08x \n", REG32(BIST_FAIL));
a000a7bc:	36730220 	ori	s3,s3,0x220
a000a7c0:	8e650000 	lw	a1,0(s3)
a000a7c4:	3c04a001 	lui	a0,0xa001
a000a7c8:	0c002325 	jal	a0008c94 <dprintf>
a000a7cc:	24845b1c 	addiu	a0,a0,23324


	
	if ( (REG32(BIST_DONE) == 0xffff4418) && 
a000a7d0:	8e030000 	lw	v1,0(s0)
a000a7d4:	3c02ffff 	lui	v0,0xffff
a000a7d8:	34424418 	ori	v0,v0,0x4418
a000a7dc:	14620009 	bne	v1,v0,a000a804 <Cmd_AllBistTest+0x400>
a000a7e0:	00000000 	nop
		( REG32(BIST_FAIL) == 0x00000000)) { printf( " ==>BIST PASS \n"); }	 
a000a7e4:	8e620000 	lw	v0,0(s3)
	printf( "R:BIST DONE=%08x \n", REG32(BIST_DONE));
	printf( "R:BIST FAIL=%08x \n", REG32(BIST_FAIL));


	
	if ( (REG32(BIST_DONE) == 0xffff4418) && 
a000a7e8:	14400006 	bnez	v0,a000a804 <Cmd_AllBistTest+0x400>
a000a7ec:	00000000 	nop
		( REG32(BIST_FAIL) == 0x00000000)) { printf( " ==>BIST PASS \n"); }	 
a000a7f0:	3c04a001 	lui	a0,0xa001
a000a7f4:	0c002325 	jal	a0008c94 <dprintf>
a000a7f8:	24845a88 	addiu	a0,a0,23176
	printf( "R:BIST DONE=%08x \n", REG32(BIST_DONE));
	printf( "R:BIST FAIL=%08x \n", REG32(BIST_FAIL));


	
	if ( (REG32(BIST_DONE) == 0xffff4418) && 
a000a7fc:	08002a18 	j	a000a860 <Cmd_AllBistTest+0x45c>
a000a800:	3c04a001 	lui	a0,0xa001
		( REG32(BIST_FAIL) == 0x00000000)) { printf( " ==>BIST PASS \n"); }	 
	else								   
	{ 	printf( " ==>BIST FAIL \n"); err++;
a000a804:	3c04a001 	lui	a0,0xa001
a000a808:	0c002325 	jal	a0008c94 <dprintf>
a000a80c:	24845a98 	addiu	a0,a0,23192
a000a810:	26310001 	addiu	s1,s1,1
		if ( REG32(BIST_DONE) != 0xffff4418) { printf( " ==>DONE FAIL \n"); }
a000a814:	3c02b800 	lui	v0,0xb800
a000a818:	34420210 	ori	v0,v0,0x210
a000a81c:	8c430000 	lw	v1,0(v0)
a000a820:	3c02ffff 	lui	v0,0xffff
a000a824:	34424418 	ori	v0,v0,0x4418
a000a828:	10620005 	beq	v1,v0,a000a840 <Cmd_AllBistTest+0x43c>
a000a82c:	3c02b800 	lui	v0,0xb800
a000a830:	3c04a001 	lui	a0,0xa001
a000a834:	0c002325 	jal	a0008c94 <dprintf>
a000a838:	24845a68 	addiu	a0,a0,23144
		if ( REG32(BIST_FAIL) != 0x00000000) { printf( " ==>FAIL FAIL \n"); }	
a000a83c:	3c02b800 	lui	v0,0xb800
a000a840:	34420220 	ori	v0,v0,0x220
a000a844:	8c420000 	lw	v0,0(v0)
a000a848:	10400004 	beqz	v0,a000a85c <Cmd_AllBistTest+0x458>
a000a84c:	00000000 	nop
a000a850:	3c04a001 	lui	a0,0xa001
a000a854:	0c002325 	jal	a0008c94 <dprintf>
a000a858:	24845a78 	addiu	a0,a0,23160
	}	 
	//============================================
	printf( "============================== \n");
a000a85c:	3c04a001 	lui	a0,0xa001
a000a860:	0c002325 	jal	a0008c94 <dprintf>
a000a864:	24845b30 	addiu	a0,a0,23344
	printf( "Mode 5 BIST :switch bist-r \n");
a000a868:	3c04a001 	lui	a0,0xa001
a000a86c:	0c002325 	jal	a0008c94 <dprintf>
a000a870:	24845b6c 	addiu	a0,a0,23404
	REG32(BIST_CTRL) = 0;
a000a874:	3c13b800 	lui	s3,0xb800
a000a878:	36700200 	ori	s0,s3,0x200
a000a87c:	ae000000 	sw	zero,0(s0)
		printf( "W:BIST_CTRL=%08x \n", REG32(BIST_CTRL) );		
a000a880:	8e050000 	lw	a1,0(s0)
a000a884:	3c12a001 	lui	s2,0xa001
a000a888:	0c002325 	jal	a0008c94 <dprintf>
a000a88c:	26445af4 	addiu	a0,s2,23284
	REG32(BIST_CTRL) |=  (0x01);
a000a890:	8e020000 	lw	v0,0(s0)
a000a894:	34420001 	ori	v0,v0,0x1
a000a898:	ae020000 	sw	v0,0(s0)
		printf( "W:BIST_CTRL=%08x \n", REG32(BIST_CTRL) );
a000a89c:	8e050000 	lw	a1,0(s0)
a000a8a0:	0c002325 	jal	a0008c94 <dprintf>
a000a8a4:	26445af4 	addiu	a0,s2,23284
	REG32(BIST_CTRL) |= (1<<27);
a000a8a8:	8e030000 	lw	v1,0(s0)
a000a8ac:	3c020800 	lui	v0,0x800
a000a8b0:	00621025 	or	v0,v1,v0
a000a8b4:	ae020000 	sw	v0,0(s0)
		printf( "W:BIST_CTRL=%08x \n", REG32(BIST_CTRL) );
a000a8b8:	8e050000 	lw	a1,0(s0)
a000a8bc:	0c002325 	jal	a0008c94 <dprintf>
a000a8c0:	26445af4 	addiu	a0,s2,23284
	    
	delay_ms(10);   
a000a8c4:	0c002219 	jal	a0008864 <delay_ms>
a000a8c8:	2404000a 	li	a0,10
	printf( "\n");
a000a8cc:	3c04a001 	lui	a0,0xa001
a000a8d0:	0c002325 	jal	a0008c94 <dprintf>
a000a8d4:	248457b8 	addiu	a0,a0,22456
	printf( "R:BIST DONE=%08x \n", REG32(BIST_DONE) );
a000a8d8:	36700210 	ori	s0,s3,0x210
a000a8dc:	8e050000 	lw	a1,0(s0)
a000a8e0:	3c04a001 	lui	a0,0xa001
a000a8e4:	0c002325 	jal	a0008c94 <dprintf>
a000a8e8:	24845b08 	addiu	a0,a0,23304
	printf( "R:BIST FAIL=%08x \n", REG32(BIST_FAIL) );
a000a8ec:	36730220 	ori	s3,s3,0x220
a000a8f0:	8e650000 	lw	a1,0(s3)
a000a8f4:	3c04a001 	lui	a0,0xa001
a000a8f8:	0c002325 	jal	a0008c94 <dprintf>
a000a8fc:	24845b1c 	addiu	a0,a0,23324


	
	if ( (REG32(BIST_DONE) == 0xffff8418) && ( REG32(BIST_FAIL) == 0x00000000)) { printf( " ==>BIST PASS \n"); }	 
a000a900:	8e030000 	lw	v1,0(s0)
a000a904:	24028418 	li	v0,-31720
a000a908:	14620009 	bne	v1,v0,a000a930 <Cmd_AllBistTest+0x52c>
a000a90c:	00000000 	nop
a000a910:	8e620000 	lw	v0,0(s3)
a000a914:	14400006 	bnez	v0,a000a930 <Cmd_AllBistTest+0x52c>
a000a918:	00000000 	nop
a000a91c:	3c04a001 	lui	a0,0xa001
a000a920:	0c002325 	jal	a0008c94 <dprintf>
a000a924:	24845a88 	addiu	a0,a0,23176
a000a928:	08002a62 	j	a000a988 <Cmd_AllBistTest+0x584>
a000a92c:	3c04a001 	lui	a0,0xa001
	else 							
	{ 	printf( " ==>BIST FAIL \n");  err++;
a000a930:	3c04a001 	lui	a0,0xa001
a000a934:	0c002325 	jal	a0008c94 <dprintf>
a000a938:	24845a98 	addiu	a0,a0,23192
a000a93c:	26310001 	addiu	s1,s1,1
		if ( REG32(BIST_DONE) != 0xffff8418) { printf( " ==>DONE FAIL \n"); }
a000a940:	3c02b800 	lui	v0,0xb800
a000a944:	34420210 	ori	v0,v0,0x210
a000a948:	8c430000 	lw	v1,0(v0)
a000a94c:	24028418 	li	v0,-31720
a000a950:	10620005 	beq	v1,v0,a000a968 <Cmd_AllBistTest+0x564>
a000a954:	3c02b800 	lui	v0,0xb800
a000a958:	3c04a001 	lui	a0,0xa001
a000a95c:	0c002325 	jal	a0008c94 <dprintf>
a000a960:	24845a68 	addiu	a0,a0,23144
		if ( REG32(BIST_FAIL) != 0x00000000) { printf( " ==>FAIL FAIL \n"); }	
a000a964:	3c02b800 	lui	v0,0xb800
a000a968:	34420220 	ori	v0,v0,0x220
a000a96c:	8c420000 	lw	v0,0(v0)
a000a970:	10400004 	beqz	v0,a000a984 <Cmd_AllBistTest+0x580>
a000a974:	00000000 	nop
a000a978:	3c04a001 	lui	a0,0xa001
a000a97c:	0c002325 	jal	a0008c94 <dprintf>
a000a980:	24845a78 	addiu	a0,a0,23160
		{ printf( " ==>DRF PASS \n"); }	 
	printf( "============================== \n");	    
#endif
		
		
	printf( "============================== \n");
a000a984:	3c04a001 	lui	a0,0xa001
a000a988:	0c002325 	jal	a0008c94 <dprintf>
a000a98c:	24845b30 	addiu	a0,a0,23344
	printf( "Mode x DRF_BIST TEST : IP \n");
a000a990:	3c04a001 	lui	a0,0xa001
a000a994:	0c002325 	jal	a0008c94 <dprintf>
a000a998:	24845b8c 	addiu	a0,a0,23436
	REG32( 0xb800020c)=0x001e0000;
a000a99c:	3c10b800 	lui	s0,0xb800
a000a9a0:	3602020c 	ori	v0,s0,0x20c
a000a9a4:	3c03001e 	lui	v1,0x1e
a000a9a8:	ac430000 	sw	v1,0(v0)
	REG32( 0xb8000200)=0x00000002;
a000a9ac:	36020200 	ori	v0,s0,0x200
a000a9b0:	24030002 	li	v1,2
a000a9b4:	ac430000 	sw	v1,0(v0)
//	REG32( 0xb8000208)=0x007f007f;   //skip mbr
	//
	REG32( 0xb8000200)=0x0fff0002;
a000a9b8:	3c030fff 	lui	v1,0xfff
a000a9bc:	34630002 	ori	v1,v1,0x2
a000a9c0:	ac430000 	sw	v1,0(v0)


	printf( "4.pause\n");    
a000a9c4:	3c04a001 	lui	a0,0xa001
a000a9c8:	0c002325 	jal	a0008c94 <dprintf>
a000a9cc:	24845ba8 	addiu	a0,a0,23464
	printf( " R:DRF_PAUSE=%08x \n", REG32(DRF_PAUSE    ));
a000a9d0:	36140270 	ori	s4,s0,0x270
a000a9d4:	8e850000 	lw	a1,0(s4)
a000a9d8:	3c15a001 	lui	s5,0xa001
a000a9dc:	0c002325 	jal	a0008c94 <dprintf>
a000a9e0:	26a45bb4 	addiu	a0,s5,23476
	if ( REG32(HS0_DRF_PAUSE) == 0xffffffff) { printf( " ==>PAUSE PASS \n"); }
	if ( REG32(HS0_DRF_PAUSE) != 0xffffffff) { printf( " ==>PAUSE FAIL \n"); }
#endif


	printf( "5.resume\n");   
a000a9e4:	3c04a001 	lui	a0,0xa001
a000a9e8:	0c002325 	jal	a0008c94 <dprintf>
a000a9ec:	24845bc8 	addiu	a0,a0,23496
	REG32(DRF_RESUME) = 0xffffffff;
a000a9f0:	36120280 	ori	s2,s0,0x280
a000a9f4:	2413ffff 	li	s3,-1
a000a9f8:	ae530000 	sw	s3,0(s2)
		printf( " W:DRF_RESUME=%08x \n", REG32(DRF_RESUME) );    
a000a9fc:	8e450000 	lw	a1,0(s2)
a000aa00:	3c16a001 	lui	s6,0xa001
a000aa04:	0c002325 	jal	a0008c94 <dprintf>
a000aa08:	26c45bd4 	addiu	a0,s6,23508

	printf( "6.two pause\n");      
a000aa0c:	3c04a001 	lui	a0,0xa001
a000aa10:	0c002325 	jal	a0008c94 <dprintf>
a000aa14:	24845bec 	addiu	a0,a0,23532
	printf( " R:DRF_PAUSE=%08x \n", REG32(DRF_PAUSE) );    
a000aa18:	8e850000 	lw	a1,0(s4)
a000aa1c:	0c002325 	jal	a0008c94 <dprintf>
a000aa20:	26a45bb4 	addiu	a0,s5,23476
#if 0 //skip mbr	 
	printf( " R:HS0_DRF_PAUSE=%08x \n", REG32(HS0_DRF_PAUSE ));
	if ( REG32(HS0_DRF_PAUSE) == 0xffffffff) { printf( " ==>PAUSE PASS \n"); }
	if ( REG32(HS0_DRF_PAUSE) != 0xffffffff) { printf( " ==>PAUSE FAIL \n"); }
#endif	    
	printf( "7.two resume\n");    
a000aa24:	3c04a001 	lui	a0,0xa001
a000aa28:	0c002325 	jal	a0008c94 <dprintf>
a000aa2c:	24845bfc 	addiu	a0,a0,23548
	REG32(DRF_RESUME) = 0xffffffff;
a000aa30:	ae530000 	sw	s3,0(s2)
		printf( " W:DRF_RESUME=%08x \n", REG32(DRF_RESUME ) ); 
a000aa34:	8e450000 	lw	a1,0(s2)
a000aa38:	0c002325 	jal	a0008c94 <dprintf>
a000aa3c:	26c45bd4 	addiu	a0,s6,23508
	  
	printf( " R:DRF_DONE=%08x \n", REG32(DRF_DONE) );
a000aa40:	36120290 	ori	s2,s0,0x290
a000aa44:	8e450000 	lw	a1,0(s2)
a000aa48:	3c04a001 	lui	a0,0xa001
a000aa4c:	0c002325 	jal	a0008c94 <dprintf>
a000aa50:	24845c0c 	addiu	a0,a0,23564
	printf( " R:DRF_FAIL=%08x \n", REG32(DRF_FAIL) );
a000aa54:	361002a0 	ori	s0,s0,0x2a0
a000aa58:	8e050000 	lw	a1,0(s0)
a000aa5c:	3c04a001 	lui	a0,0xa001
a000aa60:	0c002325 	jal	a0008c94 <dprintf>
a000aa64:	24845c20 	addiu	a0,a0,23584



	if ( (REG32(DRF_DONE)==0xffffffff) &&( REG32(DRF_FAIL)==0) ) 
a000aa68:	8e420000 	lw	v0,0(s2)
a000aa6c:	14530009 	bne	v0,s3,a000aa94 <Cmd_AllBistTest+0x690>
a000aa70:	00000000 	nop
a000aa74:	8e020000 	lw	v0,0(s0)
a000aa78:	14400006 	bnez	v0,a000aa94 <Cmd_AllBistTest+0x690>
a000aa7c:	00000000 	nop
		{ printf( " ==>DRF PASS \n"); }	 
a000aa80:	3c04a001 	lui	a0,0xa001
a000aa84:	0c002325 	jal	a0008c94 <dprintf>
a000aa88:	24845c34 	addiu	a0,a0,23604
	printf( " R:DRF_DONE=%08x \n", REG32(DRF_DONE) );
	printf( " R:DRF_FAIL=%08x \n", REG32(DRF_FAIL) );



	if ( (REG32(DRF_DONE)==0xffffffff) &&( REG32(DRF_FAIL)==0) ) 
a000aa8c:	08002aba 	j	a000aae8 <Cmd_AllBistTest+0x6e4>
a000aa90:	00000000 	nop
		{ printf( " ==>DRF PASS \n"); }	 
	else	
	{ 
		printf( " ==>DRF FAIL \n");  err++;
a000aa94:	3c04a001 	lui	a0,0xa001
a000aa98:	0c002325 	jal	a0008c94 <dprintf>
a000aa9c:	24845c44 	addiu	a0,a0,23620
a000aaa0:	26310001 	addiu	s1,s1,1
		if ( REG32(DRF_DONE) != 0xffffffff) { printf( " ==>DRF DONE FAIL \n"); }	    
a000aaa4:	3c02b800 	lui	v0,0xb800
a000aaa8:	34420290 	ori	v0,v0,0x290
a000aaac:	8c430000 	lw	v1,0(v0)
a000aab0:	2402ffff 	li	v0,-1
a000aab4:	10620005 	beq	v1,v0,a000aacc <Cmd_AllBistTest+0x6c8>
a000aab8:	3c02b800 	lui	v0,0xb800
a000aabc:	3c04a001 	lui	a0,0xa001
a000aac0:	0c002325 	jal	a0008c94 <dprintf>
a000aac4:	24845c54 	addiu	a0,a0,23636
		if ( REG32(DRF_FAIL) != 0) { printf( " ==>FAIL FAIL \n"); }		
a000aac8:	3c02b800 	lui	v0,0xb800
a000aacc:	344202a0 	ori	v0,v0,0x2a0
a000aad0:	8c420000 	lw	v0,0(v0)
a000aad4:	10400004 	beqz	v0,a000aae8 <Cmd_AllBistTest+0x6e4>
a000aad8:	00000000 	nop
a000aadc:	3c04a001 	lui	a0,0xa001
a000aae0:	0c002325 	jal	a0008c94 <dprintf>
a000aae4:	24845a78 	addiu	a0,a0,23160
	}	


	if(err==0)
a000aae8:	16200005 	bnez	s1,a000ab00 <Cmd_AllBistTest+0x6fc>
a000aaec:	3c04a001 	lui	a0,0xa001
		printf("==> IP BIST ALL PASS <== \n");
a000aaf0:	0c002325 	jal	a0008c94 <dprintf>
a000aaf4:	24845c68 	addiu	a0,a0,23656
	else
		printf("==> IP BIST FAIL count=%d <== \n", err);		

}
a000aaf8:	08002ac5 	j	a000ab14 <Cmd_AllBistTest+0x710>
a000aafc:	8fbf002c 	lw	ra,44(sp)


	if(err==0)
		printf("==> IP BIST ALL PASS <== \n");
	else
		printf("==> IP BIST FAIL count=%d <== \n", err);		
a000ab00:	3c04a001 	lui	a0,0xa001
a000ab04:	24845c84 	addiu	a0,a0,23684
a000ab08:	0c002325 	jal	a0008c94 <dprintf>
a000ab0c:	02202821 	move	a1,s1

}
a000ab10:	8fbf002c 	lw	ra,44(sp)
a000ab14:	8fb60028 	lw	s6,40(sp)
a000ab18:	8fb50024 	lw	s5,36(sp)
a000ab1c:	8fb40020 	lw	s4,32(sp)
a000ab20:	8fb3001c 	lw	s3,28(sp)
a000ab24:	8fb20018 	lw	s2,24(sp)
a000ab28:	8fb10014 	lw	s1,20(sp)
a000ab2c:	8fb00010 	lw	s0,16(sp)
a000ab30:	03e00008 	jr	ra
a000ab34:	27bd0030 	addiu	sp,sp,48

a000ab38 <GPHY_DRF_BIST>:
	else
		printf("==> GPHY BIST FAIL count=%d <== \n", err);				
}
//=============================================================================
int GPHY_DRF_BIST(int argc, char* argv[])
{
a000ab38:	27bdffb0 	addiu	sp,sp,-80
a000ab3c:	afbf004c 	sw	ra,76(sp)
a000ab40:	afbe0048 	sw	s8,72(sp)
a000ab44:	afb70044 	sw	s7,68(sp)
a000ab48:	afb60040 	sw	s6,64(sp)
a000ab4c:	afb5003c 	sw	s5,60(sp)
a000ab50:	afb40038 	sw	s4,56(sp)
a000ab54:	afb30034 	sw	s3,52(sp)
a000ab58:	afb20030 	sw	s2,48(sp)
a000ab5c:	afb1002c 	sw	s1,44(sp)
a000ab60:	afb00028 	sw	s0,40(sp)
	volatile unsigned int phyid=4,rdat=0;
a000ab64:	24020004 	li	v0,4
a000ab68:	afa20018 	sw	v0,24(sp)
a000ab6c:	afa0001c 	sw	zero,28(sp)
	int i;
	int err=0;

//	dprintf("Set P0-P4 force mode...... \n");
	REG32(0xbb804104)= 0x427f0038;
a000ab70:	3c02bb80 	lui	v0,0xbb80
a000ab74:	34434104 	ori	v1,v0,0x4104
a000ab78:	3c04427f 	lui	a0,0x427f
a000ab7c:	34840038 	ori	a0,a0,0x38
a000ab80:	ac640000 	sw	a0,0(v1)
	REG32(0xbb804108)= 0x467f0038;
a000ab84:	34434108 	ori	v1,v0,0x4108
a000ab88:	3c04467f 	lui	a0,0x467f
a000ab8c:	34840038 	ori	a0,a0,0x38
a000ab90:	ac640000 	sw	a0,0(v1)
	REG32(0xbb80410c)= 0x4a7f0038;
a000ab94:	3443410c 	ori	v1,v0,0x410c
a000ab98:	3c044a7f 	lui	a0,0x4a7f
a000ab9c:	34840038 	ori	a0,a0,0x38
a000aba0:	ac640000 	sw	a0,0(v1)
	REG32(0xbb804110)= 0x4e7f0038;
a000aba4:	34434110 	ori	v1,v0,0x4110
a000aba8:	3c044e7f 	lui	a0,0x4e7f
a000abac:	34840038 	ori	a0,a0,0x38
a000abb0:	ac640000 	sw	a0,0(v1)
	REG32(0xbb804114)= 0x527f0038;
a000abb4:	34434114 	ori	v1,v0,0x4114
a000abb8:	3c04527f 	lui	a0,0x527f
a000abbc:	34840038 	ori	a0,a0,0x38
a000abc0:	ac640000 	sw	a0,0(v1)
	REG32(0xbb804118)= 0x566f0038;
a000abc4:	34424118 	ori	v0,v0,0x4118
a000abc8:	3c03566f 	lui	v1,0x566f
a000abcc:	34630038 	ori	v1,v1,0x38
a000abd0:	ac430000 	sw	v1,0(v0)
	
//	void Set_GPHYWB(unsigned int phyid, unsigned int page, unsigned int reg, unsigned int mask, unsigned int val)
//	Set_GPHYWB(8, 24, 22, 0, 0x5bd5);
	
		
	Set_GPHYWB(0, 0xc40, 21, 0, 0xc000);
a000abd4:	3410c000 	li	s0,0xc000
a000abd8:	afb00010 	sw	s0,16(sp)
a000abdc:	00002021 	move	a0,zero
a000abe0:	24050c40 	li	a1,3136
a000abe4:	24060015 	li	a2,21
a000abe8:	0c00098a 	jal	a0002628 <Set_GPHYWB>
a000abec:	00003821 	move	a3,zero
	Set_GPHYWB(0, 0xa00, 23, 0, 0xc000);
a000abf0:	afb00010 	sw	s0,16(sp)
a000abf4:	00002021 	move	a0,zero
a000abf8:	24050a00 	li	a1,2560
a000abfc:	24060017 	li	a2,23
a000ac00:	0c00098a 	jal	a0002628 <Set_GPHYWB>
a000ac04:	00003821 	move	a3,zero

	rtl8651_setAsicEthernetPHYReg(0, 23, 0x0120 );		
a000ac08:	00002021 	move	a0,zero
a000ac0c:	24050017 	li	a1,23
a000ac10:	0c000941 	jal	a0002504 <rtl8651_setAsicEthernetPHYReg>
a000ac14:	24060120 	li	a2,288
	
	//
	Set_GPHYWB(0, 0xb81, 18, 0, 0x0000);
a000ac18:	afa00010 	sw	zero,16(sp)
a000ac1c:	00002021 	move	a0,zero
a000ac20:	24050b81 	li	a1,2945
a000ac24:	24060012 	li	a2,18
a000ac28:	0c00098a 	jal	a0002628 <Set_GPHYWB>
a000ac2c:	00003821 	move	a3,zero
	rtl8651_setAsicEthernetPHYReg(0, 18, 0x0005 );		
a000ac30:	00002021 	move	a0,zero
a000ac34:	24050012 	li	a1,18
a000ac38:	0c000941 	jal	a0002504 <rtl8651_setAsicEthernetPHYReg>
a000ac3c:	24060005 	li	a2,5

	Set_GPHYWB(0, 0xc84, 22, 0, 0x0000);			
a000ac40:	afa00010 	sw	zero,16(sp)
a000ac44:	00002021 	move	a0,zero
a000ac48:	24050c84 	li	a1,3204
a000ac4c:	24060016 	li	a2,22
a000ac50:	0c00098a 	jal	a0002628 <Set_GPHYWB>
a000ac54:	00003821 	move	a3,zero
	rtl8651_setAsicEthernetPHYReg(0, 22, 0x0007 );		
a000ac58:	00002021 	move	a0,zero
a000ac5c:	24050016 	li	a1,22
a000ac60:	0c000941 	jal	a0002504 <rtl8651_setAsicEthernetPHYReg>
a000ac64:	24060007 	li	a2,7


	delay_ms(1000);
a000ac68:	0c002219 	jal	a0008864 <delay_ms>
a000ac6c:	240403e8 	li	a0,1000

	
	//resume
	Set_GPHYWB(0, 0xa00, 23, 0xffff, 0x0040);
a000ac70:	24100040 	li	s0,64
a000ac74:	afb00010 	sw	s0,16(sp)
a000ac78:	00002021 	move	a0,zero
a000ac7c:	24050a00 	li	a1,2560
a000ac80:	24060017 	li	a2,23
a000ac84:	0c00098a 	jal	a0002628 <Set_GPHYWB>
a000ac88:	3407ffff 	li	a3,0xffff
	Set_GPHYWB(0, 0xa00, 23, 0xffbf, 0x0000);
a000ac8c:	afa00010 	sw	zero,16(sp)
a000ac90:	00002021 	move	a0,zero
a000ac94:	24050a00 	li	a1,2560
a000ac98:	24060017 	li	a2,23
a000ac9c:	0c00098a 	jal	a0002628 <Set_GPHYWB>
a000aca0:	3407ffbf 	li	a3,0xffbf
	Set_GPHYWB(0, 0xb81, 18, 0xffff, 0x0400);
a000aca4:	24110400 	li	s1,1024
a000aca8:	afb10010 	sw	s1,16(sp)
a000acac:	00002021 	move	a0,zero
a000acb0:	24050b81 	li	a1,2945
a000acb4:	24060012 	li	a2,18
a000acb8:	0c00098a 	jal	a0002628 <Set_GPHYWB>
a000acbc:	3407ffff 	li	a3,0xffff
	Set_GPHYWB(0, 0xc84, 23, 0xffff, 0x1000);			
a000acc0:	24121000 	li	s2,4096
a000acc4:	afb20010 	sw	s2,16(sp)
a000acc8:	00002021 	move	a0,zero
a000accc:	24050c84 	li	a1,3204
a000acd0:	24060017 	li	a2,23
a000acd4:	0c00098a 	jal	a0002628 <Set_GPHYWB>
a000acd8:	3407ffff 	li	a3,0xffff
	
	
	delay_ms(1000);
a000acdc:	0c002219 	jal	a0008864 <delay_ms>
a000ace0:	240403e8 	li	a0,1000
	Set_GPHYWB(0, 0xa00, 23, 0xffff, 0x0040);
a000ace4:	afb00010 	sw	s0,16(sp)
a000ace8:	00002021 	move	a0,zero
a000acec:	24050a00 	li	a1,2560
a000acf0:	24060017 	li	a2,23
a000acf4:	0c00098a 	jal	a0002628 <Set_GPHYWB>
a000acf8:	3407ffff 	li	a3,0xffff
	Set_GPHYWB(0, 0xa00, 23, 0xffbf, 0x0000);
a000acfc:	afa00010 	sw	zero,16(sp)
a000ad00:	00002021 	move	a0,zero
a000ad04:	24050a00 	li	a1,2560
a000ad08:	24060017 	li	a2,23
a000ad0c:	0c00098a 	jal	a0002628 <Set_GPHYWB>
a000ad10:	3407ffbf 	li	a3,0xffbf
	Set_GPHYWB(0, 0xb81, 18, 0xffff, 0x0400);
a000ad14:	afb10010 	sw	s1,16(sp)
a000ad18:	00002021 	move	a0,zero
a000ad1c:	24050b81 	li	a1,2945
a000ad20:	24060012 	li	a2,18
a000ad24:	0c00098a 	jal	a0002628 <Set_GPHYWB>
a000ad28:	3407ffff 	li	a3,0xffff
	Set_GPHYWB(0, 0xc84, 23, 0xffff, 0x1000);
a000ad2c:	afb20010 	sw	s2,16(sp)
a000ad30:	00002021 	move	a0,zero
a000ad34:	24050c84 	li	a1,3204
a000ad38:	24060017 	li	a2,23
a000ad3c:	0c00098a 	jal	a0002628 <Set_GPHYWB>
a000ad40:	3407ffff 	li	a3,0xffff
	
	delay_ms(1000);
a000ad44:	0c002219 	jal	a0008864 <delay_ms>
a000ad48:	240403e8 	li	a0,1000
a000ad4c:	00008821 	move	s1,zero
a000ad50:	00008021 	move	s0,zero
	{	
		if(i==0) phyid=8;
		else phyid=i;
		
		rtl8651_setAsicEthernetPHYReg(phyid, 31,0x0a00 );
		rtl8651_getAsicEthernetPHYReg(phyid, 23, &rdat );	
a000ad54:	27b3001c 	addiu	s3,sp,28
		printf("get data=%x\n", rdat);
a000ad58:	3c12a001 	lui	s2,0xa001
a000ad5c:	26525ca4 	addiu	s2,s2,23716
		
		if((rdat&(0xf<<9))== (0x4<<9)) 	printf("Port %d BIST PASS\n",i);
a000ad60:	24150800 	li	s5,2048
		else 			{ printf("Port %d BIST FAIL\n",i);  err++; }
a000ad64:	3c14a001 	lui	s4,0xa001
a000ad68:	26945cc8 	addiu	s4,s4,23752
		
		rtl8651_setAsicEthernetPHYReg(phyid, 31,0x0a00 );
		rtl8651_getAsicEthernetPHYReg(phyid, 23, &rdat );	
		printf("get data=%x\n", rdat);
		
		if((rdat&(0xf<<9))== (0x4<<9)) 	printf("Port %d BIST PASS\n",i);
a000ad6c:	3c02a001 	lui	v0,0xa001
a000ad70:	24425cb4 	addiu	v0,v0,23732
a000ad74:	afa20020 	sw	v0,32(sp)
		//
		rtl8651_setAsicEthernetPHYReg(phyid, 31,0x0b81 );
		rtl8651_getAsicEthernetPHYReg(phyid, 18, &rdat );	
		printf("get data=%x\n", rdat);
		
		if((rdat&(0xf<<12))== (0x4<<12)) 	printf("Port %d BIST PASS\n",i);
a000ad78:	24164000 	li	s6,16384
		//
		rtl8651_setAsicEthernetPHYReg(phyid, 31,0x0c84 );
		rtl8651_getAsicEthernetPHYReg(phyid, 23, &rdat );	
		printf("get data=%x\n", rdat);
		
		if((rdat&(0x7<<0))== (0x4<<0)) 	printf("Port %d BIST PASS\n",i);
a000ad7c:	24170004 	li	s7,4
	
	delay_ms(1000);
	

	
	for(i=0;i<5;i++)
a000ad80:	241e0005 	li	s8,5
	{	
		if(i==0) phyid=8;
a000ad84:	16000004 	bnez	s0,a000ad98 <GPHY_DRF_BIST+0x260>
a000ad88:	24020008 	li	v0,8
a000ad8c:	afa20018 	sw	v0,24(sp)
a000ad90:	08002b67 	j	a000ad9c <GPHY_DRF_BIST+0x264>
a000ad94:	00000000 	nop
		else phyid=i;
a000ad98:	afb00018 	sw	s0,24(sp)
		
		rtl8651_setAsicEthernetPHYReg(phyid, 31,0x0a00 );
a000ad9c:	8fa40018 	lw	a0,24(sp)
a000ada0:	2405001f 	li	a1,31
a000ada4:	0c000941 	jal	a0002504 <rtl8651_setAsicEthernetPHYReg>
a000ada8:	24060a00 	li	a2,2560
		rtl8651_getAsicEthernetPHYReg(phyid, 23, &rdat );	
a000adac:	8fa40018 	lw	a0,24(sp)
a000adb0:	24050017 	li	a1,23
a000adb4:	0c000933 	jal	a00024cc <rtl8651_getAsicEthernetPHYReg>
a000adb8:	02603021 	move	a2,s3
		printf("get data=%x\n", rdat);
a000adbc:	8fa5001c 	lw	a1,28(sp)
a000adc0:	0c002325 	jal	a0008c94 <dprintf>
a000adc4:	02402021 	move	a0,s2
		
		if((rdat&(0xf<<9))== (0x4<<9)) 	printf("Port %d BIST PASS\n",i);
a000adc8:	8fa2001c 	lw	v0,28(sp)
a000adcc:	30421e00 	andi	v0,v0,0x1e00
a000add0:	14550006 	bne	v0,s5,a000adec <GPHY_DRF_BIST+0x2b4>
a000add4:	00000000 	nop
a000add8:	8fa40020 	lw	a0,32(sp)
a000addc:	0c002325 	jal	a0008c94 <dprintf>
a000ade0:	02002821 	move	a1,s0
a000ade4:	08002b7f 	j	a000adfc <GPHY_DRF_BIST+0x2c4>
a000ade8:	00000000 	nop
		else 			{ printf("Port %d BIST FAIL\n",i);  err++; }
a000adec:	02802021 	move	a0,s4
a000adf0:	0c002325 	jal	a0008c94 <dprintf>
a000adf4:	02002821 	move	a1,s0
a000adf8:	26310001 	addiu	s1,s1,1
			
			
		//
		rtl8651_setAsicEthernetPHYReg(phyid, 31,0x0b81 );
a000adfc:	8fa40018 	lw	a0,24(sp)
a000ae00:	2405001f 	li	a1,31
a000ae04:	0c000941 	jal	a0002504 <rtl8651_setAsicEthernetPHYReg>
a000ae08:	24060b81 	li	a2,2945
		rtl8651_getAsicEthernetPHYReg(phyid, 18, &rdat );	
a000ae0c:	8fa40018 	lw	a0,24(sp)
a000ae10:	24050012 	li	a1,18
a000ae14:	0c000933 	jal	a00024cc <rtl8651_getAsicEthernetPHYReg>
a000ae18:	02603021 	move	a2,s3
		printf("get data=%x\n", rdat);
a000ae1c:	8fa5001c 	lw	a1,28(sp)
a000ae20:	0c002325 	jal	a0008c94 <dprintf>
a000ae24:	02402021 	move	a0,s2
		
		if((rdat&(0xf<<12))== (0x4<<12)) 	printf("Port %d BIST PASS\n",i);
a000ae28:	8fa2001c 	lw	v0,28(sp)
a000ae2c:	3042f000 	andi	v0,v0,0xf000
a000ae30:	14560006 	bne	v0,s6,a000ae4c <GPHY_DRF_BIST+0x314>
a000ae34:	00000000 	nop
a000ae38:	8fa40020 	lw	a0,32(sp)
a000ae3c:	0c002325 	jal	a0008c94 <dprintf>
a000ae40:	02002821 	move	a1,s0
a000ae44:	08002b97 	j	a000ae5c <GPHY_DRF_BIST+0x324>
a000ae48:	00000000 	nop
		else 			{ printf("Port %d BIST FAIL\n",i);	err++; }
a000ae4c:	02802021 	move	a0,s4
a000ae50:	0c002325 	jal	a0008c94 <dprintf>
a000ae54:	02002821 	move	a1,s0
a000ae58:	26310001 	addiu	s1,s1,1
			
		//
		rtl8651_setAsicEthernetPHYReg(phyid, 31,0x0c84 );
a000ae5c:	8fa40018 	lw	a0,24(sp)
a000ae60:	2405001f 	li	a1,31
a000ae64:	0c000941 	jal	a0002504 <rtl8651_setAsicEthernetPHYReg>
a000ae68:	24060c84 	li	a2,3204
		rtl8651_getAsicEthernetPHYReg(phyid, 23, &rdat );	
a000ae6c:	8fa40018 	lw	a0,24(sp)
a000ae70:	24050017 	li	a1,23
a000ae74:	0c000933 	jal	a00024cc <rtl8651_getAsicEthernetPHYReg>
a000ae78:	02603021 	move	a2,s3
		printf("get data=%x\n", rdat);
a000ae7c:	8fa5001c 	lw	a1,28(sp)
a000ae80:	0c002325 	jal	a0008c94 <dprintf>
a000ae84:	02402021 	move	a0,s2
		
		if((rdat&(0x7<<0))== (0x4<<0)) 	printf("Port %d BIST PASS\n",i);
a000ae88:	8fa2001c 	lw	v0,28(sp)
a000ae8c:	30420007 	andi	v0,v0,0x7
a000ae90:	14570006 	bne	v0,s7,a000aeac <GPHY_DRF_BIST+0x374>
a000ae94:	02802021 	move	a0,s4
a000ae98:	8fa40020 	lw	a0,32(sp)
a000ae9c:	0c002325 	jal	a0008c94 <dprintf>
a000aea0:	02002821 	move	a1,s0
	
	delay_ms(1000);
	

	
	for(i=0;i<5;i++)
a000aea4:	08002baf 	j	a000aebc <GPHY_DRF_BIST+0x384>
a000aea8:	26100001 	addiu	s0,s0,1
		rtl8651_setAsicEthernetPHYReg(phyid, 31,0x0c84 );
		rtl8651_getAsicEthernetPHYReg(phyid, 23, &rdat );	
		printf("get data=%x\n", rdat);
		
		if((rdat&(0x7<<0))== (0x4<<0)) 	printf("Port %d BIST PASS\n",i);
		else 			{ printf("Port %d BIST FAIL\n",i);	err++; }
a000aeac:	0c002325 	jal	a0008c94 <dprintf>
a000aeb0:	02002821 	move	a1,s0
a000aeb4:	26310001 	addiu	s1,s1,1
	
	delay_ms(1000);
	

	
	for(i=0;i<5;i++)
a000aeb8:	26100001 	addiu	s0,s0,1
a000aebc:	161effb1 	bne	s0,s8,a000ad84 <GPHY_DRF_BIST+0x24c>
a000aec0:	24050c40 	li	a1,3136
		if((rdat&(0x7<<0))== (0x4<<0)) 	printf("Port %d BIST PASS\n",i);
		else 			{ printf("Port %d BIST FAIL\n",i);	err++; }
		
	}	
	
	Set_GPHYWB(0, 0xc40, 21, 0, 0x0000);
a000aec4:	afa00010 	sw	zero,16(sp)
a000aec8:	00002021 	move	a0,zero
a000aecc:	24060015 	li	a2,21
a000aed0:	0c00098a 	jal	a0002628 <Set_GPHYWB>
a000aed4:	00003821 	move	a3,zero

	
	//=================
	if(err==0)
a000aed8:	16200005 	bnez	s1,a000aef0 <GPHY_DRF_BIST+0x3b8>
a000aedc:	3c04a001 	lui	a0,0xa001
		printf("==> GPHY BIST ALL PASS <== \n");
a000aee0:	0c002325 	jal	a0008c94 <dprintf>
a000aee4:	24845cdc 	addiu	a0,a0,23772
	else
		printf("==> GPHY BIST FAIL count=%d <== \n", err);	
			
}
a000aee8:	08002bc1 	j	a000af04 <GPHY_DRF_BIST+0x3cc>
a000aeec:	8fbf004c 	lw	ra,76(sp)
	
	//=================
	if(err==0)
		printf("==> GPHY BIST ALL PASS <== \n");
	else
		printf("==> GPHY BIST FAIL count=%d <== \n", err);	
a000aef0:	3c04a001 	lui	a0,0xa001
a000aef4:	24845cfc 	addiu	a0,a0,23804
a000aef8:	0c002325 	jal	a0008c94 <dprintf>
a000aefc:	02202821 	move	a1,s1
			
}
a000af00:	8fbf004c 	lw	ra,76(sp)
a000af04:	8fbe0048 	lw	s8,72(sp)
a000af08:	8fb70044 	lw	s7,68(sp)
a000af0c:	8fb60040 	lw	s6,64(sp)
a000af10:	8fb5003c 	lw	s5,60(sp)
a000af14:	8fb40038 	lw	s4,56(sp)
a000af18:	8fb30034 	lw	s3,52(sp)
a000af1c:	8fb20030 	lw	s2,48(sp)
a000af20:	8fb1002c 	lw	s1,44(sp)
a000af24:	8fb00028 	lw	s0,40(sp)
a000af28:	03e00008 	jr	ra
a000af2c:	27bd0050 	addiu	sp,sp,80

a000af30 <GPHY_BIST>:

//=========================================================

//=========================================================
int GPHY_BIST(int argc, char* argv[])
{
a000af30:	27bdffa8 	addiu	sp,sp,-88
a000af34:	afbf0054 	sw	ra,84(sp)
a000af38:	afbe0050 	sw	s8,80(sp)
a000af3c:	afb7004c 	sw	s7,76(sp)
a000af40:	afb60048 	sw	s6,72(sp)
a000af44:	afb50044 	sw	s5,68(sp)
a000af48:	afb40040 	sw	s4,64(sp)
a000af4c:	afb3003c 	sw	s3,60(sp)
a000af50:	afb20038 	sw	s2,56(sp)
a000af54:	afb10034 	sw	s1,52(sp)
a000af58:	afb00030 	sw	s0,48(sp)
	volatile unsigned int phyid=4,rdat=0;
a000af5c:	24020004 	li	v0,4
a000af60:	afa20018 	sw	v0,24(sp)
a000af64:	afa0001c 	sw	zero,28(sp)
	int i;
	int err=0;

	dprintf("Set P0-P4 force mode...... \n");
a000af68:	3c04a001 	lui	a0,0xa001
a000af6c:	0c002325 	jal	a0008c94 <dprintf>
a000af70:	24845d20 	addiu	a0,a0,23840
	REG32(0xbb804104)= 0x427f0038;
a000af74:	3c02bb80 	lui	v0,0xbb80
a000af78:	34434104 	ori	v1,v0,0x4104
a000af7c:	3c04427f 	lui	a0,0x427f
a000af80:	34840038 	ori	a0,a0,0x38
a000af84:	ac640000 	sw	a0,0(v1)
	REG32(0xbb804108)= 0x467f0038;
a000af88:	34434108 	ori	v1,v0,0x4108
a000af8c:	3c04467f 	lui	a0,0x467f
a000af90:	34840038 	ori	a0,a0,0x38
a000af94:	ac640000 	sw	a0,0(v1)
	REG32(0xbb80410c)= 0x4a7f0038;
a000af98:	3443410c 	ori	v1,v0,0x410c
a000af9c:	3c044a7f 	lui	a0,0x4a7f
a000afa0:	34840038 	ori	a0,a0,0x38
a000afa4:	ac640000 	sw	a0,0(v1)
	REG32(0xbb804110)= 0x4e7f0038;
a000afa8:	34434110 	ori	v1,v0,0x4110
a000afac:	3c044e7f 	lui	a0,0x4e7f
a000afb0:	34840038 	ori	a0,a0,0x38
a000afb4:	ac640000 	sw	a0,0(v1)
	REG32(0xbb804114)= 0x527f0038;
a000afb8:	34434114 	ori	v1,v0,0x4114
a000afbc:	3c04527f 	lui	a0,0x527f
a000afc0:	34840038 	ori	a0,a0,0x38
a000afc4:	ac640000 	sw	a0,0(v1)
	REG32(0xbb804118)= 0x566f0038;	
a000afc8:	34424118 	ori	v0,v0,0x4118
a000afcc:	3c03566f 	lui	v1,0x566f
a000afd0:	34630038 	ori	v1,v1,0x38
a000afd4:	ac430000 	sw	v1,0(v0)
	
	//
	rtl8651_setAsicEthernetPHYReg(8, 24, 0x2198 );		
a000afd8:	24040008 	li	a0,8
a000afdc:	24050018 	li	a1,24
a000afe0:	0c000941 	jal	a0002504 <rtl8651_setAsicEthernetPHYReg>
a000afe4:	24062198 	li	a2,8600
	rtl8651_setAsicEthernetPHYReg(1, 24, 0x2198 );	
a000afe8:	24040001 	li	a0,1
a000afec:	24050018 	li	a1,24
a000aff0:	0c000941 	jal	a0002504 <rtl8651_setAsicEthernetPHYReg>
a000aff4:	24062198 	li	a2,8600
	rtl8651_setAsicEthernetPHYReg(2, 24, 0x2198 );	
a000aff8:	24040002 	li	a0,2
a000affc:	24050018 	li	a1,24
a000b000:	0c000941 	jal	a0002504 <rtl8651_setAsicEthernetPHYReg>
a000b004:	24062198 	li	a2,8600
	rtl8651_setAsicEthernetPHYReg(3, 24, 0x2198 );
a000b008:	24040003 	li	a0,3
a000b00c:	24050018 	li	a1,24
a000b010:	0c000941 	jal	a0002504 <rtl8651_setAsicEthernetPHYReg>
a000b014:	24062198 	li	a2,8600
	rtl8651_setAsicEthernetPHYReg(4, 24, 0x2198 );	
a000b018:	24040004 	li	a0,4
a000b01c:	24050018 	li	a1,24
a000b020:	0c000941 	jal	a0002504 <rtl8651_setAsicEthernetPHYReg>
a000b024:	24062198 	li	a2,8600
	
	//
	Set_GPHYWB(0, 0xA40, 0, 0, 0x1140);
a000b028:	24021140 	li	v0,4416
a000b02c:	afa20010 	sw	v0,16(sp)
a000b030:	00002021 	move	a0,zero
a000b034:	24050a40 	li	a1,2624
a000b038:	00003021 	move	a2,zero
a000b03c:	0c00098a 	jal	a0002628 <Set_GPHYWB>
a000b040:	00003821 	move	a3,zero
	Set_GPHYWB(0, 0xA46, 20, 0, 0x0003);	
a000b044:	24020003 	li	v0,3
a000b048:	afa20010 	sw	v0,16(sp)
a000b04c:	00002021 	move	a0,zero
a000b050:	24050a46 	li	a1,2630
a000b054:	24060014 	li	a2,20
a000b058:	0c00098a 	jal	a0002628 <Set_GPHYWB>
a000b05c:	00003821 	move	a3,zero
//	Set_GPHYWB(0, 0xA4A, 19, 0, 0x001f);	
//	Set_GPHYWB(0, 0xB80, 23, 0, 0x000e);	
	
	//
	rtl8651_setAsicEthernetPHYReg(0, 31,0x0a42 );		
a000b060:	00002021 	move	a0,zero
a000b064:	2405001f 	li	a1,31
a000b068:	0c000941 	jal	a0002504 <rtl8651_setAsicEthernetPHYReg>
a000b06c:	24060a42 	li	a2,2626
a000b070:	00008821 	move	s1,zero
a000b074:	00008021 	move	s0,zero
	for(i=0;i<5;i++)
	{
		if(i==0) phyid=8;
a000b078:	24170008 	li	s7,8
		rtl8651_getAsicEthernetPHYReg(phyid, 16, &rdat );
a000b07c:	27b5001c 	addiu	s5,sp,28
		printf("get data=%x\n", rdat);
a000b080:	3c12a001 	lui	s2,0xa001
a000b084:	26525ca4 	addiu	s2,s2,23716
		if((rdat&0x7)==	0x3) 	printf("Port %d PCS ready PASS\n",i);
a000b088:	24130003 	li	s3,3
		else 			{ printf("Port %d PCS ready FAIL\n",i); err++; }
a000b08c:	3c16a001 	lui	s6,0xa001
a000b090:	26d65d58 	addiu	s6,s6,23896
	for(i=0;i<5;i++)
	{
		if(i==0) phyid=8;
		rtl8651_getAsicEthernetPHYReg(phyid, 16, &rdat );
		printf("get data=%x\n", rdat);
		if((rdat&0x7)==	0x3) 	printf("Port %d PCS ready PASS\n",i);
a000b094:	3c1ea001 	lui	s8,0xa001
a000b098:	27de5d40 	addiu	s8,s8,23872
//	Set_GPHYWB(0, 0xA4A, 19, 0, 0x001f);	
//	Set_GPHYWB(0, 0xB80, 23, 0, 0x000e);	
	
	//
	rtl8651_setAsicEthernetPHYReg(0, 31,0x0a42 );		
	for(i=0;i<5;i++)
a000b09c:	24140005 	li	s4,5
	{
		if(i==0) phyid=8;
a000b0a0:	16000002 	bnez	s0,a000b0ac <GPHY_BIST+0x17c>
a000b0a4:	00000000 	nop
a000b0a8:	afb70018 	sw	s7,24(sp)
		rtl8651_getAsicEthernetPHYReg(phyid, 16, &rdat );
a000b0ac:	8fa40018 	lw	a0,24(sp)
a000b0b0:	24050010 	li	a1,16
a000b0b4:	0c000933 	jal	a00024cc <rtl8651_getAsicEthernetPHYReg>
a000b0b8:	02a03021 	move	a2,s5
		printf("get data=%x\n", rdat);
a000b0bc:	8fa5001c 	lw	a1,28(sp)
a000b0c0:	0c002325 	jal	a0008c94 <dprintf>
a000b0c4:	02402021 	move	a0,s2
		if((rdat&0x7)==	0x3) 	printf("Port %d PCS ready PASS\n",i);
a000b0c8:	8fa2001c 	lw	v0,28(sp)
a000b0cc:	30420007 	andi	v0,v0,0x7
a000b0d0:	14530006 	bne	v0,s3,a000b0ec <GPHY_BIST+0x1bc>
a000b0d4:	02c02021 	move	a0,s6
a000b0d8:	03c02021 	move	a0,s8
a000b0dc:	0c002325 	jal	a0008c94 <dprintf>
a000b0e0:	02002821 	move	a1,s0
//	Set_GPHYWB(0, 0xA4A, 19, 0, 0x001f);	
//	Set_GPHYWB(0, 0xB80, 23, 0, 0x000e);	
	
	//
	rtl8651_setAsicEthernetPHYReg(0, 31,0x0a42 );		
	for(i=0;i<5;i++)
a000b0e4:	08002c3f 	j	a000b0fc <GPHY_BIST+0x1cc>
a000b0e8:	26100001 	addiu	s0,s0,1
	{
		if(i==0) phyid=8;
		rtl8651_getAsicEthernetPHYReg(phyid, 16, &rdat );
		printf("get data=%x\n", rdat);
		if((rdat&0x7)==	0x3) 	printf("Port %d PCS ready PASS\n",i);
		else 			{ printf("Port %d PCS ready FAIL\n",i); err++; }
a000b0ec:	0c002325 	jal	a0008c94 <dprintf>
a000b0f0:	02002821 	move	a1,s0
a000b0f4:	26310001 	addiu	s1,s1,1
//	Set_GPHYWB(0, 0xA4A, 19, 0, 0x001f);	
//	Set_GPHYWB(0, 0xB80, 23, 0, 0x000e);	
	
	//
	rtl8651_setAsicEthernetPHYReg(0, 31,0x0a42 );		
	for(i=0;i<5;i++)
a000b0f8:	26100001 	addiu	s0,s0,1
a000b0fc:	1614ffe8 	bne	s0,s4,a000b0a0 <GPHY_BIST+0x170>
a000b100:	3402c000 	li	v0,0xc000
		if((rdat&0x7)==	0x3) 	printf("Port %d PCS ready PASS\n",i);
		else 			{ printf("Port %d PCS ready FAIL\n",i); err++; }
	}
	
	//3. m3 bist
	Set_GPHYWB(0, 0xc40, 21, 0, 0xc000);
a000b104:	afa20010 	sw	v0,16(sp)
a000b108:	00002021 	move	a0,zero
a000b10c:	24050c40 	li	a1,3136
a000b110:	24060015 	li	a2,21
a000b114:	0c00098a 	jal	a0002628 <Set_GPHYWB>
a000b118:	00003821 	move	a3,zero
	Set_GPHYWB(0, 0xA00, 20, 0, 0x0000);	
a000b11c:	afa00010 	sw	zero,16(sp)
a000b120:	00002021 	move	a0,zero
a000b124:	24050a00 	li	a1,2560
a000b128:	24060014 	li	a2,20
a000b12c:	0c00098a 	jal	a0002628 <Set_GPHYWB>
a000b130:	00003821 	move	a3,zero
	rtl8651_setAsicEthernetPHYReg(0, 20, 0x0060 );			
a000b134:	00002021 	move	a0,zero
a000b138:	24050014 	li	a1,20
a000b13c:	0c000941 	jal	a0002504 <rtl8651_setAsicEthernetPHYReg>
a000b140:	24060060 	li	a2,96
	rtl8651_setAsicEthernetPHYReg(0, 23, 0x0000 );	
a000b144:	00002021 	move	a0,zero
a000b148:	24050017 	li	a1,23
a000b14c:	0c000941 	jal	a0002504 <rtl8651_setAsicEthernetPHYReg>
a000b150:	00003021 	move	a2,zero
	rtl8651_setAsicEthernetPHYReg(0, 23, 0x00a0 );	
a000b154:	00002021 	move	a0,zero
a000b158:	24050017 	li	a1,23
a000b15c:	0c000941 	jal	a0002504 <rtl8651_setAsicEthernetPHYReg>
a000b160:	240600a0 	li	a2,160
	Set_GPHYWB(0, 0xb81, 18, 0, 0x0000);
a000b164:	afa00010 	sw	zero,16(sp)
a000b168:	00002021 	move	a0,zero
a000b16c:	24050b81 	li	a1,2945
a000b170:	24060012 	li	a2,18
a000b174:	0c00098a 	jal	a0002628 <Set_GPHYWB>
a000b178:	00003821 	move	a3,zero
	rtl8651_setAsicEthernetPHYReg(0, 18, 0x001b );					
a000b17c:	00002021 	move	a0,zero
a000b180:	24050012 	li	a1,18
a000b184:	0c000941 	jal	a0002504 <rtl8651_setAsicEthernetPHYReg>
a000b188:	2406001b 	li	a2,27
	Set_GPHYWB(0, 0xc84, 22, 0, 0x0000);	
a000b18c:	afa00010 	sw	zero,16(sp)
a000b190:	00002021 	move	a0,zero
a000b194:	24050c84 	li	a1,3204
a000b198:	24060016 	li	a2,22
a000b19c:	0c00098a 	jal	a0002628 <Set_GPHYWB>
a000b1a0:	00003821 	move	a3,zero
	rtl8651_setAsicEthernetPHYReg(0, 22, 0x0005 );	
a000b1a4:	00002021 	move	a0,zero
a000b1a8:	24050016 	li	a1,22
a000b1ac:	0c000941 	jal	a0002504 <rtl8651_setAsicEthernetPHYReg>
a000b1b0:	24060005 	li	a2,5
	
	delay_ms(100);
a000b1b4:	0c002219 	jal	a0008864 <delay_ms>
a000b1b8:	24040064 	li	a0,100
	printf("\n");
a000b1bc:	3c04a001 	lui	a0,0xa001
a000b1c0:	0c002325 	jal	a0008c94 <dprintf>
a000b1c4:	248457b8 	addiu	a0,a0,22456
a000b1c8:	00008021 	move	s0,zero
	{	
		if(i==0) phyid=8;
		else phyid=i;		
		rtl8651_setAsicEthernetPHYReg(phyid, 31,0x0a00 );
		rtl8651_getAsicEthernetPHYReg(phyid, 23, &rdat );	
		printf("get data=%x\n", rdat);
a000b1cc:	3c12a001 	lui	s2,0xa001
a000b1d0:	26525ca4 	addiu	s2,s2,23716
		if((rdat&(0xf<<9))== (0x8<<9)) 	printf("Port %d BIST PASS\n",i);
		else 			{ printf("Port %d BIST FAIL\n",i); err++; }
a000b1d4:	3c14a001 	lui	s4,0xa001
a000b1d8:	26945cc8 	addiu	s4,s4,23752
		if(i==0) phyid=8;
		else phyid=i;		
		rtl8651_setAsicEthernetPHYReg(phyid, 31,0x0a00 );
		rtl8651_getAsicEthernetPHYReg(phyid, 23, &rdat );	
		printf("get data=%x\n", rdat);
		if((rdat&(0xf<<9))== (0x8<<9)) 	printf("Port %d BIST PASS\n",i);
a000b1dc:	3c02a001 	lui	v0,0xa001
a000b1e0:	24425cb4 	addiu	v0,v0,23732
a000b1e4:	afa20020 	sw	v0,32(sp)
			
		//	
		rtl8651_getAsicEthernetPHYReg(phyid, 22, &rdat );	
		printf("get data=%x\n", rdat);
		if(rdat== 0xd279) 	printf("Port %d BIST_ROM [31:16] PASS\n",i);
		else 			{ printf("Port %d BIST_ROM [31:16] FAIL\n",i);	err++; }
a000b1e8:	3c15a001 	lui	s5,0xa001
a000b1ec:	26b55d90 	addiu	s5,s5,23952
			
			
		//	
		rtl8651_getAsicEthernetPHYReg(phyid, 22, &rdat );	
		printf("get data=%x\n", rdat);
		if(rdat== 0xd279) 	printf("Port %d BIST_ROM [31:16] PASS\n",i);
a000b1f0:	3c02a001 	lui	v0,0xa001
a000b1f4:	24425d70 	addiu	v0,v0,23920
a000b1f8:	afa20024 	sw	v0,36(sp)
			
		//
		rtl8651_getAsicEthernetPHYReg(phyid, 21, &rdat );	
		printf("get data=%x\n", rdat);
		if(rdat== 0xa555) 	printf("Port %d BIST_ROM [15:0] PASS\n",i);
		else 			{ printf("Port %d BIST_ROM [15:0] FAIL\n",i);	err++; }
a000b1fc:	3c16a001 	lui	s6,0xa001
a000b200:	26d65dd0 	addiu	s6,s6,24016
		else 			{ printf("Port %d BIST_ROM [31:16] FAIL\n",i);	err++; }
			
		//
		rtl8651_getAsicEthernetPHYReg(phyid, 21, &rdat );	
		printf("get data=%x\n", rdat);
		if(rdat== 0xa555) 	printf("Port %d BIST_ROM [15:0] PASS\n",i);
a000b204:	3c02a001 	lui	v0,0xa001
a000b208:	24425db0 	addiu	v0,v0,23984
a000b20c:	afa20028 	sw	v0,40(sp)
		
		rtl8651_setAsicEthernetPHYReg(phyid, 31,0x0b81 );
		rtl8651_getAsicEthernetPHYReg(phyid, 18, &rdat );				
		printf("get data=%x\n", rdat);
		if((rdat&(0xf<<12))== (0x1<<12)) 	printf("Port %d GPHY BIST PASS\n",i);
		else 			{		printf("Port %d GPHY BIST FAIL\n",i);	err++; }
a000b210:	3c13a001 	lui	s3,0xa001
a000b214:	26735e08 	addiu	s3,s3,24072
		else 			{ printf("Port %d BIST_ROM [15:0] FAIL\n",i);	err++; }
		
		rtl8651_setAsicEthernetPHYReg(phyid, 31,0x0b81 );
		rtl8651_getAsicEthernetPHYReg(phyid, 18, &rdat );				
		printf("get data=%x\n", rdat);
		if((rdat&(0xf<<12))== (0x1<<12)) 	printf("Port %d GPHY BIST PASS\n",i);
a000b218:	3c1ea001 	lui	s8,0xa001
a000b21c:	27de5df0 	addiu	s8,s8,24048
			
			
		rtl8651_getAsicEthernetPHYReg(phyid, 19, &rdat );				
		printf("get data=%x\n", rdat);
		if(rdat== 0x2c34) 	printf("Port %d GPHY BIST_ROM PASS\n",i);
		else 			{ printf("Port %d GPHY BIST_ROM FAIL\n",i);	err++; }
a000b220:	3c17a001 	lui	s7,0xa001
a000b224:	26f75e3c 	addiu	s7,s7,24124
		else 			{		printf("Port %d GPHY BIST FAIL\n",i);	err++; }
			
			
		rtl8651_getAsicEthernetPHYReg(phyid, 19, &rdat );				
		printf("get data=%x\n", rdat);
		if(rdat== 0x2c34) 	printf("Port %d GPHY BIST_ROM PASS\n",i);
a000b228:	3c02a001 	lui	v0,0xa001
a000b22c:	24425e20 	addiu	v0,v0,24096
a000b230:	afa2002c 	sw	v0,44(sp)
	delay_ms(100);
	printf("\n");
	
	for(i=0;i<5;i++)
	{	
		if(i==0) phyid=8;
a000b234:	16000004 	bnez	s0,a000b248 <GPHY_BIST+0x318>
a000b238:	24020008 	li	v0,8
a000b23c:	afa20018 	sw	v0,24(sp)
a000b240:	08002c93 	j	a000b24c <GPHY_BIST+0x31c>
a000b244:	00000000 	nop
		else phyid=i;		
a000b248:	afb00018 	sw	s0,24(sp)
		rtl8651_setAsicEthernetPHYReg(phyid, 31,0x0a00 );
a000b24c:	8fa40018 	lw	a0,24(sp)
a000b250:	2405001f 	li	a1,31
a000b254:	0c000941 	jal	a0002504 <rtl8651_setAsicEthernetPHYReg>
a000b258:	24060a00 	li	a2,2560
		rtl8651_getAsicEthernetPHYReg(phyid, 23, &rdat );	
a000b25c:	8fa40018 	lw	a0,24(sp)
a000b260:	24050017 	li	a1,23
a000b264:	0c000933 	jal	a00024cc <rtl8651_getAsicEthernetPHYReg>
a000b268:	27a6001c 	addiu	a2,sp,28
		printf("get data=%x\n", rdat);
a000b26c:	8fa5001c 	lw	a1,28(sp)
a000b270:	0c002325 	jal	a0008c94 <dprintf>
a000b274:	02402021 	move	a0,s2
		if((rdat&(0xf<<9))== (0x8<<9)) 	printf("Port %d BIST PASS\n",i);
a000b278:	8fa3001c 	lw	v1,28(sp)
a000b27c:	30631e00 	andi	v1,v1,0x1e00
a000b280:	24021000 	li	v0,4096
a000b284:	14620006 	bne	v1,v0,a000b2a0 <GPHY_BIST+0x370>
a000b288:	00000000 	nop
a000b28c:	8fa40020 	lw	a0,32(sp)
a000b290:	0c002325 	jal	a0008c94 <dprintf>
a000b294:	02002821 	move	a1,s0
a000b298:	08002cac 	j	a000b2b0 <GPHY_BIST+0x380>
a000b29c:	00000000 	nop
		else 			{ printf("Port %d BIST FAIL\n",i); err++; }
a000b2a0:	02802021 	move	a0,s4
a000b2a4:	0c002325 	jal	a0008c94 <dprintf>
a000b2a8:	02002821 	move	a1,s0
a000b2ac:	26310001 	addiu	s1,s1,1
			
			
		//	
		rtl8651_getAsicEthernetPHYReg(phyid, 22, &rdat );	
a000b2b0:	8fa40018 	lw	a0,24(sp)
a000b2b4:	24050016 	li	a1,22
a000b2b8:	0c000933 	jal	a00024cc <rtl8651_getAsicEthernetPHYReg>
a000b2bc:	27a6001c 	addiu	a2,sp,28
		printf("get data=%x\n", rdat);
a000b2c0:	8fa5001c 	lw	a1,28(sp)
a000b2c4:	0c002325 	jal	a0008c94 <dprintf>
a000b2c8:	02402021 	move	a0,s2
		if(rdat== 0xd279) 	printf("Port %d BIST_ROM [31:16] PASS\n",i);
a000b2cc:	8fa3001c 	lw	v1,28(sp)
a000b2d0:	3402d279 	li	v0,0xd279
a000b2d4:	14620006 	bne	v1,v0,a000b2f0 <GPHY_BIST+0x3c0>
a000b2d8:	00000000 	nop
a000b2dc:	8fa40024 	lw	a0,36(sp)
a000b2e0:	0c002325 	jal	a0008c94 <dprintf>
a000b2e4:	02002821 	move	a1,s0
a000b2e8:	08002cc0 	j	a000b300 <GPHY_BIST+0x3d0>
a000b2ec:	00000000 	nop
		else 			{ printf("Port %d BIST_ROM [31:16] FAIL\n",i);	err++; }
a000b2f0:	02a02021 	move	a0,s5
a000b2f4:	0c002325 	jal	a0008c94 <dprintf>
a000b2f8:	02002821 	move	a1,s0
a000b2fc:	26310001 	addiu	s1,s1,1
			
		//
		rtl8651_getAsicEthernetPHYReg(phyid, 21, &rdat );	
a000b300:	8fa40018 	lw	a0,24(sp)
a000b304:	24050015 	li	a1,21
a000b308:	0c000933 	jal	a00024cc <rtl8651_getAsicEthernetPHYReg>
a000b30c:	27a6001c 	addiu	a2,sp,28
		printf("get data=%x\n", rdat);
a000b310:	8fa5001c 	lw	a1,28(sp)
a000b314:	0c002325 	jal	a0008c94 <dprintf>
a000b318:	02402021 	move	a0,s2
		if(rdat== 0xa555) 	printf("Port %d BIST_ROM [15:0] PASS\n",i);
a000b31c:	8fa3001c 	lw	v1,28(sp)
a000b320:	3402a555 	li	v0,0xa555
a000b324:	14620006 	bne	v1,v0,a000b340 <GPHY_BIST+0x410>
a000b328:	00000000 	nop
a000b32c:	8fa40028 	lw	a0,40(sp)
a000b330:	0c002325 	jal	a0008c94 <dprintf>
a000b334:	02002821 	move	a1,s0
a000b338:	08002cd4 	j	a000b350 <GPHY_BIST+0x420>
a000b33c:	00000000 	nop
		else 			{ printf("Port %d BIST_ROM [15:0] FAIL\n",i);	err++; }
a000b340:	02c02021 	move	a0,s6
a000b344:	0c002325 	jal	a0008c94 <dprintf>
a000b348:	02002821 	move	a1,s0
a000b34c:	26310001 	addiu	s1,s1,1
		
		rtl8651_setAsicEthernetPHYReg(phyid, 31,0x0b81 );
a000b350:	8fa40018 	lw	a0,24(sp)
a000b354:	2405001f 	li	a1,31
a000b358:	0c000941 	jal	a0002504 <rtl8651_setAsicEthernetPHYReg>
a000b35c:	24060b81 	li	a2,2945
		rtl8651_getAsicEthernetPHYReg(phyid, 18, &rdat );				
a000b360:	8fa40018 	lw	a0,24(sp)
a000b364:	24050012 	li	a1,18
a000b368:	0c000933 	jal	a00024cc <rtl8651_getAsicEthernetPHYReg>
a000b36c:	27a6001c 	addiu	a2,sp,28
		printf("get data=%x\n", rdat);
a000b370:	8fa5001c 	lw	a1,28(sp)
a000b374:	0c002325 	jal	a0008c94 <dprintf>
a000b378:	02402021 	move	a0,s2
		if((rdat&(0xf<<12))== (0x1<<12)) 	printf("Port %d GPHY BIST PASS\n",i);
a000b37c:	8fa3001c 	lw	v1,28(sp)
a000b380:	3063f000 	andi	v1,v1,0xf000
a000b384:	24021000 	li	v0,4096
a000b388:	14620006 	bne	v1,v0,a000b3a4 <GPHY_BIST+0x474>
a000b38c:	00000000 	nop
a000b390:	03c02021 	move	a0,s8
a000b394:	0c002325 	jal	a0008c94 <dprintf>
a000b398:	02002821 	move	a1,s0
a000b39c:	08002ced 	j	a000b3b4 <GPHY_BIST+0x484>
a000b3a0:	00000000 	nop
		else 			{		printf("Port %d GPHY BIST FAIL\n",i);	err++; }
a000b3a4:	02602021 	move	a0,s3
a000b3a8:	0c002325 	jal	a0008c94 <dprintf>
a000b3ac:	02002821 	move	a1,s0
a000b3b0:	26310001 	addiu	s1,s1,1
			
			
		rtl8651_getAsicEthernetPHYReg(phyid, 19, &rdat );				
a000b3b4:	8fa40018 	lw	a0,24(sp)
a000b3b8:	24050013 	li	a1,19
a000b3bc:	0c000933 	jal	a00024cc <rtl8651_getAsicEthernetPHYReg>
a000b3c0:	27a6001c 	addiu	a2,sp,28
		printf("get data=%x\n", rdat);
a000b3c4:	8fa5001c 	lw	a1,28(sp)
a000b3c8:	0c002325 	jal	a0008c94 <dprintf>
a000b3cc:	02402021 	move	a0,s2
		if(rdat== 0x2c34) 	printf("Port %d GPHY BIST_ROM PASS\n",i);
a000b3d0:	8fa3001c 	lw	v1,28(sp)
a000b3d4:	24022c34 	li	v0,11316
a000b3d8:	14620006 	bne	v1,v0,a000b3f4 <GPHY_BIST+0x4c4>
a000b3dc:	00000000 	nop
a000b3e0:	8fa4002c 	lw	a0,44(sp)
a000b3e4:	0c002325 	jal	a0008c94 <dprintf>
a000b3e8:	02002821 	move	a1,s0
a000b3ec:	08002d01 	j	a000b404 <GPHY_BIST+0x4d4>
a000b3f0:	00000000 	nop
		else 			{ printf("Port %d GPHY BIST_ROM FAIL\n",i);	err++; }
a000b3f4:	02e02021 	move	a0,s7
a000b3f8:	0c002325 	jal	a0008c94 <dprintf>
a000b3fc:	02002821 	move	a1,s0
a000b400:	26310001 	addiu	s1,s1,1
			
		rtl8651_setAsicEthernetPHYReg(phyid, 31,0x0c84 );
a000b404:	8fa40018 	lw	a0,24(sp)
a000b408:	2405001f 	li	a1,31
a000b40c:	0c000941 	jal	a0002504 <rtl8651_setAsicEthernetPHYReg>
a000b410:	24060c84 	li	a2,3204
		rtl8651_getAsicEthernetPHYReg(phyid, 23, &rdat );				
a000b414:	8fa40018 	lw	a0,24(sp)
a000b418:	24050017 	li	a1,23
a000b41c:	0c000933 	jal	a00024cc <rtl8651_getAsicEthernetPHYReg>
a000b420:	27a6001c 	addiu	a2,sp,28
		printf("get data=%x\n", rdat);
a000b424:	8fa5001c 	lw	a1,28(sp)
a000b428:	0c002325 	jal	a0008c94 <dprintf>
a000b42c:	02402021 	move	a0,s2
		if((rdat&(0x7<<0))== (0x4<<0)) 	printf("Port %d GPHY BIST PASS\n",i);
a000b430:	8fa3001c 	lw	v1,28(sp)
a000b434:	30630007 	andi	v1,v1,0x7
a000b438:	24020004 	li	v0,4
a000b43c:	14620006 	bne	v1,v0,a000b458 <GPHY_BIST+0x528>
a000b440:	02602021 	move	a0,s3
a000b444:	03c02021 	move	a0,s8
a000b448:	0c002325 	jal	a0008c94 <dprintf>
a000b44c:	02002821 	move	a1,s0
	rtl8651_setAsicEthernetPHYReg(0, 22, 0x0005 );	
	
	delay_ms(100);
	printf("\n");
	
	for(i=0;i<5;i++)
a000b450:	08002d1a 	j	a000b468 <GPHY_BIST+0x538>
a000b454:	26100001 	addiu	s0,s0,1
			
		rtl8651_setAsicEthernetPHYReg(phyid, 31,0x0c84 );
		rtl8651_getAsicEthernetPHYReg(phyid, 23, &rdat );				
		printf("get data=%x\n", rdat);
		if((rdat&(0x7<<0))== (0x4<<0)) 	printf("Port %d GPHY BIST PASS\n",i);
		else 			{	printf("Port %d GPHY BIST FAIL\n",i);	err++; }
a000b458:	0c002325 	jal	a0008c94 <dprintf>
a000b45c:	02002821 	move	a1,s0
a000b460:	26310001 	addiu	s1,s1,1
	rtl8651_setAsicEthernetPHYReg(0, 22, 0x0005 );	
	
	delay_ms(100);
	printf("\n");
	
	for(i=0;i<5;i++)
a000b464:	26100001 	addiu	s0,s0,1
a000b468:	24020005 	li	v0,5
a000b46c:	1602ff71 	bne	s0,v0,a000b234 <GPHY_BIST+0x304>
a000b470:	00000000 	nop
		else 			{	printf("Port %d GPHY BIST FAIL\n",i);	err++; }
					
						
	}	
	
	if(err==0)
a000b474:	16200005 	bnez	s1,a000b48c <GPHY_BIST+0x55c>
a000b478:	3c04a001 	lui	a0,0xa001
		printf("==> GPHY BIST ALL PASS <== \n");
a000b47c:	0c002325 	jal	a0008c94 <dprintf>
a000b480:	24845cdc 	addiu	a0,a0,23772
	else
		printf("==> GPHY BIST FAIL count=%d <== \n", err);				
}
a000b484:	08002d28 	j	a000b4a0 <GPHY_BIST+0x570>
a000b488:	8fbf0054 	lw	ra,84(sp)
	}	
	
	if(err==0)
		printf("==> GPHY BIST ALL PASS <== \n");
	else
		printf("==> GPHY BIST FAIL count=%d <== \n", err);				
a000b48c:	3c04a001 	lui	a0,0xa001
a000b490:	24845cfc 	addiu	a0,a0,23804
a000b494:	0c002325 	jal	a0008c94 <dprintf>
a000b498:	02202821 	move	a1,s1
}
a000b49c:	8fbf0054 	lw	ra,84(sp)
a000b4a0:	8fbe0050 	lw	s8,80(sp)
a000b4a4:	8fb7004c 	lw	s7,76(sp)
a000b4a8:	8fb60048 	lw	s6,72(sp)
a000b4ac:	8fb50044 	lw	s5,68(sp)
a000b4b0:	8fb40040 	lw	s4,64(sp)
a000b4b4:	8fb3003c 	lw	s3,60(sp)
a000b4b8:	8fb20038 	lw	s2,56(sp)
a000b4bc:	8fb10034 	lw	s1,52(sp)
a000b4c0:	8fb00030 	lw	s0,48(sp)
a000b4c4:	03e00008 	jr	ra
a000b4c8:	27bd0058 	addiu	sp,sp,88

a000b4cc <ExtractACmdLine>:

};  

//return position 
unsigned int ExtractACmdLine(const char *pPattScript,  char *pOneCmdString, int first)
{
a000b4cc:	27bdffe0 	addiu	sp,sp,-32
a000b4d0:	afbf001c 	sw	ra,28(sp)
a000b4d4:	afb20018 	sw	s2,24(sp)
a000b4d8:	afb10014 	sw	s1,20(sp)
a000b4dc:	afb00010 	sw	s0,16(sp)
a000b4e0:	00809021 	move	s2,a0
	//first=1 reset index, to buffer head
	//first=0 continue read a line

	static unsigned int idx=0;
	unsigned char *p=pPattScript+idx;
a000b4e4:	3c02a002 	lui	v0,0xa002
a000b4e8:	8c508920 	lw	s0,-30432(v0)
	int push=0;
	
	if(first==1)
a000b4ec:	24020001 	li	v0,1
a000b4f0:	14c20005 	bne	a2,v0,a000b508 <ExtractACmdLine+0x3c>
a000b4f4:	00a08821 	move	s1,a1
	{	idx=0;
a000b4f8:	3c02a002 	lui	v0,0xa002
a000b4fc:	ac408920 	sw	zero,-30432(v0)
		return 0;
a000b500:	08002d93 	j	a000b64c <ExtractACmdLine+0x180>
a000b504:	00001021 	move	v0,zero
{
	//first=1 reset index, to buffer head
	//first=0 continue read a line

	static unsigned int idx=0;
	unsigned char *p=pPattScript+idx;
a000b508:	00908021 	addu	s0,a0,s0
	if(first==1)
	{	idx=0;
		return 0;
	}
	
	memset( pOneCmdString, 0, MAX_MONITOR_BUFFER );
a000b50c:	00a02021 	move	a0,a1
a000b510:	00002821 	move	a1,zero
a000b514:	0c00203d 	jal	a00080f4 <memset>
a000b518:	24060080 	li	a2,128
a000b51c:	02204821 	move	t1,s1
a000b520:	240a0001 	li	t2,1
a000b524:	00004021 	move	t0,zero
	while( *p )
	{
		if(n==0)
		{
			//skip first return-line
			while( *p && ((*p == 0x0d) ||(*p==0x0a) ||(*p=='\t') ||(*p==' ') ) )
a000b528:	2403000d 	li	v1,13
a000b52c:	2404000a 	li	a0,10
a000b530:	24060009 	li	a2,9
a000b534:	24070020 	li	a3,32
				p++;
		}

		if ((n==0) && (*p =='~') )
a000b538:	240b007e 	li	t3,126


		//end
		if(n!=0)
		{
			if( (*p == 0x0d)  || (*p == 0x0a)  || (*p == '#'))
a000b53c:	240c0023 	li	t4,35
		}
	
		pOneCmdString[n] = *p ;
		n++;		
		p++;	
		if (n == 80) break;
a000b540:	240d0050 	li	t5,80
	
	memset( pOneCmdString, 0, MAX_MONITOR_BUFFER );


	int n=0;
	while( *p )
a000b544:	08002d7a 	j	a000b5e8 <ExtractACmdLine+0x11c>
a000b548:	240e0020 	li	t6,32
	{
		if(n==0)
a000b54c:	10a00007 	beqz	a1,a000b56c <ExtractACmdLine+0xa0>
a000b550:	00000000 	nop
a000b554:	08002d66 	j	a000b598 <ExtractACmdLine+0xcc>
a000b558:	00000000 	nop
		{
			//skip first return-line
			while( *p && ((*p == 0x0d) ||(*p==0x0a) ||(*p=='\t') ||(*p==' ') ) )
				p++;
a000b55c:	26100001 	addiu	s0,s0,1
	while( *p )
	{
		if(n==0)
		{
			//skip first return-line
			while( *p && ((*p == 0x0d) ||(*p==0x0a) ||(*p=='\t') ||(*p==' ') ) )
a000b560:	92020000 	lbu	v0,0(s0)
a000b564:	1040003f 	beqz	v0,a000b664 <ExtractACmdLine+0x198>
a000b568:	00000000 	nop
a000b56c:	1043fffb 	beq	v0,v1,a000b55c <ExtractACmdLine+0x90>
a000b570:	00000000 	nop
a000b574:	1044fff9 	beq	v0,a0,a000b55c <ExtractACmdLine+0x90>
a000b578:	00000000 	nop
a000b57c:	1046fff7 	beq	v0,a2,a000b55c <ExtractACmdLine+0x90>
a000b580:	00000000 	nop
a000b584:	1047fff6 	beq	v0,a3,a000b560 <ExtractACmdLine+0x94>
a000b588:	26100001 	addiu	s0,s0,1
a000b58c:	2610ffff 	addiu	s0,s0,-1
				p++;
		}

		if ((n==0) && (*p =='~') )
a000b590:	08002d99 	j	a000b664 <ExtractACmdLine+0x198>
a000b594:	92020000 	lbu	v0,0(s0)


		//end
		if(n!=0)
		{
			if( (*p == 0x0d)  || (*p == 0x0a)  || (*p == '#'))
a000b598:	10430005 	beq	v0,v1,a000b5b0 <ExtractACmdLine+0xe4>
a000b59c:	00000000 	nop
a000b5a0:	10440003 	beq	v0,a0,a000b5b0 <ExtractACmdLine+0xe4>
a000b5a4:	00000000 	nop
a000b5a8:	144c0004 	bne	v0,t4,a000b5bc <ExtractACmdLine+0xf0>
a000b5ac:	00000000 	nop
			{	pOneCmdString[n] = 0 ;
a000b5b0:	02251021 	addu	v0,s1,a1
				break;
a000b5b4:	08002d7d 	j	a000b5f4 <ExtractACmdLine+0x128>
a000b5b8:	a0400000 	sb	zero,0(v0)
			}
			if(*p==0x09) //TAB->SPACE
a000b5bc:	14460002 	bne	v0,a2,a000b5c8 <ExtractACmdLine+0xfc>
a000b5c0:	00000000 	nop
				*p=' ';
a000b5c4:	a20e0000 	sb	t6,0(s0)
		}
	
		pOneCmdString[n] = *p ;
a000b5c8:	92020000 	lbu	v0,0(s0)
a000b5cc:	a1220000 	sb	v0,0(t1)
a000b5d0:	01402821 	move	a1,t2
		n++;		
		p++;	
		if (n == 80) break;
a000b5d4:	114d002a 	beq	t2,t5,a000b680 <ExtractACmdLine+0x1b4>
a000b5d8:	26100001 	addiu	s0,s0,1
a000b5dc:	25080001 	addiu	t0,t0,1
a000b5e0:	254a0001 	addiu	t2,t2,1
a000b5e4:	25290001 	addiu	t1,t1,1
	
	memset( pOneCmdString, 0, MAX_MONITOR_BUFFER );


	int n=0;
	while( *p )
a000b5e8:	92020000 	lbu	v0,0(s0)
a000b5ec:	1440ffd7 	bnez	v0,a000b54c <ExtractACmdLine+0x80>
a000b5f0:	01002821 	move	a1,t0
		pOneCmdString[n] = *p ;
		n++;		
		p++;	
		if (n == 80) break;
	}
	idx= (int)p-(int)pPattScript+1;
a000b5f4:	02121023 	subu	v0,s0,s2
a000b5f8:	24420001 	addiu	v0,v0,1
a000b5fc:	3c03a002 	lui	v1,0xa002
a000b600:	ac628920 	sw	v0,-30432(v1)

	//thrim last space
	for(;n>1;n--)
a000b604:	28a30002 	slti	v1,a1,2
a000b608:	10600021 	beqz	v1,a000b690 <ExtractACmdLine+0x1c4>
a000b60c:	8fbf001c 	lw	ra,28(sp)
		}

	//dprintf("test=> %s \r\n", pOneCmdString);
	return idx;	

}
a000b610:	08002d95 	j	a000b654 <ExtractACmdLine+0x188>
a000b614:	8fb20018 	lw	s2,24(sp)
	}
	idx= (int)p-(int)pPattScript+1;

	//thrim last space
	for(;n>1;n--)
		if( (pOneCmdString[n-1]!=' ')  &&  (pOneCmdString[n-1]!='\t') )
a000b618:	8064ffff 	lb	a0,-1(v1)
a000b61c:	10860007 	beq	a0,a2,a000b63c <ExtractACmdLine+0x170>
a000b620:	00000000 	nop
a000b624:	10880006 	beq	a0,t0,a000b640 <ExtractACmdLine+0x174>
a000b628:	24a5ffff 	addiu	a1,a1,-1
a000b62c:	24a50001 	addiu	a1,a1,1
		{	pOneCmdString[n]=0;
a000b630:	02253821 	addu	a3,s1,a1
			break;
a000b634:	08002d93 	j	a000b64c <ExtractACmdLine+0x180>
a000b638:	a0e00000 	sb	zero,0(a3)
		if (n == 80) break;
	}
	idx= (int)p-(int)pPattScript+1;

	//thrim last space
	for(;n>1;n--)
a000b63c:	24a5ffff 	addiu	a1,a1,-1
a000b640:	28a40002 	slti	a0,a1,2
a000b644:	1080fff4 	beqz	a0,a000b618 <ExtractACmdLine+0x14c>
a000b648:	2463ffff 	addiu	v1,v1,-1
		}

	//dprintf("test=> %s \r\n", pOneCmdString);
	return idx;	

}
a000b64c:	8fbf001c 	lw	ra,28(sp)
a000b650:	8fb20018 	lw	s2,24(sp)
a000b654:	8fb10014 	lw	s1,20(sp)
a000b658:	8fb00010 	lw	s0,16(sp)
a000b65c:	03e00008 	jr	ra
a000b660:	27bd0020 	addiu	sp,sp,32
			//skip first return-line
			while( *p && ((*p == 0x0d) ||(*p==0x0a) ||(*p=='\t') ||(*p==' ') ) )
				p++;
		}

		if ((n==0) && (*p =='~') )
a000b664:	144b0003 	bne	v0,t3,a000b674 <ExtractACmdLine+0x1a8>
a000b668:	00000000 	nop
a000b66c:	08002d93 	j	a000b64c <ExtractACmdLine+0x180>
a000b670:	00001021 	move	v0,zero
			}
			if(*p==0x09) //TAB->SPACE
				*p=' ';
		}
	
		pOneCmdString[n] = *p ;
a000b674:	a1220000 	sb	v0,0(t1)
		n++;		
		p++;	
a000b678:	08002d77 	j	a000b5dc <ExtractACmdLine+0x110>
a000b67c:	26100001 	addiu	s0,s0,1
		if (n == 80) break;
	}
	idx= (int)p-(int)pPattScript+1;
a000b680:	02121023 	subu	v0,s0,s2
a000b684:	24420001 	addiu	v0,v0,1
a000b688:	3c03a002 	lui	v1,0xa002
a000b68c:	ac628920 	sw	v0,-30432(v1)
a000b690:	02251821 	addu	v1,s1,a1

	//thrim last space
	for(;n>1;n--)
		if( (pOneCmdString[n-1]!=' ')  &&  (pOneCmdString[n-1]!='\t') )
a000b694:	24060020 	li	a2,32
a000b698:	08002d86 	j	a000b618 <ExtractACmdLine+0x14c>
a000b69c:	24080009 	li	t0,9

a000b6a0 <CmdMEMCLK>:
#endif		
	dprintf("Change M2x clock freq=%d \n", m2x_clksel_table[clk_sel] );
}
//---------------------------------------------------------------------------
int CmdMEMCLK(int argc, char* argv[])
{
a000b6a0:	27bdffd8 	addiu	sp,sp,-40
a000b6a4:	afbf0024 	sw	ra,36(sp)
a000b6a8:	afb30020 	sw	s3,32(sp)
a000b6ac:	afb2001c 	sw	s2,28(sp)
a000b6b0:	afb10018 	sw	s1,24(sp)
a000b6b4:	afb00014 	sw	s0,20(sp)

	int clk_sel=0;
	int tmp;
	if( argc < 1 ) 
a000b6b8:	1c80001f 	bgtz	a0,a000b738 <CmdMEMCLK+0x98>
a000b6bc:	00000000 	nop
	{
		dprintf("Usage: MEMCLK <sel>: 0-7  \n");		
a000b6c0:	3c04a001 	lui	a0,0xa001
a000b6c4:	0c002325 	jal	a0008c94 <dprintf>
a000b6c8:	24845e58 	addiu	a0,a0,24152
a000b6cc:	3c11a001 	lui	s1,0xa001
a000b6d0:	26310440 	addiu	s1,s1,1088
a000b6d4:	00008021 	move	s0,zero
		int i;
		for(i=0; i<8;i++)
		dprintf(" %d : %d MHz \n", i, m2x_clksel_table[i]);
a000b6d8:	3c12a001 	lui	s2,0xa001
a000b6dc:	26525e74 	addiu	s2,s2,24180
	int tmp;
	if( argc < 1 ) 
	{
		dprintf("Usage: MEMCLK <sel>: 0-7  \n");		
		int i;
		for(i=0; i<8;i++)
a000b6e0:	24130008 	li	s3,8
		dprintf(" %d : %d MHz \n", i, m2x_clksel_table[i]);
a000b6e4:	02402021 	move	a0,s2
a000b6e8:	02002821 	move	a1,s0
a000b6ec:	0c002325 	jal	a0008c94 <dprintf>
a000b6f0:	8e260000 	lw	a2,0(s1)
	int tmp;
	if( argc < 1 ) 
	{
		dprintf("Usage: MEMCLK <sel>: 0-7  \n");		
		int i;
		for(i=0; i<8;i++)
a000b6f4:	26100001 	addiu	s0,s0,1
a000b6f8:	1613fffa 	bne	s0,s3,a000b6e4 <CmdMEMCLK+0x44>
a000b6fc:	26310004 	addiu	s1,s1,4
		dprintf(" %d : %d MHz \n", i, m2x_clksel_table[i]);
		
		int	m2xsel=(REG32(SYS_HW_STRAP) & (CK_M2X_FREQ_SEL))>>10;
a000b700:	3c02b800 	lui	v0,0xb800
a000b704:	34420008 	ori	v0,v0,0x8
a000b708:	8c450000 	lw	a1,0(v0)
a000b70c:	7ca52280 	ext	a1,a1,0xa,0x5
		dprintf("status: %d = %d Mhz \n",  m2xsel, m2x_clksel_table[m2xsel] );
a000b710:	00051880 	sll	v1,a1,0x2
a000b714:	3c02a001 	lui	v0,0xa001
a000b718:	24420440 	addiu	v0,v0,1088
a000b71c:	00621021 	addu	v0,v1,v0
a000b720:	3c04a001 	lui	a0,0xa001
a000b724:	24845e84 	addiu	a0,a0,24196
a000b728:	0c002325 	jal	a0008c94 <dprintf>
a000b72c:	8c460000 	lw	a2,0(v0)
		return;	
a000b730:	08002dd5 	j	a000b754 <CmdMEMCLK+0xb4>
a000b734:	8fbf0024 	lw	ra,36(sp)
	}
	

	clk_sel = strtoul((const char*)(argv[0]), (char **)NULL, 16);
a000b738:	8ca40000 	lw	a0,0(a1)
a000b73c:	00002821 	move	a1,zero
a000b740:	0c0020c4 	jal	a0008310 <strtoul>
a000b744:	24060010 	li	a2,16
		SettingM2xClk(clk_sel);
a000b748:	0c00279b 	jal	a0009e6c <SettingM2xClk>
a000b74c:	00402021 	move	a0,v0


}
a000b750:	8fbf0024 	lw	ra,36(sp)
a000b754:	8fb30020 	lw	s3,32(sp)
a000b758:	8fb2001c 	lw	s2,28(sp)
a000b75c:	8fb10018 	lw	s1,24(sp)
a000b760:	8fb00014 	lw	s0,20(sp)
a000b764:	03e00008 	jr	ra
a000b768:	27bd0028 	addiu	sp,sp,40

a000b76c <TestStrapPin>:
}

//=================================================================================

int TestStrapPin(int argc, char* argv[])
{
a000b76c:	27bdffe0 	addiu	sp,sp,-32
a000b770:	afbf001c 	sw	ra,28(sp)
a000b774:	afb10018 	sw	s1,24(sp)
a000b778:	afb00014 	sw	s0,20(sp)

	if(argc < 2) 
a000b77c:	28840002 	slti	a0,a0,2
a000b780:	10800008 	beqz	a0,a000b7a4 <TestStrapPin+0x38>
a000b784:	00a08021 	move	s0,a1
	{	ShowStrapMsg();
a000b788:	0c002870 	jal	a000a1c0 <ShowStrapMsg>
a000b78c:	00000000 	nop
		dprintf("Usage: strap bit value \n\n");	
a000b790:	3c04a001 	lui	a0,0xa001
a000b794:	0c002325 	jal	a0008c94 <dprintf>
a000b798:	24845e9c 	addiu	a0,a0,24220
	{
		dprintf("Unsupport value \n");	
	}
	ShowStrapMsg();
	
}
a000b79c:	08002e0d 	j	a000b834 <TestStrapPin+0xc8>
a000b7a0:	24020001 	li	v0,1
	if(argc < 2) 
	{	ShowStrapMsg();
		dprintf("Usage: strap bit value \n\n");	
		return 1;
	}
	unsigned int bit = strtoul((const char*)(argv[0]), (char **)NULL, 10);		
a000b7a4:	8ca40000 	lw	a0,0(a1)
a000b7a8:	00002821 	move	a1,zero
a000b7ac:	0c0020c4 	jal	a0008310 <strtoul>
a000b7b0:	2406000a 	li	a2,10
a000b7b4:	00408821 	move	s1,v0
	unsigned int val = strtoul((const char*)(argv[1]), (char **)NULL, 16);		
a000b7b8:	8e040004 	lw	a0,4(s0)
a000b7bc:	00002821 	move	a1,zero
a000b7c0:	0c0020c4 	jal	a0008310 <strtoul>
a000b7c4:	24060010 	li	a2,16


	if(val==0)
a000b7c8:	1440000b 	bnez	v0,a000b7f8 <TestStrapPin+0x8c>
a000b7cc:	24030001 	li	v1,1
	{		
		REG32(SYS_HW_STRAP) &= ~(1<<bit);		
a000b7d0:	3c02b800 	lui	v0,0xb800
a000b7d4:	34420008 	ori	v0,v0,0x8
a000b7d8:	8c430000 	lw	v1,0(v0)
a000b7dc:	24040001 	li	a0,1
a000b7e0:	02248804 	sllv	s1,a0,s1
a000b7e4:	00118827 	nor	s1,zero,s1
a000b7e8:	02238824 	and	s1,s1,v1
a000b7ec:	ac510000 	sw	s1,0(v0)
a000b7f0:	08002e0b 	j	a000b82c <TestStrapPin+0xc0>
a000b7f4:	00000000 	nop
	}
	else if(val==1)
a000b7f8:	1443000a 	bne	v0,v1,a000b824 <TestStrapPin+0xb8>
a000b7fc:	3c04a001 	lui	a0,0xa001
	{			
		REG32(SYS_HW_STRAP) |= (1<<bit);		
a000b800:	3c02b800 	lui	v0,0xb800
a000b804:	34420008 	ori	v0,v0,0x8
a000b808:	8c430000 	lw	v1,0(v0)
a000b80c:	24040001 	li	a0,1
a000b810:	02248804 	sllv	s1,a0,s1
a000b814:	02238825 	or	s1,s1,v1
a000b818:	ac510000 	sw	s1,0(v0)
a000b81c:	08002e0b 	j	a000b82c <TestStrapPin+0xc0>
a000b820:	00000000 	nop
	}
	else
	{
		dprintf("Unsupport value \n");	
a000b824:	0c002325 	jal	a0008c94 <dprintf>
a000b828:	24845eb8 	addiu	a0,a0,24248
	}
	ShowStrapMsg();
a000b82c:	0c002870 	jal	a000a1c0 <ShowStrapMsg>
a000b830:	00000000 	nop
	
}
a000b834:	8fbf001c 	lw	ra,28(sp)
a000b838:	8fb10018 	lw	s1,24(sp)
a000b83c:	8fb00014 	lw	s0,20(sp)
a000b840:	03e00008 	jr	ra
a000b844:	27bd0020 	addiu	sp,sp,32

a000b848 <SettingLxClk>:

}
//---------------------------------------------------------------------------

int SettingLxClk(int clklx_from_clkm)
{	
a000b848:	27bdffc0 	addiu	sp,sp,-64
a000b84c:	afbf003c 	sw	ra,60(sp)
a000b850:	afb20038 	sw	s2,56(sp)
a000b854:	afb10034 	sw	s1,52(sp)
a000b858:	afb00030 	sw	s0,48(sp)
a000b85c:	00808821 	move	s1,a0
	
	int	tmp=REG32(SYS_HW_STRAP) & ~(ST_CLKLX_FROM_HALFOC);
a000b860:	3c02b800 	lui	v0,0xb800
a000b864:	34420008 	ori	v0,v0,0x8
a000b868:	8c450000 	lw	a1,0(v0)
	int strap_newval= tmp | ((clklx_from_clkm&0x01) <<ST_CLKLX_FROM_HALFOC_OFFSET) ;

	//--------------------------------------
	//int lexra_newval;

	if(clklx_from_clkm==0)
a000b86c:	14800006 	bnez	a0,a000b888 <SettingLxClk+0x40>
a000b870:	3c0207d2 	lui	v0,0x7d2
	{	
		glexra_clock=200*1000*1000;
a000b874:	3c030beb 	lui	v1,0xbeb
a000b878:	3463c200 	ori	v1,v1,0xc200
a000b87c:	3c02a001 	lui	v0,0xa001
a000b880:	08002e43 	j	a000b90c <SettingLxClk+0xc4>
a000b884:	ac437670 	sw	v1,30320(v0)
	}
	else
	{
		//prepare uart 
		unsigned long mem2x_clksel_table[]={ 131250000, 156250000, 300000000, 250000000,  312500000, 337500000, 475000000, 387500000 	};
a000b888:	3442b750 	ori	v0,v0,0xb750
a000b88c:	afa20010 	sw	v0,16(sp)
a000b890:	3c020950 	lui	v0,0x950
a000b894:	34422f90 	ori	v0,v0,0x2f90
a000b898:	afa20014 	sw	v0,20(sp)
a000b89c:	3c0211e1 	lui	v0,0x11e1
a000b8a0:	3442a300 	ori	v0,v0,0xa300
a000b8a4:	afa20018 	sw	v0,24(sp)
a000b8a8:	3c020ee6 	lui	v0,0xee6
a000b8ac:	3442b280 	ori	v0,v0,0xb280
a000b8b0:	afa2001c 	sw	v0,28(sp)
a000b8b4:	3c0212a0 	lui	v0,0x12a0
a000b8b8:	34425f20 	ori	v0,v0,0x5f20
a000b8bc:	afa20020 	sw	v0,32(sp)
a000b8c0:	3c02141d 	lui	v0,0x141d
a000b8c4:	3442d760 	ori	v0,v0,0xd760
a000b8c8:	afa20024 	sw	v0,36(sp)
a000b8cc:	3c021c4f 	lui	v0,0x1c4f
a000b8d0:	3442ecc0 	ori	v0,v0,0xecc0
a000b8d4:	afa20028 	sw	v0,40(sp)
a000b8d8:	3c021718 	lui	v0,0x1718
a000b8dc:	3442c7e0 	ori	v0,v0,0xc7e0
a000b8e0:	afa2002c 	sw	v0,44(sp)
		int	m2xsel=(REG32(SYS_HW_STRAP) & (CK_M2X_FREQ_SEL))>>CK_M2X_FREQ_SEL_OFFSET;
a000b8e4:	3c02b800 	lui	v0,0xb800
a000b8e8:	34420008 	ori	v0,v0,0x8
a000b8ec:	8c420000 	lw	v0,0(v0)
	       glexra_clock=mem2x_clksel_table[m2xsel] /2;
a000b8f0:	7c422280 	ext	v0,v0,0xa,0x5
a000b8f4:	00021080 	sll	v0,v0,0x2
a000b8f8:	03a21021 	addu	v0,sp,v0
a000b8fc:	8c430010 	lw	v1,16(v0)
a000b900:	00031842 	srl	v1,v1,0x1
a000b904:	3c02a001 	lui	v0,0xa001
a000b908:	ac437670 	sw	v1,30320(v0)

	}
	//--------------------------------------
	int gimr_tmp=REG32(GIMR_REG);
a000b90c:	3c02b800 	lui	v0,0xb800
a000b910:	34433000 	ori	v1,v0,0x3000
a000b914:	8c720000 	lw	s2,0(v1)
	REG32(GIMR_REG)=0;
a000b918:	ac600000 	sw	zero,0(v1)
	

		#if 1  //lock bus			
			REG32(SYS_LX_CTRL) |= (1<<2) ;	  //lock bus arb2
a000b91c:	34420014 	ori	v0,v0,0x14
a000b920:	8c430000 	lw	v1,0(v0)
a000b924:	34630004 	ori	v1,v1,0x4
a000b928:	ac430000 	sw	v1,0(v0)
			while( (REG32(SYS_BIST_DONE)&(1<<0))==0)  ; //wait bit to 1, is mean lock ok	
a000b92c:	3c03b800 	lui	v1,0xb800
a000b930:	34630020 	ori	v1,v1,0x20
a000b934:	8c620000 	lw	v0,0(v1)
a000b938:	30420001 	andi	v0,v0,0x1
a000b93c:	1040fffd 	beqz	v0,a000b934 <SettingLxClk+0xec>
a000b940:	3c02b800 	lui	v0,0xb800

			REG32(SYS_LX_CTRL) |= (1<<3) ;	  //lock bus arb4
a000b944:	34420014 	ori	v0,v0,0x14
a000b948:	8c430000 	lw	v1,0(v0)
a000b94c:	34630008 	ori	v1,v1,0x8
a000b950:	ac430000 	sw	v1,0(v0)
			while( (REG32(SYS_BIST_DONE)&(1<<1))==0)  ; //wait bit to 1, is mean lock ok		
a000b954:	3c03b800 	lui	v1,0xb800
a000b958:	34630020 	ori	v1,v1,0x20
a000b95c:	8c620000 	lw	v0,0(v1)
a000b960:	30420002 	andi	v0,v0,0x2
a000b964:	1040fffd 	beqz	v0,a000b95c <SettingLxClk+0x114>
a000b968:	3c02b800 	lui	v0,0xb800

			REG32(SYS_LX_CTRL) |= (1<<4) ;	  //lock bus arb6
a000b96c:	34420014 	ori	v0,v0,0x14
a000b970:	8c430000 	lw	v1,0(v0)
a000b974:	34630010 	ori	v1,v1,0x10
a000b978:	ac430000 	sw	v1,0(v0)
			while( (REG32(SYS_BIST_DONE)&(1<<2))==0)  ; //wait bit to 1, is mean lock ok	
a000b97c:	3c03b800 	lui	v1,0xb800
a000b980:	34630020 	ori	v1,v1,0x20
a000b984:	8c620000 	lw	v0,0(v1)
a000b988:	30420004 	andi	v0,v0,0x4
a000b98c:	1040fffd 	beqz	v0,a000b984 <SettingLxClk+0x13c>
a000b990:	32220001 	andi	v0,s1,0x1
		#endif
	


	//go
	REG32(SYS_HW_STRAP)=strap_newval;    //change lx clk
a000b994:	00021540 	sll	v0,v0,0x15
a000b998:	3c04ffdf 	lui	a0,0xffdf
a000b99c:	3484ffff 	ori	a0,a0,0xffff
a000b9a0:	00a42024 	and	a0,a1,a0
a000b9a4:	00442025 	or	a0,v0,a0
a000b9a8:	3c02b800 	lui	v0,0xb800
a000b9ac:	34430008 	ori	v1,v0,0x8
a000b9b0:	ac640000 	sw	a0,0(v1)


		#if 1   //check m2xusable and unlock bus
			//while( (REG32(SYS_BIST_DONE)&(1<<18))==0)  ;   //wait to 1, mean m2x is usable
	
			REG32(SYS_LX_CTRL) &= ~(1<<2);	//unlock
a000b9b4:	34420014 	ori	v0,v0,0x14
a000b9b8:	8c440000 	lw	a0,0(v0)
a000b9bc:	2403fffb 	li	v1,-5
a000b9c0:	00831824 	and	v1,a0,v1
a000b9c4:	ac430000 	sw	v1,0(v0)
			while( (REG32(SYS_BIST_DONE)&(1<<0))==(1<<0)) ;  //wait bit to 0  unlock
a000b9c8:	3c03b800 	lui	v1,0xb800
a000b9cc:	34630020 	ori	v1,v1,0x20
a000b9d0:	8c620000 	lw	v0,0(v1)
a000b9d4:	30420001 	andi	v0,v0,0x1
a000b9d8:	1440fffd 	bnez	v0,a000b9d0 <SettingLxClk+0x188>
a000b9dc:	3c02b800 	lui	v0,0xb800

			REG32(SYS_LX_CTRL) &= ~(1<<3);	//unlock
a000b9e0:	34420014 	ori	v0,v0,0x14
a000b9e4:	8c440000 	lw	a0,0(v0)
a000b9e8:	2403fff7 	li	v1,-9
a000b9ec:	00831824 	and	v1,a0,v1
a000b9f0:	ac430000 	sw	v1,0(v0)
			while( (REG32(SYS_BIST_DONE)&(1<<1))==(1<<1)) ;  //wait bit to 0  unlock
a000b9f4:	3c03b800 	lui	v1,0xb800
a000b9f8:	34630020 	ori	v1,v1,0x20
a000b9fc:	8c620000 	lw	v0,0(v1)
a000ba00:	30420002 	andi	v0,v0,0x2
a000ba04:	1440fffd 	bnez	v0,a000b9fc <SettingLxClk+0x1b4>
a000ba08:	3c02b800 	lui	v0,0xb800

			REG32(SYS_LX_CTRL) &= ~(1<<4);	//unlock
a000ba0c:	34420014 	ori	v0,v0,0x14
a000ba10:	8c440000 	lw	a0,0(v0)
a000ba14:	2403ffef 	li	v1,-17
a000ba18:	00831824 	and	v1,a0,v1
a000ba1c:	ac430000 	sw	v1,0(v0)
			while( (REG32(SYS_BIST_DONE)&(1<<2))==(1<<2)) ;  //wait bit to 0  unlock	
a000ba20:	3c03b800 	lui	v1,0xb800
a000ba24:	34630020 	ori	v1,v1,0x20
a000ba28:	8c620000 	lw	v0,0(v1)
a000ba2c:	30420004 	andi	v0,v0,0x4
a000ba30:	1440fffd 	bnez	v0,a000ba28 <SettingLxClk+0x1e0>
a000ba34:	3c10a001 	lui	s0,0xa001
		#endif

		
	console_init(glexra_clock);
a000ba38:	0c003693 	jal	a000da4c <console_init>
a000ba3c:	8e047670 	lw	a0,30320(s0)
	timer_init(glexra_clock);
a000ba40:	0c0038f0 	jal	a000e3c0 <timer_init>
a000ba44:	8e047670 	lw	a0,30320(s0)

		
	REG32(GIMR_REG)=gimr_tmp;
a000ba48:	3c02b800 	lui	v0,0xb800
a000ba4c:	34423000 	ori	v0,v0,0x3000
a000ba50:	ac520000 	sw	s2,0(v0)



	

	dprintf("clklx_from_clkm=%d \n", clklx_from_clkm );
a000ba54:	3c04a001 	lui	a0,0xa001
a000ba58:	24845ecc 	addiu	a0,a0,24268
a000ba5c:	0c002325 	jal	a0008c94 <dprintf>
a000ba60:	02202821 	move	a1,s1
	
}
a000ba64:	8fbf003c 	lw	ra,60(sp)
a000ba68:	8fb20038 	lw	s2,56(sp)
a000ba6c:	8fb10034 	lw	s1,52(sp)
a000ba70:	8fb00030 	lw	s0,48(sp)
a000ba74:	03e00008 	jr	ra
a000ba78:	27bd0040 	addiu	sp,sp,64

a000ba7c <CmdLXCLK>:

int CmdLXCLK(int argc, char* argv[])
{
a000ba7c:	27bdffe8 	addiu	sp,sp,-24
a000ba80:	afbf0014 	sw	ra,20(sp)
	if( argc < 1 ) 
a000ba84:	1c80000d 	bgtz	a0,a000babc <CmdLXCLK+0x40>
a000ba88:	00000000 	nop
	{
		dprintf("Usage: LXCLK <sel>: 0-1  \r\n");		
a000ba8c:	3c04a001 	lui	a0,0xa001
a000ba90:	0c002325 	jal	a0008c94 <dprintf>
a000ba94:	24845ee4 	addiu	a0,a0,24292
		int	lxsel=(REG32(SYS_HW_STRAP) & (ST_CLKLX_FROM_HALFOC))>>ST_CLKLX_FROM_HALFOC_OFFSET;
a000ba98:	3c02b800 	lui	v0,0xb800
a000ba9c:	34420008 	ori	v0,v0,0x8
a000baa0:	8c450000 	lw	a1,0(v0)
		dprintf("status: %d \n", lxsel );		
a000baa4:	3c04a001 	lui	a0,0xa001
a000baa8:	24845f00 	addiu	a0,a0,24320
a000baac:	0c002325 	jal	a0008c94 <dprintf>
a000bab0:	7ca50540 	ext	a1,a1,0x15,0x1
		return;	
a000bab4:	08002eb6 	j	a000bad8 <CmdLXCLK+0x5c>
a000bab8:	8fbf0014 	lw	ra,20(sp)
	}

	
	int clklx_from_clkm = strtoul((const char*)(argv[0]), (char **)NULL, 16);
a000babc:	8ca40000 	lw	a0,0(a1)
a000bac0:	00002821 	move	a1,zero
a000bac4:	0c0020c4 	jal	a0008310 <strtoul>
a000bac8:	24060010 	li	a2,16
	SettingLxClk(clklx_from_clkm);
a000bacc:	0c002e12 	jal	a000b848 <SettingLxClk>
a000bad0:	00402021 	move	a0,v0


	//--------------------------------------


};  
a000bad4:	8fbf0014 	lw	ra,20(sp)
a000bad8:	03e00008 	jr	ra
a000badc:	27bd0018 	addiu	sp,sp,24

a000bae0 <SettingCPUClk>:
#endif
}
//---------------------------------------------------------------------------

int SettingCPUClk(int clk_sel, int clk_div)
{
a000bae0:	27bdffe0 	addiu	sp,sp,-32
a000bae4:	afbf001c 	sw	ra,28(sp)
a000bae8:	afb20018 	sw	s2,24(sp)
a000baec:	afb10014 	sw	s1,20(sp)
a000baf0:	afb00010 	sw	s0,16(sp)
a000baf4:	00808021 	move	s0,a0
a000baf8:	00a08821 	move	s1,a1
	int clk_curr, clk_exp;	
	unsigned int old_clk_sel;
	unsigned int mask;
	unsigned int sysreg;

	REG32(SYS_INT_STATUS)=(1<<1);  //clear cpu wakeup.
a000bafc:	3c02b800 	lui	v0,0xb800
a000bb00:	34430004 	ori	v1,v0,0x4
a000bb04:	24040002 	li	a0,2
a000bb08:	ac640000 	sw	a0,0(v1)

#if 1  //check core 1 exist
		#define POLLING_REG 0xb800006c
  		#define PATT_SLEEP  0x3333		
  		#define PATT_READY  0x5555
	if(REG32(POLLING_REG)!=PATT_SLEEP)
a000bb0c:	3442006c 	ori	v0,v0,0x6c
a000bb10:	8c440000 	lw	a0,0(v0)
a000bb14:	24033333 	li	v1,13107
a000bb18:	14830074 	bne	a0,v1,a000bcec <SettingCPUClk+0x20c>
a000bb1c:	00001021 	move	v0,zero
	}


#endif
	
	clk_curr = check_cpu_speed();
a000bb20:	0c003edc 	jal	a000fb70 <check_cpu_speed>
a000bb24:	3c12b800 	lui	s2,0xb800
#ifdef _verbose
	dprintf("Now CPU Speed=%d \n",clk_curr);	
#endif
	//----------------------------
	REG32(SYS_INT_STATUS)=(1<<1);  //enable cpu wakeup interrupt mask
a000bb28:	36420004 	ori	v0,s2,0x4
a000bb2c:	24030002 	li	v1,2
a000bb30:	ac430000 	sw	v1,0(v0)

	request_IRQ(SPEED_IRQ_NO, &irq_SPEED, NULL); 	
a000bb34:	2404002b 	li	a0,43
a000bb38:	3c05a001 	lui	a1,0xa001
a000bb3c:	24a57590 	addiu	a1,a1,30096
a000bb40:	0c000274 	jal	a00009d0 <request_IRQ>
a000bb44:	00003021 	move	a2,zero

	//-------------
	sysreg=REG32(SYS_HW_STRAP);
a000bb48:	36520008 	ori	s2,s2,0x8
a000bb4c:	8e430000 	lw	v1,0(s2)
	//dprintf("Read  SYS_HW_STRAP=%08x\r\n", sysreg);	
	old_clk_sel=(sysreg & ST_CPU_FREQ_SEL) >>ST_CPU_FREQ_SEL_OFFSET;

	sysreg&= ~(ST_FW_CPU_FREQDIV_SEL);
	sysreg&= ~(ST_CK_CPU_FREQDIV_SEL);	
	sysreg&= ~(ST_CPU_FREQ_SEL);
a000bb50:	3c02ffe0 	lui	v0,0xffe0
a000bb54:	34427fff 	ori	v0,v0,0x7fff
a000bb58:	00621024 	and	v0,v1,v0

	sysreg|=  (clk_div & 0x03) <<ST_CPU_FREQDIV_SEL_OFFSET ;
a000bb5c:	3205000f 	andi	a1,s0,0xf
a000bb60:	00052bc0 	sll	a1,a1,0xf
a000bb64:	00a22825 	or	a1,a1,v0
	sysreg|=	 (clk_sel&0x0f)<<ST_CPU_FREQ_SEL_OFFSET ;
a000bb68:	32220003 	andi	v0,s1,0x3
a000bb6c:	000214c0 	sll	v0,v0,0x13
a000bb70:	00a22825 	or	a1,a1,v0
	//-------------------------

	clk_exp=cpu_clksel_table[clk_sel] / cpu_clkdiv_table[clk_div];
a000bb74:	00102080 	sll	a0,s0,0x2
a000bb78:	3c02a001 	lui	v0,0xa001
a000bb7c:	24420400 	addiu	v0,v0,1024
a000bb80:	00821021 	addu	v0,a0,v0
a000bb84:	8c440000 	lw	a0,0(v0)
a000bb88:	00118880 	sll	s1,s1,0x2
a000bb8c:	3c02a001 	lui	v0,0xa001
a000bb90:	24427580 	addiu	v0,v0,30080
a000bb94:	02228821 	addu	s1,s1,v0
a000bb98:	8e220000 	lw	v0,0(s1)
	
#ifdef _verbose
	dprintf("Write SYS_HW_STRAP=%08x \n", sysreg);
#endif	

	REG32(SYS_HW_STRAP)=sysreg  ;
a000bb9c:	ae450000 	sw	a1,0(s2)
	//dprintf("Read  SYS_HW_STRAP=%08x \n", REG32(SYS_HW_STRAP));
	
	//--------------
	if(old_clk_sel != clk_sel)
a000bba0:	3c050007 	lui	a1,0x7
a000bba4:	34a58000 	ori	a1,a1,0x8000
a000bba8:	00651824 	and	v1,v1,a1
a000bbac:	00031bc2 	srl	v1,v1,0xf
a000bbb0:	1203004a 	beq	s0,v1,a000bcdc <SettingCPUClk+0x1fc>
a000bbb4:	00002821 	move	a1,zero
	{
#if 1
	HS0_Control(clk_exp, 0, 0, 0);
a000bbb8:	0082001b 	divu	zero,a0,v0
a000bbbc:	004001f4 	teq	v0,zero,0x7
a000bbc0:	00002012 	mflo	a0
a000bbc4:	00003021 	move	a2,zero
a000bbc8:	0c002817 	jal	a000a05c <HS0_Control>
a000bbcc:	00003821 	move	a3,zero
#endif	
		REG32(GISR_REG)=0xffffffff;	
a000bbd0:	3c02b800 	lui	v0,0xb800
a000bbd4:	34433004 	ori	v1,v0,0x3004
a000bbd8:	2404ffff 	li	a0,-1
a000bbdc:	ac640000 	sw	a0,0(v1)
		//dprintf("before sleep, Read  SYS_HW_STRAP=%08x \n", REG32(SYS_HW_STRAP));	
		//dprintf("GISR=%08x \n",REG32(GISR_REG));
		//dprintf("GIMR=%08x \n",REG32(GIMR_REG));	

		#if 1	
			REG32(SYS_CLKMANAGE) |= (1<<12)|(1<<13)|(1<<19)|(1<<20);  //active lx1 lx2
a000bbe0:	34430010 	ori	v1,v0,0x10
a000bbe4:	8c650000 	lw	a1,0(v1)
a000bbe8:	3c040018 	lui	a0,0x18
a000bbec:	34843000 	ori	a0,a0,0x3000
a000bbf0:	00a42025 	or	a0,a1,a0
a000bbf4:	ac640000 	sw	a0,0(v1)
		
			REG32(SYS_LX_CTRL) |= (1<<2) ;	  //lock bus arb2
a000bbf8:	34420014 	ori	v0,v0,0x14
a000bbfc:	8c430000 	lw	v1,0(v0)
a000bc00:	34630004 	ori	v1,v1,0x4
a000bc04:	ac430000 	sw	v1,0(v0)
			while( (REG32(SYS_LX_CTRL)&(1<<12))==0)  ; //wait bit to 1, is mean lock ok	
a000bc08:	00401821 	move	v1,v0
a000bc0c:	8c620000 	lw	v0,0(v1)
a000bc10:	30421000 	andi	v0,v0,0x1000
a000bc14:	1040fffd 	beqz	v0,a000bc0c <SettingCPUClk+0x12c>
a000bc18:	3c02b800 	lui	v0,0xb800

			REG32(SYS_LX_CTRL) |= (1<<3) ;	  //lock bus arb4
a000bc1c:	34420014 	ori	v0,v0,0x14
a000bc20:	8c430000 	lw	v1,0(v0)
a000bc24:	34630008 	ori	v1,v1,0x8
a000bc28:	ac430000 	sw	v1,0(v0)
			while( (REG32(SYS_LX_CTRL)&(1<<13))==0)  ; //wait bit to 1, is mean lock ok		
a000bc2c:	00401821 	move	v1,v0
a000bc30:	8c620000 	lw	v0,0(v1)
a000bc34:	30422000 	andi	v0,v0,0x2000
a000bc38:	1040fffd 	beqz	v0,a000bc30 <SettingCPUClk+0x150>
a000bc3c:	3c02b800 	lui	v0,0xb800

			REG32(SYS_LX_CTRL) |= (1<<4) ;	  //lock bus arb6
a000bc40:	34420014 	ori	v0,v0,0x14
a000bc44:	8c430000 	lw	v1,0(v0)
a000bc48:	34630010 	ori	v1,v1,0x10
a000bc4c:	ac430000 	sw	v1,0(v0)
			while( (REG32(SYS_LX_CTRL)&(1<<14))==0)  ; //wait bit to 1, is mean lock ok				
a000bc50:	00401821 	move	v1,v0
a000bc54:	8c620000 	lw	v0,0(v1)
a000bc58:	30424000 	andi	v0,v0,0x4000
a000bc5c:	1040fffd 	beqz	v0,a000bc54 <SettingCPUClk+0x174>
a000bc60:	00000000 	nop
	...
		
		__asm__ volatile("nop");
		__asm__ volatile("nop");
		__asm__ volatile("nop");
		__asm__ volatile("nop");
		__asm__ volatile("wait");	
a000bc74:	42000020 	wait
	...
		__asm__ volatile("nop");
		__asm__ volatile("nop");
		__asm__ volatile("nop");

		#if 1
			REG32(SYS_LX_CTRL) &= ~(1<<2);	//unlock
a000bc90:	3c03b800 	lui	v1,0xb800
a000bc94:	34620014 	ori	v0,v1,0x14
a000bc98:	8c450000 	lw	a1,0(v0)
a000bc9c:	2404fffb 	li	a0,-5
a000bca0:	00a42024 	and	a0,a1,a0
a000bca4:	ac440000 	sw	a0,0(v0)
			while( (REG32(SYS_LX_CTRL)&(1<<12))==(1<<0)) ;  //wait bit to 0  unlock
a000bca8:	8c440000 	lw	a0,0(v0)

			REG32(SYS_LX_CTRL) &= ~(1<<3);	//unlock
a000bcac:	8c450000 	lw	a1,0(v0)
a000bcb0:	2404fff7 	li	a0,-9
a000bcb4:	00a42024 	and	a0,a1,a0
a000bcb8:	ac440000 	sw	a0,0(v0)
			while( (REG32(SYS_LX_CTRL)&(1<<13))==(1<<1)) ;  //wait bit to 0  unlock
a000bcbc:	8c440000 	lw	a0,0(v0)

			REG32(SYS_LX_CTRL) &= ~(1<<4);	//unlock
a000bcc0:	8c450000 	lw	a1,0(v0)
a000bcc4:	2404ffef 	li	a0,-17
a000bcc8:	00a42024 	and	a0,a1,a0
a000bccc:	ac440000 	sw	a0,0(v0)
			while( (REG32(SYS_LX_CTRL)&(1<<14))==(1<<2)) ;  //wait bit to 0  unlock				
a000bcd0:	8c420000 	lw	v0,0(v0)
		#endif

		int strap_new=REG32(SYS_HW_STRAP) ;
a000bcd4:	34630008 	ori	v1,v1,0x8
a000bcd8:	8c620000 	lw	v0,0(v1)

	}
	
	//-----------------------
	//test cpu can work
	LetCPUDoSomething();
a000bcdc:	0c0027f6 	jal	a0009fd8 <LetCPUDoSomething>
a000bce0:	00000000 	nop

	//-----------------------
	clk_curr = check_cpu_speed();
a000bce4:	0c003edc 	jal	a000fb70 <check_cpu_speed>
a000bce8:	00000000 	nop
	{	dprintf("Test FAIL! Curr_speed=%d but Exp_speed=%d \n", clk_curr, clk_exp);
		//while(1) ;
	}
#endif

}
a000bcec:	8fbf001c 	lw	ra,28(sp)
a000bcf0:	8fb20018 	lw	s2,24(sp)
a000bcf4:	8fb10014 	lw	s1,20(sp)
a000bcf8:	8fb00010 	lw	s0,16(sp)
a000bcfc:	03e00008 	jr	ra
a000bd00:	27bd0020 	addiu	sp,sp,32

a000bd04 <CmdCPUCLK>:
//---------------------------------------------------------------------------
int CmdCPUCLK(int argc, char* argv[])
{
a000bd04:	27bdffd0 	addiu	sp,sp,-48
a000bd08:	afbf002c 	sw	ra,44(sp)
a000bd0c:	afb50028 	sw	s5,40(sp)
a000bd10:	afb40024 	sw	s4,36(sp)
a000bd14:	afb30020 	sw	s3,32(sp)
a000bd18:	afb2001c 	sw	s2,28(sp)
a000bd1c:	afb10018 	sw	s1,24(sp)
a000bd20:	afb00014 	sw	s0,20(sp)
	int clk_curr;	


	
	int i;
	if( argc <1 )	//read
a000bd24:	1c80002b 	bgtz	a0,a000bdd4 <CmdCPUCLK+0xd0>
a000bd28:	00a08021 	move	s0,a1
	{
		clk_curr = check_cpu_speed();
a000bd2c:	0c003edc 	jal	a000fb70 <check_cpu_speed>
a000bd30:	3c11a001 	lui	s1,0xa001
		dprintf("Now CPU Speed=%d \n",clk_curr);			
a000bd34:	3c04a001 	lui	a0,0xa001
a000bd38:	24845f10 	addiu	a0,a0,24336
a000bd3c:	0c002325 	jal	a0008c94 <dprintf>
a000bd40:	00402821 	move	a1,v0
		ShowStrapMsg();	
a000bd44:	0c002870 	jal	a000a1c0 <ShowStrapMsg>
a000bd48:	26310404 	addiu	s1,s1,1028
		dprintf("Usage: CPUCLK clk_sel div_value : 0-f, 0-3  \n");	
a000bd4c:	3c04a001 	lui	a0,0xa001
a000bd50:	0c002325 	jal	a0008c94 <dprintf>
a000bd54:	24845f24 	addiu	a0,a0,24356
		dprintf("Usage: CPUCLK 999 999: test all freq  \n");		
a000bd58:	3c04a001 	lui	a0,0xa001
a000bd5c:	0c002325 	jal	a0008c94 <dprintf>
a000bd60:	24845f54 	addiu	a0,a0,24404


		int i;
		for(i=0; i<16;i++)
		{ dprintf(" %x : %d MHz,  ", i, cpu_clksel_table[i]);
a000bd64:	3c04a001 	lui	a0,0xa001
a000bd68:	24845f7c 	addiu	a0,a0,24444
a000bd6c:	00002821 	move	a1,zero
a000bd70:	0c002325 	jal	a0008c94 <dprintf>
a000bd74:	240601c2 	li	a2,450
a000bd78:	00008021 	move	s0,zero
		dprintf("Usage: CPUCLK clk_sel div_value : 0-f, 0-3  \n");	
		dprintf("Usage: CPUCLK 999 999: test all freq  \n");		


		int i;
		for(i=0; i<16;i++)
a000bd7c:	24120010 	li	s2,16
		{ dprintf(" %x : %d MHz,  ", i, cpu_clksel_table[i]);
a000bd80:	3c13a001 	lui	s3,0xa001
a000bd84:	26735f7c 	addiu	s3,s3,24444
		  if( (i&0x3) ==0x3) dprintf("\n");
a000bd88:	24140003 	li	s4,3
a000bd8c:	3c15a001 	lui	s5,0xa001
a000bd90:	08002f70 	j	a000bdc0 <CmdCPUCLK+0xbc>
a000bd94:	26b557b8 	addiu	s5,s5,22456
		dprintf("Usage: CPUCLK 999 999: test all freq  \n");		


		int i;
		for(i=0; i<16;i++)
		{ dprintf(" %x : %d MHz,  ", i, cpu_clksel_table[i]);
a000bd98:	02602021 	move	a0,s3
a000bd9c:	02002821 	move	a1,s0
a000bda0:	0c002325 	jal	a0008c94 <dprintf>
a000bda4:	8e260000 	lw	a2,0(s1)
		  if( (i&0x3) ==0x3) dprintf("\n");
a000bda8:	32020003 	andi	v0,s0,0x3
a000bdac:	14540003 	bne	v0,s4,a000bdbc <CmdCPUCLK+0xb8>
a000bdb0:	00000000 	nop
a000bdb4:	0c002325 	jal	a0008c94 <dprintf>
a000bdb8:	02a02021 	move	a0,s5
a000bdbc:	26310004 	addiu	s1,s1,4
		dprintf("Usage: CPUCLK clk_sel div_value : 0-f, 0-3  \n");	
		dprintf("Usage: CPUCLK 999 999: test all freq  \n");		


		int i;
		for(i=0; i<16;i++)
a000bdc0:	26100001 	addiu	s0,s0,1
a000bdc4:	1612fff4 	bne	s0,s2,a000bd98 <CmdCPUCLK+0x94>
a000bdc8:	8fbf002c 	lw	ra,44(sp)
			
	}
	else
		SettingCPUClk(clk_sel, clk_div);

}
a000bdcc:	08002fae 	j	a000beb8 <CmdCPUCLK+0x1b4>
a000bdd0:	8fb50028 	lw	s5,40(sp)
		return;	
	}


	
	if(argv[0])	clk_sel = strtoul((const char*)(argv[0]), (char **)NULL, 16);
a000bdd4:	8ca40000 	lw	a0,0(a1)
a000bdd8:	10800005 	beqz	a0,a000bdf0 <CmdCPUCLK+0xec>
a000bddc:	00009021 	move	s2,zero
a000bde0:	00002821 	move	a1,zero
a000bde4:	0c0020c4 	jal	a0008310 <strtoul>
a000bde8:	24060010 	li	a2,16
a000bdec:	00409021 	move	s2,v0
	if(argv[1])	clk_div = strtoul((const char*)(argv[1]), (char **)NULL, 16);
a000bdf0:	8e040004 	lw	a0,4(s0)
a000bdf4:	10800005 	beqz	a0,a000be0c <CmdCPUCLK+0x108>
a000bdf8:	00008821 	move	s1,zero
a000bdfc:	00002821 	move	a1,zero
a000be00:	0c0020c4 	jal	a0008310 <strtoul>
a000be04:	24060010 	li	a2,16
a000be08:	00408821 	move	s1,v0
//	if(argv[2])	sync_oc = strtoul((const char*)(argv[2]), (char **)NULL, 16);


	if(clk_sel==0x999)
a000be0c:	24020999 	li	v0,2457
a000be10:	16420025 	bne	s2,v0,a000bea8 <CmdCPUCLK+0x1a4>
a000be14:	02402021 	move	a0,s2
				SettingCPUClk(clk_sel, 3);

			for(clk_sel=0; clk_sel<=0x0f; clk_sel++)
				SettingCPUClk(clk_sel, 2);
			
			for(clk_sel=0; clk_sel<=0x0f; clk_sel++)
a000be18:	00008021 	move	s0,zero
//	if(argv[2])	sync_oc = strtoul((const char*)(argv[2]), (char **)NULL, 16);


	if(clk_sel==0x999)
	{
		if(clk_div==0x999)
a000be1c:	1622001a 	bne	s1,v0,a000be88 <CmdCPUCLK+0x184>
a000be20:	24120010 	li	s2,16
		{
			for(clk_sel=0; clk_sel<=0x0f; clk_sel++)
a000be24:	24110010 	li	s1,16
				SettingCPUClk(clk_sel, 3);
a000be28:	02002021 	move	a0,s0
a000be2c:	0c002eb8 	jal	a000bae0 <SettingCPUClk>
a000be30:	24050003 	li	a1,3

	if(clk_sel==0x999)
	{
		if(clk_div==0x999)
		{
			for(clk_sel=0; clk_sel<=0x0f; clk_sel++)
a000be34:	26100001 	addiu	s0,s0,1
a000be38:	1611fffc 	bne	s0,s1,a000be2c <CmdCPUCLK+0x128>
a000be3c:	02002021 	move	a0,s0
a000be40:	00008021 	move	s0,zero
				SettingCPUClk(clk_sel, 3);

			for(clk_sel=0; clk_sel<=0x0f; clk_sel++)
a000be44:	24110010 	li	s1,16
				SettingCPUClk(clk_sel, 2);
a000be48:	02002021 	move	a0,s0
a000be4c:	0c002eb8 	jal	a000bae0 <SettingCPUClk>
a000be50:	24050002 	li	a1,2
		if(clk_div==0x999)
		{
			for(clk_sel=0; clk_sel<=0x0f; clk_sel++)
				SettingCPUClk(clk_sel, 3);

			for(clk_sel=0; clk_sel<=0x0f; clk_sel++)
a000be54:	26100001 	addiu	s0,s0,1
a000be58:	1611fffc 	bne	s0,s1,a000be4c <CmdCPUCLK+0x148>
a000be5c:	02002021 	move	a0,s0
a000be60:	00008021 	move	s0,zero
				SettingCPUClk(clk_sel, 2);
			
			for(clk_sel=0; clk_sel<=0x0f; clk_sel++)
a000be64:	24110010 	li	s1,16
				SettingCPUClk(clk_sel, 0);
a000be68:	02002021 	move	a0,s0
a000be6c:	0c002eb8 	jal	a000bae0 <SettingCPUClk>
a000be70:	00002821 	move	a1,zero
				SettingCPUClk(clk_sel, 3);

			for(clk_sel=0; clk_sel<=0x0f; clk_sel++)
				SettingCPUClk(clk_sel, 2);
			
			for(clk_sel=0; clk_sel<=0x0f; clk_sel++)
a000be74:	26100001 	addiu	s0,s0,1
a000be78:	1611fffc 	bne	s0,s1,a000be6c <CmdCPUCLK+0x168>
a000be7c:	02002021 	move	a0,s0
			
	}
	else
		SettingCPUClk(clk_sel, clk_div);

}
a000be80:	08002fad 	j	a000beb4 <CmdCPUCLK+0x1b0>
a000be84:	8fbf002c 	lw	ra,44(sp)
				SettingCPUClk(clk_sel, 0);
		}
		else
		{
			for(clk_sel=0; clk_sel<=0x0f; clk_sel++)
				SettingCPUClk(clk_sel, clk_div);
a000be88:	02002021 	move	a0,s0
a000be8c:	0c002eb8 	jal	a000bae0 <SettingCPUClk>
a000be90:	02202821 	move	a1,s1
			for(clk_sel=0; clk_sel<=0x0f; clk_sel++)
				SettingCPUClk(clk_sel, 0);
		}
		else
		{
			for(clk_sel=0; clk_sel<=0x0f; clk_sel++)
a000be94:	26100001 	addiu	s0,s0,1
a000be98:	1612fffc 	bne	s0,s2,a000be8c <CmdCPUCLK+0x188>
a000be9c:	02002021 	move	a0,s0
			
	}
	else
		SettingCPUClk(clk_sel, clk_div);

}
a000bea0:	08002fad 	j	a000beb4 <CmdCPUCLK+0x1b0>
a000bea4:	8fbf002c 	lw	ra,44(sp)
		}

			
	}
	else
		SettingCPUClk(clk_sel, clk_div);
a000bea8:	0c002eb8 	jal	a000bae0 <SettingCPUClk>
a000beac:	02202821 	move	a1,s1

}
a000beb0:	8fbf002c 	lw	ra,44(sp)
a000beb4:	8fb50028 	lw	s5,40(sp)
a000beb8:	8fb40024 	lw	s4,36(sp)
a000bebc:	8fb30020 	lw	s3,32(sp)
a000bec0:	8fb2001c 	lw	s2,28(sp)
a000bec4:	8fb10018 	lw	s1,24(sp)
a000bec8:	8fb00014 	lw	s0,20(sp)
a000becc:	03e00008 	jr	ra
a000bed0:	27bd0030 	addiu	sp,sp,48

a000bed4 <CPUWAKEUP>:

}

//------------------------------------------------------------------------------
void CPUWAKEUP(void)
{
a000bed4:	27bdffe8 	addiu	sp,sp,-24
a000bed8:	afbf0014 	sw	ra,20(sp)
	request_IRQ(SPEED_IRQ_NO, &irq_SPEED, NULL); 
a000bedc:	2404002b 	li	a0,43
a000bee0:	3c05a001 	lui	a1,0xa001
a000bee4:	24a57590 	addiu	a1,a1,30096
a000bee8:	0c000274 	jal	a00009d0 <request_IRQ>
a000beec:	00003021 	move	a2,zero
}
a000bef0:	8fbf0014 	lw	ra,20(sp)
a000bef4:	03e00008 	jr	ra
a000bef8:	27bd0018 	addiu	sp,sp,24
a000befc:	00000000 	nop

a000bf00 <Enable_SRAM>:

//------------------------------------------------------------------------
void Enable_SRAM(unsigned int paddr)
{
	//unmap
	REG32(0xb8001304)=0x5;   //unmap seg len=4K
a000bf00:	3c02b800 	lui	v0,0xb800
a000bf04:	34451304 	ori	a1,v0,0x1304
a000bf08:	24030005 	li	v1,5
a000bf0c:	aca30000 	sw	v1,0(a1)
	REG32(0xb8001300)=(unsigned int)paddr |1;   //unmap seg addr
a000bf10:	34840001 	ori	a0,a0,0x1
a000bf14:	34451300 	ori	a1,v0,0x1300
a000bf18:	aca40000 	sw	a0,0(a1)

	//enable sram
	REG32(0xb8004004)=0x05;   //sram seg len=4K		
a000bf1c:	34454004 	ori	a1,v0,0x4004
a000bf20:	aca30000 	sw	v1,0(a1)
	REG32(0xb8004000)=(unsigned int)paddr |1;   //sram seg addr
a000bf24:	34424000 	ori	v0,v0,0x4000
a000bf28:	ac440000 	sw	a0,0(v0)
}
a000bf2c:	03e00008 	jr	ra
a000bf30:	00000000 	nop

a000bf34 <Disable_SRAM>:

void Disable_SRAM()
{
	//unmap
	REG32(0xb8001300)=0;   //unmap seg addr
a000bf34:	3c02b800 	lui	v0,0xb800
a000bf38:	34431300 	ori	v1,v0,0x1300
a000bf3c:	ac600000 	sw	zero,0(v1)
	//enable sram
	REG32(0xb8004000)=0;   //sram seg addr
a000bf40:	34424000 	ori	v0,v0,0x4000
a000bf44:	ac400000 	sw	zero,0(v0)
}
a000bf48:	03e00008 	jr	ra
a000bf4c:	00000000 	nop

a000bf50 <PCIE_MDIO_Reset>:
        #define SYS_PCIE_PHY0   (0xb8000000 +0x50)
        #define SYS_PCIE_PHY1   (0xb8000000 +0x54)	
	 
	unsigned int sys_pcie_phy;

	if(portnum==0)	sys_pcie_phy=SYS_PCIE_PHY0;
a000bf50:	14800003 	bnez	a0,a000bf60 <PCIE_MDIO_Reset+0x10>
a000bf54:	3c02b800 	lui	v0,0xb800
a000bf58:	08002fdc 	j	a000bf70 <PCIE_MDIO_Reset+0x20>
a000bf5c:	34420050 	ori	v0,v0,0x50
	else if(portnum==1)	sys_pcie_phy=SYS_PCIE_PHY1;
a000bf60:	24020001 	li	v0,1
a000bf64:	14820008 	bne	a0,v0,a000bf88 <PCIE_MDIO_Reset+0x38>
a000bf68:	3c02b800 	lui	v0,0xb800
a000bf6c:	34420054 	ori	v0,v0,0x54
	else return;
		
       // 3.MDIO Reset
 	   REG32(sys_pcie_phy) = (1<<3) |(0<<1) | (0<<0);     //mdio reset=0,     	    //0x088
a000bf70:	24030008 	li	v1,8
a000bf74:	ac430000 	sw	v1,0(v0)
 	   REG32(sys_pcie_phy) = (1<<3) |(0<<1) | (1<<0);     //mdio reset=1,           //0x09
a000bf78:	24030009 	li	v1,9
a000bf7c:	ac430000 	sw	v1,0(v0)
 	   REG32(sys_pcie_phy) = (1<<3) |(1<<1) | (1<<0);     //bit1 load_done=1       //0x0b
a000bf80:	2403000b 	li	v1,11
a000bf84:	ac430000 	sw	v1,0(v0)
a000bf88:	03e00008 	jr	ra
a000bf8c:	00000000 	nop

a000bf90 <PCIE_PHY_Reset>:
	 #define PCIE_PHY0 	0xb8b01008
	 #define PCIE_PHY1 	0xb8b21008
	 
	unsigned int pcie_phy;

	if(portnum==0)	pcie_phy=PCIE_PHY0;
a000bf90:	14800003 	bnez	a0,a000bfa0 <PCIE_PHY_Reset+0x10>
a000bf94:	3c02b8b0 	lui	v0,0xb8b0
a000bf98:	08002fec 	j	a000bfb0 <PCIE_PHY_Reset+0x20>
a000bf9c:	34421008 	ori	v0,v0,0x1008
	else if(portnum==1)	pcie_phy=PCIE_PHY1;
a000bfa0:	24020001 	li	v0,1
a000bfa4:	14820006 	bne	a0,v0,a000bfc0 <PCIE_PHY_Reset+0x30>
a000bfa8:	3c02b8b2 	lui	v0,0xb8b2
a000bfac:	34421008 	ori	v0,v0,0x1008
	else return;

        //4. PCIE PHY Reset       
	REG32(pcie_phy) = 0x01;	//bit7:PHY reset=0   bit0: Enable LTSSM=1
a000bfb0:	24030001 	li	v1,1
a000bfb4:	ac430000 	sw	v1,0(v0)
	REG32(pcie_phy) = 0x81;   //bit7: PHY reset=1   bit0: Enable LTSSM=1
a000bfb8:	24030081 	li	v1,129
a000bfbc:	ac430000 	sw	v1,0(v0)
a000bfc0:	03e00008 	jr	ra
a000bfc4:	00000000 	nop

a000bfc8 <HostPCIe_SetPhyMdioRead>:
//------------------------------------------------------------------------
unsigned int HostPCIe_SetPhyMdioRead(unsigned int portnum, unsigned int regaddr)
{
	unsigned int mdioaddr;

	if(portnum==0)		mdioaddr=PCIE0_MDIO;	
a000bfc8:	14800004 	bnez	a0,a000bfdc <HostPCIe_SetPhyMdioRead+0x14>
a000bfcc:	27bdfff8 	addiu	sp,sp,-8
a000bfd0:	3c03b8b0 	lui	v1,0xb8b0
a000bfd4:	08003001 	j	a000c004 <HostPCIe_SetPhyMdioRead+0x3c>
a000bfd8:	34631000 	ori	v1,v1,0x1000
	else if(portnum==1)	mdioaddr=PCIE1_MDIO;
a000bfdc:	24020001 	li	v0,1
a000bfe0:	14820003 	bne	a0,v0,a000bff0 <HostPCIe_SetPhyMdioRead+0x28>
a000bfe4:	3c03b8b2 	lui	v1,0xb8b2
a000bfe8:	08003001 	j	a000c004 <HostPCIe_SetPhyMdioRead+0x3c>
a000bfec:	34631000 	ori	v1,v1,0x1000
	else if(portnum==2)	mdioaddr=0xb8b410c0;	  //EP MDIO
a000bff0:	24030002 	li	v1,2
a000bff4:	14830014 	bne	a0,v1,a000c048 <HostPCIe_SetPhyMdioRead+0x80>
a000bff8:	00001021 	move	v0,zero
a000bffc:	3c03b8b4 	lui	v1,0xb8b4
a000c000:	346310c0 	ori	v1,v1,0x10c0
	else return 0;
	
	REG32(mdioaddr)= ((regaddr&0x1f)<<PCIE_MDIO_REG_OFFSET)  | (0<<PCIE_MDIO_RDWR_OFFSET); 
a000c004:	30a5001f 	andi	a1,a1,0x1f
a000c008:	00052a00 	sll	a1,a1,0x8
a000c00c:	ac650000 	sw	a1,0(v1)
	//delay 
	volatile int i;
	for(i=0;i<5555;i++)  ;
a000c010:	afa00000 	sw	zero,0(sp)
a000c014:	8fa20000 	lw	v0,0(sp)
a000c018:	284215b3 	slti	v0,v0,5555
a000c01c:	10400008 	beqz	v0,a000c040 <HostPCIe_SetPhyMdioRead+0x78>
a000c020:	00000000 	nop
a000c024:	8fa20000 	lw	v0,0(sp)
a000c028:	24420001 	addiu	v0,v0,1
a000c02c:	afa20000 	sw	v0,0(sp)
a000c030:	8fa20000 	lw	v0,0(sp)
a000c034:	284215b3 	slti	v0,v0,5555
a000c038:	1440fffa 	bnez	v0,a000c024 <HostPCIe_SetPhyMdioRead+0x5c>
a000c03c:	00000000 	nop

	int val;
	val=REG32(mdioaddr)&  (0xffff <<PCIE_MDIO_DATA_OFFSET) ;
a000c040:	8c620000 	lw	v0,0(v1)
	return ((val>>PCIE_MDIO_DATA_OFFSET)&0xffff);
a000c044:	00021402 	srl	v0,v0,0x10
	
}
a000c048:	27bd0008 	addiu	sp,sp,8
a000c04c:	03e00008 	jr	ra
a000c050:	00000000 	nop

a000c054 <HostPCIe_SetPhyMdioWrite>:


void HostPCIe_SetPhyMdioWrite(unsigned int portnum, unsigned int regaddr, unsigned short val)
{
a000c054:	27bdfff8 	addiu	sp,sp,-8
	unsigned int mdioaddr;

	if(portnum==0)		mdioaddr=PCIE0_MDIO;	
a000c058:	14800004 	bnez	a0,a000c06c <HostPCIe_SetPhyMdioWrite+0x18>
a000c05c:	30c6ffff 	andi	a2,a2,0xffff
a000c060:	3c02b8b0 	lui	v0,0xb8b0
a000c064:	08003024 	j	a000c090 <HostPCIe_SetPhyMdioWrite+0x3c>
a000c068:	34421000 	ori	v0,v0,0x1000
	else if(portnum==1)	mdioaddr=PCIE1_MDIO;
a000c06c:	24020001 	li	v0,1
a000c070:	14820003 	bne	a0,v0,a000c080 <HostPCIe_SetPhyMdioWrite+0x2c>
a000c074:	3c02b8b2 	lui	v0,0xb8b2
a000c078:	08003024 	j	a000c090 <HostPCIe_SetPhyMdioWrite+0x3c>
a000c07c:	34421000 	ori	v0,v0,0x1000
	else if(portnum==2)	mdioaddr=0xb8b410c0;	  //EP MDIO	
a000c080:	24020002 	li	v0,2
a000c084:	14820014 	bne	a0,v0,a000c0d8 <HostPCIe_SetPhyMdioWrite+0x84>
a000c088:	3c02b8b4 	lui	v0,0xb8b4
a000c08c:	344210c0 	ori	v0,v0,0x10c0
	else return 0;
	
	REG32(mdioaddr)= ( (regaddr&0x1f)<<PCIE_MDIO_REG_OFFSET) | ((val&0xffff)<<PCIE_MDIO_DATA_OFFSET)  | (1<<PCIE_MDIO_RDWR_OFFSET) ; 
a000c090:	30a5001f 	andi	a1,a1,0x1f
a000c094:	00052a00 	sll	a1,a1,0x8
a000c098:	34a50001 	ori	a1,a1,0x1
a000c09c:	00063400 	sll	a2,a2,0x10
a000c0a0:	00a63025 	or	a2,a1,a2
a000c0a4:	ac460000 	sw	a2,0(v0)
	//delay 
	volatile int i;
	for(i=0;i<5555;i++)  ;
a000c0a8:	afa00000 	sw	zero,0(sp)
a000c0ac:	8fa20000 	lw	v0,0(sp)
a000c0b0:	284215b3 	slti	v0,v0,5555
a000c0b4:	10400008 	beqz	v0,a000c0d8 <HostPCIe_SetPhyMdioWrite+0x84>
a000c0b8:	00000000 	nop
a000c0bc:	8fa20000 	lw	v0,0(sp)
a000c0c0:	24420001 	addiu	v0,v0,1
a000c0c4:	afa20000 	sw	v0,0(sp)
a000c0c8:	8fa20000 	lw	v0,0(sp)
a000c0cc:	284215b3 	slti	v0,v0,5555
a000c0d0:	1440fffa 	bnez	v0,a000c0bc <HostPCIe_SetPhyMdioWrite+0x68>
a000c0d4:	00000000 	nop
}
a000c0d8:	27bd0008 	addiu	sp,sp,8
a000c0dc:	03e00008 	jr	ra
a000c0e0:	00000000 	nop

a000c0e4 <HostPCIe_TestINT>:

}; 

//---------------------------------------------------------------------------
int  HostPCIe_TestINT(int argc, char* argv[])
{
a000c0e4:	27bdffc8 	addiu	sp,sp,-56
a000c0e8:	afbf0034 	sw	ra,52(sp)
a000c0ec:	afbe0030 	sw	s8,48(sp)
a000c0f0:	afb7002c 	sw	s7,44(sp)
a000c0f4:	afb60028 	sw	s6,40(sp)
a000c0f8:	afb50024 	sw	s5,36(sp)
a000c0fc:	afb40020 	sw	s4,32(sp)
a000c100:	afb3001c 	sw	s3,28(sp)
a000c104:	afb20018 	sw	s2,24(sp)
a000c108:	afb10014 	sw	s1,20(sp)
a000c10c:	afb00010 	sw	s0,16(sp)
	if( argc < 2 ) 
a000c110:	28820002 	slti	v0,a0,2
a000c114:	10400006 	beqz	v0,a000c130 <HostPCIe_TestINT+0x4c>
a000c118:	00a08021 	move	s0,a1
	{
		dprintf("eint <portnum> <loops>.\n");	
a000c11c:	3c04a001 	lui	a0,0xa001
a000c120:	0c002325 	jal	a0008c94 <dprintf>
a000c124:	24845f94 	addiu	a0,a0,24468
a000c128:	080030a5 	j	a000c294 <HostPCIe_TestINT+0x1b0>
a000c12c:	00001021 	move	v0,zero
	
		return 0;
	}
	unsigned int portnum=0, loops=10;
	if(argc>=1)	portnum = strtoul((const char*)(argv[0]), (char **)NULL, 16);
a000c130:	18800052 	blez	a0,a000c27c <HostPCIe_TestINT+0x198>
a000c134:	00000000 	nop
a000c138:	8ca40000 	lw	a0,0(a1)
a000c13c:	00002821 	move	a1,zero
a000c140:	0c0020c4 	jal	a0008310 <strtoul>
a000c144:	24060010 	li	a2,16
a000c148:	00408821 	move	s1,v0
	if(argc>=2)   loops = strtoul((const char*)(argv[1]), (char **)NULL, 16);
a000c14c:	8e040004 	lw	a0,4(s0)
a000c150:	00002821 	move	a1,zero
a000c154:	0c0020c4 	jal	a0008310 <strtoul>
a000c158:	24060010 	li	a2,16

	int rc_cfg, cfgaddr;
	int iomapaddr;
	int memmapaddr;
	
	if(portnum==0)
a000c15c:	1620003e 	bnez	s1,a000c258 <HostPCIe_TestINT+0x174>
a000c160:	0040b821 	move	s7,v0
		cfgaddr=PCIE1_EP_CFG_BASE;
		iomapaddr=PCIE1_MAP_IO_BASE;
		memmapaddr=PCIE1_MAP_MEM_BASE;	
	}

	REG32(memmapaddr + 0x3c) |= (1<<8);  //swint mask
a000c164:	3c10b900 	lui	s0,0xb900
a000c168:	3610003c 	ori	s0,s0,0x3c
a000c16c:	8e020000 	lw	v0,0(s0)
a000c170:	34420100 	ori	v0,v0,0x100
a000c174:	ae020000 	sw	v0,0(s0)
a000c178:	0200b021 	move	s6,s0
a000c17c:	3c15b900 	lui	s5,0xb900
a000c180:	3c130020 	lui	s3,0x20

	
	#define GISR (0xb8003004)
	
	int i;
	for(i=0; i<loops; i++)
a000c184:	12e00032 	beqz	s7,a000c250 <HostPCIe_TestINT+0x16c>
a000c188:	0000a021 	move	s4,zero
	{

		REG32(memmapaddr + 0x38) |= (1<<0);  //kick swint
a000c18c:	26b50038 	addiu	s5,s5,56
		
		while(1) 
		{
			if( REG32(memmapaddr + 0x3c) & SWINT)   //check interrupt status swINT=1
a000c190:	3c120100 	lui	s2,0x100
				break;
		}

		dprintf("Got   SWINT %x=%x \n",memmapaddr + 0x3c, REG32(memmapaddr + 0x3c) );
a000c194:	3c1ea001 	lui	s8,0xa001
a000c198:	27de5fb0 	addiu	s8,s8,24496

		
		while(1) 
		{
			if( REG32(GISR) & PCIEISR )  //check pcie port 0
a000c19c:	3c11b800 	lui	s1,0xb800
a000c1a0:	36313004 	ori	s1,s1,0x3004
	
	int i;
	for(i=0; i<loops; i++)
	{

		REG32(memmapaddr + 0x38) |= (1<<0);  //kick swint
a000c1a4:	8ea20000 	lw	v0,0(s5)
a000c1a8:	34420001 	ori	v0,v0,0x1
a000c1ac:	aea20000 	sw	v0,0(s5)
		
		while(1) 
		{
			if( REG32(memmapaddr + 0x3c) & SWINT)   //check interrupt status swINT=1
a000c1b0:	8e020000 	lw	v0,0(s0)
a000c1b4:	00521024 	and	v0,v0,s2
a000c1b8:	1040fffd 	beqz	v0,a000c1b0 <HostPCIe_TestINT+0xcc>
a000c1bc:	00000000 	nop
				break;
		}

		dprintf("Got   SWINT %x=%x \n",memmapaddr + 0x3c, REG32(memmapaddr + 0x3c) );
a000c1c0:	8e060000 	lw	a2,0(s0)
a000c1c4:	03c02021 	move	a0,s8
a000c1c8:	0c002325 	jal	a0008c94 <dprintf>
a000c1cc:	02c02821 	move	a1,s6

		
		while(1) 
		{
			if( REG32(GISR) & PCIEISR )  //check pcie port 0
a000c1d0:	8e220000 	lw	v0,0(s1)
a000c1d4:	02621024 	and	v0,s3,v0
a000c1d8:	1040fffd 	beqz	v0,a000c1d0 <HostPCIe_TestINT+0xec>
a000c1dc:	00000000 	nop
				break;
		}
		dprintf("Got   GISR=%x \n", REG32(0xb8003004) );
a000c1e0:	8e250000 	lw	a1,0(s1)
a000c1e4:	3c04a001 	lui	a0,0xa001
a000c1e8:	0c002325 	jal	a0008c94 <dprintf>
a000c1ec:	24845fc4 	addiu	a0,a0,24516


		//-----------------
		REG32(memmapaddr + 0x3c) |= SWINT;  //write to clear
a000c1f0:	8e020000 	lw	v0,0(s0)
a000c1f4:	00521025 	or	v0,v0,s2
a000c1f8:	ae020000 	sw	v0,0(s0)



		while(1) 
		{
			if( (REG32(memmapaddr + 0x3c) & SWINT) ==0)  //check interrupt status swINT=1
a000c1fc:	8e020000 	lw	v0,0(s0)
a000c200:	00521024 	and	v0,v0,s2
a000c204:	1440fffd 	bnez	v0,a000c1fc <HostPCIe_TestINT+0x118>
a000c208:	00000000 	nop
				break;
		}

		dprintf("Clear SWINT %x=%x \n",memmapaddr + 0x3c, REG32(memmapaddr + 0x3c) );
a000c20c:	8e060000 	lw	a2,0(s0)
a000c210:	3c04a001 	lui	a0,0xa001
a000c214:	24845fd4 	addiu	a0,a0,24532
a000c218:	0c002325 	jal	a0008c94 <dprintf>
a000c21c:	02c02821 	move	a1,s6

		
		while(1) 
		{
			if( (REG32(GISR) & PCIEISR )==0)  //check pcie port 0
a000c220:	8e220000 	lw	v0,0(s1)
a000c224:	02621024 	and	v0,s3,v0
a000c228:	1440fffd 	bnez	v0,a000c220 <HostPCIe_TestINT+0x13c>
a000c22c:	00000000 	nop
				break;
		}
		dprintf("Clear GISR=%x \n", REG32(0xb8003004) );
a000c230:	8e250000 	lw	a1,0(s1)
a000c234:	3c04a001 	lui	a0,0xa001
a000c238:	0c002325 	jal	a0008c94 <dprintf>
a000c23c:	24845fe8 	addiu	a0,a0,24552

	
	#define GISR (0xb8003004)
	
	int i;
	for(i=0; i<loops; i++)
a000c240:	26940001 	addiu	s4,s4,1
a000c244:	0297102b 	sltu	v0,s4,s7
a000c248:	1440ffd6 	bnez	v0,a000c1a4 <HostPCIe_TestINT+0xc0>
a000c24c:	00000000 	nop
		}
		dprintf("Clear GISR=%x \n", REG32(0xb8003004) );
	}
	

}
a000c250:	080030a6 	j	a000c298 <HostPCIe_TestINT+0x1b4>
a000c254:	8fbf0034 	lw	ra,52(sp)
		cfgaddr=PCIE1_EP_CFG_BASE;
		iomapaddr=PCIE1_MAP_IO_BASE;
		memmapaddr=PCIE1_MAP_MEM_BASE;	
	}

	REG32(memmapaddr + 0x3c) |= (1<<8);  //swint mask
a000c258:	3c10ba00 	lui	s0,0xba00
a000c25c:	3610003c 	ori	s0,s0,0x3c
a000c260:	8e020000 	lw	v0,0(s0)
a000c264:	34420100 	ori	v0,v0,0x100
a000c268:	ae020000 	sw	v0,0(s0)
a000c26c:	0200b021 	move	s6,s0
a000c270:	3c15ba00 	lui	s5,0xba00
a000c274:	08003061 	j	a000c184 <HostPCIe_TestINT+0xa0>
a000c278:	3c130040 	lui	s3,0x40
	
		return 0;
	}
	unsigned int portnum=0, loops=10;
	if(argc>=1)	portnum = strtoul((const char*)(argv[0]), (char **)NULL, 16);
	if(argc>=2)   loops = strtoul((const char*)(argv[1]), (char **)NULL, 16);
a000c27c:	8ca40004 	lw	a0,4(a1)
a000c280:	00002821 	move	a1,zero
a000c284:	0c0020c4 	jal	a0008310 <strtoul>
a000c288:	24060010 	li	a2,16
a000c28c:	08003059 	j	a000c164 <HostPCIe_TestINT+0x80>
a000c290:	0040b821 	move	s7,v0
		}
		dprintf("Clear GISR=%x \n", REG32(0xb8003004) );
	}
	

}
a000c294:	8fbf0034 	lw	ra,52(sp)
a000c298:	8fbe0030 	lw	s8,48(sp)
a000c29c:	8fb7002c 	lw	s7,44(sp)
a000c2a0:	8fb60028 	lw	s6,40(sp)
a000c2a4:	8fb50024 	lw	s5,36(sp)
a000c2a8:	8fb40020 	lw	s4,32(sp)
a000c2ac:	8fb3001c 	lw	s3,28(sp)
a000c2b0:	8fb20018 	lw	s2,24(sp)
a000c2b4:	8fb10014 	lw	s1,20(sp)
a000c2b8:	8fb00010 	lw	s0,16(sp)
a000c2bc:	03e00008 	jr	ra
a000c2c0:	27bd0038 	addiu	sp,sp,56

a000c2c4 <HostPCIe_MDIOWrite>:


}; 
//----------------------------------------------------------------------------
int HostPCIe_MDIOWrite(int argc, char* argv[])
{
a000c2c4:	27bdffe0 	addiu	sp,sp,-32
a000c2c8:	afbf001c 	sw	ra,28(sp)
a000c2cc:	afb20018 	sw	s2,24(sp)
a000c2d0:	afb10014 	sw	s1,20(sp)
a000c2d4:	afb00010 	sw	s0,16(sp)

	if(argc<3)
a000c2d8:	28840003 	slti	a0,a0,3
a000c2dc:	10800009 	beqz	a0,a000c304 <HostPCIe_MDIOWrite+0x40>
a000c2e0:	00a08021 	move	s0,a1
	{	 
		dprintf("mdiow <portnum> <addr> <val> \n");		
a000c2e4:	3c04a001 	lui	a0,0xa001
a000c2e8:	0c002325 	jal	a0008c94 <dprintf>
a000c2ec:	24845ff8 	addiu	a0,a0,24568
		dprintf("ex: mdiow 0 00  ffff \n");			
a000c2f0:	3c04a001 	lui	a0,0xa001
a000c2f4:	0c002325 	jal	a0008c94 <dprintf>
a000c2f8:	24846018 	addiu	a0,a0,24600
		return;	
a000c2fc:	080030d4 	j	a000c350 <HostPCIe_MDIOWrite+0x8c>
a000c300:	8fbf001c 	lw	ra,28(sp)
	}

	unsigned int portnum = strtoul((const char*)(argv[0]), (char **)NULL, 16);	
a000c304:	8ca40000 	lw	a0,0(a1)
a000c308:	00002821 	move	a1,zero
a000c30c:	0c0020c4 	jal	a0008310 <strtoul>
a000c310:	24060010 	li	a2,16
a000c314:	00408821 	move	s1,v0
	unsigned int addr = strtoul((const char*)(argv[1]), (char **)NULL, 16);	
a000c318:	8e040004 	lw	a0,4(s0)
a000c31c:	00002821 	move	a1,zero
a000c320:	0c0020c4 	jal	a0008310 <strtoul>
a000c324:	24060010 	li	a2,16
a000c328:	00409021 	move	s2,v0
	unsigned int val = strtoul((const char*)(argv[2]), (char **)NULL, 16);	
a000c32c:	8e040008 	lw	a0,8(s0)
a000c330:	00002821 	move	a1,zero
a000c334:	0c0020c4 	jal	a0008310 <strtoul>
a000c338:	24060010 	li	a2,16
/*
	REG32(PCIE0_MDIO)= (addr<<PCIE_MDIO_REG_OFFSET) | (val<<PCIE_MDIO_DATA_OFFSET)  | (1<<PCIE_MDIO_RDWR_OFFSET) ;   ;   
*/
	HostPCIe_SetPhyMdioWrite(portnum, addr, val);
a000c33c:	02202021 	move	a0,s1
a000c340:	02402821 	move	a1,s2
a000c344:	0c003015 	jal	a000c054 <HostPCIe_SetPhyMdioWrite>
a000c348:	3046ffff 	andi	a2,v0,0xffff

}; 
a000c34c:	8fbf001c 	lw	ra,28(sp)
a000c350:	8fb20018 	lw	s2,24(sp)
a000c354:	8fb10014 	lw	s1,20(sp)
a000c358:	8fb00010 	lw	s0,16(sp)
a000c35c:	03e00008 	jr	ra
a000c360:	27bd0020 	addiu	sp,sp,32

a000c364 <HostPCIe_MDIORead>:
}


//----------------------------------------------------------------------------
int HostPCIe_MDIORead(int argc, char* argv[])
{
a000c364:	27bdffd8 	addiu	sp,sp,-40
a000c368:	afbf0024 	sw	ra,36(sp)
a000c36c:	afb30020 	sw	s3,32(sp)
a000c370:	afb2001c 	sw	s2,28(sp)
a000c374:	afb10018 	sw	s1,24(sp)
a000c378:	afb00014 	sw	s0,20(sp)
		return;
	}
*/	
	unsigned int portnum=0;
	
	if(argc>=1)
a000c37c:	18800006 	blez	a0,a000c398 <HostPCIe_MDIORead+0x34>
a000c380:	00008821 	move	s1,zero
		portnum	= strtoul((const char*)(argv[0]), (char **)NULL, 16);		
a000c384:	8ca40000 	lw	a0,0(a1)
a000c388:	00002821 	move	a1,zero
a000c38c:	0c0020c4 	jal	a0008310 <strtoul>
a000c390:	24060010 	li	a2,16
a000c394:	00408821 	move	s1,v0
a000c398:	00008021 	move	s0,zero
		for(j=0;j<0x5555;j++) ;
		val=REG32(PCIE0_MDIO);
		val=( val& PCIE_MDIO_DATA_MASK ) >> PCIE_MDIO_DATA_OFFSET;		
	*/
		val=HostPCIe_SetPhyMdioRead(portnum, i);
		dprintf("MDIO Reg %x=%x \n", i,val);
a000c39c:	3c12a001 	lui	s2,0xa001
a000c3a0:	26526030 	addiu	s2,s2,24624
	unsigned int portnum=0;
	
	if(argc>=1)
		portnum	= strtoul((const char*)(argv[0]), (char **)NULL, 16);		
	
	for(i=0; i<=0x1f; i++)
a000c3a4:	24130020 	li	s3,32
		REG32(PCIE0_MDIO)= (i<<PCIE_MDIO_REG_OFFSET) | (0<<PCIE_MDIO_RDWR_OFFSET) ;   
		for(j=0;j<0x5555;j++) ;
		val=REG32(PCIE0_MDIO);
		val=( val& PCIE_MDIO_DATA_MASK ) >> PCIE_MDIO_DATA_OFFSET;		
	*/
		val=HostPCIe_SetPhyMdioRead(portnum, i);
a000c3a8:	02202021 	move	a0,s1
a000c3ac:	0c002ff2 	jal	a000bfc8 <HostPCIe_SetPhyMdioRead>
a000c3b0:	02002821 	move	a1,s0
		dprintf("MDIO Reg %x=%x \n", i,val);
a000c3b4:	02402021 	move	a0,s2
a000c3b8:	02002821 	move	a1,s0
a000c3bc:	0c002325 	jal	a0008c94 <dprintf>
a000c3c0:	00403021 	move	a2,v0
	unsigned int portnum=0;
	
	if(argc>=1)
		portnum	= strtoul((const char*)(argv[0]), (char **)NULL, 16);		
	
	for(i=0; i<=0x1f; i++)
a000c3c4:	26100001 	addiu	s0,s0,1
a000c3c8:	1613fff8 	bne	s0,s3,a000c3ac <HostPCIe_MDIORead+0x48>
a000c3cc:	02202021 	move	a0,s1

	}



}; 
a000c3d0:	8fbf0024 	lw	ra,36(sp)
a000c3d4:	8fb30020 	lw	s3,32(sp)
a000c3d8:	8fb2001c 	lw	s2,28(sp)
a000c3dc:	8fb10018 	lw	s1,24(sp)
a000c3e0:	8fb00014 	lw	s0,20(sp)
a000c3e4:	03e00008 	jr	ra
a000c3e8:	27bd0028 	addiu	sp,sp,40

a000c3ec <PCIE_Host_Init>:
}; 


//--------------------------------------------------------------------------
int PCIE_Host_Init(int argc, char* argv[])
{
a000c3ec:	27bdffe0 	addiu	sp,sp,-32
a000c3f0:	afbf001c 	sw	ra,28(sp)
a000c3f4:	afb10018 	sw	s1,24(sp)
a000c3f8:	afb00014 	sw	s0,20(sp)
	int portnum=0;
	if(argc >= 1) 
a000c3fc:	18800010 	blez	a0,a000c440 <PCIE_Host_Init+0x54>
a000c400:	3c04b900 	lui	a0,0xb900
	{	portnum= strtoul((const char*)(argv[0]), (char **)NULL, 16);	
a000c404:	8ca40000 	lw	a0,0(a1)
a000c408:	00002821 	move	a1,zero
a000c40c:	0c0020c4 	jal	a0008310 <strtoul>
a000c410:	24060010 	li	a2,16

	int rc_cfg, cfgaddr;
	int iomapaddr;
	int memmapaddr;

	if(portnum==0)
a000c414:	10400009 	beqz	v0,a000c43c <PCIE_Host_Init+0x50>
a000c418:	00401821 	move	v1,v0
	{	rc_cfg=PCIE0_RC_CFG_BASE;
		cfgaddr=PCIE0_EP_CFG_BASE;
		iomapaddr=PCIE0_MAP_IO_BASE;
		memmapaddr=PCIE0_MAP_MEM_BASE;
	}
	else if(portnum==1)
a000c41c:	24040001 	li	a0,1
a000c420:	1464004b 	bne	v1,a0,a000c550 <PCIE_Host_Init+0x164>
a000c424:	00001021 	move	v0,zero
a000c428:	3c04ba00 	lui	a0,0xba00
a000c42c:	3c07b8e0 	lui	a3,0xb8e0
a000c430:	3c03b8b3 	lui	v1,0xb8b3
a000c434:	08003113 	j	a000c44c <PCIE_Host_Init+0x60>
a000c438:	3c10b8b2 	lui	s0,0xb8b2
a000c43c:	3c04b900 	lui	a0,0xb900
a000c440:	3c07b8c0 	lui	a3,0xb8c0
a000c444:	3c03b8b1 	lui	v1,0xb8b1
a000c448:	3c10b8b0 	lui	s0,0xb8b0
	}
	else 
	{	return 0;
	}
	
	int t=REG32(rc_cfg);
a000c44c:	8e060000 	lw	a2,0(s0)
	unsigned int vid=t&0x0000ffff;   //0x819810EC
a000c450:	30c5ffff 	andi	a1,a2,0xffff
	unsigned int pid=(t&0xffff0000) >>16;
	
	if( (vid!= 0x10ec) || (pid!=0x8198))
a000c454:	240210ec 	li	v0,4332
a000c458:	14a20004 	bne	a1,v0,a000c46c <PCIE_Host_Init+0x80>
a000c45c:	00063402 	srl	a2,a2,0x10
a000c460:	34028198 	li	v0,0x8198
a000c464:	10c20009 	beq	a2,v0,a000c48c <PCIE_Host_Init+0xa0>
a000c468:	00000000 	nop
	{	DBG_PRINT("VID=%x, PID=%x \n", vid, pid );
a000c46c:	3c04a001 	lui	a0,0xa001
a000c470:	0c002325 	jal	a0008c94 <dprintf>
a000c474:	24846044 	addiu	a0,a0,24644
		DBG_PRINT(" !!!  Read VID PID fail !!! \n");
a000c478:	3c04a001 	lui	a0,0xa001
a000c47c:	0c002325 	jal	a0008c94 <dprintf>
a000c480:	24846058 	addiu	a0,a0,24664
		//at_errcnt++;
		return;
a000c484:	08003155 	j	a000c554 <PCIE_Host_Init+0x168>
a000c488:	8fbf001c 	lw	ra,28(sp)
	//CMD
	//bit 2: Enable Bys master, 
	//bit 1: enable memmap, 
	//bit 0: enable iomap

	REG32(rc_cfg + 0x04)= 0x00100007;   
a000c48c:	26050004 	addiu	a1,s0,4
a000c490:	3c020010 	lui	v0,0x10
a000c494:	34420007 	ori	v0,v0,0x7
a000c498:	aca20000 	sw	v0,0(a1)

	//Device Control Register 
	//bit [7-5]  payload size
	REG32(rc_cfg + 0x78)= (REG32(rc_cfg + 0x78 ) & (~0xE0)) | MAX_PAYLOAD_SIZE_128B;  // Set MAX_PAYLOAD_SIZE to 128B,default
a000c49c:	26060078 	addiu	a2,s0,120
a000c4a0:	8cc80000 	lw	t0,0(a2)
a000c4a4:	2405ff1f 	li	a1,-225
a000c4a8:	01054024 	and	t0,t0,a1
a000c4ac:	acc80000 	sw	t0,0(a2)
	  
      REG32(cfgaddr + 0x04)= 0x00100007;    //0x00180007
a000c4b0:	24660004 	addiu	a2,v1,4
a000c4b4:	acc20000 	sw	v0,0(a2)

	//bit 0: 0:memory, 1 io indicate
      REG32(cfgaddr + 0x10)= (iomapaddr | 0x00000001) & 0x1FFFFFFF;  // Set BAR0
a000c4b8:	24620010 	addiu	v0,v1,16
a000c4bc:	3c061fff 	lui	a2,0x1fff
a000c4c0:	34c8fffe 	ori	t0,a2,0xfffe
a000c4c4:	00e83824 	and	a3,a3,t0
a000c4c8:	34e70001 	ori	a3,a3,0x1
a000c4cc:	ac470000 	sw	a3,0(v0)

	//bit 3: prefetch
	//bit [2:1] 00:32bit, 01:reserved, 10:64bit 11:reserved
      REG32(cfgaddr + 0x18)= (memmapaddr | 0x00000004) & 0x1FFFFFFF;  // Set BAR1  
a000c4d0:	24710018 	addiu	s1,v1,24
a000c4d4:	34c6fffb 	ori	a2,a2,0xfffb
a000c4d8:	00862024 	and	a0,a0,a2
a000c4dc:	34840004 	ori	a0,a0,0x4
a000c4e0:	ae240000 	sw	a0,0(s1)


	//offset 0x78 [7:5]
      REG32(cfgaddr + 0x78) = (REG32(cfgaddr + 0x78) & (~0xE0)) | (MAX_PAYLOAD_SIZE_128B);  // Set MAX_PAYLOAD_SIZE to 128B
a000c4e4:	24630078 	addiu	v1,v1,120
a000c4e8:	8c640000 	lw	a0,0(v1)
a000c4ec:	00852824 	and	a1,a0,a1
a000c4f0:	ac650000 	sw	a1,0(v1)

	//offset 0x79: [6:4] 
      REG32(cfgaddr + 0x78) = (REG32(cfgaddr + 0x78) & (~0x7000)) | (MAX_READ_REQSIZE_256B<<8);  // Set MAX_REQ_SIZE to 256B,default
a000c4f4:	8c650000 	lw	a1,0(v1)
a000c4f8:	24048fff 	li	a0,-28673
a000c4fc:	00a42024 	and	a0,a1,a0
a000c500:	34841000 	ori	a0,a0,0x1000
a000c504:	ac640000 	sw	a0,0(v1)

	  
	//check
//      if(REG32(cfgaddr + 0x10) != ((iomapaddr | 0x00000001) & 0x1FFFFFFF))
      {	//at_errcnt++;
      		DBG_PRINT("Read Bar0=%x \n", REG32(cfgaddr + 0x10)); //for test
a000c508:	8c450000 	lw	a1,0(v0)
a000c50c:	3c04a001 	lui	a0,0xa001
a000c510:	0c002325 	jal	a0008c94 <dprintf>
a000c514:	24846078 	addiu	a0,a0,24696
      	}
	  

//	if(REG32(cfgaddr + 0x18)!=((memmapaddr| 0x00000004) & 0x1FFFFFFF))
	{	//at_errcnt++;
      		DBG_PRINT("Read Bar1=%x \n", REG32(cfgaddr + 0x18));      //for test
a000c518:	8e250000 	lw	a1,0(s1)
a000c51c:	3c04a001 	lui	a0,0xa001
a000c520:	0c002325 	jal	a0008c94 <dprintf>
a000c524:	24846088 	addiu	a0,a0,24712
	}
	DBG_PRINT("Set BAR finish \n");
a000c528:	3c04a001 	lui	a0,0xa001
a000c52c:	0c002325 	jal	a0008c94 <dprintf>
a000c530:	24846098 	addiu	a0,a0,24728


	//io and mem limit, setting to no litmit
	REG32(rc_cfg+ 0x1c) = (2<<4) | (0<<12);   //  [7:4]=base  [15:12]=limit
a000c534:	2603001c 	addiu	v1,s0,28
a000c538:	24020020 	li	v0,32
a000c53c:	ac620000 	sw	v0,0(v1)
	REG32(rc_cfg+ 0x20) = (2<<4) | (0<<20);   //  [15:4]=base  [31:20]=limit	
a000c540:	26030020 	addiu	v1,s0,32
a000c544:	ac620000 	sw	v0,0(v1)
	REG32(rc_cfg+ 0x24) = (2<<4) | (0<<20);   //  [15:4]=base  [31:20]=limit		
a000c548:	26100024 	addiu	s0,s0,36
a000c54c:	ae020000 	sw	v0,0(s0)

}
a000c550:	8fbf001c 	lw	ra,28(sp)
a000c554:	8fb10018 	lw	s1,24(sp)
a000c558:	8fb00014 	lw	s0,20(sp)
a000c55c:	03e00008 	jr	ra
a000c560:	27bd0020 	addiu	sp,sp,32

a000c564 <PCIE_PHYLoop>:
		
};

//---------------------------------------------------------------------------
int PCIE_PHYLoop(int argc, char* argv[])
{
a000c564:	27bdffd8 	addiu	sp,sp,-40
a000c568:	afbf0024 	sw	ra,36(sp)
a000c56c:	afb30020 	sw	s3,32(sp)
a000c570:	afb2001c 	sw	s2,28(sp)
a000c574:	afb10018 	sw	s1,24(sp)
a000c578:	afb00014 	sw	s0,20(sp)
	int portnum=0;
	int mode=1; 
	if( argc < 2 ) 
a000c57c:	28820002 	slti	v0,a0,2
a000c580:	10400006 	beqz	v0,a000c59c <PCIE_PHYLoop+0x38>
a000c584:	00a08021 	move	s0,a1
	{
		dprintf("epdn <portnum> <stop/start>.\n");	
a000c588:	3c04a001 	lui	a0,0xa001
a000c58c:	0c002325 	jal	a0008c94 <dprintf>
a000c590:	248460ac 	addiu	a0,a0,24748
		dprintf("ERR=%x\n",v);
	}
	


}; 
a000c594:	080031b6 	j	a000c6d8 <PCIE_PHYLoop+0x174>
a000c598:	00001021 	move	v0,zero
	if( argc < 2 ) 
	{
		dprintf("epdn <portnum> <stop/start>.\n");	
		return 0;
	}
	if(argc>=1)	portnum = strtoul((const char*)(argv[0]), (char **)NULL, 16);
a000c59c:	18800006 	blez	a0,a000c5b8 <PCIE_PHYLoop+0x54>
a000c5a0:	00008821 	move	s1,zero
a000c5a4:	8ca40000 	lw	a0,0(a1)
a000c5a8:	00002821 	move	a1,zero
a000c5ac:	0c0020c4 	jal	a0008310 <strtoul>
a000c5b0:	24060010 	li	a2,16
a000c5b4:	00408821 	move	s1,v0
	if(argc>=2)   mode = strtoul((const char*)(argv[1]), (char **)NULL, 16);	
a000c5b8:	8e040004 	lw	a0,4(s0)
a000c5bc:	00002821 	move	a1,zero
a000c5c0:	0c0020c4 	jal	a0008310 <strtoul>
a000c5c4:	24060010 	li	a2,16
a000c5c8:	00409021 	move	s2,v0




	unsigned int v;
	v=HostPCIe_SetPhyMdioRead(portnum, 0);  
a000c5cc:	02208021 	move	s0,s1
a000c5d0:	02202021 	move	a0,s1
a000c5d4:	0c002ff2 	jal	a000bfc8 <HostPCIe_SetPhyMdioRead>
a000c5d8:	00002821 	move	a1,zero
a000c5dc:	00409821 	move	s3,v0


	if(mode==1)
a000c5e0:	24020001 	li	v0,1
a000c5e4:	16420023 	bne	s2,v0,a000c674 <PCIE_PHYLoop+0x110>
a000c5e8:	3c04a001 	lui	a0,0xa001
	{	
		dprintf("Start... port=%d   ", portnum);
a000c5ec:	248460cc 	addiu	a0,a0,24780
a000c5f0:	0c002325 	jal	a0008c94 <dprintf>
a000c5f4:	02202821 	move	a1,s1

		v=v|(1<<8);  //bit 8
		HostPCIe_SetPhyMdioWrite(portnum, 0x00, v);  
a000c5f8:	36660100 	ori	a2,s3,0x100
a000c5fc:	02202021 	move	a0,s1
a000c600:	00002821 	move	a1,zero
a000c604:	0c003015 	jal	a000c054 <HostPCIe_SetPhyMdioWrite>
a000c608:	30c6ffff 	andi	a2,a2,0xffff
		
		// start bist
		HostPCIe_SetPhyMdioWrite(portnum, 0x13, 0x8497);  
a000c60c:	02202021 	move	a0,s1
a000c610:	24050013 	li	a1,19
a000c614:	0c003015 	jal	a000c054 <HostPCIe_SetPhyMdioWrite>
a000c618:	34068497 	li	a2,0x8497
		delay_ms(100);
a000c61c:	0c002219 	jal	a0008864 <delay_ms>
a000c620:	24040064 	li	a0,100
		HostPCIe_SetPhyMdioWrite(portnum, 0x14, 0xde01);  
a000c624:	02202021 	move	a0,s1
a000c628:	24050014 	li	a1,20
a000c62c:	0c003015 	jal	a000c054 <HostPCIe_SetPhyMdioWrite>
a000c630:	3406de01 	li	a2,0xde01
		delay_ms(100);		
a000c634:	0c002219 	jal	a0008864 <delay_ms>
a000c638:	24040064 	li	a0,100
		HostPCIe_SetPhyMdioWrite(portnum, 0x13, 0x8c97);  
a000c63c:	02202021 	move	a0,s1
a000c640:	24050013 	li	a1,19
a000c644:	0c003015 	jal	a000c054 <HostPCIe_SetPhyMdioWrite>
a000c648:	34068c97 	li	a2,0x8c97
		delay_ms(100);		
a000c64c:	0c002219 	jal	a0008864 <delay_ms>
a000c650:	24040064 	li	a0,100
		HostPCIe_SetPhyMdioWrite(portnum, 0x13, 0xcc97);  	
a000c654:	02202021 	move	a0,s1
a000c658:	24050013 	li	a1,19
a000c65c:	0c003015 	jal	a000c054 <HostPCIe_SetPhyMdioWrite>
a000c660:	3406cc97 	li	a2,0xcc97
		delay_ms(100);		
a000c664:	0c002219 	jal	a0008864 <delay_ms>
a000c668:	24040064 	li	a0,100
a000c66c:	080031a6 	j	a000c698 <PCIE_PHYLoop+0x134>
a000c670:	00000000 	nop
		//end bist


	
	}
	else if(mode==0)
a000c674:	16400008 	bnez	s2,a000c698 <PCIE_PHYLoop+0x134>
a000c678:	3c04a001 	lui	a0,0xa001
	{	
		dprintf("Stop...  port=%d  ", portnum);	
a000c67c:	248460e0 	addiu	a0,a0,24800
a000c680:	0c002325 	jal	a0008c94 <dprintf>
a000c684:	02202821 	move	a1,s1
		v=v&0xffffffff-(1<<8);
		HostPCIe_SetPhyMdioWrite(portnum, 0, v);  	
a000c688:	02202021 	move	a0,s1
a000c68c:	00002821 	move	a1,zero
a000c690:	0c003015 	jal	a000c054 <HostPCIe_SetPhyMdioWrite>
a000c694:	3266feff 	andi	a2,s3,0xfeff
	}


	//if(mode==1)
	{
		delay_ms(500);
a000c698:	0c002219 	jal	a0008864 <delay_ms>
a000c69c:	240401f4 	li	a0,500
		
		v=HostPCIe_SetPhyMdioRead(portnum, 0x17);	
a000c6a0:	02002021 	move	a0,s0
a000c6a4:	0c002ff2 	jal	a000bfc8 <HostPCIe_SetPhyMdioRead>
a000c6a8:	24050017 	li	a1,23
		dprintf("LOOP CNT=%x ",v);		
a000c6ac:	3c04a001 	lui	a0,0xa001
a000c6b0:	248460f4 	addiu	a0,a0,24820
a000c6b4:	0c002325 	jal	a0008c94 <dprintf>
a000c6b8:	00402821 	move	a1,v0
		v=HostPCIe_SetPhyMdioRead(portnum, 0x18);
a000c6bc:	02002021 	move	a0,s0
a000c6c0:	0c002ff2 	jal	a000bfc8 <HostPCIe_SetPhyMdioRead>
a000c6c4:	24050018 	li	a1,24
		v=(v &  (0xff<<4)) >>4;  //bit [11:04]
		dprintf("ERR=%x\n",v);
a000c6c8:	3c04a001 	lui	a0,0xa001
a000c6cc:	24846104 	addiu	a0,a0,24836
a000c6d0:	0c002325 	jal	a0008c94 <dprintf>
a000c6d4:	7c453900 	ext	a1,v0,0x4,0x8
	}
	


}; 
a000c6d8:	8fbf0024 	lw	ra,36(sp)
a000c6dc:	8fb30020 	lw	s3,32(sp)
a000c6e0:	8fb2001c 	lw	s2,28(sp)
a000c6e4:	8fb10018 	lw	s1,24(sp)
a000c6e8:	8fb00014 	lw	s0,20(sp)
a000c6ec:	03e00008 	jr	ra
a000c6f0:	27bd0028 	addiu	sp,sp,40

a000c6f4 <PCIE_PowerDown>:

}; 
//---------------------------------------------------------------------------

int  PCIE_PowerDown(int argc, char* argv[])
{
a000c6f4:	27bdffd8 	addiu	sp,sp,-40
a000c6f8:	afbf0024 	sw	ra,36(sp)
a000c6fc:	afb40020 	sw	s4,32(sp)
a000c700:	afb3001c 	sw	s3,28(sp)
a000c704:	afb20018 	sw	s2,24(sp)
a000c708:	afb10014 	sw	s1,20(sp)
a000c70c:	afb00010 	sw	s0,16(sp)
	 
	 int portnum=0;
	 int mode=0;
	int baseaddr=0xb8b00000;
	 
	if( argc < 2 ) 
a000c710:	28820002 	slti	v0,a0,2
a000c714:	1040002c 	beqz	v0,a000c7c8 <PCIE_PowerDown+0xd4>
a000c718:	00a08021 	move	s0,a1
	{
		dprintf("epdn <portnum> <mode>.\n");	
a000c71c:	3c04a001 	lui	a0,0xa001
a000c720:	0c002325 	jal	a0008c94 <dprintf>
a000c724:	2484610c 	addiu	a0,a0,24844
		dprintf("epdn 0: D0 ->L0 \n");			
a000c728:	3c04a001 	lui	a0,0xa001
a000c72c:	0c002325 	jal	a0008c94 <dprintf>
a000c730:	24846124 	addiu	a0,a0,24868
		dprintf("epdn 3: D3hot ->L1 \n");
a000c734:	3c04a001 	lui	a0,0xa001
a000c738:	0c002325 	jal	a0008c94 <dprintf>
a000c73c:	24846138 	addiu	a0,a0,24888
		dprintf("epdn 4: board cast PME_TurnOff \n");	
a000c740:	3c04a001 	lui	a0,0xa001
a000c744:	0c002325 	jal	a0008c94 <dprintf>
a000c748:	24846150 	addiu	a0,a0,24912
		
		dprintf("epdn 7: enable aspm and L0s entry \n");	
a000c74c:	3c04a001 	lui	a0,0xa001
a000c750:	0c002325 	jal	a0008c94 <dprintf>
a000c754:	24846174 	addiu	a0,a0,24948
		dprintf("epdn 8: enable aspm and L1 entry \n");	
a000c758:	3c04a001 	lui	a0,0xa001
a000c75c:	0c002325 	jal	a0008c94 <dprintf>
a000c760:	24846198 	addiu	a0,a0,24984
		dprintf("epdn 9: diable  aspm \n");	
a000c764:	3c04a001 	lui	a0,0xa001
a000c768:	0c002325 	jal	a0008c94 <dprintf>
a000c76c:	248461bc 	addiu	a0,a0,25020

		dprintf("epdn 010: measure L0->L1->L0 \n");		
a000c770:	3c04a001 	lui	a0,0xa001
a000c774:	0c002325 	jal	a0008c94 <dprintf>
a000c778:	248461d4 	addiu	a0,a0,25044
		dprintf("epdn 020: measure L0->L2->L0 \n");			
a000c77c:	3c04a001 	lui	a0,0xa001
a000c780:	0c002325 	jal	a0008c94 <dprintf>
a000c784:	248461f4 	addiu	a0,a0,25076
		dprintf("P0 Link status=%x \n", REG32(0xb8b00728)&0x1f );		
a000c788:	3c02b8b0 	lui	v0,0xb8b0
a000c78c:	34420728 	ori	v0,v0,0x728
a000c790:	8c450000 	lw	a1,0(v0)
a000c794:	3c04a001 	lui	a0,0xa001
a000c798:	24846214 	addiu	a0,a0,25108
a000c79c:	0c002325 	jal	a0008c94 <dprintf>
a000c7a0:	30a5001f 	andi	a1,a1,0x1f
		dprintf("P1 Link status=%x \n", REG32(0xb8b20728)&0x1f );		
a000c7a4:	3c02b8b2 	lui	v0,0xb8b2
a000c7a8:	34420728 	ori	v0,v0,0x728
a000c7ac:	8c450000 	lw	a1,0(v0)
a000c7b0:	3c04a001 	lui	a0,0xa001
a000c7b4:	24846228 	addiu	a0,a0,25128
a000c7b8:	0c002325 	jal	a0008c94 <dprintf>
a000c7bc:	30a5001f 	andi	a1,a1,0x1f
		return 0;
a000c7c0:	080032dd 	j	a000cb74 <PCIE_PowerDown+0x480>
a000c7c4:	00001021 	move	v0,zero
	}
	if(argc>=1)	portnum = strtoul((const char*)(argv[0]), (char **)NULL, 16);
a000c7c8:	188000e2 	blez	a0,a000cb54 <PCIE_PowerDown+0x460>
a000c7cc:	00000000 	nop
a000c7d0:	8ca40000 	lw	a0,0(a1)
a000c7d4:	00002821 	move	a1,zero
a000c7d8:	0c0020c4 	jal	a0008310 <strtoul>
a000c7dc:	24060010 	li	a2,16
a000c7e0:	00409021 	move	s2,v0
	if(argc>=2)   mode = strtoul((const char*)(argv[1]), (char **)NULL, 16);	
a000c7e4:	8e040004 	lw	a0,4(s0)
a000c7e8:	00002821 	move	a1,zero
a000c7ec:	0c0020c4 	jal	a0008310 <strtoul>
a000c7f0:	24060010 	li	a2,16
	int tmp;

	if(portnum==0) baseaddr=PCIE0_RC_CFG_BASE;
a000c7f4:	12400009 	beqz	s2,a000c81c <PCIE_PowerDown+0x128>
a000c7f8:	00408021 	move	s0,v0
	else if(portnum==1) baseaddr=PCIE1_RC_CFG_BASE;
a000c7fc:	24020001 	li	v0,1
a000c800:	12420007 	beq	s2,v0,a000c820 <PCIE_PowerDown+0x12c>
a000c804:	3c11b8b2 	lui	s1,0xb8b2
	else { dprintf("Only support P0 and P1 \n"); return 0; }
a000c808:	3c04a001 	lui	a0,0xa001
a000c80c:	0c002325 	jal	a0008c94 <dprintf>
a000c810:	2484623c 	addiu	a0,a0,25148
a000c814:	080032d3 	j	a000cb4c <PCIE_PowerDown+0x458>
a000c818:	00001021 	move	v0,zero
a000c81c:	3c11b8b0 	lui	s1,0xb8b0


	if(mode==0)
a000c820:	1600000c 	bnez	s0,a000c854 <PCIE_PowerDown+0x160>
a000c824:	3c020001 	lui	v0,0x1

		#if 0 //saving more power, leave L1 write
		HostPCIe_SetPhyMdioWrite(portnum, 0xf, 0x0f0f);
		#endif	
		
		tmp = REG32(baseaddr+DEVICE_OFFSET+0x44) &( ~(3));  //D0
a000c828:	34420044 	ori	v0,v0,0x44
a000c82c:	02221021 	addu	v0,s1,v0
a000c830:	8c440000 	lw	a0,0(v0)
		REG32(baseaddr+DEVICE_OFFSET+0x44) = tmp|  (0);  //D0	
a000c834:	2403fffc 	li	v1,-4
a000c838:	00831824 	and	v1,a0,v1
a000c83c:	ac430000 	sw	v1,0(v0)
		dprintf("D0 \n");
a000c840:	3c04a001 	lui	a0,0xa001
a000c844:	0c002325 	jal	a0008c94 <dprintf>
a000c848:	24846258 	addiu	a0,a0,25176
		#endif	
	
		REG32(baseaddr+0x1008) |= (0x200);  		
		dprintf("Host boardcase PME_TurnOff \n");		
	}
	if(mode==7)
a000c84c:	08003233 	j	a000c8cc <PCIE_PowerDown+0x1d8>
a000c850:	24020007 	li	v0,7
		dprintf("D0 \n");
	
	}

	
	if(mode==3)
a000c854:	24020003 	li	v0,3
a000c858:	16020010 	bne	s0,v0,a000c89c <PCIE_PowerDown+0x1a8>
a000c85c:	3c020001 	lui	v0,0x1
	{

		#if 1 //saving more power
		REG32(baseaddr+DEVICE_OFFSET+0x80)|= (0x100);  //enable clock PM
a000c860:	34430080 	ori	v1,v0,0x80
a000c864:	02231821 	addu	v1,s1,v1
a000c868:	8c640000 	lw	a0,0(v1)
a000c86c:	34840100 	ori	a0,a0,0x100
a000c870:	ac640000 	sw	a0,0(v1)
		#endif
		
		tmp = REG32(baseaddr+DEVICE_OFFSET+0x44) &( ~(3));  //D0
a000c874:	34420044 	ori	v0,v0,0x44
a000c878:	02221021 	addu	v0,s1,v0
a000c87c:	8c430000 	lw	v1,0(v0)
		REG32(baseaddr+DEVICE_OFFSET+0x44) = tmp|  (3);  //D3	
a000c880:	34630003 	ori	v1,v1,0x3
a000c884:	ac430000 	sw	v1,0(v0)
		//HostPCIe_SetPhyMdioWrite(0xd, 0x15a6);
		dprintf("D3 hot \n");		
a000c888:	3c04a001 	lui	a0,0xa001
a000c88c:	0c002325 	jal	a0008c94 <dprintf>
a000c890:	24846260 	addiu	a0,a0,25184

	}



	if(mode==8)
a000c894:	08003253 	j	a000c94c <PCIE_PowerDown+0x258>
a000c898:	24020008 	li	v0,8
		#if 0 //saving more power		
		HostPCIe_SetPhyMdioWrite(portnum, 0xf, 0x0708);
		#endif
	}

	if(mode==4)
a000c89c:	24020004 	li	v0,4
a000c8a0:	16020009 	bne	s0,v0,a000c8c8 <PCIE_PowerDown+0x1d4>
a000c8a4:	26221008 	addiu	v0,s1,4104
	{	
		#if 0 //saving more power   leave L1 write
		HostPCIe_SetPhyMdioWrite(portnum, 0xf, 0x0f0f);
		#endif	
	
		REG32(baseaddr+0x1008) |= (0x200);  		
a000c8a8:	8c430000 	lw	v1,0(v0)
a000c8ac:	34630200 	ori	v1,v1,0x200
a000c8b0:	ac430000 	sw	v1,0(v0)
		dprintf("Host boardcase PME_TurnOff \n");		
a000c8b4:	3c04a001 	lui	a0,0xa001
a000c8b8:	0c002325 	jal	a0008c94 <dprintf>
a000c8bc:	2484626c 	addiu	a0,a0,25196
		REG32(baseaddr+0x80) |= 3;   //L1
		REG32(baseaddr+DEVICE_OFFSET+0x80) |= 3;	//L1			

	}

	if(mode==9)
a000c8c0:	08003273 	j	a000c9cc <PCIE_PowerDown+0x2d8>
a000c8c4:	24020009 	li	v0,9
		#endif	
	
		REG32(baseaddr+0x1008) |= (0x200);  		
		dprintf("Host boardcase PME_TurnOff \n");		
	}
	if(mode==7)
a000c8c8:	24020007 	li	v0,7
a000c8cc:	1602001e 	bne	s0,v0,a000c948 <PCIE_PowerDown+0x254>
a000c8d0:	3c020001 	lui	v0,0x1
	{
		REG32(baseaddr+DEVICE_OFFSET+0x070c) &= ~  ((0x7 <<27)|(0x7<<24));
a000c8d4:	3443070c 	ori	v1,v0,0x70c
a000c8d8:	02231821 	addu	v1,s1,v1
a000c8dc:	8c650000 	lw	a1,0(v1)
a000c8e0:	3c04c0ff 	lui	a0,0xc0ff
a000c8e4:	3484ffff 	ori	a0,a0,0xffff
a000c8e8:	00a42024 	and	a0,a1,a0
a000c8ec:	ac640000 	sw	a0,0(v1)
		REG32(baseaddr+DEVICE_OFFSET+0x070c) |=  ((3)<<27) | ((1)<<24);   //L1=3us, L0s=1us
a000c8f0:	8c650000 	lw	a1,0(v1)
a000c8f4:	3c041900 	lui	a0,0x1900
a000c8f8:	00a42025 	or	a0,a1,a0
a000c8fc:	ac640000 	sw	a0,0(v1)

		REG32(baseaddr+0x80) &= ~(0x3);
a000c900:	26230080 	addiu	v1,s1,128
a000c904:	8c650000 	lw	a1,0(v1)
a000c908:	2404fffc 	li	a0,-4
a000c90c:	00a42824 	and	a1,a1,a0
a000c910:	ac650000 	sw	a1,0(v1)
		REG32(baseaddr+DEVICE_OFFSET+0x80) &= ~(0x3);		
a000c914:	34420080 	ori	v0,v0,0x80
a000c918:	02221021 	addu	v0,s1,v0
a000c91c:	8c450000 	lw	a1,0(v0)
a000c920:	00a42024 	and	a0,a1,a0
a000c924:	ac440000 	sw	a0,0(v0)

		REG32(baseaddr+0x80) |= 1;   //L0s
a000c928:	8c640000 	lw	a0,0(v1)
a000c92c:	34840001 	ori	a0,a0,0x1
a000c930:	ac640000 	sw	a0,0(v1)
		REG32(baseaddr+DEVICE_OFFSET+0x80) |= 1;				
a000c934:	8c430000 	lw	v1,0(v0)
a000c938:	34630001 	ori	v1,v1,0x1
a000c93c:	ac430000 	sw	v1,0(v0)
		dprintf("status=%x \n", REG32(0xb8b00728) );		
	}
#endif

       //-------------------------------------------------------------	
	if(mode==0x010)
a000c940:	08003282 	j	a000ca08 <PCIE_PowerDown+0x314>
a000c944:	24020010 	li	v0,16

	}



	if(mode==8)
a000c948:	24020008 	li	v0,8
a000c94c:	1602001e 	bne	s0,v0,a000c9c8 <PCIE_PowerDown+0x2d4>
a000c950:	3c020001 	lui	v0,0x1
	{
		REG32(baseaddr+DEVICE_OFFSET+0x070c) &= ~  ((0x7 <<27)|(0x7<<24));
a000c954:	3443070c 	ori	v1,v0,0x70c
a000c958:	02231821 	addu	v1,s1,v1
a000c95c:	8c650000 	lw	a1,0(v1)
a000c960:	3c04c0ff 	lui	a0,0xc0ff
a000c964:	3484ffff 	ori	a0,a0,0xffff
a000c968:	00a42024 	and	a0,a1,a0
a000c96c:	ac640000 	sw	a0,0(v1)
		REG32(baseaddr+DEVICE_OFFSET+0x070c) |=  ((1)<<27) | ((3)<<24);   //L1=1us, L0s=3us
a000c970:	8c650000 	lw	a1,0(v1)
a000c974:	3c040b00 	lui	a0,0xb00
a000c978:	00a42025 	or	a0,a1,a0
a000c97c:	ac640000 	sw	a0,0(v1)

		REG32(baseaddr+0x80) &= ~(0x3);
a000c980:	26230080 	addiu	v1,s1,128
a000c984:	8c650000 	lw	a1,0(v1)
a000c988:	2404fffc 	li	a0,-4
a000c98c:	00a42824 	and	a1,a1,a0
a000c990:	ac650000 	sw	a1,0(v1)
		REG32(baseaddr+DEVICE_OFFSET+0x80) &= ~(0x3);		
a000c994:	34420080 	ori	v0,v0,0x80
a000c998:	02221021 	addu	v0,s1,v0
a000c99c:	8c450000 	lw	a1,0(v0)
a000c9a0:	00a42024 	and	a0,a1,a0
a000c9a4:	ac440000 	sw	a0,0(v0)

		REG32(baseaddr+0x80) |= 3;   //L1
a000c9a8:	8c640000 	lw	a0,0(v1)
a000c9ac:	34840003 	ori	a0,a0,0x3
a000c9b0:	ac640000 	sw	a0,0(v1)
		REG32(baseaddr+DEVICE_OFFSET+0x80) |= 3;	//L1			
a000c9b4:	8c430000 	lw	v1,0(v0)
a000c9b8:	34630003 	ori	v1,v1,0x3
a000c9bc:	ac430000 	sw	v1,0(v0)
		
		//delay_ms(100);
		dprintf("DID/VID=%x\n", REG32(0xb8b10000));
	}
	//-------------------------------------------------------------	
	if(mode==0x020)
a000c9c0:	0800329b 	j	a000ca6c <PCIE_PowerDown+0x378>
a000c9c4:	24020020 	li	v0,32
		REG32(baseaddr+0x80) |= 3;   //L1
		REG32(baseaddr+DEVICE_OFFSET+0x80) |= 3;	//L1			

	}

	if(mode==9)
a000c9c8:	24020009 	li	v0,9
a000c9cc:	1602000d 	bne	s0,v0,a000ca04 <PCIE_PowerDown+0x310>
a000c9d0:	26220080 	addiu	v0,s1,128
	{
		REG32(baseaddr+0x80) &= ~(0x3);
a000c9d4:	8c440000 	lw	a0,0(v0)
a000c9d8:	2403fffc 	li	v1,-4
a000c9dc:	00832024 	and	a0,a0,v1
a000c9e0:	ac440000 	sw	a0,0(v0)
		REG32(baseaddr+DEVICE_OFFSET+0x80) &= ~(0x3);
a000c9e4:	3c020001 	lui	v0,0x1
a000c9e8:	34420080 	ori	v0,v0,0x80
a000c9ec:	02221021 	addu	v0,s1,v0
a000c9f0:	8c440000 	lw	a0,0(v0)
a000c9f4:	00831824 	and	v1,a0,v1
a000c9f8:	ac430000 	sw	v1,0(v0)





		dprintf("Port%d Link status=%x \n", portnum, REG32(baseaddr+0x728)&0x1f );			
a000c9fc:	080032cb 	j	a000cb2c <PCIE_PowerDown+0x438>
a000ca00:	26310728 	addiu	s1,s1,1832
		dprintf("status=%x \n", REG32(0xb8b00728) );		
	}
#endif

       //-------------------------------------------------------------	
	if(mode==0x010)
a000ca04:	24020010 	li	v0,16
a000ca08:	16020018 	bne	s0,v0,a000ca6c <PCIE_PowerDown+0x378>
a000ca0c:	24020020 	li	v0,32
	{
             //L0->L1->L0
		tmp = REG32(0xb8b10044) &( ~(3));  //D0
a000ca10:	3c10b8b1 	lui	s0,0xb8b1
a000ca14:	36100044 	ori	s0,s0,0x44
a000ca18:	8e130000 	lw	s3,0(s0)
a000ca1c:	2402fffc 	li	v0,-4
a000ca20:	02629824 	and	s3,s3,v0
		{	if((REG32(0xb8b00728)&0x1f)==0x11)   //wait to L0
			break;
		}	
	
       */
		REG32(0xb8b10044) = tmp|  (3);  //D3	
a000ca24:	36620003 	ori	v0,s3,0x3
a000ca28:	ae020000 	sw	v0,0(s0)
		while(1)
		{	if((REG32(0xb8b00728)&0x1f)==0x14)   //wait to L1
			break;
		}	
		*/
		delay_ms(100);
a000ca2c:	0c002219 	jal	a0008864 <delay_ms>
a000ca30:	24040064 	li	a0,100
		//REG32(0xb8b10000);
		REG32(0xb8b10044) = tmp|  (0);  //D0, wakeup
a000ca34:	ae130000 	sw	s3,0(s0)
		
		while(1)
		{	if((REG32(0xb8b00728)&0x1f)==0x11)   //wait to L0
a000ca38:	3c04b8b0 	lui	a0,0xb8b0
a000ca3c:	34840728 	ori	a0,a0,0x728
a000ca40:	24030011 	li	v1,17
a000ca44:	8c820000 	lw	v0,0(a0)
a000ca48:	3042001f 	andi	v0,v0,0x1f
a000ca4c:	1443fffd 	bne	v0,v1,a000ca44 <PCIE_PowerDown+0x350>
a000ca50:	3c02b8b1 	lui	v0,0xb8b1
			break;
		}	
		
		//delay_ms(100);
		dprintf("DID/VID=%x\n", REG32(0xb8b10000));
a000ca54:	8c450000 	lw	a1,0(v0)
a000ca58:	3c04a001 	lui	a0,0xa001
a000ca5c:	0c002325 	jal	a0008c94 <dprintf>
a000ca60:	2484628c 	addiu	a0,a0,25228





		dprintf("Port%d Link status=%x \n", portnum, REG32(baseaddr+0x728)&0x1f );			
a000ca64:	080032cb 	j	a000cb2c <PCIE_PowerDown+0x438>
a000ca68:	26310728 	addiu	s1,s1,1832
		
		//delay_ms(100);
		dprintf("DID/VID=%x\n", REG32(0xb8b10000));
	}
	//-------------------------------------------------------------	
	if(mode==0x020)
a000ca6c:	1602002e 	bne	s0,v0,a000cb28 <PCIE_PowerDown+0x434>
a000ca70:	00000000 	nop
	{
             //L0->L2->L0
		tmp = REG32(0xb8b10044) &( ~(3));  //D0
a000ca74:	3c02b8b1 	lui	v0,0xb8b1
a000ca78:	34420044 	ori	v0,v0,0x44
a000ca7c:	8c430000 	lw	v1,0(v0)

		REG32(0xb8b10044) = tmp|  (3);  //D3	
a000ca80:	34630003 	ori	v1,v1,0x3
a000ca84:	ac430000 	sw	v1,0(v0)
		delay_ms(100);
a000ca88:	0c002219 	jal	a0008864 <delay_ms>
a000ca8c:	24040064 	li	a0,100

		REG32(0xb8b01008) |= (0x200);  
a000ca90:	3c14b8b0 	lui	s4,0xb8b0
a000ca94:	36941008 	ori	s4,s4,0x1008
a000ca98:	8e820000 	lw	v0,0(s4)
a000ca9c:	34420200 	ori	v0,v0,0x200
a000caa0:	ae820000 	sw	v0,0(s4)
        __delay(100000);  		
a000caa4:	3c100001 	lui	s0,0x1
a000caa8:	0c0038dc 	jal	a000e370 <__delay>
a000caac:	360486a0 	ori	a0,s0,0x86a0
		//dprintf("Host boardcase PME_TurnOff \n");	
		//delay_ms(100);

	//wakeup
     REG32(SYS_CLKMANAGE) &= ~(1<<12);    //perst=0 off.
a000cab0:	3c13b800 	lui	s3,0xb800
a000cab4:	36730010 	ori	s3,s3,0x10
a000cab8:	8e630000 	lw	v1,0(s3)
a000cabc:	2402efff 	li	v0,-4097
a000cac0:	00621024 	and	v0,v1,v0
a000cac4:	ae620000 	sw	v0,0(s3)
            //dprintf("CLK_MANAGE=%x \n",  REG32(CLK_MANAGE));
        __delay(100000);   
a000cac8:	0c0038dc 	jal	a000e370 <__delay>
a000cacc:	360486a0 	ori	a0,s0,0x86a0
        __delay(100000);   
a000cad0:	0c0038dc 	jal	a000e370 <__delay>
a000cad4:	360486a0 	ori	a0,s0,0x86a0
        __delay(100000);   
a000cad8:	0c0038dc 	jal	a000e370 <__delay>
a000cadc:	360486a0 	ori	a0,s0,0x86a0
		
    REG32(SYS_CLKMANAGE) |=  (1<<12);   //PERST=1
a000cae0:	8e620000 	lw	v0,0(s3)
a000cae4:	34421000 	ori	v0,v0,0x1000
a000cae8:	ae620000 	sw	v0,0(s3)
    //prom_printf("\nCLK_MANAGE(0x%x)=0x%x\n\n",CLK_MANAGE,READ_MEM32(CLK_MANAGE));

	
        //4. PCIE PHY Reset       
    REG32(PCIE_PHY0) = 0x01;	//bit7 PHY reset=0   bit0 Enable LTSSM=1
a000caec:	24020001 	li	v0,1
a000caf0:	ae820000 	sw	v0,0(s4)
    REG32(PCIE_PHY0) = 0x81;   //bit7 PHY reset=1   bit0 Enable LTSSM=1
a000caf4:	24020081 	li	v0,129
a000caf8:	ae820000 	sw	v0,0(s4)
	}
#else

	while(1)
	{
		if( (REG32(0xb8b00728)&0x1f)==0x11)
a000cafc:	3c04b8b0 	lui	a0,0xb8b0
a000cb00:	34840728 	ori	a0,a0,0x728
a000cb04:	24030011 	li	v1,17
a000cb08:	8c820000 	lw	v0,0(a0)
a000cb0c:	3042001f 	andi	v0,v0,0x1f
a000cb10:	1443fffd 	bne	v0,v1,a000cb08 <PCIE_PowerDown+0x414>
a000cb14:	3c02b8b1 	lui	v0,0xb8b1
	}
#endif



		dprintf("DID/VID=%x\n", REG32(0xb8b10000));
a000cb18:	8c450000 	lw	a1,0(v0)
a000cb1c:	3c04a001 	lui	a0,0xa001
a000cb20:	0c002325 	jal	a0008c94 <dprintf>
a000cb24:	2484628c 	addiu	a0,a0,25228





		dprintf("Port%d Link status=%x \n", portnum, REG32(baseaddr+0x728)&0x1f );			
a000cb28:	26310728 	addiu	s1,s1,1832
a000cb2c:	8e260000 	lw	a2,0(s1)
a000cb30:	3c04a001 	lui	a0,0xa001
a000cb34:	24846298 	addiu	a0,a0,25240
a000cb38:	02402821 	move	a1,s2
a000cb3c:	0c002325 	jal	a0008c94 <dprintf>
a000cb40:	30c6001f 	andi	a2,a2,0x1f
		
};
a000cb44:	080032de 	j	a000cb78 <PCIE_PowerDown+0x484>
a000cb48:	8fbf0024 	lw	ra,36(sp)
a000cb4c:	080032de 	j	a000cb78 <PCIE_PowerDown+0x484>
a000cb50:	8fbf0024 	lw	ra,36(sp)
		dprintf("P0 Link status=%x \n", REG32(0xb8b00728)&0x1f );		
		dprintf("P1 Link status=%x \n", REG32(0xb8b20728)&0x1f );		
		return 0;
	}
	if(argc>=1)	portnum = strtoul((const char*)(argv[0]), (char **)NULL, 16);
	if(argc>=2)   mode = strtoul((const char*)(argv[1]), (char **)NULL, 16);	
a000cb54:	8ca40004 	lw	a0,4(a1)
a000cb58:	00002821 	move	a1,zero
a000cb5c:	0c0020c4 	jal	a0008310 <strtoul>
a000cb60:	24060010 	li	a2,16
a000cb64:	00408021 	move	s0,v0
a000cb68:	00009021 	move	s2,zero
a000cb6c:	08003208 	j	a000c820 <PCIE_PowerDown+0x12c>
a000cb70:	3c11b8b0 	lui	s1,0xb8b0



		dprintf("Port%d Link status=%x \n", portnum, REG32(baseaddr+0x728)&0x1f );			
		
};
a000cb74:	8fbf0024 	lw	ra,36(sp)
a000cb78:	8fb40020 	lw	s4,32(sp)
a000cb7c:	8fb3001c 	lw	s3,28(sp)
a000cb80:	8fb20018 	lw	s2,24(sp)
a000cb84:	8fb10014 	lw	s1,20(sp)
a000cb88:	8fb00010 	lw	s0,16(sp)
a000cb8c:	03e00008 	jr	ra
a000cb90:	27bd0028 	addiu	sp,sp,40

a000cb94 <PCIE_Device_PERST>:

//===========================================================

//------------------------------------------------------------------------
void PCIE_Device_PERST(void)
{
a000cb94:	27bdffe0 	addiu	sp,sp,-32
a000cb98:	afbf001c 	sw	ra,28(sp)
a000cb9c:	afb10018 	sw	s1,24(sp)
a000cba0:	afb00014 	sw	s0,20(sp)
	 #define CLK_MANAGE 	0xb8000010
        // 6. PCIE Device Reset       
     REG32(CLK_MANAGE) &= ~(1<<26);    //perst=0 off.    
a000cba4:	3c11b800 	lui	s1,0xb800
a000cba8:	36310010 	ori	s1,s1,0x10
a000cbac:	8e230000 	lw	v1,0(s1)
a000cbb0:	3c02fbff 	lui	v0,0xfbff
a000cbb4:	3442ffff 	ori	v0,v0,0xffff
a000cbb8:	00621024 	and	v0,v1,v0
a000cbbc:	ae220000 	sw	v0,0(s1)
        __delay(100000);   //PCIE standadrd: poweron: 100us, after poweron: 100ms
a000cbc0:	3c100001 	lui	s0,0x1
a000cbc4:	0c0038dc 	jal	a000e370 <__delay>
a000cbc8:	360486a0 	ori	a0,s0,0x86a0
        __delay(100000);   
a000cbcc:	0c0038dc 	jal	a000e370 <__delay>
a000cbd0:	360486a0 	ori	a0,s0,0x86a0
        __delay(100000);   		
a000cbd4:	0c0038dc 	jal	a000e370 <__delay>
a000cbd8:	360486a0 	ori	a0,s0,0x86a0
    REG32(CLK_MANAGE) |=  (1<<26);   //PERST=1
a000cbdc:	8e230000 	lw	v1,0(s1)
a000cbe0:	3c020400 	lui	v0,0x400
a000cbe4:	00621025 	or	v0,v1,v0
a000cbe8:	ae220000 	sw	v0,0(s1)

}
a000cbec:	8fbf001c 	lw	ra,28(sp)
a000cbf0:	8fb10018 	lw	s1,24(sp)
a000cbf4:	8fb00014 	lw	s0,20(sp)
a000cbf8:	03e00008 	jr	ra
a000cbfc:	27bd0020 	addiu	sp,sp,32

a000cc00 <Test_HostPCIE_DataLoopback>:
}


//------------------------------------------------------------------------
int Test_HostPCIE_DataLoopback(int argc, char* argv[])
{
a000cc00:	27bdffd0 	addiu	sp,sp,-48
a000cc04:	afbf002c 	sw	ra,44(sp)
a000cc08:	afb50028 	sw	s5,40(sp)
a000cc0c:	afb40024 	sw	s4,36(sp)
a000cc10:	afb30020 	sw	s3,32(sp)
a000cc14:	afb2001c 	sw	s2,28(sp)
a000cc18:	afb10018 	sw	s1,24(sp)
a000cc1c:	afb00014 	sw	s0,20(sp)
a000cc20:	00808821 	move	s1,a0
a000cc24:	00a09021 	move	s2,a1

//    PCIE_reset_procedure(0,0,1);
	unsigned int portnum=0;
	unsigned int test_packet_num=1;
	
	if(argc >= 1) 
a000cc28:	18800006 	blez	a0,a000cc44 <Test_HostPCIE_DataLoopback+0x44>
a000cc2c:	00008021 	move	s0,zero
	{	portnum= strtoul((const char*)(argv[0]), (char **)NULL, 16);
a000cc30:	8ca40000 	lw	a0,0(a1)
a000cc34:	00002821 	move	a1,zero
a000cc38:	0c0020c4 	jal	a0008310 <strtoul>
a000cc3c:	24060010 	li	a2,16
a000cc40:	00408021 	move	s0,v0
	}

	if(argc >= 2) 
a000cc44:	2a220002 	slti	v0,s1,2
a000cc48:	14400007 	bnez	v0,a000cc68 <Test_HostPCIE_DataLoopback+0x68>
a000cc4c:	24110001 	li	s1,1
	{	test_packet_num= strtoul((const char*)(argv[1]), (char **)NULL, 16);
a000cc50:	8e440004 	lw	a0,4(s2)
a000cc54:	00002821 	move	a1,zero
a000cc58:	0c0020c4 	jal	a0008310 <strtoul>
a000cc5c:	24060010 	li	a2,16
    unsigned int cnt;

    unsigned int PCIE_Test_cnt;
	unsigned int pcie_err=0;
	
	if(test_packet_num==0)
a000cc60:	10400006 	beqz	v0,a000cc7c <Test_HostPCIE_DataLoopback+0x7c>
a000cc64:	00408821 	move	s1,v0
a000cc68:	00009021 	move	s2,zero
a000cc6c:	24130001 	li	s3,1
#if DBG
        prom_printf("\n==================(Start)======================\n");
        prom_printf("\nPCIE_Test_cnt:%d\n",PCIE_Test_cnt);
#endif        

        if(example(portnum, at2_mode)==0)   //0: mean fail
a000cc70:	3c15a002 	lui	s5,0xa002

	{		at2_errcnt++;
a000cc74:	08003333 	j	a000cccc <Test_HostPCIE_DataLoopback+0xcc>
a000cc78:	3c14a002 	lui	s4,0xa002
	unsigned int pcie_err=0;
	
	if(test_packet_num==0)
	{
		while(1)
       	 if(example(portnum, at2_mode)==0)   //0: mean fail
a000cc7c:	3c11a002 	lui	s1,0xa002
       	 {
				//printf("FAIL, and hang!\n");
				printf("FAIL!\n");
a000cc80:	3c12a001 	lui	s2,0xa001
a000cc84:	265262b0 	addiu	s2,s2,25264
	unsigned int pcie_err=0;
	
	if(test_packet_num==0)
	{
		while(1)
       	 if(example(portnum, at2_mode)==0)   //0: mean fail
a000cc88:	02002021 	move	a0,s0
a000cc8c:	0c002671 	jal	a00099c4 <example>
a000cc90:	8e258934 	lw	a1,-30412(s1)
a000cc94:	1440fffc 	bnez	v0,a000cc88 <Test_HostPCIE_DataLoopback+0x88>
a000cc98:	00000000 	nop
       	 {
				//printf("FAIL, and hang!\n");
				printf("FAIL!\n");
a000cc9c:	0c002325 	jal	a0008c94 <dprintf>
a000cca0:	02402021 	move	a0,s2
	unsigned int pcie_err=0;
	
	if(test_packet_num==0)
	{
		while(1)
       	 if(example(portnum, at2_mode)==0)   //0: mean fail
a000cca4:	08003323 	j	a000cc8c <Test_HostPCIE_DataLoopback+0x8c>
a000cca8:	02002021 	move	a0,s0
#if DBG
        prom_printf("\n==================(Start)======================\n");
        prom_printf("\nPCIE_Test_cnt:%d\n",PCIE_Test_cnt);
#endif        

        if(example(portnum, at2_mode)==0)   //0: mean fail
a000ccac:	0c002671 	jal	a00099c4 <example>
a000ccb0:	8ea58934 	lw	a1,-30412(s5)
a000ccb4:	14400004 	bnez	v0,a000ccc8 <Test_HostPCIE_DataLoopback+0xc8>
a000ccb8:	8e828930 	lw	v0,-30416(s4)

	{		at2_errcnt++;
a000ccbc:	24420001 	addiu	v0,v0,1
a000ccc0:	ae828930 	sw	v0,-30416(s4)
		pcie_err++;
a000ccc4:	26520001 	addiu	s2,s2,1
				printf("FAIL!\n");
				//while(1)  {};
		 }
	}
	
    for (PCIE_Test_cnt=1; PCIE_Test_cnt<=test_packet_num; PCIE_Test_cnt++)
a000ccc8:	26730001 	addiu	s3,s3,1
a000cccc:	0233102b 	sltu	v0,s1,s3
a000ccd0:	1040fff6 	beqz	v0,a000ccac <Test_HostPCIE_DataLoopback+0xac>
a000ccd4:	02002021 	move	a0,s0
			return;
	}
#endif
		
    }
	printf("====> Total test cnt=%d, test fail=%d\n", test_packet_num,  pcie_err);
a000ccd8:	3c04a001 	lui	a0,0xa001
a000ccdc:	248462b8 	addiu	a0,a0,25272
a000cce0:	02202821 	move	a1,s1
a000cce4:	0c002325 	jal	a0008c94 <dprintf>
a000cce8:	02403021 	move	a2,s2
	
}; 
a000ccec:	8fbf002c 	lw	ra,44(sp)
a000ccf0:	8fb50028 	lw	s5,40(sp)
a000ccf4:	8fb40024 	lw	s4,36(sp)
a000ccf8:	8fb30020 	lw	s3,32(sp)
a000ccfc:	8fb2001c 	lw	s2,28(sp)
a000cd00:	8fb10018 	lw	s1,24(sp)
a000cd04:	8fb00014 	lw	s0,20(sp)
a000cd08:	03e00008 	jr	ra
a000cd0c:	27bd0030 	addiu	sp,sp,48

a000cd10 <PCIE_Check_Link>:
	REG32(pcie_phy) = 0x81;   //bit7: PHY reset=1   bit0: Enable LTSSM=1
	
}
//------------------------------------------------------------------------
int PCIE_Check_Link(unsigned int portnum)
{
a000cd10:	27bdffd0 	addiu	sp,sp,-48
a000cd14:	afbf002c 	sw	ra,44(sp)
a000cd18:	afb30028 	sw	s3,40(sp)
a000cd1c:	afb20024 	sw	s2,36(sp)
a000cd20:	afb10020 	sw	s1,32(sp)
a000cd24:	afb0001c 	sw	s0,28(sp)
	unsigned int dbgaddr;
	unsigned int cfgaddr;
	
	if(portnum==0)	dbgaddr=0xb8b00728;
a000cd28:	14800004 	bnez	a0,a000cd3c <PCIE_Check_Link+0x2c>
a000cd2c:	00808021 	move	s0,a0
a000cd30:	3c11b8b0 	lui	s1,0xb8b0
a000cd34:	08003359 	j	a000cd64 <PCIE_Check_Link+0x54>
a000cd38:	36310728 	ori	s1,s1,0x728
	else if(portnum==1)	dbgaddr=0xb8b20728;
a000cd3c:	24020001 	li	v0,1
a000cd40:	14820004 	bne	a0,v0,a000cd54 <PCIE_Check_Link+0x44>
a000cd44:	24020002 	li	v0,2
a000cd48:	3c11b8b2 	lui	s1,0xb8b2
a000cd4c:	08003359 	j	a000cd64 <PCIE_Check_Link+0x54>
a000cd50:	36310728 	ori	s1,s1,0x728
	else if(portnum==2)	dbgaddr=0xb8b40728;	
a000cd54:	14820033 	bne	a0,v0,a000ce24 <PCIE_Check_Link+0x114>
a000cd58:	8fbf002c 	lw	ra,44(sp)
a000cd5c:	3c11b8b4 	lui	s1,0xb8b4
a000cd60:	36310728 	ori	s1,s1,0x728
	else return;	

  //wait for LinkUP
      delay_ms(10);
a000cd64:	0c002219 	jal	a0008864 <delay_ms>
a000cd68:	2404000a 	li	a0,10
	volatile int i=5;
a000cd6c:	24020005 	li	v0,5
a000cd70:	afa20010 	sw	v0,16(sp)
	while(--i)
a000cd74:	08003365 	j	a000cd94 <PCIE_Check_Link+0x84>
a000cd78:	24120011 	li	s2,17
	{
		 delay_ms(10);	  
a000cd7c:	0c002219 	jal	a0008864 <delay_ms>
a000cd80:	2404000a 	li	a0,10
	      if( (REG32(dbgaddr)&0x1f)==0x11)
a000cd84:	8e220000 	lw	v0,0(s1)
a000cd88:	3042001f 	andi	v0,v0,0x1f
a000cd8c:	10520007 	beq	v0,s2,a000cdac <PCIE_Check_Link+0x9c>
a000cd90:	00000000 	nop
	else return;	

  //wait for LinkUP
      delay_ms(10);
	volatile int i=5;
	while(--i)
a000cd94:	8fa20010 	lw	v0,16(sp)
a000cd98:	2442ffff 	addiu	v0,v0,-1
a000cd9c:	afa20010 	sw	v0,16(sp)
a000cda0:	8fa20010 	lw	v0,16(sp)
a000cda4:	1440fff5 	bnez	v0,a000cd7c <PCIE_Check_Link+0x6c>
a000cda8:	00000000 	nop
		 delay_ms(10);	  
	      if( (REG32(dbgaddr)&0x1f)==0x11)
		  	break;

	}
	if(i==0)
a000cdac:	8fa20010 	lw	v0,16(sp)
a000cdb0:	14400006 	bnez	v0,a000cdcc <PCIE_Check_Link+0xbc>
a000cdb4:	3c04a001 	lui	a0,0xa001
	{	//if(at2_mode==0)  //not auto test, show message
		prom_printf("PCIE_P%d ->  Cannot LinkUP\n",portnum);
a000cdb8:	248462e0 	addiu	a0,a0,25312
a000cdbc:	0c0023a7 	jal	a0008e9c <prom_printf>
a000cdc0:	02002821 	move	a1,s0
		return 0;
a000cdc4:	08003388 	j	a000ce20 <PCIE_Check_Link+0x110>
a000cdc8:	00001021 	move	v0,zero
	}
	else  //already  linkup
	{
		if(portnum==0)	      REG32(PCIE0_RC_CFG_BASE + 0x04)= 0x00100007;
a000cdcc:	16000007 	bnez	s0,a000cdec <PCIE_Check_Link+0xdc>
a000cdd0:	3c030010 	lui	v1,0x10
a000cdd4:	34630007 	ori	v1,v1,0x7
a000cdd8:	3c02b8b0 	lui	v0,0xb8b0
a000cddc:	34420004 	ori	v0,v0,0x4
a000cde0:	ac430000 	sw	v1,0(v0)
a000cde4:	08003382 	j	a000ce08 <PCIE_Check_Link+0xf8>
a000cde8:	3c13b8b1 	lui	s3,0xb8b1
		else if(portnum==1) REG32(PCIE1_RC_CFG_BASE + 0x04)= 0x00100007;
a000cdec:	24020001 	li	v0,1
a000cdf0:	16020005 	bne	s0,v0,a000ce08 <PCIE_Check_Link+0xf8>
a000cdf4:	34630007 	ori	v1,v1,0x7
a000cdf8:	3c02b8b2 	lui	v0,0xb8b2
a000cdfc:	34420004 	ori	v0,v0,0x4
a000ce00:	ac430000 	sw	v1,0(v0)
a000ce04:	3c13b8b3 	lui	s3,0xb8b3
		  
		if(portnum==0) cfgaddr=0xb8b10000;
		else if(portnum==1) cfgaddr=0xb8b30000;

		//if(at2_mode==0)
		dprintf("Find Port=%x Device:Vender ID=%x\n", portnum, REG32(cfgaddr) );
a000ce08:	8e660000 	lw	a2,0(s3)
a000ce0c:	3c04a001 	lui	a0,0xa001
a000ce10:	248462fc 	addiu	a0,a0,25340
a000ce14:	0c002325 	jal	a0008c94 <dprintf>
a000ce18:	02002821 	move	a1,s0
a000ce1c:	24020001 	li	v0,1
	}
	return 1;
}
a000ce20:	8fbf002c 	lw	ra,44(sp)
a000ce24:	8fb30028 	lw	s3,40(sp)
a000ce28:	8fb20024 	lw	s2,36(sp)
a000ce2c:	8fb10020 	lw	s1,32(sp)
a000ce30:	8fb0001c 	lw	s0,28(sp)
a000ce34:	03e00008 	jr	ra
a000ce38:	27bd0030 	addiu	sp,sp,48

a000ce3c <PCIE_reset_procedure>:
//#else  //25MHz
//#define PHY_EAT_40MHZ 0
//#endif

void PCIE_reset_procedure(int portnum, int Use_External_PCIE_CLK, int mdio_reset)
{
a000ce3c:	27bdffe0 	addiu	sp,sp,-32
a000ce40:	afbf001c 	sw	ra,28(sp)
a000ce44:	afb10018 	sw	s1,24(sp)
a000ce48:	afb00014 	sw	s0,20(sp)
a000ce4c:	00808021 	move	s0,a0
a000ce50:	00c08821 	move	s1,a2
 	//dprintf("port=%x, mdio_rst=%x \n", portnum, mdio_reset);

	
 #if 1
	#define SYS_HW_STRAP   (0xb8000000 +0x08)
	unsigned int v=REG32(SYS_HW_STRAP);
a000ce54:	3c03b800 	lui	v1,0xb800
a000ce58:	34620008 	ori	v0,v1,0x8
a000ce5c:	8c420000 	lw	v0,0(v0)
	//unsigned char sel40m=GET_BITVAL(v, 25, RANG1);
	unsigned char sel40m=GET_BITVAL(v, 24, RANG1);
#endif

	//for RTL8198c pin_mux2 (0xb8000104) [21:20]=01
	REG32(0xb8000104)&=~(3<<20);
a000ce60:	34620104 	ori	v0,v1,0x104
a000ce64:	8c450000 	lw	a1,0(v0)
a000ce68:	3c04ffcf 	lui	a0,0xffcf
a000ce6c:	3484ffff 	ori	a0,a0,0xffff
a000ce70:	00a42024 	and	a0,a1,a0
a000ce74:	ac440000 	sw	a0,0(v0)
	REG32(0xb8000104)|=(1<<20);
a000ce78:	8c450000 	lw	a1,0(v0)
a000ce7c:	3c040010 	lui	a0,0x10
a000ce80:	00a42025 	or	a0,a1,a0
a000ce84:	ac440000 	sw	a0,0(v0)



 	//first, Turn On PCIE IP
	 #define CLK_MANAGE 	0xb8000010
	REG32(CLK_MANAGE) |= (1<<12) | (1<<13) | (1<<18);
a000ce88:	34630010 	ori	v1,v1,0x10
a000ce8c:	8c640000 	lw	a0,0(v1)
a000ce90:	3c020004 	lui	v0,0x4
a000ce94:	34423000 	ori	v0,v0,0x3000
a000ce98:	00821025 	or	v0,a0,v0
a000ce9c:	ac620000 	sw	v0,0(v1)
	 
	if(portnum==0)		    REG32(CLK_MANAGE) |=  (1<<14);        //enable active_pcie0
a000cea0:	1600000d 	bnez	s0,a000ced8 <PCIE_reset_procedure+0x9c>
a000cea4:	24020001 	li	v0,1
a000cea8:	00601021 	move	v0,v1
a000ceac:	8c630000 	lw	v1,0(v1)
a000ceb0:	34634000 	ori	v1,v1,0x4000
a000ceb4:	ac430000 	sw	v1,0(v0)
	else return;
		    

			
      // __delay(1000*1000*1);
       delay_ms(10);
a000ceb8:	0c002219 	jal	a0008864 <delay_ms>
a000cebc:	2404000a 	li	a0,10

        //add compatible, slove sata pcie card.
	if(portnum==0)	  REG32(0xb8b0100c)=(1<<3);  //set target Device Num=1;
a000cec0:	24030008 	li	v1,8
a000cec4:	3c02b8b0 	lui	v0,0xb8b0
a000cec8:	3442100c 	ori	v0,v0,0x100c
a000cecc:	ac430000 	sw	v1,0(v0)
a000ced0:	080033c4 	j	a000cf10 <PCIE_reset_procedure+0xd4>
a000ced4:	00000000 	nop
 	//first, Turn On PCIE IP
	 #define CLK_MANAGE 	0xb8000010
	REG32(CLK_MANAGE) |= (1<<12) | (1<<13) | (1<<18);
	 
	if(portnum==0)		    REG32(CLK_MANAGE) |=  (1<<14);        //enable active_pcie0
	else if(portnum==1)	    REG32(CLK_MANAGE) |=  (1<<16);        //enable active_pcie1	
a000ced8:	16020069 	bne	s0,v0,a000d080 <PCIE_reset_procedure+0x244>
a000cedc:	8fbf001c 	lw	ra,28(sp)
a000cee0:	3c02b800 	lui	v0,0xb800
a000cee4:	34420010 	ori	v0,v0,0x10
a000cee8:	8c440000 	lw	a0,0(v0)
a000ceec:	3c030001 	lui	v1,0x1
a000cef0:	00831825 	or	v1,a0,v1
a000cef4:	ac430000 	sw	v1,0(v0)
	else return;
		    

			
      // __delay(1000*1000*1);
       delay_ms(10);
a000cef8:	0c002219 	jal	a0008864 <delay_ms>
a000cefc:	2404000a 	li	a0,10

        //add compatible, slove sata pcie card.
	if(portnum==0)	  REG32(0xb8b0100c)=(1<<3);  //set target Device Num=1;
	if(portnum==1)	  REG32(0xb8b2100c)=(2<<3);  //set target Device Num=1;
a000cf00:	24030010 	li	v1,16
a000cf04:	3c02b8b2 	lui	v0,0xb8b2
a000cf08:	3442100c 	ori	v0,v0,0x100c
a000cf0c:	ac430000 	sw	v1,0(v0)

 	//REG32(SYS_PCIE_ANA)=0x3f39;   //PCIE_ANA  bokai tell me to do this.

	if(mdio_reset)
a000cf10:	12200019 	beqz	s1,a000cf78 <PCIE_reset_procedure+0x13c>
a000cf14:	3c02a002 	lui	v0,0xa002
	{
		if(at2_mode==0)  //no auto test, show message
a000cf18:	8c428934 	lw	v0,-30412(v0)
a000cf1c:	14400003 	bnez	v0,a000cf2c <PCIE_reset_procedure+0xf0>
a000cf20:	3c04a001 	lui	a0,0xa001
			dprintf("Do MDIO_RESET\n");
a000cf24:	0c002325 	jal	a0008c94 <dprintf>
a000cf28:	24846320 	addiu	a0,a0,25376
		
		 delay_ms(10);
a000cf2c:	0c002219 	jal	a0008864 <delay_ms>
a000cf30:	2404000a 	li	a0,10
       	// 3.MDIO Reset
		PCIE_MDIO_Reset(portnum);
a000cf34:	02008821 	move	s1,s0
a000cf38:	0c002fd4 	jal	a000bf50 <PCIE_MDIO_Reset>
a000cf3c:	02002021 	move	a0,s0
	}  
	
	  delay_ms(10);
a000cf40:	0c002219 	jal	a0008864 <delay_ms>
a000cf44:	2404000a 	li	a0,10
 	PCIE_PHY_Reset(portnum);	
a000cf48:	0c002fe4 	jal	a000bf90 <PCIE_PHY_Reset>
a000cf4c:	02002021 	move	a0,s0
	
       // __delay(1000*1000);
        delay_ms(10);
a000cf50:	0c002219 	jal	a0008864 <delay_ms>
a000cf54:	2404000a 	li	a0,10
#endif
#if 1  //v6 FPGA 98C PCIE PHY 40MHZ
		{
		int phy40M=0;
		
		 phy40M=(REG32(0xb8000008)&(1<<24))>>24;
a000cf58:	3c02b800 	lui	v0,0xb800
a000cf5c:	34420008 	ori	v0,v0,0x8
a000cf60:	8c420000 	lw	v0,0(v0)
		if(phy40M)
a000cf64:	7c420600 	ext	v0,v0,0x18,0x1
a000cf68:	1440000c 	bnez	v0,a000cf9c <PCIE_reset_procedure+0x160>
a000cf6c:	00000000 	nop
		HostPCIe_SetPhyMdioWrite(portnum, 0x19, 0xFC70); 
		// HostPCIe_SetPhyMdioWrite(portnum, 0x13, 0x026c);
		}
		else
		{
			dprintf("PCIE PHY=25MHZ,portnum=%d\n",portnum);
a000cf70:	080033f9 	j	a000cfe4 <PCIE_reset_procedure+0x1a8>
a000cf74:	3c04a001 	lui	a0,0xa001
		 delay_ms(10);
       	// 3.MDIO Reset
		PCIE_MDIO_Reset(portnum);
	}  
	
	  delay_ms(10);
a000cf78:	0c002219 	jal	a0008864 <delay_ms>
a000cf7c:	2404000a 	li	a0,10
 	PCIE_PHY_Reset(portnum);	
a000cf80:	02008821 	move	s1,s0
a000cf84:	0c002fe4 	jal	a000bf90 <PCIE_PHY_Reset>
a000cf88:	02002021 	move	a0,s0
	
       // __delay(1000*1000);
        delay_ms(10);
a000cf8c:	0c002219 	jal	a0008864 <delay_ms>
a000cf90:	2404000a 	li	a0,10
a000cf94:	0800340c 	j	a000d030 <PCIE_reset_procedure+0x1f4>
a000cf98:	00000000 	nop
		int phy40M=0;
		
		 phy40M=(REG32(0xb8000008)&(1<<24))>>24;
		if(phy40M)
		{
		dprintf("PCIE PHY=40MHZ,portnum=%d\n",portnum);
a000cf9c:	3c04a001 	lui	a0,0xa001
a000cfa0:	24846330 	addiu	a0,a0,25392
a000cfa4:	0c002325 	jal	a0008c94 <dprintf>
a000cfa8:	02002821 	move	a1,s0
		HostPCIe_SetPhyMdioWrite(portnum, 0x3, 0x7b01);
a000cfac:	02002021 	move	a0,s0
a000cfb0:	24050003 	li	a1,3
a000cfb4:	0c003015 	jal	a000c054 <HostPCIe_SetPhyMdioWrite>
a000cfb8:	24067b01 	li	a2,31489
		HostPCIe_SetPhyMdioWrite(portnum, 0x6, 0x0268);
a000cfbc:	02002021 	move	a0,s0
a000cfc0:	24050006 	li	a1,6
a000cfc4:	0c003015 	jal	a000c054 <HostPCIe_SetPhyMdioWrite>
a000cfc8:	24060268 	li	a2,616
		//f26c
		
		HostPCIe_SetPhyMdioWrite(portnum, 0x19, 0xFC70); 
a000cfcc:	02002021 	move	a0,s0
a000cfd0:	24050019 	li	a1,25
a000cfd4:	0c003015 	jal	a000c054 <HostPCIe_SetPhyMdioWrite>
a000cfd8:	3406fc70 	li	a2,0xfc70
a000cfdc:	0800340c 	j	a000d030 <PCIE_reset_procedure+0x1f4>
a000cfe0:	00000000 	nop
		// HostPCIe_SetPhyMdioWrite(portnum, 0x13, 0x026c);
		}
		else
		{
			dprintf("PCIE PHY=25MHZ,portnum=%d\n",portnum);
a000cfe4:	2484634c 	addiu	a0,a0,25420
a000cfe8:	0c002325 	jal	a0008c94 <dprintf>
a000cfec:	02002821 	move	a1,s0
			HostPCIe_SetPhyMdioWrite(portnum, 0x3, 0x3001);
a000cff0:	02002021 	move	a0,s0
a000cff4:	24050003 	li	a1,3
a000cff8:	0c003015 	jal	a000c054 <HostPCIe_SetPhyMdioWrite>
a000cffc:	24063001 	li	a2,12289
        		HostPCIe_SetPhyMdioWrite(portnum, 0x6, 0xe0b8); //Hannah
a000d000:	02002021 	move	a0,s0
a000d004:	24050006 	li	a1,6
a000d008:	0c003015 	jal	a000c054 <HostPCIe_SetPhyMdioWrite>
a000d00c:	3406e0b8 	li	a2,0xe0b8

        		HostPCIe_SetPhyMdioWrite(portnum, 0xF, 0x400F);
a000d010:	02002021 	move	a0,s0
a000d014:	2405000f 	li	a1,15
a000d018:	0c003015 	jal	a000c054 <HostPCIe_SetPhyMdioWrite>
a000d01c:	2406400f 	li	a2,16399
        		HostPCIe_SetPhyMdioWrite(portnum, 0x19, 0xFC70);	
a000d020:	02002021 	move	a0,s0
a000d024:	24050019 	li	a1,25
a000d028:	0c003015 	jal	a000c054 <HostPCIe_SetPhyMdioWrite>
a000d02c:	3406fc70 	li	a2,0xfc70
#endif
	  	}
 
	//---------------------------------------
         // 6. PCIE Device Reset
       delay_ms(10);
a000d030:	0c002219 	jal	a0008864 <delay_ms>
a000d034:	2404000a 	li	a0,10
	PCIE_PHY_Reset(portnum);
a000d038:	0c002fe4 	jal	a000bf90 <PCIE_PHY_Reset>
a000d03c:	02202021 	move	a0,s1
       REG32(CLK_MANAGE) &= ~(1<<26);    //perst=0 off.
a000d040:	3c10b800 	lui	s0,0xb800
a000d044:	36100010 	ori	s0,s0,0x10
a000d048:	8e030000 	lw	v1,0(s0)
a000d04c:	3c02fbff 	lui	v0,0xfbff
a000d050:	3442ffff 	ori	v0,v0,0xffff
a000d054:	00621024 	and	v0,v1,v0
a000d058:	ae020000 	sw	v0,0(s0)
     	delay_ms(300);
a000d05c:	0c002219 	jal	a0008864 <delay_ms>
a000d060:	2404012c 	li	a0,300
       REG32(CLK_MANAGE) |=  (1<<26);   //PERST=1 
a000d064:	8e030000 	lw	v1,0(s0)
a000d068:	3c020400 	lui	v0,0x400
a000d06c:	00621025 	or	v0,v1,v0
a000d070:	ae020000 	sw	v0,0(s0)
	//---------------------------------------	  
	PCIE_Check_Link(portnum);
a000d074:	0c003344 	jal	a000cd10 <PCIE_Check_Link>
a000d078:	02202021 	move	a0,s1

}
a000d07c:	8fbf001c 	lw	ra,28(sp)
a000d080:	8fb10018 	lw	s1,24(sp)
a000d084:	8fb00014 	lw	s0,20(sp)
a000d088:	03e00008 	jr	ra
a000d08c:	27bd0020 	addiu	sp,sp,32

a000d090 <PCIE_Host_RESET>:
	printf("====> Total test cnt=%d, test fail=%d\n", test_packet_num,  pcie_err);
	
}; 
//------------------------------------------------------------------------
int PCIE_Host_RESET(int argc, char* argv[])
{
a000d090:	27bdffe0 	addiu	sp,sp,-32
a000d094:	afbf001c 	sw	ra,28(sp)
a000d098:	afb10018 	sw	s1,24(sp)
a000d09c:	afb00014 	sw	s0,20(sp)
	int  portnum= 0;  //0: one port, 1: two port
	int Use_External_PCIE_CLK=0;
	int mdio_reset=0;
	if(argc<2)
a000d0a0:	28820002 	slti	v0,a0,2
a000d0a4:	10400009 	beqz	v0,a000d0cc <PCIE_Host_RESET+0x3c>
a000d0a8:	00a08021 	move	s0,a1
	{//dump all	
	       dprintf("\n"); 		   
a000d0ac:	3c04a001 	lui	a0,0xa001
a000d0b0:	0c002325 	jal	a0008c94 <dprintf>
a000d0b4:	248457b8 	addiu	a0,a0,22456
		dprintf("hrst <portnum> <mdio_reset>\n");
a000d0b8:	3c04a001 	lui	a0,0xa001
a000d0bc:	0c002325 	jal	a0008c94 <dprintf>
a000d0c0:	24846368 	addiu	a0,a0,25448
		return;
a000d0c4:	08003450 	j	a000d140 <PCIE_Host_RESET+0xb0>
a000d0c8:	8fbf001c 	lw	ra,28(sp)
	}
	
	if(argc >= 1) 
a000d0cc:	18800020 	blez	a0,a000d150 <PCIE_Host_RESET+0xc0>
a000d0d0:	00000000 	nop
	{	portnum= strtoul((const char*)(argv[0]), (char **)NULL, 16);	
a000d0d4:	8ca40000 	lw	a0,0(a1)
a000d0d8:	00002821 	move	a1,zero
a000d0dc:	0c0020c4 	jal	a0008310 <strtoul>
a000d0e0:	24060010 	li	a2,16
a000d0e4:	00408821 	move	s1,v0
	}
	if(argc >= 2) 
	{	mdio_reset= strtoul((const char*)(argv[1]), (char **)NULL, 16);	
a000d0e8:	8e040004 	lw	a0,4(s0)
a000d0ec:	00002821 	move	a1,zero
a000d0f0:	0c0020c4 	jal	a0008310 <strtoul>
a000d0f4:	24060010 	li	a2,16
a000d0f8:	00408021 	move	s0,v0
	}

	if(portnum==2)
a000d0fc:	24020002 	li	v0,2
a000d100:	1622000a 	bne	s1,v0,a000d12c <PCIE_Host_RESET+0x9c>
a000d104:	00002021 	move	a0,zero
	{
		PCIE_reset_procedure(0, Use_External_PCIE_CLK, mdio_reset);
a000d108:	00002821 	move	a1,zero
a000d10c:	0c00338f 	jal	a000ce3c <PCIE_reset_procedure>
a000d110:	02003021 	move	a2,s0
		PCIE_reset_procedure(1, Use_External_PCIE_CLK, mdio_reset);
a000d114:	24040001 	li	a0,1
a000d118:	00002821 	move	a1,zero
a000d11c:	0c00338f 	jal	a000ce3c <PCIE_reset_procedure>
a000d120:	02003021 	move	a2,s0
		//PCIE_reset_procedure(portnum, 1, mdio_reset);		
	}		
	else
		PCIE_reset_procedure(portnum, Use_External_PCIE_CLK, mdio_reset);

}; 
a000d124:	08003450 	j	a000d140 <PCIE_Host_RESET+0xb0>
a000d128:	8fbf001c 	lw	ra,28(sp)
		PCIE_reset_procedure(0, Use_External_PCIE_CLK, mdio_reset);
		PCIE_reset_procedure(1, Use_External_PCIE_CLK, mdio_reset);
		//PCIE_reset_procedure(portnum, 1, mdio_reset);		
	}		
	else
		PCIE_reset_procedure(portnum, Use_External_PCIE_CLK, mdio_reset);
a000d12c:	02202021 	move	a0,s1
a000d130:	00002821 	move	a1,zero
a000d134:	0c00338f 	jal	a000ce3c <PCIE_reset_procedure>
a000d138:	02003021 	move	a2,s0

}; 
a000d13c:	8fbf001c 	lw	ra,28(sp)
a000d140:	8fb10018 	lw	s1,24(sp)
a000d144:	8fb00014 	lw	s0,20(sp)
a000d148:	03e00008 	jr	ra
a000d14c:	27bd0020 	addiu	sp,sp,32
	
	if(argc >= 1) 
	{	portnum= strtoul((const char*)(argv[0]), (char **)NULL, 16);	
	}
	if(argc >= 2) 
	{	mdio_reset= strtoul((const char*)(argv[1]), (char **)NULL, 16);	
a000d150:	8ca40004 	lw	a0,4(a1)
a000d154:	00002821 	move	a1,zero
a000d158:	0c0020c4 	jal	a0008310 <strtoul>
a000d15c:	24060010 	li	a2,16
a000d160:	00408021 	move	s0,v0
a000d164:	0800344b 	j	a000d12c <PCIE_Host_RESET+0x9c>
a000d168:	00008821 	move	s1,zero

a000d16c <CmdTestSRAM>:
	REG32(0xb8004000)=0;   //sram seg addr
}


int CmdTestSRAM(int argc, char* argv[])
{
a000d16c:	27bdff98 	addiu	sp,sp,-104
a000d170:	afbf0064 	sw	ra,100(sp)
a000d174:	afbe0060 	sw	s8,96(sp)
a000d178:	afb7005c 	sw	s7,92(sp)
a000d17c:	afb60058 	sw	s6,88(sp)
a000d180:	afb50054 	sw	s5,84(sp)
a000d184:	afb40050 	sw	s4,80(sp)
a000d188:	afb3004c 	sw	s3,76(sp)
a000d18c:	afb20048 	sw	s2,72(sp)
a000d190:	afb10044 	sw	s1,68(sp)
a000d194:	afb00040 	sw	s0,64(sp)

	unsigned char *addr;
	unsigned int len=(1<<12);  //SRAM size=4K
	unsigned int i;
	
	if( argc < 1 ) 
a000d198:	1c800006 	bgtz	a0,a000d1b4 <CmdTestSRAM+0x48>
a000d19c:	00000000 	nop
	{
		dprintf("Usage: sram <map addr> \n");		
a000d1a0:	3c04a001 	lui	a0,0xa001
a000d1a4:	0c002325 	jal	a0008c94 <dprintf>
a000d1a8:	24846388 	addiu	a0,a0,25480
		return;	
a000d1ac:	08003589 	j	a000d624 <CmdTestSRAM+0x4b8>
a000d1b0:	8fbf0064 	lw	ra,100(sp)
	}
	addr = strtoul((const char*)(argv[0]), (char **)NULL, 16);	
a000d1b4:	8ca40000 	lw	a0,0(a1)
a000d1b8:	00002821 	move	a1,zero
a000d1bc:	0c0020c4 	jal	a0008310 <strtoul>
a000d1c0:	24060010 	li	a2,16

	unsigned char *paddr=VIR2PHY(addr);
a000d1c4:	3c031fff 	lui	v1,0x1fff
a000d1c8:	3463ffff 	ori	v1,v1,0xffff
a000d1cc:	00431824 	and	v1,v0,v1
a000d1d0:	afa30038 	sw	v1,56(sp)
	unsigned char  *n8addr=VIR2NOC(addr);
a000d1d4:	3c13a000 	lui	s3,0xa000
a000d1d8:	00539825 	or	s3,v0,s3
a000d1dc:	afb3002c 	sw	s3,44(sp)
	unsigned short *n16addr=VIR2NOC(addr);		
	unsigned int     *n32addr=VIR2NOC(addr);	
	
	//===============================================
	//stage 1: r/w
	memset(n8addr, 0xff, len);
a000d1e0:	02602021 	move	a0,s3
a000d1e4:	240500ff 	li	a1,255
a000d1e8:	0c00203d 	jal	a00080f4 <memset>
a000d1ec:	24061000 	li	a2,4096
#if 1
	Enable_SRAM(paddr);
a000d1f0:	0c002fc0 	jal	a000bf00 <Enable_SRAM>
a000d1f4:	8fa40038 	lw	a0,56(sp)
#endif
	//-----------------------------------------------------
	//test fix pattern
	unsigned int patt_array[]={ 0x00000000, 0x55555555, 0xaaaaaaaa, 0xffffffff, 0x1234567, 0xa5a55a5a  };
a000d1f8:	afa00010 	sw	zero,16(sp)
a000d1fc:	3c025555 	lui	v0,0x5555
a000d200:	34425555 	ori	v0,v0,0x5555
a000d204:	afa20014 	sw	v0,20(sp)
a000d208:	3c02aaaa 	lui	v0,0xaaaa
a000d20c:	3442aaaa 	ori	v0,v0,0xaaaa
a000d210:	afa20018 	sw	v0,24(sp)
a000d214:	2402ffff 	li	v0,-1
a000d218:	afa2001c 	sw	v0,28(sp)
a000d21c:	3c020123 	lui	v0,0x123
a000d220:	34424567 	ori	v0,v0,0x4567
a000d224:	afa20020 	sw	v0,32(sp)
a000d228:	3c02a5a5 	lui	v0,0xa5a5
a000d22c:	34425a5a 	ori	v0,v0,0x5a5a
a000d230:	afa20024 	sw	v0,36(sp)
a000d234:	0000b821 	move	s7,zero
	//enable sram
	REG32(0xb8004000)=0;   //sram seg addr
}


int CmdTestSRAM(int argc, char* argv[])
a000d238:	27be0028 	addiu	s8,sp,40
			}
		}
		else if(accmode==ACC32)   //pattern fix value, 32 bit access
		{			
			unsigned int patt=patt_array[patt_idx];
			printf("Test Patt %08x, int w/r \n", patt);	
a000d23c:	3c02a001 	lui	v0,0xa001
a000d240:	244263f8 	addiu	v0,v0,25592
a000d244:	afa2003c 	sw	v0,60(sp)
	//enable sram
	REG32(0xb8004000)=0;   //sram seg addr
}


int CmdTestSRAM(int argc, char* argv[])
a000d248:	26711000 	addiu	s1,s3,4096
			}
		}
		else if(accmode==ACC16)			//pattern fix value, 16 bit access
		{
			unsigned short patt=patt_array[patt_idx];
			printf("Test Patt %04x, short w/r \n", patt);	
a000d24c:	3c02a001 	lui	v0,0xa001
a000d250:	244263dc 	addiu	v0,v0,25564
a000d254:	afa20034 	sw	v0,52(sp)
	for(patt_idx=0; patt_idx< sizeof(patt_array)/sizeof(patt_array[0]) ; patt_idx++)
	{
		if(accmode==ACC8)  //pattern fix value, 8 bit access
		{			
			unsigned char patt=patt_array[patt_idx];
			printf("Test Patt %02x, byte w/r \n", patt);	
a000d258:	3c02a001 	lui	v0,0xa001
a000d25c:	244263a4 	addiu	v0,v0,25508
a000d260:	afa20030 	sw	v0,48(sp)
	//enable sram
	REG32(0xb8004000)=0;   //sram seg addr
}


int CmdTestSRAM(int argc, char* argv[])
a000d264:	afb30028 	sw	s3,40(sp)
				REG32(n8addr+i)= patt;	

			for(i=0; i<len; i+=4)
			{
				if(REG32(n8addr+i) != patt)
					printf("%x err, exp=%x, read=%x\n", n8addr+i, patt, REG32(n8addr+i));
a000d268:	3c14a001 	lui	s4,0xa001
a000d26c:	080034fc 	j	a000d3f0 <CmdTestSRAM+0x284>
a000d270:	269463c0 	addiu	s4,s4,25536
	for(accmode=ACC8; accmode<ACCEND; accmode++)  // 8 bit, 16bit, 32bit
	{
	
	for(patt_idx=0; patt_idx< sizeof(patt_array)/sizeof(patt_array[0]) ; patt_idx++)
	{
		if(accmode==ACC8)  //pattern fix value, 8 bit access
a000d274:	16e0001a 	bnez	s7,a000d2e0 <CmdTestSRAM+0x174>
a000d278:	24020001 	li	v0,1
		{			
			unsigned char patt=patt_array[patt_idx];
a000d27c:	92d20003 	lbu	s2,3(s6)
			printf("Test Patt %02x, byte w/r \n", patt);	
a000d280:	0240a821 	move	s5,s2
a000d284:	8fa40030 	lw	a0,48(sp)
a000d288:	0c002325 	jal	a0008c94 <dprintf>
a000d28c:	02402821 	move	a1,s2
			memset(n8addr, patt, len);	
a000d290:	8fa4002c 	lw	a0,44(sp)
a000d294:	02402821 	move	a1,s2
a000d298:	0c00203d 	jal	a00080f4 <memset>
a000d29c:	24061000 	li	a2,4096
	//enable sram
	REG32(0xb8004000)=0;   //sram seg addr
}


int CmdTestSRAM(int argc, char* argv[])
a000d2a0:	8fb00028 	lw	s0,40(sp)
			unsigned char patt=patt_array[patt_idx];
			printf("Test Patt %02x, byte w/r \n", patt);	
			memset(n8addr, patt, len);	
			for(i=0; i<len; i++)
			{
				if(REG8(n8addr+i) != patt)
a000d2a4:	92020000 	lbu	v0,0(s0)
a000d2a8:	304200ff 	andi	v0,v0,0xff
a000d2ac:	10520007 	beq	v0,s2,a000d2cc <CmdTestSRAM+0x160>
a000d2b0:	00000000 	nop
					printf("%x err, exp=%x, read=%x\n", n8addr+i, patt, REG8(n8addr+i));
a000d2b4:	92070000 	lbu	a3,0(s0)
a000d2b8:	02802021 	move	a0,s4
a000d2bc:	02002821 	move	a1,s0
a000d2c0:	02a03021 	move	a2,s5
a000d2c4:	0c002325 	jal	a0008c94 <dprintf>
a000d2c8:	30e700ff 	andi	a3,a3,0xff
a000d2cc:	26100001 	addiu	s0,s0,1
		if(accmode==ACC8)  //pattern fix value, 8 bit access
		{			
			unsigned char patt=patt_array[patt_idx];
			printf("Test Patt %02x, byte w/r \n", patt);	
			memset(n8addr, patt, len);	
			for(i=0; i<len; i++)
a000d2d0:	1611fff4 	bne	s0,s1,a000d2a4 <CmdTestSRAM+0x138>
a000d2d4:	00000000 	nop
			printf("Test Patt %08x, int w/r \n", patt);	

			for(i=0; i<len; i+=4)			
				REG32(n8addr+i)= patt;	

			for(i=0; i<len; i+=4)
a000d2d8:	080034e9 	j	a000d3a4 <CmdTestSRAM+0x238>
a000d2dc:	26d60004 	addiu	s6,s6,4
			{
				if(REG8(n8addr+i) != patt)
					printf("%x err, exp=%x, read=%x\n", n8addr+i, patt, REG8(n8addr+i));
			}
		}
		else if(accmode==ACC16)			//pattern fix value, 16 bit access
a000d2e0:	16e2001a 	bne	s7,v0,a000d34c <CmdTestSRAM+0x1e0>
a000d2e4:	24020002 	li	v0,2
		{
			unsigned short patt=patt_array[patt_idx];
a000d2e8:	96d20002 	lhu	s2,2(s6)
			printf("Test Patt %04x, short w/r \n", patt);	
a000d2ec:	0240a821 	move	s5,s2
a000d2f0:	8fa40034 	lw	a0,52(sp)
a000d2f4:	0c002325 	jal	a0008c94 <dprintf>
a000d2f8:	02402821 	move	a1,s2
	//enable sram
	REG32(0xb8004000)=0;   //sram seg addr
}


int CmdTestSRAM(int argc, char* argv[])
a000d2fc:	8fa20028 	lw	v0,40(sp)
		{
			unsigned short patt=patt_array[patt_idx];
			printf("Test Patt %04x, short w/r \n", patt);	

			for(i=0; i<len; i+=2)			
				REG16(n8addr+i)= patt;	
a000d300:	a4520000 	sh	s2,0(v0)
a000d304:	24420002 	addiu	v0,v0,2
		else if(accmode==ACC16)			//pattern fix value, 16 bit access
		{
			unsigned short patt=patt_array[patt_idx];
			printf("Test Patt %04x, short w/r \n", patt);	

			for(i=0; i<len; i+=2)			
a000d308:	1451fffd 	bne	v0,s1,a000d300 <CmdTestSRAM+0x194>
a000d30c:	8fb00028 	lw	s0,40(sp)
				REG16(n8addr+i)= patt;	
			
			for(i=0; i<len; i+=2)
			{
				if(REG16(n8addr+i) != patt)
a000d310:	96020000 	lhu	v0,0(s0)
a000d314:	3042ffff 	andi	v0,v0,0xffff
a000d318:	10520007 	beq	v0,s2,a000d338 <CmdTestSRAM+0x1cc>
a000d31c:	00000000 	nop
					printf("%x err, exp=%x, read=%x\n", n8addr+i, patt, REG16(n8addr+i));
a000d320:	96070000 	lhu	a3,0(s0)
a000d324:	02802021 	move	a0,s4
a000d328:	02002821 	move	a1,s0
a000d32c:	02a03021 	move	a2,s5
a000d330:	0c002325 	jal	a0008c94 <dprintf>
a000d334:	30e7ffff 	andi	a3,a3,0xffff
a000d338:	26100002 	addiu	s0,s0,2
			printf("Test Patt %04x, short w/r \n", patt);	

			for(i=0; i<len; i+=2)			
				REG16(n8addr+i)= patt;	
			
			for(i=0; i<len; i+=2)
a000d33c:	1630fff4 	bne	s1,s0,a000d310 <CmdTestSRAM+0x1a4>
a000d340:	00000000 	nop
			printf("Test Patt %08x, int w/r \n", patt);	

			for(i=0; i<len; i+=4)			
				REG32(n8addr+i)= patt;	

			for(i=0; i<len; i+=4)
a000d344:	080034e9 	j	a000d3a4 <CmdTestSRAM+0x238>
a000d348:	26d60004 	addiu	s6,s6,4
			{
				if(REG16(n8addr+i) != patt)
					printf("%x err, exp=%x, read=%x\n", n8addr+i, patt, REG16(n8addr+i));
			}
		}
		else if(accmode==ACC32)   //pattern fix value, 32 bit access
a000d34c:	16e20014 	bne	s7,v0,a000d3a0 <CmdTestSRAM+0x234>
a000d350:	8fa4003c 	lw	a0,60(sp)
		{			
			unsigned int patt=patt_array[patt_idx];
a000d354:	8ed20000 	lw	s2,0(s6)
			printf("Test Patt %08x, int w/r \n", patt);	
a000d358:	0c002325 	jal	a0008c94 <dprintf>
a000d35c:	02402821 	move	a1,s2
	//enable sram
	REG32(0xb8004000)=0;   //sram seg addr
}


int CmdTestSRAM(int argc, char* argv[])
a000d360:	8fa20028 	lw	v0,40(sp)
		{			
			unsigned int patt=patt_array[patt_idx];
			printf("Test Patt %08x, int w/r \n", patt);	

			for(i=0; i<len; i+=4)			
				REG32(n8addr+i)= patt;	
a000d364:	ac520000 	sw	s2,0(v0)
a000d368:	24420004 	addiu	v0,v0,4
		else if(accmode==ACC32)   //pattern fix value, 32 bit access
		{			
			unsigned int patt=patt_array[patt_idx];
			printf("Test Patt %08x, int w/r \n", patt);	

			for(i=0; i<len; i+=4)			
a000d36c:	1451fffd 	bne	v0,s1,a000d364 <CmdTestSRAM+0x1f8>
a000d370:	8fb00028 	lw	s0,40(sp)
				REG32(n8addr+i)= patt;	

			for(i=0; i<len; i+=4)
			{
				if(REG32(n8addr+i) != patt)
a000d374:	8e020000 	lw	v0,0(s0)
a000d378:	10520006 	beq	v0,s2,a000d394 <CmdTestSRAM+0x228>
a000d37c:	00000000 	nop
					printf("%x err, exp=%x, read=%x\n", n8addr+i, patt, REG32(n8addr+i));
a000d380:	8e070000 	lw	a3,0(s0)
a000d384:	02802021 	move	a0,s4
a000d388:	02002821 	move	a1,s0
a000d38c:	0c002325 	jal	a0008c94 <dprintf>
a000d390:	02403021 	move	a2,s2
a000d394:	26100004 	addiu	s0,s0,4
			printf("Test Patt %08x, int w/r \n", patt);	

			for(i=0; i<len; i+=4)			
				REG32(n8addr+i)= patt;	

			for(i=0; i<len; i+=4)
a000d398:	1630fff6 	bne	s1,s0,a000d374 <CmdTestSRAM+0x208>
a000d39c:	00000000 	nop
a000d3a0:	26d60004 	addiu	s6,s6,4
	unsigned int accmode;
	
	for(accmode=ACC8; accmode<ACCEND; accmode++)  // 8 bit, 16bit, 32bit
	{
	
	for(patt_idx=0; patt_idx< sizeof(patt_array)/sizeof(patt_array[0]) ; patt_idx++)
a000d3a4:	16deffb3 	bne	s6,s8,a000d274 <CmdTestSRAM+0x108>
a000d3a8:	24020003 	li	v0,3
	#define ACC16 1
	#define ACC32 2
	#define ACCEND 3
	unsigned int accmode;
	
	for(accmode=ACC8; accmode<ACCEND; accmode++)  // 8 bit, 16bit, 32bit
a000d3ac:	26f70001 	addiu	s7,s7,1
a000d3b0:	16e2000f 	bne	s7,v0,a000d3f0 <CmdTestSRAM+0x284>
a000d3b4:	3c02a001 	lui	v0,0xa001
a000d3b8:	24170001 	li	s7,1
a000d3bc:	0000b021 	move	s6,zero
			{
				if(REG8(n8addr+i) != (i&0xff) )
					printf("%x err, exp=%x, read=%x\n", n8addr+i, (i&0xff), REG8(n8addr+i));
			}
		}
		else if(accmode==ACC16)			//pattern fix value, 16 bit access
a000d3c0:	241e0001 	li	s8,1
		{
			printf("Test inc Patt, short w/r \n");	
a000d3c4:	24426430 	addiu	v0,v0,25648
a000d3c8:	afa20030 	sw	v0,48(sp)
a000d3cc:	afb30028 	sw	s3,40(sp)

			for(i=0; i<len/2; i++)			
a000d3d0:	24150800 	li	s5,2048
				REG16(n16addr+i)= i;	
			
			for(i=0; i<len/2; i++)
			{
				if(REG16(n16addr+i) != (i&0xffff) )
					printf("%x err, exp=%x, read=%x\n", n16addr+i, (i&0xffff), REG16(n16addr+i));
a000d3d4:	3c14a001 	lui	s4,0xa001
a000d3d8:	269463c0 	addiu	s4,s4,25536
	//test inc patt
	for(accmode=ACC8; accmode<ACCEND; accmode++)  // 8 bit, 16bit, 32bit
	{
		if(accmode==ACC8)  //pattern fix value, 8 bit access
		{			
			printf("Test inc Patt, byte w/r \n");	
a000d3dc:	3c02a001 	lui	v0,0xa001
a000d3e0:	24426414 	addiu	v0,v0,25620
a000d3e4:	afa20034 	sw	v0,52(sp)
			for(i=0; i<len; i++)		
a000d3e8:	08003500 	j	a000d400 <CmdTestSRAM+0x294>
a000d3ec:	24121000 	li	s2,4096
	#define ACC16 1
	#define ACC32 2
	#define ACCEND 3
	unsigned int accmode;
	
	for(accmode=ACC8; accmode<ACCEND; accmode++)  // 8 bit, 16bit, 32bit
a000d3f0:	0800349d 	j	a000d274 <CmdTestSRAM+0x108>
a000d3f4:	27b60010 	addiu	s6,sp,16
	//enable sram
	REG32(0xb8004000)=0;   //sram seg addr
}


int CmdTestSRAM(int argc, char* argv[])
a000d3f8:	26d60001 	addiu	s6,s6,1
a000d3fc:	26f70001 	addiu	s7,s7,1
	}
	//-----------------------------------------------------	
	//test inc patt
	for(accmode=ACC8; accmode<ACCEND; accmode++)  // 8 bit, 16bit, 32bit
	{
		if(accmode==ACC8)  //pattern fix value, 8 bit access
a000d400:	16c0001b 	bnez	s6,a000d470 <CmdTestSRAM+0x304>
a000d404:	00000000 	nop
		{			
			printf("Test inc Patt, byte w/r \n");	
a000d408:	0c002325 	jal	a0008c94 <dprintf>
a000d40c:	8fa40034 	lw	a0,52(sp)
a000d410:	00001021 	move	v0,zero
a000d414:	00531821 	addu	v1,v0,s3
a000d418:	304400ff 	andi	a0,v0,0xff
			for(i=0; i<len; i++)		
				REG8(n8addr+i)=i;
a000d41c:	a0640000 	sb	a0,0(v1)
	for(accmode=ACC8; accmode<ACCEND; accmode++)  // 8 bit, 16bit, 32bit
	{
		if(accmode==ACC8)  //pattern fix value, 8 bit access
		{			
			printf("Test inc Patt, byte w/r \n");	
			for(i=0; i<len; i++)		
a000d420:	24420001 	addiu	v0,v0,1
a000d424:	1452fffc 	bne	v0,s2,a000d418 <CmdTestSRAM+0x2ac>
a000d428:	00531821 	addu	v1,v0,s3
a000d42c:	8fb00028 	lw	s0,40(sp)
a000d430:	00008821 	move	s1,zero
				REG8(n8addr+i)=i;
			
			for(i=0; i<len; i++)
			{
				if(REG8(n8addr+i) != (i&0xff) )
a000d434:	92020000 	lbu	v0,0(s0)
a000d438:	304200ff 	andi	v0,v0,0xff
a000d43c:	322600ff 	andi	a2,s1,0xff
a000d440:	10460006 	beq	v0,a2,a000d45c <CmdTestSRAM+0x2f0>
a000d444:	00000000 	nop
					printf("%x err, exp=%x, read=%x\n", n8addr+i, (i&0xff), REG8(n8addr+i));
a000d448:	92070000 	lbu	a3,0(s0)
a000d44c:	02802021 	move	a0,s4
a000d450:	02002821 	move	a1,s0
a000d454:	0c002325 	jal	a0008c94 <dprintf>
a000d458:	30e700ff 	andi	a3,a3,0xff
		{			
			printf("Test inc Patt, byte w/r \n");	
			for(i=0; i<len; i++)		
				REG8(n8addr+i)=i;
			
			for(i=0; i<len; i++)
a000d45c:	26310001 	addiu	s1,s1,1
a000d460:	1632fff4 	bne	s1,s2,a000d434 <CmdTestSRAM+0x2c8>
a000d464:	26100001 	addiu	s0,s0,1
	//enable sram
	REG32(0xb8004000)=0;   //sram seg addr
}


int CmdTestSRAM(int argc, char* argv[])
a000d468:	080034ff 	j	a000d3fc <CmdTestSRAM+0x290>
a000d46c:	26d60001 	addiu	s6,s6,1
			{
				if(REG8(n8addr+i) != (i&0xff) )
					printf("%x err, exp=%x, read=%x\n", n8addr+i, (i&0xff), REG8(n8addr+i));
			}
		}
		else if(accmode==ACC16)			//pattern fix value, 16 bit access
a000d470:	16de001b 	bne	s6,s8,a000d4e0 <CmdTestSRAM+0x374>
a000d474:	24020002 	li	v0,2
		{
			printf("Test inc Patt, short w/r \n");	
a000d478:	0c002325 	jal	a0008c94 <dprintf>
a000d47c:	8fa40030 	lw	a0,48(sp)
a000d480:	8fa30028 	lw	v1,40(sp)
a000d484:	00001021 	move	v0,zero
a000d488:	3044ffff 	andi	a0,v0,0xffff

			for(i=0; i<len/2; i++)			
				REG16(n16addr+i)= i;	
a000d48c:	a4640000 	sh	a0,0(v1)
		}
		else if(accmode==ACC16)			//pattern fix value, 16 bit access
		{
			printf("Test inc Patt, short w/r \n");	

			for(i=0; i<len/2; i++)			
a000d490:	24420001 	addiu	v0,v0,1
a000d494:	1455fffc 	bne	v0,s5,a000d488 <CmdTestSRAM+0x31c>
a000d498:	24630002 	addiu	v1,v1,2
a000d49c:	8fb00028 	lw	s0,40(sp)
a000d4a0:	00008821 	move	s1,zero
				REG16(n16addr+i)= i;	
			
			for(i=0; i<len/2; i++)
			{
				if(REG16(n16addr+i) != (i&0xffff) )
a000d4a4:	96020000 	lhu	v0,0(s0)
a000d4a8:	3042ffff 	andi	v0,v0,0xffff
a000d4ac:	3226ffff 	andi	a2,s1,0xffff
a000d4b0:	10460006 	beq	v0,a2,a000d4cc <CmdTestSRAM+0x360>
a000d4b4:	00000000 	nop
					printf("%x err, exp=%x, read=%x\n", n16addr+i, (i&0xffff), REG16(n16addr+i));
a000d4b8:	96070000 	lhu	a3,0(s0)
a000d4bc:	02802021 	move	a0,s4
a000d4c0:	02002821 	move	a1,s0
a000d4c4:	0c002325 	jal	a0008c94 <dprintf>
a000d4c8:	30e7ffff 	andi	a3,a3,0xffff
			printf("Test inc Patt, short w/r \n");	

			for(i=0; i<len/2; i++)			
				REG16(n16addr+i)= i;	
			
			for(i=0; i<len/2; i++)
a000d4cc:	26310001 	addiu	s1,s1,1
a000d4d0:	1635fff4 	bne	s1,s5,a000d4a4 <CmdTestSRAM+0x338>
a000d4d4:	26100002 	addiu	s0,s0,2
	//enable sram
	REG32(0xb8004000)=0;   //sram seg addr
}


int CmdTestSRAM(int argc, char* argv[])
a000d4d8:	080034ff 	j	a000d3fc <CmdTestSRAM+0x290>
a000d4dc:	26d60001 	addiu	s6,s6,1
			{
				if(REG16(n16addr+i) != (i&0xffff) )
					printf("%x err, exp=%x, read=%x\n", n16addr+i, (i&0xffff), REG16(n16addr+i));
			}
		}
		else if(accmode==ACC32)   //pattern fix value, 32 bit access
a000d4e0:	16c2001d 	bne	s6,v0,a000d558 <CmdTestSRAM+0x3ec>
a000d4e4:	2ee20003 	sltiu	v0,s7,3
		{			
			printf("Test inc Patt, int w/r \n");	
a000d4e8:	3c04a001 	lui	a0,0xa001
a000d4ec:	0c002325 	jal	a0008c94 <dprintf>
a000d4f0:	2484644c 	addiu	a0,a0,25676
a000d4f4:	02601821 	move	v1,s3
a000d4f8:	00001021 	move	v0,zero

			for(i=0; i<len/4; i++)			
a000d4fc:	24040400 	li	a0,1024
				REG32(n32addr+i)= i;	
a000d500:	ac620000 	sw	v0,0(v1)
		}
		else if(accmode==ACC32)   //pattern fix value, 32 bit access
		{			
			printf("Test inc Patt, int w/r \n");	

			for(i=0; i<len/4; i++)			
a000d504:	24420001 	addiu	v0,v0,1
a000d508:	1444fffd 	bne	v0,a0,a000d500 <CmdTestSRAM+0x394>
a000d50c:	24630004 	addiu	v1,v1,4
a000d510:	02608021 	move	s0,s3
a000d514:	00008821 	move	s1,zero
				REG32(n32addr+i)= i;	

			for(i=0; i<len/4; i++)
			{
				if(REG32(n32addr+i) != i)
					printf("%x err, exp=%x, read=%x\n", n32addr+i, i, REG32(n32addr+i));
a000d518:	3c14a001 	lui	s4,0xa001
a000d51c:	269463c0 	addiu	s4,s4,25536
			printf("Test inc Patt, int w/r \n");	

			for(i=0; i<len/4; i++)			
				REG32(n32addr+i)= i;	

			for(i=0; i<len/4; i++)
a000d520:	24120400 	li	s2,1024
			{
				if(REG32(n32addr+i) != i)
a000d524:	8e020000 	lw	v0,0(s0)
a000d528:	10510006 	beq	v0,s1,a000d544 <CmdTestSRAM+0x3d8>
a000d52c:	00000000 	nop
					printf("%x err, exp=%x, read=%x\n", n32addr+i, i, REG32(n32addr+i));
a000d530:	8e070000 	lw	a3,0(s0)
a000d534:	02802021 	move	a0,s4
a000d538:	02002821 	move	a1,s0
a000d53c:	0c002325 	jal	a0008c94 <dprintf>
a000d540:	02203021 	move	a2,s1
			printf("Test inc Patt, int w/r \n");	

			for(i=0; i<len/4; i++)			
				REG32(n32addr+i)= i;	

			for(i=0; i<len/4; i++)
a000d544:	26310001 	addiu	s1,s1,1
a000d548:	1632fff6 	bne	s1,s2,a000d524 <CmdTestSRAM+0x3b8>
a000d54c:	26100004 	addiu	s0,s0,4
		if(n32addr[i] !=data)
			printf("%x err, exp=%x, read=%x\n", n8addr+i, data, n8addr[i]);
	}
#endif
	//-----------------------------------------------------
	memset(n8addr,0xaa,len);
a000d550:	08003558 	j	a000d560 <CmdTestSRAM+0x3f4>
a000d554:	8fa4002c 	lw	a0,44(sp)
		}		
	}
	}
	//-----------------------------------------------------	
	//test inc patt
	for(accmode=ACC8; accmode<ACCEND; accmode++)  // 8 bit, 16bit, 32bit
a000d558:	1440ffa7 	bnez	v0,a000d3f8 <CmdTestSRAM+0x28c>
a000d55c:	8fa4002c 	lw	a0,44(sp)
		if(n32addr[i] !=data)
			printf("%x err, exp=%x, read=%x\n", n8addr+i, data, n8addr[i]);
	}
#endif
	//-----------------------------------------------------
	memset(n8addr,0xaa,len);
a000d560:	240500aa 	li	a1,170
a000d564:	0c00203d 	jal	a00080f4 <memset>
a000d568:	24061000 	li	a2,4096
	Disable_SRAM();
a000d56c:	0c002fcd 	jal	a000bf34 <Disable_SRAM>
a000d570:	26711000 	addiu	s1,s3,4096


	//===========================================
	//stage 2: test on/off
	printf("Test Pattern 0x55 in DRAM, 0xaa in SRAM \n");
a000d574:	3c04a001 	lui	a0,0xa001
a000d578:	0c002325 	jal	a0008c94 <dprintf>
a000d57c:	24846468 	addiu	a0,a0,25704
	
	memset(n8addr,0x55,len);
a000d580:	8fa4002c 	lw	a0,44(sp)
a000d584:	24050055 	li	a1,85
a000d588:	0c00203d 	jal	a00080f4 <memset>
a000d58c:	24061000 	li	a2,4096
	
#if 1
	printf("Enable SRAM, do compare\n");
a000d590:	3c04a001 	lui	a0,0xa001
a000d594:	0c002325 	jal	a0008c94 <dprintf>
a000d598:	24846494 	addiu	a0,a0,25748
	Enable_SRAM(paddr);
a000d59c:	0c002fc0 	jal	a000bf00 <Enable_SRAM>
a000d5a0:	8fa40038 	lw	a0,56(sp)
	//enable sram
	REG32(0xb8004000)=0;   //sram seg addr
}


int CmdTestSRAM(int argc, char* argv[])
a000d5a4:	02608021 	move	s0,s3

	
	//compare the original sdram
	for(i=0; i<len; i++)
	{
		if(n8addr[i] != 0xaa)
a000d5a8:	241200aa 	li	s2,170
			printf("%x err, exp=%x, read=%x\n", n8addr+i, 0xaa, n8addr[i]);
a000d5ac:	3c14a001 	lui	s4,0xa001
a000d5b0:	269463c0 	addiu	s4,s4,25536

	
	//compare the original sdram
	for(i=0; i<len; i++)
	{
		if(n8addr[i] != 0xaa)
a000d5b4:	92070000 	lbu	a3,0(s0)
a000d5b8:	10f20004 	beq	a3,s2,a000d5cc <CmdTestSRAM+0x460>
a000d5bc:	02002821 	move	a1,s0
			printf("%x err, exp=%x, read=%x\n", n8addr+i, 0xaa, n8addr[i]);
a000d5c0:	02802021 	move	a0,s4
a000d5c4:	0c002325 	jal	a0008c94 <dprintf>
a000d5c8:	02403021 	move	a2,s2
a000d5cc:	26100001 	addiu	s0,s0,1
	Enable_SRAM(paddr);
#endif

	
	//compare the original sdram
	for(i=0; i<len; i++)
a000d5d0:	1611fff8 	bne	s0,s1,a000d5b4 <CmdTestSRAM+0x448>
a000d5d4:	00000000 	nop
	{
		if(n8addr[i] != 0xaa)
			printf("%x err, exp=%x, read=%x\n", n8addr+i, 0xaa, n8addr[i]);
	}
	
	printf("Disable SRAM, do compare\n");
a000d5d8:	3c04a001 	lui	a0,0xa001
a000d5dc:	0c002325 	jal	a0008c94 <dprintf>
a000d5e0:	248464b0 	addiu	a0,a0,25776
	Disable_SRAM();
a000d5e4:	0c002fcd 	jal	a000bf34 <Disable_SRAM>
a000d5e8:	24100055 	li	s0,85
	
	for(i=0; i<len; i++)
	{
		if(n8addr[i] != 0x55)
			printf("%x err, exp=%x, read=%x\n", n8addr+i, 0x55, n8addr[i]);
a000d5ec:	3c12a001 	lui	s2,0xa001
a000d5f0:	265263c0 	addiu	s2,s2,25536
	printf("Disable SRAM, do compare\n");
	Disable_SRAM();
	
	for(i=0; i<len; i++)
	{
		if(n8addr[i] != 0x55)
a000d5f4:	92670000 	lbu	a3,0(s3)
a000d5f8:	10f00004 	beq	a3,s0,a000d60c <CmdTestSRAM+0x4a0>
a000d5fc:	02602821 	move	a1,s3
			printf("%x err, exp=%x, read=%x\n", n8addr+i, 0x55, n8addr[i]);
a000d600:	02402021 	move	a0,s2
a000d604:	0c002325 	jal	a0008c94 <dprintf>
a000d608:	02003021 	move	a2,s0
a000d60c:	26730001 	addiu	s3,s3,1
	}
	
	printf("Disable SRAM, do compare\n");
	Disable_SRAM();
	
	for(i=0; i<len; i++)
a000d610:	1671fff8 	bne	s3,s1,a000d5f4 <CmdTestSRAM+0x488>
a000d614:	3c04a001 	lui	a0,0xa001
	}

	//-----------------------------------------------------

	
	printf("No error is pass\n");
a000d618:	0c002325 	jal	a0008c94 <dprintf>
a000d61c:	248464cc 	addiu	a0,a0,25804
}
a000d620:	8fbf0064 	lw	ra,100(sp)
a000d624:	8fbe0060 	lw	s8,96(sp)
a000d628:	8fb7005c 	lw	s7,92(sp)
a000d62c:	8fb60058 	lw	s6,88(sp)
a000d630:	8fb50054 	lw	s5,84(sp)
a000d634:	8fb40050 	lw	s4,80(sp)
a000d638:	8fb3004c 	lw	s3,76(sp)
a000d63c:	8fb20048 	lw	s2,72(sp)
a000d640:	8fb10044 	lw	s1,68(sp)
a000d644:	8fb00040 	lw	s0,64(sp)
a000d648:	03e00008 	jr	ra
a000d64c:	27bd0068 	addiu	sp,sp,104

a000d650 <Check_UartRxDataRdy>:



unsigned int Check_UartRxDataRdy()
{
	if 	(REG32(UART_LSR) & (1<<24) )
a000d650:	3c02b800 	lui	v0,0xb800
a000d654:	34422014 	ori	v0,v0,0x2014
a000d658:	8c420000 	lw	v0,0(v0)
		return 1;
	else
		return 0;
}
a000d65c:	03e00008 	jr	ra
a000d660:	7c420600 	ext	v0,v0,0x18,0x1

a000d664 <Get_UartData>:

unsigned char Get_UartData()
{	return REG32(UART_RBR)>>24;
a000d664:	3c02b800 	lui	v0,0xb800
a000d668:	34422000 	ori	v0,v0,0x2000
a000d66c:	8c420000 	lw	v0,0(v0)
}
a000d670:	03e00008 	jr	ra
a000d674:	00021602 	srl	v0,v0,0x18

a000d678 <Get_UartData_timeout>:

int Get_UartData_timeout(unsigned char *c, unsigned int  timeout)
{	
a000d678:	27bdffe0 	addiu	sp,sp,-32
a000d67c:	afbf001c 	sw	ra,28(sp)
a000d680:	afb10018 	sw	s1,24(sp)
a000d684:	afb00014 	sw	s0,20(sp)
a000d688:	00808821 	move	s1,a0
	unsigned int t=timeout;

	while(t--)
a000d68c:	080035ae 	j	a000d6b8 <Get_UartData_timeout+0x40>
a000d690:	00a08021 	move	s0,a1
	{
		if(Check_UartRxDataRdy())
a000d694:	0c003594 	jal	a000d650 <Check_UartRxDataRdy>
a000d698:	2610ffff 	addiu	s0,s0,-1
a000d69c:	10400006 	beqz	v0,a000d6b8 <Get_UartData_timeout+0x40>
a000d6a0:	00000000 	nop
		{	*c=Get_UartData();
a000d6a4:	0c003599 	jal	a000d664 <Get_UartData>
a000d6a8:	00000000 	nop
a000d6ac:	a2220000 	sb	v0,0(s1)
			return 1;
a000d6b0:	080035b0 	j	a000d6c0 <Get_UartData_timeout+0x48>
a000d6b4:	24020001 	li	v0,1

int Get_UartData_timeout(unsigned char *c, unsigned int  timeout)
{	
	unsigned int t=timeout;

	while(t--)
a000d6b8:	1600fff6 	bnez	s0,a000d694 <Get_UartData_timeout+0x1c>
a000d6bc:	00001021 	move	v0,zero
			return 1;
		}

	}
	return 0;
}
a000d6c0:	8fbf001c 	lw	ra,28(sp)
a000d6c4:	8fb10018 	lw	s1,24(sp)
a000d6c8:	8fb00014 	lw	s0,20(sp)
a000d6cc:	03e00008 	jr	ra
a000d6d0:	27bd0020 	addiu	sp,sp,32

a000d6d4 <xmodem_receive>:




int xmodem_receive(unsigned char  * buf)
{
a000d6d4:	27bdffa8 	addiu	sp,sp,-88
a000d6d8:	afbf0054 	sw	ra,84(sp)
a000d6dc:	afbe0050 	sw	s8,80(sp)
a000d6e0:	afb7004c 	sw	s7,76(sp)
a000d6e4:	afb60048 	sw	s6,72(sp)
a000d6e8:	afb50044 	sw	s5,68(sp)
a000d6ec:	afb40040 	sw	s4,64(sp)
a000d6f0:	afb3003c 	sw	s3,60(sp)
a000d6f4:	afb20038 	sw	s2,56(sp)
a000d6f8:	afb10034 	sw	s1,52(sp)
a000d6fc:	afb00030 	sw	s0,48(sp)
a000d700:	afa40018 	sw	a0,24(sp)
a000d704:	24110014 	li	s1,20
a000d708:	00009821 	move	s3,zero
a000d70c:	00008021 	move	s0,zero
a000d710:	24020001 	li	v0,1
a000d714:	afa2001c 	sw	v0,28(sp)
	/* received buffer size to zero */
	int size = 0;
	
	while(retry > 0)
	{
		switch(state)
a000d718:	3c14a001 	lui	s4,0xa001
a000d71c:	269404c0 	addiu	s4,s4,1216
					retry--;
				}
				break;
				
			case XMODEM_RX_PACKET:
				if(getc_with_timeout(&c, timeout))
a000d720:	27b50010 	addiu	s5,sp,16
a000d724:	3c120001 	lui	s2,0x1
a000d728:	365286a0 	ori	s2,s2,0x86a0
				{	head1=c;
				}
				else goto fail;
				
				if(getc_with_timeout(&c, timeout))
				{	head2=c;				
a000d72c:	0000f021 	move	s8,zero
						 continue;
					}
				}
				
				retry--;
				putc(NAK);
a000d730:	24160001 	li	s6,1
					}
				
					else if(c == CAN)
					{	state = XMODEM_CANCEL;
					}
					else if(c == EOT)
a000d734:	24170004 	li	s7,4
	/* received buffer size to zero */
	int size = 0;
	
	while(retry > 0)
	{
		switch(state)
a000d738:	2e020005 	sltiu	v0,s0,5
a000d73c:	1040ffff 	beqz	v0,a000d73c <xmodem_receive+0x68>
a000d740:	00000000 	nop
a000d744:	00101080 	sll	v0,s0,0x2
a000d748:	02821021 	addu	v0,s4,v0
a000d74c:	8c420000 	lw	v0,0(v0)
a000d750:	00400008 	jr	v0
a000d754:	00000000 	nop
		{
			case XMODEM_RX_READY:
				
				putc(NAK);			
a000d758:	0c001fe0 	jal	a0007f80 <serial_outc>
a000d75c:	24040015 	li	a0,21
				if(getc_with_timeout(&c, timeout))
a000d760:	02a02021 	move	a0,s5
a000d764:	0c00359e 	jal	a000d678 <Get_UartData_timeout>
a000d768:	02402821 	move	a1,s2
a000d76c:	10400078 	beqz	v0,a000d950 <xmodem_receive+0x27c>
a000d770:	93a20010 	lbu	v0,16(sp)
				{
					if(c == SOH)
a000d774:	10560075 	beq	v0,s6,a000d94c <xmodem_receive+0x278>
a000d778:	24030003 	li	v1,3
					{
						packet_size = 128;						
						state = XMODEM_RX_PACKET;
					}			
					else if(c == 3)  //Ctrl+C
a000d77c:	14430074 	bne	v0,v1,a000d950 <xmodem_receive+0x27c>
a000d780:	00000000 	nop
					{
						putc(CAN);	putc(CAN);
a000d784:	0c001fe0 	jal	a0007f80 <serial_outc>
a000d788:	24040018 	li	a0,24
a000d78c:	0c001fe0 	jal	a0007f80 <serial_outc>
a000d790:	24040018 	li	a0,24
						putc(CAN);	putc(CAN);
a000d794:	0c001fe0 	jal	a0007f80 <serial_outc>
a000d798:	24040018 	li	a0,24
a000d79c:	0c001fe0 	jal	a0007f80 <serial_outc>
a000d7a0:	24040018 	li	a0,24
						size = 0;
						return false;
a000d7a4:	0800365f 	j	a000d97c <xmodem_receive+0x2a8>
a000d7a8:	00009821 	move	s3,zero
					}
				}	
				break;
				
			case XMODEM_WAIT_HEADER:
				if(getc_with_timeout(&c, timeout))
a000d7ac:	02a02021 	move	a0,s5
a000d7b0:	0c00359e 	jal	a000d678 <Get_UartData_timeout>
a000d7b4:	02402821 	move	a1,s2
a000d7b8:	10400009 	beqz	v0,a000d7e0 <xmodem_receive+0x10c>
a000d7bc:	93a20010 	lbu	v0,16(sp)
				{
					if(c == SOH)
a000d7c0:	10560062 	beq	v0,s6,a000d94c <xmodem_receive+0x278>
a000d7c4:	24040018 	li	a0,24
					{
						packet_size = 128;						
						state = XMODEM_RX_PACKET;
					}
				
					else if(c == CAN)
a000d7c8:	14440003 	bne	v0,a0,a000d7d8 <xmodem_receive+0x104>
a000d7cc:	00571026 	xor	v0,v0,s7
a000d7d0:	08003654 	j	a000d950 <xmodem_receive+0x27c>
a000d7d4:	24100003 	li	s0,3
					{	state = XMODEM_CANCEL;
					}
					else if(c == EOT)
a000d7d8:	08003654 	j	a000d950 <xmodem_receive+0x27c>
a000d7dc:	02e2800a 	movz	s0,s7,v0
					}
				}
				else
				{
					/* timed out, try again */
					retry--;
a000d7e0:	08003654 	j	a000d950 <xmodem_receive+0x27c>
a000d7e4:	2631ffff 	addiu	s1,s1,-1
				}
				break;
				
			case XMODEM_RX_PACKET:
				if(getc_with_timeout(&c, timeout))
a000d7e8:	02a02021 	move	a0,s5
a000d7ec:	0c00359e 	jal	a000d678 <Get_UartData_timeout>
a000d7f0:	02402821 	move	a1,s2
a000d7f4:	10400024 	beqz	v0,a000d888 <xmodem_receive+0x1b4>
a000d7f8:	93a50010 	lbu	a1,16(sp)
				{	head1=c;
a000d7fc:	afa50028 	sw	a1,40(sp)
				}
				else goto fail;
				
				if(getc_with_timeout(&c, timeout))
a000d800:	02a02021 	move	a0,s5
a000d804:	0c00359e 	jal	a000d678 <Get_UartData_timeout>
a000d808:	02402821 	move	a1,s2
a000d80c:	1040001e 	beqz	v0,a000d888 <xmodem_receive+0x1b4>
a000d810:	93a20010 	lbu	v0,16(sp)
				{	head2=c;				
a000d814:	afa2002c 	sw	v0,44(sp)
a000d818:	afbe0024 	sw	s8,36(sp)
a000d81c:	afbe0020 	sw	s8,32(sp)
				else goto fail;

				csum=0;
				for(i = 0; i < packet_size  ; i++)
				{
					if(getc_with_timeout(&c, timeout))
a000d820:	02a02021 	move	a0,s5
a000d824:	0c00359e 	jal	a000d678 <Get_UartData_timeout>
a000d828:	02402821 	move	a1,s2
a000d82c:	10400016 	beqz	v0,a000d888 <xmodem_receive+0x1b4>
a000d830:	8fa40018 	lw	a0,24(sp)
					{	ptr[i] = c;
a000d834:	8fa50020 	lw	a1,32(sp)
a000d838:	00851821 	addu	v1,a0,a1
a000d83c:	93a20010 	lbu	v0,16(sp)
a000d840:	a0620000 	sb	v0,0(v1)
						csum+=c;
a000d844:	8fa30024 	lw	v1,36(sp)
a000d848:	00621021 	addu	v0,v1,v0
a000d84c:	304200ff 	andi	v0,v0,0xff
a000d850:	afa20024 	sw	v0,36(sp)
				{	head2=c;				
				}
				else goto fail;

				csum=0;
				for(i = 0; i < packet_size  ; i++)
a000d854:	24a50001 	addiu	a1,a1,1
a000d858:	24040080 	li	a0,128
a000d85c:	14a4fff0 	bne	a1,a0,a000d820 <xmodem_receive+0x14c>
a000d860:	afa50020 	sw	a1,32(sp)
					}
					else
						goto fail;
				}

				if(getc_with_timeout(&c, timeout))
a000d864:	02a02021 	move	a0,s5
a000d868:	0c00359e 	jal	a000d678 <Get_UartData_timeout>
a000d86c:	02402821 	move	a1,s2
a000d870:	10400005 	beqz	v0,a000d888 <xmodem_receive+0x1b4>
a000d874:	8fa50020 	lw	a1,32(sp)

				
				state = XMODEM_WAIT_HEADER;
				
				/* packet was too small, retry */
				if(i < (packet_size))
a000d878:	2ca30080 	sltiu	v1,a1,128
a000d87c:	10600007 	beqz	v1,a000d89c <xmodem_receive+0x1c8>
a000d880:	93a20010 	lbu	v0,16(sp)
a000d884:	02c08021 	move	s0,s6
				{
fail:				
					retry--;
a000d888:	2631ffff 	addiu	s1,s1,-1
					putc(NAK);
a000d88c:	0c001fe0 	jal	a0007f80 <serial_outc>
a000d890:	24040015 	li	a0,21
					continue;
a000d894:	08003654 	j	a000d950 <xmodem_receive+0x27c>
a000d898:	00000000 	nop
				}
				
				/* check validity of packet */
				if( (head1 == 255-head2) && (head_csum==csum) )
a000d89c:	240400ff 	li	a0,255
a000d8a0:	8fa5002c 	lw	a1,44(sp)
a000d8a4:	00851823 	subu	v1,a0,a1
a000d8a8:	8fa40028 	lw	a0,40(sp)
a000d8ac:	1483001a 	bne	a0,v1,a000d918 <xmodem_receive+0x244>
a000d8b0:	8fa50024 	lw	a1,36(sp)
a000d8b4:	14450018 	bne	v0,a1,a000d918 <xmodem_receive+0x244>
a000d8b8:	8fa2001c 	lw	v0,28(sp)
				{
					/* is this the packet we were waiting for? */
					if(head1== block_index)
a000d8bc:	1444000d 	bne	v0,a0,a000d8f4 <xmodem_receive+0x220>
a000d8c0:	8fa4001c 	lw	a0,28(sp)
					{
						ptr+=packet_size;
a000d8c4:	8fa30018 	lw	v1,24(sp)
a000d8c8:	24630080 	addiu	v1,v1,128
a000d8cc:	afa30018 	sw	v1,24(sp)
						size += packet_size;						
a000d8d0:	26730080 	addiu	s3,s3,128
						block_index++;
a000d8d4:	24420001 	addiu	v0,v0,1
a000d8d8:	304200ff 	andi	v0,v0,0xff
a000d8dc:	afa2001c 	sw	v0,28(sp)
						retry = RETRY;
						putc(ACK);
a000d8e0:	0c001fe0 	jal	a0007f80 <serial_outc>
a000d8e4:	24040006 	li	a0,6
a000d8e8:	24110014 	li	s1,20
a000d8ec:	080035ce 	j	a000d738 <xmodem_receive+0x64>
a000d8f0:	02c08021 	move	s0,s6
						continue;
					}
					else if(head1 == (unsigned char )(block_index-1))
a000d8f4:	2482ffff 	addiu	v0,a0,-1
a000d8f8:	304200ff 	andi	v0,v0,0xff
a000d8fc:	8fa50028 	lw	a1,40(sp)
a000d900:	14450005 	bne	v0,a1,a000d918 <xmodem_receive+0x244>
a000d904:	00000000 	nop
					{
						/* this is a retransmission of the last packet */
						putc(ACK);
a000d908:	0c001fe0 	jal	a0007f80 <serial_outc>
a000d90c:	24040006 	li	a0,6
						 continue;
a000d910:	08003654 	j	a000d950 <xmodem_receive+0x27c>
a000d914:	02c08021 	move	s0,s6
					}
				}
				
				retry--;
a000d918:	2631ffff 	addiu	s1,s1,-1
				putc(NAK);
a000d91c:	0c001fe0 	jal	a0007f80 <serial_outc>
a000d920:	24040015 	li	a0,21
				break;
a000d924:	08003654 	j	a000d950 <xmodem_receive+0x27c>
a000d928:	02c08021 	move	s0,s6
				
			case XMODEM_CANCEL:
				putc(ACK);
a000d92c:	0c001fe0 	jal	a0007f80 <serial_outc>
a000d930:	24040006 	li	a0,6
				
				return false;
a000d934:	0800365f 	j	a000d97c <xmodem_receive+0x2a8>
a000d938:	00009821 	move	s3,zero
				
			case XMODEM_EOT:
				putc(ACK);
a000d93c:	0c001fe0 	jal	a0007f80 <serial_outc>
a000d940:	24040006 	li	a0,6
				//mdelay(100);				
				return size;
a000d944:	08003660 	j	a000d980 <xmodem_receive+0x2ac>
a000d948:	02601021 	move	v0,s3
a000d94c:	24100002 	li	s0,2

	
	/* received buffer size to zero */
	int size = 0;
	
	while(retry > 0)
a000d950:	1620ff7a 	bnez	s1,a000d73c <xmodem_receive+0x68>
a000d954:	2e020005 	sltiu	v0,s0,5
				break;
		}
	}
	
	/* retry too much, fail */
	putc(CAN);	putc(CAN);
a000d958:	0c001fe0 	jal	a0007f80 <serial_outc>
a000d95c:	24040018 	li	a0,24
a000d960:	0c001fe0 	jal	a0007f80 <serial_outc>
a000d964:	24040018 	li	a0,24
	putc(CAN);	putc(CAN);
a000d968:	0c001fe0 	jal	a0007f80 <serial_outc>
a000d96c:	24040018 	li	a0,24
a000d970:	0c001fe0 	jal	a0007f80 <serial_outc>
a000d974:	24040018 	li	a0,24
a000d978:	00009821 	move	s3,zero
	
	
	return false;
}
a000d97c:	02601021 	move	v0,s3
a000d980:	8fbf0054 	lw	ra,84(sp)
a000d984:	8fbe0050 	lw	s8,80(sp)
a000d988:	8fb7004c 	lw	s7,76(sp)
a000d98c:	8fb60048 	lw	s6,72(sp)
a000d990:	8fb50044 	lw	s5,68(sp)
a000d994:	8fb40040 	lw	s4,64(sp)
a000d998:	8fb3003c 	lw	s3,60(sp)
a000d99c:	8fb20038 	lw	s2,56(sp)
a000d9a0:	8fb10034 	lw	s1,52(sp)
a000d9a4:	8fb00030 	lw	s0,48(sp)
a000d9a8:	03e00008 	jr	ra
a000d9ac:	27bd0058 	addiu	sp,sp,88

a000d9b0 <pollingDownModeKeyword>:
{
	int i;
                 #if CONFIG_ESD_SUPPORT//patch for ESD
                  	 REG32(0xb800311c)|= (1<<23);
                  #endif
	if  (Check_UART_DataReady() )
a000d9b0:	3c02b800 	lui	v0,0xb800
a000d9b4:	34422014 	ori	v0,v0,0x2014
a000d9b8:	8c420000 	lw	v0,0(v0)
a000d9bc:	7c420600 	ext	v0,v0,0x18,0x1
a000d9c0:	1040000c 	beqz	v0,a000d9f4 <pollingDownModeKeyword+0x44>
a000d9c4:	00000000 	nop
	{
		i=Get_UART_Data();
a000d9c8:	3c02b800 	lui	v0,0xb800
a000d9cc:	34422000 	ori	v0,v0,0x2000
a000d9d0:	8c430000 	lw	v1,0(v0)
		Get_UART_Data();
a000d9d4:	8c420000 	lw	v0,0(v0)
		if( i == key )
a000d9d8:	00031602 	srl	v0,v1,0x18
a000d9dc:	14440005 	bne	v0,a0,a000d9f4 <pollingDownModeKeyword+0x44>
a000d9e0:	24030001 	li	v1,1
		{ 	
#if defined(UTILITY_DEBUG)		
			dprintf("User Press ESC Break Key\r\n");
#endif			
			gCHKKEY_HIT=1;
a000d9e4:	3c02a002 	lui	v0,0xa002
a000d9e8:	ac438950 	sw	v1,-30384(v0)
			return 1;
a000d9ec:	03e00008 	jr	ra
a000d9f0:	24020001 	li	v0,1
		}
	}
	return 0;
}
a000d9f4:	03e00008 	jr	ra
a000d9f8:	00001021 	move	v0,zero

a000d9fc <pollingPressedButton>:
int pollingPressedButton(int pressedFlag)
{
#ifndef CONFIG_NFBI
#ifndef CONFIG_FPGA_PLATFORM
		// polling if button is pressed --------------------------------------
    		if (pressedFlag == -1 ||  pressedFlag == 1) 
a000d9fc:	2403ffff 	li	v1,-1
a000da00:	10830004 	beq	a0,v1,a000da14 <pollingPressedButton+0x18>
a000da04:	00801021 	move	v0,a0
a000da08:	24030001 	li	v1,1
a000da0c:	1483000b 	bne	a0,v1,a000da3c <pollingPressedButton+0x40>
a000da10:	00000000 	nop
	//		REG32(RTL_GPIO_MUX) =  0x0c0f;
	//		REG32(PEFGHCNR_REG) = REG32(PEFGHCNR_REG)& (~(1<<25) ); //set byte F GPIO7 = gpio
        //     		REG32(PEFGHDIR_REG) = REG32(PEFGHDIR_REG) & (~(1<<25) );  //0 input, 1 out
#endif
		
			if ( Get_GPIO_SW_IN() )			
a000da14:	3c02b800 	lui	v0,0xb800
a000da18:	34423528 	ori	v0,v0,0x3528
a000da1c:	8c430000 	lw	v1,0(v0)
a000da20:	7c630740 	ext	v1,v1,0x1d,0x1
a000da24:	14600005 	bnez	v1,a000da3c <pollingPressedButton+0x40>
a000da28:	00001021 	move	v0,zero
				if (pressedFlag == -1) 
				{
					//SET_TIMER(1*CPU_CLOCK); // wait 1 sec
				}
				pressedFlag = 1;
				gCHKKEY_HIT=1;
a000da2c:	24030001 	li	v1,1
a000da30:	3c02a002 	lui	v0,0xa002
a000da34:	ac438950 	sw	v1,-30384(v0)
a000da38:	24020001 	li	v0,1
#endif
#endif
#endif //CONFIG_NFBI

	return pressedFlag;
}
a000da3c:	03e00008 	jr	ra
a000da40:	00000000 	nop

a000da44 <Init_GPIO>:
	REG32(PEFGHDIR_REG) = REG32(PEFGHDIR_REG) & (~(1<<25) );  //0 input, 1 output, set F bit 7 input
#endif	
#endif
#endif
#endif
}
a000da44:	03e00008 	jr	ra
a000da48:	00000000 	nop

a000da4c <console_init>:
	unsigned long dl;
	unsigned long dll;     
	unsigned long dlm;       


  	REG32(UART_LCR_REG)=0x03000000;		//Line Control Register  8,n,1
a000da4c:	3c02b800 	lui	v0,0xb800
a000da50:	3443200c 	ori	v1,v0,0x200c
a000da54:	3c050300 	lui	a1,0x300
a000da58:	ac650000 	sw	a1,0(v1)
  			
  	REG32( UART_FCR_REG)=0xc7000000;		//FIFO Ccontrol Register
a000da5c:	34462008 	ori	a2,v0,0x2008
a000da60:	3c07c700 	lui	a3,0xc700
a000da64:	acc70000 	sw	a3,0(a2)
  	REG32( UART_IER_REG)=0x00000000;
a000da68:	34462004 	ori	a2,v0,0x2004
a000da6c:	acc00000 	sw	zero,0(a2)
  	dl = (lexea_clock /16)/BAUD_RATE-1;
a000da70:	3c071b4e 	lui	a3,0x1b4e
a000da74:	34e781b5 	ori	a3,a3,0x81b5
a000da78:	00870019 	multu	a0,a3
a000da7c:	00002010 	mfhi	a0
a000da80:	00042402 	srl	a0,a0,0x10
a000da84:	2484ffff 	addiu	a0,a0,-1
  	//*(volatile unsigned long *)(0xa1000000) = dl ; 
  	dll = dl & 0xff;
  	dlm = dl / 0x100;
  	REG32( UART_LCR_REG)=0x83000000;		//Divisor latch access bit=1
a000da88:	3c078300 	lui	a3,0x8300
a000da8c:	ac670000 	sw	a3,0(v1)
  	REG32( UART_DLL_REG)=dll*0x1000000;
a000da90:	00043e00 	sll	a3,a0,0x18
a000da94:	34422000 	ori	v0,v0,0x2000
a000da98:	ac470000 	sw	a3,0(v0)
   	REG32( UART_DLM_REG)=dlm*0x1000000; 
a000da9c:	00042202 	srl	a0,a0,0x8
a000daa0:	00042600 	sll	a0,a0,0x18
a000daa4:	acc40000 	sw	a0,0(a2)
    	REG32( UART_LCR_REG)=0x83000000& 0x7fffffff;	//Divisor latch access bit=0
a000daa8:	ac650000 	sw	a1,0(v1)
   	//rtl_outl( UART_THR,0x41000000);	

	//dprintf("\n\n-------------------------------------------");
	//dprintf("\nUART1 output test ok\n");
}
a000daac:	03e00008 	jr	ra
a000dab0:	00000000 	nop

a000dab4 <setClkInitConsole>:
}
#endif
//-------------------------------------------------------
//set clk and init console	
void setClkInitConsole(void)
{
a000dab4:	27bdffe8 	addiu	sp,sp,-24
a000dab8:	afbf0014 	sw	ra,20(sp)
	console_init( glexra_clock);
a000dabc:	3c02a001 	lui	v0,0xa001
a000dac0:	0c003693 	jal	a000da4c <console_init>
a000dac4:	8c447670 	lw	a0,30320(v0)
//	printf("\n=>init console ok\n");
}
a000dac8:	8fbf0014 	lw	ra,20(sp)
a000dacc:	03e00008 	jr	ra
a000dad0:	27bd0018 	addiu	sp,sp,24

a000dad4 <initFlash>:
//-------------------------------------------------------

//-------------------------------------------------------
// init flash 
void initFlash(void)
{
a000dad4:	27bdffe8 	addiu	sp,sp,-24
a000dad8:	afbf0014 	sw	ra,20(sp)
#if defined(CONFIG_SPI_FLASH)
   	spi_probe();                                  
#endif  

#if defined CONFIG_NAND_FLASH_BOOTING ||defined(CONFIG_NAND_FLASH)
		rtk_nand_probe ();
a000dadc:	0c0019cd 	jal	a0006734 <rtk_nand_probe>
a000dae0:	00000000 	nop

#ifdef CONFIG_RTK_NAND_BBT	
		//dprintf("[%s:] %d NAND_ADDR_CYCLE = %d\n",__func__,__LINE__,NAND_ADDR_CYCLE);
		rtk_scan_v2r_bbt();
a000dae4:	0c0017c5 	jal	a0005f14 <rtk_scan_v2r_bbt>
a000dae8:	00000000 	nop
		rtk_nand_scan_bbt();
a000daec:	0c0015e8 	jal	a00057a0 <rtk_nand_scan_bbt>
a000daf0:	00000000 	nop
#endif

#endif
}
a000daf4:	8fbf0014 	lw	ra,20(sp)
a000daf8:	03e00008 	jr	ra
a000dafc:	27bd0018 	addiu	sp,sp,24

a000db00 <initHeap>:
//	printf("\n=>init console ok\n");
}
//-------------------------------------------------------
//init heap	
void initHeap(void)
{
a000db00:	27bdffe8 	addiu	sp,sp,-24
a000db04:	afbf0014 	sw	ra,20(sp)
#if defined(RTL8198)
	/* Initialize malloc mechanism */
	UINT32 heap_addr=((UINT32)dl_heap&(~7))+8 ;
a000db08:	2403fff8 	li	v1,-8
a000db0c:	3c02a002 	lui	v0,0xa002
a000db10:	2442aaa8 	addiu	v0,v0,-21848
a000db14:	00431024 	and	v0,v0,v1
a000db18:	24420008 	addiu	v0,v0,8
	UINT32 heap_end=heap_addr+sizeof(dl_heap)-8;
  	i_alloc((void *)heap_addr, heap_end);
a000db1c:	00402021 	move	a0,v0
a000db20:	3c050003 	lui	a1,0x3
a000db24:	34a5fff8 	ori	a1,a1,0xfff8
a000db28:	0c001f4c 	jal	a0007d30 <i_alloc>
a000db2c:	00452821 	addu	a1,v0,a1
a000db30:	40016000 	mfc0	at,c0_status
a000db34:	34210001 	ori	at,at,0x1
a000db38:	38210001 	xori	at,at,0x1
a000db3c:	40816000 	mtc0	at,c0_status
a000db40:	000000c0 	ehb
	...
#endif
	cli();  	
	flush_cache(); // david
a000db50:	0c001eae 	jal	a0007ab8 <flush_cache>
a000db54:	00000000 	nop
}
a000db58:	8fbf0014 	lw	ra,20(sp)
a000db5c:	03e00008 	jr	ra
a000db60:	27bd0018 	addiu	sp,sp,24

a000db64 <CmdEthStartup>:
	//dprintf("\nUART1 output test ok\n");
}
//-------------------------------------------------------

void CmdEthStartup(int argc, char* argv[])
{
a000db64:	27bdffe8 	addiu	sp,sp,-24
a000db68:	afbf0014 	sw	ra,20(sp)
	eth_startup(0);	
a000db6c:	0c0008ab 	jal	a00022ac <eth_startup>
a000db70:	00002021 	move	a0,zero

	dprintf("\n---Ethernet init Okay!\n");
a000db74:	3c04a001 	lui	a0,0xa001
a000db78:	0c002325 	jal	a0008c94 <dprintf>
a000db7c:	248466e8 	addiu	a0,a0,26344


extern __inline__ void
__sti(void)
{
	__asm__ __volatile__(
a000db80:	40016000 	mfc0	at,c0_status
a000db84:	34210001 	ori	at,at,0x1
a000db88:	40816000 	mtc0	at,c0_status
a000db8c:	000000c0 	ehb
	sti();

#ifdef SUPPORT_TFTP_CLIENT	
	tftpd_entry(0);		
#else
	tftpd_entry();		
a000db90:	0c000376 	jal	a0000dd8 <tftpd_entry>
a000db94:	00000000 	nop
#endif
	return ;		
}
a000db98:	8fbf0014 	lw	ra,20(sp)
a000db9c:	03e00008 	jr	ra
a000dba0:	27bd0018 	addiu	sp,sp,24

a000dba4 <goToDownMode>:

void goToDownMode()
{
a000dba4:	27bdffe8 	addiu	sp,sp,-24
a000dba8:	afbf0014 	sw	ra,20(sp)
#ifndef CONFIG_SW_NONE

	if(pollingDownModeKeyword('m')==0)
a000dbac:	0c00366c 	jal	a000d9b0 <pollingDownModeKeyword>
a000dbb0:	2404006d 	li	a0,109
a000dbb4:	1440000c 	bnez	v0,a000dbe8 <goToDownMode+0x44>
a000dbb8:	00000000 	nop
	{
		eth_startup(0);	
a000dbbc:	0c0008ab 	jal	a00022ac <eth_startup>
a000dbc0:	00002021 	move	a0,zero

		dprintf("\n---Ethernet init Okay!\n");
a000dbc4:	3c04a001 	lui	a0,0xa001
a000dbc8:	0c002325 	jal	a0008c94 <dprintf>
a000dbcc:	248466e8 	addiu	a0,a0,26344
a000dbd0:	40016000 	mfc0	at,c0_status
a000dbd4:	34210001 	ori	at,at,0x1
a000dbd8:	40816000 	mtc0	at,c0_status
a000dbdc:	000000c0 	ehb
		sti();

#ifdef SUPPORT_TFTP_CLIENT	
		tftpd_entry(0);
#else
		tftpd_entry();		
a000dbe0:	0c000376 	jal	a0000dd8 <tftpd_entry>
a000dbe4:	00000000 	nop
		httpd_entry();
#endif

	}
#endif
	monitor();
a000dbe8:	0c003bd9 	jal	a000ef64 <monitor>
a000dbec:	00000000 	nop
	return ;
}
a000dbf0:	8fbf0014 	lw	ra,20(sp)
a000dbf4:	03e00008 	jr	ra
a000dbf8:	27bd0018 	addiu	sp,sp,24

a000dbfc <user_interrupt>:
#endif
//------------------------------------------------------------------------------------------

//return 0: do nothing; 1: jump to down load mode; 3 jump to debug down load mode
int user_interrupt(unsigned long time)
{
a000dbfc:	27bdffe8 	addiu	sp,sp,-24
a000dc00:	afbf0014 	sw	ra,20(sp)
	
#ifdef CONFIG_BOOT_RESET_ENABLE
	int button_press_detected=-1;
#endif
	
	tickStart=get_timer_jiffies();
a000dc04:	0c0038ec 	jal	a000e3b0 <get_timer_jiffies>
a000dc08:	00000000 	nop
#ifdef  SUPPORT_TFTP_CLIENT
	do 
#endif
    {
		ret=pollingDownModeKeyword(ESC);
a000dc0c:	0c00366c 	jal	a000d9b0 <pollingDownModeKeyword>
a000dc10:	2404001b 	li	a0,27
		if(ret == 1) return 1;
a000dc14:	24030001 	li	v1,1
a000dc18:	10430006 	beq	v0,v1,a000dc34 <user_interrupt+0x38>
a000dc1c:	8fbf0014 	lw	ra,20(sp)
#ifdef CONFIG_BOOT_RESET_ENABLE		
		ret=pollingPressedButton(button_press_detected);
a000dc20:	0c00367f 	jal	a000d9fc <pollingPressedButton>
a000dc24:	2404ffff 	li	a0,-1
a000dc28:	28430000 	slti	v1,v0,0
a000dc2c:	0003100b 	movn	v0,zero,v1
		gCHKKEY_HIT=1;    
		return 1;
	}
#endif	
	return 0;
}
a000dc30:	8fbf0014 	lw	ra,20(sp)
a000dc34:	03e00008 	jr	ra
a000dc38:	27bd0018 	addiu	sp,sp,24

a000dc3c <goToLocalStartMode>:
#endif		
//-------------------------------------------------------

#if !defined(CONFIG_NONE_FLASH)
void goToLocalStartMode(unsigned long addr,IMG_HEADER_Tp pheader)
{
a000dc3c:	27bdffe0 	addiu	sp,sp,-32
a000dc40:	afbf001c 	sw	ra,28(sp)
a000dc44:	afb10018 	sw	s1,24(sp)
a000dc48:	afb00014 	sw	s0,20(sp)
a000dc4c:	00a08021 	move	s0,a1
	// move image to SDRAM
#if !defined(CONFIG_NONE_FLASH)	
	flashread( pheader->startAddr|0x20000000,	(unsigned int)(addr-FLASH_BASE+sizeof(IMG_HEADER_T)), 	pheader->len-2);
#endif		
#endif
	if ( !user_interrupt(0) )  // See if user escape during copy image
a000dc50:	0c0036ff 	jal	a000dbfc <user_interrupt>
a000dc54:	00002021 	move	a0,zero
a000dc58:	14400028 	bnez	v0,a000dcfc <goToLocalStartMode+0xc0>
a000dc5c:	8fbf001c 	lw	ra,28(sp)
a000dc60:	3c03b800 	lui	v1,0xb800
a000dc64:	ac623000 	sw	v0,12288(v1)
	{
		outl(0,GIMR0); // mask all interrupt
#if defined(CONFIG_BOOT_RESET_ENABLE)
		Set_GPIO_LED_OFF();
a000dc68:	3c11b800 	lui	s1,0xb800
a000dc6c:	36223528 	ori	v0,s1,0x3528
a000dc70:	8c440000 	lw	a0,0(v0)
a000dc74:	3c030100 	lui	v1,0x100
a000dc78:	00831825 	or	v1,a0,v1
a000dc7c:	ac430000 	sw	v1,0(v0)
#endif

		prom_printf("Jump to image start=0x%x...\n", pheader->startAddr);
a000dc80:	3c04a001 	lui	a0,0xa001
a000dc84:	24846704 	addiu	a0,a0,26372
a000dc88:	0c0023a7 	jal	a0008e9c <prom_printf>
a000dc8c:	8e050004 	lw	a1,4(s0)
		set_bankinfo_register();
#endif
#ifdef CONFIG_RTK_BOOTINFO_SUPPORT
		rtk_inc_bootcnt();
#endif
		jump = (void *)(pheader->startAddr);
a000dc90:	8e100004 	lw	s0,4(s0)

		 REG32(0xb8003114)=0;
a000dc94:	36223114 	ori	v0,s1,0x3114
a000dc98:	ac400000 	sw	zero,0(v0)
  		REG32(0xb8000010)&=~(1<<11);
a000dc9c:	36310010 	ori	s1,s1,0x10
a000dca0:	8e230000 	lw	v1,0(s1)
a000dca4:	2402f7ff 	li	v0,-2049
a000dca8:	00621024 	and	v0,v1,v0
a000dcac:	ae220000 	sw	v0,0(s1)
  		REG32(0xbbdc0300)=0xffffffff;
a000dcb0:	3c03bbdc 	lui	v1,0xbbdc
a000dcb4:	34640300 	ori	a0,v1,0x300
a000dcb8:	2402ffff 	li	v0,-1
a000dcbc:	ac820000 	sw	v0,0(a0)
  		REG32(0xbbdc0304)=0xffffffff;
a000dcc0:	34630304 	ori	v1,v1,0x304
a000dcc4:	ac620000 	sw	v0,0(v1)
 * no nops at all.
 */
extern __inline__ void
__cli(void)
{
	__asm__ __volatile__(
a000dcc8:	40016000 	mfc0	at,c0_status
a000dccc:	34210001 	ori	at,at,0x1
a000dcd0:	38210001 	xori	at,at,0x1
a000dcd4:	40816000 	mtc0	at,c0_status
a000dcd8:	000000c0 	ehb
	...
		cli();
		flush_cache(); 
a000dce8:	0c001eae 	jal	a0007ab8 <flush_cache>
a000dcec:	00000000 	nop
		jump();				 // jump to start
a000dcf0:	0200f809 	jalr	s0
a000dcf4:	00000000 	nop
		return ;
	}
	return;
}
a000dcf8:	8fbf001c 	lw	ra,28(sp)
a000dcfc:	8fb10018 	lw	s1,24(sp)
a000dd00:	8fb00014 	lw	s0,20(sp)
a000dd04:	03e00008 	jr	ra
a000dd08:	27bd0020 	addiu	sp,sp,32

a000dd0c <doBooting>:
#define RTL_8198CS 0x80
#define RTL_8954ES 0x83


void doBooting(int flag, unsigned long addr, IMG_HEADER_Tp pheader)
{
a000dd0c:	27bdffe0 	addiu	sp,sp,-32
a000dd10:	afbf001c 	sw	ra,28(sp)
a000dd14:	afb20018 	sw	s2,24(sp)
a000dd18:	afb10014 	sw	s1,20(sp)
a000dd1c:	afb00010 	sw	s0,16(sp)
a000dd20:	00a08021 	move	s0,a1
a000dd24:	00c08821 	move	s1,a2
	unsigned int id = REG32(0xb800000c) & 0xff;
a000dd28:	3c02b800 	lui	v0,0xb800
a000dd2c:	3442000c 	ori	v0,v0,0xc
a000dd30:	8c520000 	lw	s2,0(v0)
#ifdef SUPPORT_TFTP_CLIENT	
	extern int check_tftp_client_state();

	if(flag || check_tftp_client_state() >= 0)
#else
	if(flag)
a000dd34:	10800031 	beqz	a0,a000ddfc <doBooting+0xf0>
a000dd38:	3c043b02 	lui	a0,0x3b02
#endif
	{
		switch(user_interrupt(WAIT_TIME_USER_INTERRUPT))
a000dd3c:	0c0036ff 	jal	a000dbfc <user_interrupt>
a000dd40:	34843380 	ori	a0,a0,0x3380
a000dd44:	24030001 	li	v1,1
a000dd48:	1043001f 	beq	v0,v1,a000ddc8 <doBooting+0xbc>
a000dd4c:	325200ff 	andi	s2,s2,0xff
		{
		case LOCALSTART_MODE:
		default:
			if ((id==RTL_8198C)||(id==RTL_8198CS||(id==RTL_8954E)||(id==RTL_8954ES)))
a000dd50:	12400007 	beqz	s2,a000dd70 <doBooting+0x64>
a000dd54:	24020080 	li	v0,128
a000dd58:	12420005 	beq	s2,v0,a000dd70 <doBooting+0x64>
a000dd5c:	24020003 	li	v0,3
a000dd60:	12420003 	beq	s2,v0,a000dd70 <doBooting+0x64>
a000dd64:	24020083 	li	v0,131
a000dd68:	16420006 	bne	s2,v0,a000dd84 <doBooting+0x78>
a000dd6c:	24020002 	li	v0,2
			{
				SettingCPUClk(0xb,0);      //chg f1000MHz
a000dd70:	2404000b 	li	a0,11
a000dd74:	0c002eb8 	jal	a000bae0 <SettingCPUClk>
a000dd78:	00002821 	move	a1,zero
	{
		switch(user_interrupt(WAIT_TIME_USER_INTERRUPT))
		{
		case LOCALSTART_MODE:
		default:
			if ((id==RTL_8198C)||(id==RTL_8198CS||(id==RTL_8954E)||(id==RTL_8954ES)))
a000dd7c:	0800376b 	j	a000ddac <doBooting+0xa0>
a000dd80:	00002021 	move	a0,zero
			{
				SettingCPUClk(0xb,0);      //chg f1000MHz
			}
			else if (id==RTL_8198CD)
a000dd84:	16420005 	bne	s2,v0,a000dd9c <doBooting+0x90>
a000dd88:	24040003 	li	a0,3
			{
				SettingCPUClk(3,0);      //chg f600MHz	
a000dd8c:	0c002eb8 	jal	a000bae0 <SettingCPUClk>
a000dd90:	00002821 	move	a1,zero
			}
			else
			{
				SettingCPUClk(0x7,0);      //chg f800MHz			
			}
			CmdCore1Wakeup(0,NULL);		
a000dd94:	0800376b 	j	a000ddac <doBooting+0xa0>
a000dd98:	00002021 	move	a0,zero
			{
				SettingCPUClk(3,0);      //chg f600MHz	
			}
			else
			{
				SettingCPUClk(0x7,0);      //chg f800MHz			
a000dd9c:	24040007 	li	a0,7
a000dda0:	0c002eb8 	jal	a000bae0 <SettingCPUClk>
a000dda4:	00002821 	move	a1,zero
			}
			CmdCore1Wakeup(0,NULL);		
a000dda8:	00002021 	move	a0,zero
a000ddac:	0c002758 	jal	a0009d60 <CmdCore1Wakeup>
a000ddb0:	00002821 	move	a1,zero
			if (!flag) {
				REG32(GIMR_REG)=0x0;   //add by jiawenjian
				goToDownMode(); 	
			}	
#endif			
			goToLocalStartMode(addr,pheader);
a000ddb4:	02002021 	move	a0,s0
a000ddb8:	0c00370f 	jal	a000dc3c <goToLocalStartMode>
a000ddbc:	02202821 	move	a1,s1
			break;
a000ddc0:	0800378a 	j	a000de28 <doBooting+0x11c>
a000ddc4:	8fbf001c 	lw	ra,28(sp)
			
		case DOWN_MODE:
		 	CmdCore1Wakeup(0,NULL);	
a000ddc8:	00002021 	move	a0,zero
a000ddcc:	0c002758 	jal	a0009d60 <CmdCore1Wakeup>
a000ddd0:	00002821 	move	a1,zero
			dprintf("\n---Escape booting by user\n");	
a000ddd4:	3c04a001 	lui	a0,0xa001
a000ddd8:	0c002325 	jal	a0008c94 <dprintf>
a000dddc:	24846724 	addiu	a0,a0,26404
			//REG32(GIMR_REG)=0x0;   //add by jiawenjian
			 #if CONFIG_ESD_SUPPORT//patch for ESD
                         REG32(0xb800311c)=0xa5000000 ;
        		 #endif
			#ifdef CONFIG_NAND_FLASH
			REG32(0xb8019004) = 0;
a000dde0:	3c02b801 	lui	v0,0xb801
a000dde4:	34429004 	ori	v0,v0,0x9004
a000dde8:	ac400000 	sw	zero,0(v0)
			#endif
			goToDownMode();	
a000ddec:	0c0036e9 	jal	a000dba4 <goToDownMode>
a000ddf0:	00000000 	nop
		REG32(0xb8019004) = 0;
		#endif
		goToDownMode();		
	}
	return;
}
a000ddf4:	0800378a 	j	a000de28 <doBooting+0x11c>
a000ddf8:	8fbf001c 	lw	ra,28(sp)
		}/*switch case */
	}/*if image correct*/
	else
#endif //CONFIG_NFBI
	{
		CmdCore1Wakeup(0,NULL);		
a000ddfc:	00002021 	move	a0,zero
a000de00:	0c002758 	jal	a0009d60 <CmdCore1Wakeup>
a000de04:	00002821 	move	a1,zero
		flush_cache();
a000de08:	0c001eae 	jal	a0007ab8 <flush_cache>
a000de0c:	00000000 	nop
		 #if CONFIG_ESD_SUPPORT//patch for ESD
                       REG32(0xb800311c)=0xa5000000 ;
                 #endif	
		//REG32(GIMR_REG)=0x0;   //add by jiawenjian
		#ifdef CONFIG_NAND_FLASH
		REG32(0xb8019004) = 0;
a000de10:	3c02b801 	lui	v0,0xb801
a000de14:	34429004 	ori	v0,v0,0x9004
a000de18:	ac400000 	sw	zero,0(v0)
		#endif
		goToDownMode();		
a000de1c:	0c0036e9 	jal	a000dba4 <goToDownMode>
a000de20:	00000000 	nop
	}
	return;
}
a000de24:	8fbf001c 	lw	ra,28(sp)
a000de28:	8fb20018 	lw	s2,24(sp)
a000de2c:	8fb10014 	lw	s1,20(sp)
a000de30:	8fb00010 	lw	s0,16(sp)
a000de34:	03e00008 	jr	ra
a000de38:	27bd0020 	addiu	sp,sp,32

a000de3c <check_rootfs_image>:
	return (ret);
}
//------------------------------------------------------------------------------------------

int check_rootfs_image(unsigned long addr)
{
a000de3c:	27bdffb8 	addiu	sp,sp,-72
a000de40:	afbf0044 	sw	ra,68(sp)
a000de44:	afbe0040 	sw	s8,64(sp)
a000de48:	afb7003c 	sw	s7,60(sp)
a000de4c:	afb60038 	sw	s6,56(sp)
a000de50:	afb50034 	sw	s5,52(sp)
a000de54:	afb40030 	sw	s4,48(sp)
a000de58:	afb3002c 	sw	s3,44(sp)
a000de5c:	afb20028 	sw	s2,40(sp)
a000de60:	afb10024 	sw	s1,36(sp)
a000de64:	afb00020 	sw	s0,32(sp)
	unsigned char __attribute__ ((aligned(64))) oob_buf[64];
	unsigned char *data_buf = (unsigned char *)(DRAM_DIMAGE_ADDR);
	int jump_to_backup=0;
#endif
	
	if(gCHKKEY_HIT==1)
a000de68:	3c02a002 	lui	v0,0xa002
a000de6c:	8c438950 	lw	v1,-30384(v0)
a000de70:	24020001 	li	v0,1
a000de74:	10620042 	beq	v1,v0,a000df80 <check_rootfs_image+0x144>
a000de78:	0080f021 	move	s8,a0
		return 0;
	
	word_ptr = (unsigned short *)tmpbuf;
a000de7c:	27a20010 	addiu	v0,sp,16
a000de80:	3c14b800 	lui	s4,0xb800
a000de84:	0094a021 	addu	s4,a0,s4

	return (ret);
}
//------------------------------------------------------------------------------------------

int check_rootfs_image(unsigned long addr)
a000de88:	27a50020 	addiu	a1,sp,32
a000de8c:	02801821 	move	v1,s4
	if(gCHKKEY_HIT==1)
		return 0;
	
	word_ptr = (unsigned short *)tmpbuf;
	for (i=0; i<16; i+=2, word_ptr++)
		*word_ptr = rtl_inw(addr + i);
a000de90:	94640000 	lhu	a0,0(v1)
a000de94:	a4440000 	sh	a0,0(v0)
	
	if(gCHKKEY_HIT==1)
		return 0;
	
	word_ptr = (unsigned short *)tmpbuf;
	for (i=0; i<16; i+=2, word_ptr++)
a000de98:	24420002 	addiu	v0,v0,2
a000de9c:	1445fffc 	bne	v0,a1,a000de90 <check_rootfs_image+0x54>
a000dea0:	24630002 	addiu	v1,v1,2
		*word_ptr = rtl_inw(addr + i);

	if ( memcmp(tmpbuf, SQSH_SIGNATURE, SIG_LEN) && memcmp(tmpbuf, SQSH_SIGNATURE_LE, SIG_LEN)) {
a000dea4:	27a40010 	addiu	a0,sp,16
a000dea8:	3c05a001 	lui	a1,0xa001
a000deac:	24a54178 	addiu	a1,a1,16760
a000deb0:	0c002051 	jal	a0008144 <memcmp>
a000deb4:	24060004 	li	a2,4
a000deb8:	1040000e 	beqz	v0,a000def4 <check_rootfs_image+0xb8>
a000debc:	8fb50018 	lw	s5,24(sp)
a000dec0:	27a40010 	addiu	a0,sp,16
a000dec4:	3c05a001 	lui	a1,0xa001
a000dec8:	24a56740 	addiu	a1,a1,26432
a000decc:	0c002051 	jal	a0008144 <memcmp>
a000ded0:	24060004 	li	a2,4
a000ded4:	10400007 	beqz	v0,a000def4 <check_rootfs_image+0xb8>
a000ded8:	8fb50018 	lw	s5,24(sp)
		prom_printf("no rootfs signature at %X!\n",addr-FLASH_BASE);
a000dedc:	3c04a001 	lui	a0,0xa001
a000dee0:	24846748 	addiu	a0,a0,26440
a000dee4:	0c0023a7 	jal	a0008e9c <prom_printf>
a000dee8:	03c02821 	move	a1,s8
		return 0;
a000deec:	080037e3 	j	a000df8c <check_rootfs_image+0x150>
a000def0:	00001021 	move	v0,zero
	}

#if CHECK_BURN_SERIAL
	board_rootfs_length =
#endif
	length = *(((unsigned long *)tmpbuf) + OFFSET_OF_LEN) + SIZE_OF_SQFS_SUPER_BLOCK + SIZE_OF_CHECKSUM;
a000def4:	26b50282 	addiu	s5,s5,642
}

SKIP_CHECK_BURN_SERIAL:
#endif

	for (i=0; i<length; i+=2) {
a000def8:	12a00023 	beqz	s5,a000df88 <check_rootfs_image+0x14c>
a000defc:	00009821 	move	s3,zero
a000df00:	00009021 	move	s2,zero
a000df04:	00008021 	move	s0,zero
#if 1  //slowly
                 #if CONFIG_ESD_SUPPORT//patch for ESD
                  	 REG32(0xb800311c)|= (1<<23);
                  #endif
			gCHKKEY_CNT++;
a000df08:	3c11a002 	lui	s1,0xa002
			if( gCHKKEY_CNT>ACCCNT_TOCHKKEY)
a000df0c:	3c160002 	lui	s6,0x2
a000df10:	36d60001 	ori	s6,s6,0x1
			{	gCHKKEY_CNT=0;
				if ( user_interrupt(0)==1 )  //return 1: got ESC Key
a000df14:	24170001 	li	s7,1
	for (i=0; i<length; i+=2) {
#if 1  //slowly
                 #if CONFIG_ESD_SUPPORT//patch for ESD
                  	 REG32(0xb800311c)|= (1<<23);
                  #endif
			gCHKKEY_CNT++;
a000df18:	8e228954 	lw	v0,-30380(s1)
a000df1c:	24420001 	addiu	v0,v0,1
a000df20:	ae228954 	sw	v0,-30380(s1)
			if( gCHKKEY_CNT>ACCCNT_TOCHKKEY)
a000df24:	0056102b 	sltu	v0,v0,s6
a000df28:	14400006 	bnez	v0,a000df44 <check_rootfs_image+0x108>
a000df2c:	00000000 	nop
			{	gCHKKEY_CNT=0;
a000df30:	ae208954 	sw	zero,-30380(s1)
				if ( user_interrupt(0)==1 )  //return 1: got ESC Key
a000df34:	0c0036ff 	jal	a000dbfc <user_interrupt>
a000df38:	00002021 	move	a0,zero
a000df3c:	10570013 	beq	v0,s7,a000df8c <check_rootfs_image+0x150>
a000df40:	00001021 	move	v0,zero
			{	gCHKKEY_HIT=1; 
				return 0;
			}
#endif			
#if defined(NEED_CHKSUM)	
		sum += rtl_inw(addr + i);
a000df44:	02939821 	addu	s3,s4,s3
a000df48:	96620000 	lhu	v0,0(s3)
a000df4c:	02429021 	addu	s2,s2,v0
a000df50:	3252ffff 	andi	s2,s2,0xffff
}

SKIP_CHECK_BURN_SERIAL:
#endif

	for (i=0; i<length; i+=2) {
a000df54:	26100002 	addiu	s0,s0,2
a000df58:	0215102b 	sltu	v0,s0,s5
a000df5c:	1440ffee 	bnez	v0,a000df18 <check_rootfs_image+0xdc>
a000df60:	02009821 	move	s3,s0
		sum += rtl_inw(addr + i);
#endif
	}

#if defined(NEED_CHKSUM)		
	if ( sum ) {
a000df64:	12400008 	beqz	s2,a000df88 <check_rootfs_image+0x14c>
a000df68:	3c04a001 	lui	a0,0xa001
		prom_printf("rootfs checksum error at %X!\n",addr-FLASH_BASE);
a000df6c:	24846764 	addiu	a0,a0,26468
a000df70:	0c0023a7 	jal	a0008e9c <prom_printf>
a000df74:	03c02821 	move	a1,s8
		return 0;
a000df78:	080037e3 	j	a000df8c <check_rootfs_image+0x150>
a000df7c:	00001021 	move	v0,zero
a000df80:	080037e3 	j	a000df8c <check_rootfs_image+0x150>
a000df84:	00001021 	move	v0,zero
a000df88:	24020001 	li	v0,1
	}	
#endif	
	return 1;
#endif //CONFIG_RTK_VOIP
}
a000df8c:	8fbf0044 	lw	ra,68(sp)
a000df90:	8fbe0040 	lw	s8,64(sp)
a000df94:	8fb7003c 	lw	s7,60(sp)
a000df98:	8fb60038 	lw	s6,56(sp)
a000df9c:	8fb50034 	lw	s5,52(sp)
a000dfa0:	8fb40030 	lw	s4,48(sp)
a000dfa4:	8fb3002c 	lw	s3,44(sp)
a000dfa8:	8fb20028 	lw	s2,40(sp)
a000dfac:	8fb10024 	lw	s1,36(sp)
a000dfb0:	8fb00020 	lw	s0,32(sp)
a000dfb4:	03e00008 	jr	ra
a000dfb8:	27bd0048 	addiu	sp,sp,72

a000dfbc <check_system_image>:
	return ret;
}
#endif
// return,  0: not found, 1: linux found, 2:linux with root found
int check_system_image(unsigned long addr,IMG_HEADER_Tp pHeader,SETTING_HEADER_Tp setting_header)
{
a000dfbc:	27bdffb8 	addiu	sp,sp,-72
a000dfc0:	afbf0044 	sw	ra,68(sp)
a000dfc4:	afbe0040 	sw	s8,64(sp)
a000dfc8:	afb7003c 	sw	s7,60(sp)
a000dfcc:	afb60038 	sw	s6,56(sp)
a000dfd0:	afb50034 	sw	s5,52(sp)
a000dfd4:	afb40030 	sw	s4,48(sp)
a000dfd8:	afb3002c 	sw	s3,44(sp)
a000dfdc:	afb20028 	sw	s2,40(sp)
a000dfe0:	afb10024 	sw	s1,36(sp)
a000dfe4:	afb00020 	sw	s0,32(sp)
a000dfe8:	0080b821 	move	s7,a0
	int i, ret=0;
	unsigned short sum=0, *word_ptr;
	unsigned short length=0;
	unsigned short temp16=0;
	char image_sig_check[1]={0};
	char image_sig[4]={0};
a000dfec:	afa00010 	sw	zero,16(sp)
	char image_sig_root[4]={0};
a000dff0:	afa00014 	sw	zero,20(sp)
	unsigned char __attribute__ ((aligned(64))) oob_buf[64];
	unsigned char *data_buf = (unsigned char *)(DRAM_DIMAGE_ADDR);
	int jump_to_backup=0;
	#endif

	if(gCHKKEY_HIT==1)
a000dff4:	3c02a002 	lui	v0,0xa002
a000dff8:	8c438950 	lw	v1,-30384(v0)
a000dffc:	24020001 	li	v0,1
a000e000:	10620095 	beq	v1,v0,a000e258 <check_system_image+0x29c>
a000e004:	00a08821 	move	s1,a1
		    //dprintf("[%s]:%d\n",__func__,__LINE__);
			word_ptr = (unsigned short *)pHeader;
			start_page = ((addr)/page_size)-ppb;			
			start_position = addr;
			#ifdef CONFIG_RTK_NAND_BBT			
						start_block = (addr >> block_shift);//virtual block index
a000e008:	3c02a002 	lui	v0,0xa002
a000e00c:	8c568870 	lw	s6,-30608(v0)
a000e010:	02c4b006 	srlv	s6,a0,s6
		}
			#ifdef CONFIG_RTK_NAND_BBT
			//printf("start blockv %x addr %x page_size:%x ppb:%x ptr_data:%x\n\r",start_block,addr,page_size,ppb,ptr_data);
		    //dprintf("[%s]:%d block_shift = %d\n",__func__,__LINE__,block_shift );
			count=0;
			 for(i=start_block;i< start_block+1;i++){ //caculate how many block.
a000e014:	02c08021 	move	s0,s6
a000e018:	26d30001 	addiu	s3,s6,1
a000e01c:	02d3102b 	sltu	v0,s6,s3
a000e020:	1040000f 	beqz	v0,a000e060 <check_system_image+0xa4>
a000e024:	00009021 	move	s2,zero
				addr_bt = (i << block_shift);//real block index, addr.
		       //printf("blockv:%x addrv:%x addr_bt:%x\n\r",i,addr,addr_bt);
			   //while(1); //debug cl for safe sake //read a block here
				if(nand_read_ecc_ob(addr_bt, block_size, ptr_data+(count*block_size), ptr_oob)){
a000e028:	3c14a001 	lui	s4,0xa001
a000e02c:	3c15a002 	lui	s5,0xa002
a000e030:	3c1ea0a0 	lui	s8,0xa0a0
a000e034:	8e867524 	lw	a2,29988(s4)
a000e038:	8ea48870 	lw	a0,-30608(s5)
a000e03c:	00902004 	sllv	a0,s0,a0
a000e040:	00c02821 	move	a1,a2
a000e044:	72461002 	mul	v0,s2,a2
a000e048:	005e3021 	addu	a2,v0,s8
a000e04c:	0c001be3 	jal	a0006f8c <nand_read_ecc_ob>
a000e050:	3c07a100 	lui	a3,0xa100
a000e054:	10400007 	beqz	v0,a000e074 <check_system_image+0xb8>
a000e058:	26100001 	addiu	s0,s0,1
a000e05c:	2610ffff 	addiu	s0,s0,-1
a000e060:	00001821 	move	v1,zero
a000e064:	00001021 	move	v0,zero
			
		    //dprintf("[%s]:%d read signature block ok, print header data:...\n",__func__,__LINE__);
			 //printf("FF size:%x  ptr:%x \r\n",sizeof(IMG_HEADER_T),word_ptr);
			for (i=0; i<sizeof(IMG_HEADER_T); i+=2, word_ptr++)
			{
				*word_ptr = ((*(ptr_data+1+i))|*(ptr_data+i)<<8)&0xffff;
a000e068:	3c08a0a0 	lui	t0,0xa0a0
				count++;
			 }
			
		    //dprintf("[%s]:%d read signature block ok, print header data:...\n",__func__,__LINE__);
			 //printf("FF size:%x  ptr:%x \r\n",sizeof(IMG_HEADER_T),word_ptr);
			for (i=0; i<sizeof(IMG_HEADER_T); i+=2, word_ptr++)
a000e06c:	08003822 	j	a000e088 <check_system_image+0xcc>
a000e070:	24070010 	li	a3,16
		}
			#ifdef CONFIG_RTK_NAND_BBT
			//printf("start blockv %x addr %x page_size:%x ppb:%x ptr_data:%x\n\r",start_block,addr,page_size,ppb,ptr_data);
		    //dprintf("[%s]:%d block_shift = %d\n",__func__,__LINE__,block_shift );
			count=0;
			 for(i=start_block;i< start_block+1;i++){ //caculate how many block.
a000e074:	0213102b 	sltu	v0,s0,s3
a000e078:	1440ffee 	bnez	v0,a000e034 <check_system_image+0x78>
a000e07c:	26520001 	addiu	s2,s2,1
				addr_bt = (i << block_shift);//real block index, addr.
		       //printf("blockv:%x addrv:%x addr_bt:%x\n\r",i,addr,addr_bt);
			   //while(1); //debug cl for safe sake //read a block here
				if(nand_read_ecc_ob(addr_bt, block_size, ptr_data+(count*block_size), ptr_oob)){
a000e080:	08003819 	j	a000e064 <check_system_image+0xa8>
a000e084:	00001821 	move	v1,zero
			
		    //dprintf("[%s]:%d read signature block ok, print header data:...\n",__func__,__LINE__);
			 //printf("FF size:%x  ptr:%x \r\n",sizeof(IMG_HEADER_T),word_ptr);
			for (i=0; i<sizeof(IMG_HEADER_T); i+=2, word_ptr++)
			{
				*word_ptr = ((*(ptr_data+1+i))|*(ptr_data+i)<<8)&0xffff;
a000e088:	02222021 	addu	a0,s1,v0
a000e08c:	01031821 	addu	v1,t0,v1
a000e090:	90660000 	lbu	a2,0(v1)
a000e094:	90650001 	lbu	a1,1(v1)
a000e098:	00061a00 	sll	v1,a2,0x8
a000e09c:	00651825 	or	v1,v1,a1
a000e0a0:	a4830000 	sh	v1,0(a0)
				count++;
			 }
			
		    //dprintf("[%s]:%d read signature block ok, print header data:...\n",__func__,__LINE__);
			 //printf("FF size:%x  ptr:%x \r\n",sizeof(IMG_HEADER_T),word_ptr);
			for (i=0; i<sizeof(IMG_HEADER_T); i+=2, word_ptr++)
a000e0a4:	24420002 	addiu	v0,v0,2
a000e0a8:	1447fff7 	bne	v0,a3,a000e088 <check_system_image+0xcc>
a000e0ac:	00401821 	move	v1,v0
	word_ptr = (unsigned short *)pHeader;
	for (i=0; i<sizeof(IMG_HEADER_T); i+=2, word_ptr++)
		*word_ptr = rtl_inw(addr + i);	
#endif

	memcpy(image_sig, FW_SIGNATURE, SIG_LEN);
a000e0b0:	3c02a001 	lui	v0,0xa001
a000e0b4:	8c424334 	lw	v0,17204(v0)
a000e0b8:	afa20010 	sw	v0,16(sp)
	memcpy(image_sig_root, FW_SIGNATURE_WITH_ROOT, SIG_LEN);
a000e0bc:	3c02a001 	lui	v0,0xa001
a000e0c0:	8c42434c 	lw	v0,17228(v0)
a000e0c4:	afa20014 	sw	v0,20(sp)

	if (!memcmp(pHeader->signature, image_sig, SIG_LEN))
a000e0c8:	02202021 	move	a0,s1
a000e0cc:	27a50010 	addiu	a1,sp,16
a000e0d0:	0c002051 	jal	a0008144 <memcmp>
a000e0d4:	24060004 	li	a2,4
		ret=1;
	else if  (!memcmp(pHeader->signature, image_sig_root, SIG_LEN))
		ret=2;
	else{
		prom_printf("no sys signature at %X!\n",addr-FLASH_BASE);
a000e0d8:	24030001 	li	v1,1
#endif

	memcpy(image_sig, FW_SIGNATURE, SIG_LEN);
	memcpy(image_sig_root, FW_SIGNATURE_WITH_ROOT, SIG_LEN);

	if (!memcmp(pHeader->signature, image_sig, SIG_LEN))
a000e0dc:	1040000e 	beqz	v0,a000e118 <check_system_image+0x15c>
a000e0e0:	afa3001c 	sw	v1,28(sp)
		ret=1;
	else if  (!memcmp(pHeader->signature, image_sig_root, SIG_LEN))
a000e0e4:	02202021 	move	a0,s1
a000e0e8:	27a50014 	addiu	a1,sp,20
a000e0ec:	0c002051 	jal	a0008144 <memcmp>
a000e0f0:	24060004 	li	a2,4
a000e0f4:	24030002 	li	v1,2
a000e0f8:	10400007 	beqz	v0,a000e118 <check_system_image+0x15c>
a000e0fc:	afa3001c 	sw	v1,28(sp)
		ret=2;
	else{
		prom_printf("no sys signature at %X!\n",addr-FLASH_BASE);
a000e100:	3c04a001 	lui	a0,0xa001
a000e104:	24846784 	addiu	a0,a0,26500
a000e108:	0c0023a7 	jal	a0008e9c <prom_printf>
a000e10c:	02e02821 	move	a1,s7
a000e110:	08003897 	j	a000e25c <check_system_image+0x2a0>
a000e114:	afa0001c 	sw	zero,28(sp)
	
	if (ret) {

#ifdef CONFIG_NAND_FLASH_BOOTING
		#ifdef CONFIG_RTK_NAND_BBT
		for(i=(start_block+1);i< (pHeader->len/block_size)+start_block+1;i++){ //caculate how many block.
a000e118:	02608021 	move	s0,s3
a000e11c:	3c02a001 	lui	v0,0xa001
a000e120:	8c467524 	lw	a2,29988(v0)
a000e124:	8e22000c 	lw	v0,12(s1)
a000e128:	0046001b 	divu	zero,v0,a2
a000e12c:	00c001f4 	teq	a2,zero,0x7
a000e130:	00001812 	mflo	v1
a000e134:	24620001 	addiu	v0,v1,1
a000e138:	00561021 	addu	v0,v0,s6
a000e13c:	0262102b 	sltu	v0,s3,v0
a000e140:	1040002c 	beqz	v0,a000e1f4 <check_system_image+0x238>
a000e144:	0260a021 	move	s4,s3
			addr_bt = (i << block_shift);//real block index, addr.
		       //printf("blockv:%x addrv:%x\n\r",i,addr_bt);
				if(nand_read_ecc_ob(addr_bt, block_size, ptr_data+(count*block_size), ptr_oob)){
a000e148:	3c13a002 	lui	s3,0xa002
a000e14c:	3c17a0a0 	lui	s7,0xa0a0
		                    break;
				}
				count++;
				//Enhance the user interrupt latency
				if((i%0x10000) == 0){
					gCHKKEY_CNT++;
a000e150:	3c15a002 	lui	s5,0xa002
					if( gCHKKEY_CNT>ACCCNT_TOCHKKEY)
a000e154:	3c020002 	lui	v0,0x2
a000e158:	34420001 	ori	v0,v0,0x1
a000e15c:	afa20018 	sw	v0,24(sp)
	
	if (ret) {

#ifdef CONFIG_NAND_FLASH_BOOTING
		#ifdef CONFIG_RTK_NAND_BBT
		for(i=(start_block+1);i< (pHeader->len/block_size)+start_block+1;i++){ //caculate how many block.
a000e160:	3c1ea001 	lui	s8,0xa001
			addr_bt = (i << block_shift);//real block index, addr.
		       //printf("blockv:%x addrv:%x\n\r",i,addr_bt);
				if(nand_read_ecc_ob(addr_bt, block_size, ptr_data+(count*block_size), ptr_oob)){
a000e164:	8e648870 	lw	a0,-30608(s3)
a000e168:	00902004 	sllv	a0,s0,a0
a000e16c:	00c02821 	move	a1,a2
a000e170:	70d21002 	mul	v0,a2,s2
a000e174:	00573021 	addu	a2,v0,s7
a000e178:	0c001be3 	jal	a0006f8c <nand_read_ecc_ob>
a000e17c:	3c07a100 	lui	a3,0xa100
a000e180:	1440001c 	bnez	v0,a000e1f4 <check_system_image+0x238>
a000e184:	3294ffff 	andi	s4,s4,0xffff
							//while(1); //debug cl for safe sake
		                    break;
				}
				count++;
				//Enhance the user interrupt latency
				if((i%0x10000) == 0){
a000e188:	1680000d 	bnez	s4,a000e1c0 <check_system_image+0x204>
a000e18c:	8ea28954 	lw	v0,-30380(s5)
					gCHKKEY_CNT++;
a000e190:	24420001 	addiu	v0,v0,1
a000e194:	aea28954 	sw	v0,-30380(s5)
					if( gCHKKEY_CNT>ACCCNT_TOCHKKEY)
a000e198:	8fa30018 	lw	v1,24(sp)
a000e19c:	0043102b 	sltu	v0,v0,v1
a000e1a0:	14400007 	bnez	v0,a000e1c0 <check_system_image+0x204>
a000e1a4:	00000000 	nop
					{	gCHKKEY_CNT=0;
a000e1a8:	aea08954 	sw	zero,-30380(s5)
						if ( user_interrupt(0)==1 )  //return 1: got ESC Key
a000e1ac:	0c0036ff 	jal	a000dbfc <user_interrupt>
a000e1b0:	00002021 	move	a0,zero
a000e1b4:	24030001 	li	v1,1
a000e1b8:	10430027 	beq	v0,v1,a000e258 <check_system_image+0x29c>
a000e1bc:	00000000 	nop
	
	if (ret) {

#ifdef CONFIG_NAND_FLASH_BOOTING
		#ifdef CONFIG_RTK_NAND_BBT
		for(i=(start_block+1);i< (pHeader->len/block_size)+start_block+1;i++){ //caculate how many block.
a000e1c0:	26100001 	addiu	s0,s0,1
a000e1c4:	8fc67524 	lw	a2,29988(s8)
a000e1c8:	8e22000c 	lw	v0,12(s1)
a000e1cc:	0046001b 	divu	zero,v0,a2
a000e1d0:	00c001f4 	teq	a2,zero,0x7
a000e1d4:	00001812 	mflo	v1
a000e1d8:	24620001 	addiu	v0,v1,1
a000e1dc:	00561021 	addu	v0,v0,s6
a000e1e0:	0202102b 	sltu	v0,s0,v0
a000e1e4:	10400003 	beqz	v0,a000e1f4 <check_system_image+0x238>
a000e1e8:	0200a021 	move	s4,s0
				if(nand_read_ecc_ob(addr_bt, block_size, ptr_data+(count*block_size), ptr_oob)){
		                    //printf("%s: nand_read_ecc addrv :%x error\n",__FUNCTION__, addr_bt);
							//while(1); //debug cl for safe sake
		                    break;
				}
				count++;
a000e1ec:	08003859 	j	a000e164 <check_system_image+0x1a8>
a000e1f0:	26520001 	addiu	s2,s2,1
						}
					}
				}
		}
		
		for (i=0; i<pHeader->len; i+=2){
a000e1f4:	8e26000c 	lw	a2,12(s1)
a000e1f8:	10c00011 	beqz	a2,a000e240 <check_system_image+0x284>
a000e1fc:	00001821 	move	v1,zero
a000e200:	00002021 	move	a0,zero
a000e204:	00001021 	move	v0,zero
                 #if CONFIG_ESD_SUPPORT//patch for ESD
                  	 REG32(0xb800311c)|= (1<<23);
                  #endif
			
			#if defined(NEED_CHKSUM)	
			sum +=(unsigned short)(((*(ptr_data+1+i+ sizeof(IMG_HEADER_T)))|(*(ptr_data+i+ sizeof(IMG_HEADER_T)))<<8)&0xffff);
a000e208:	3c08a0a0 	lui	t0,0xa0a0
a000e20c:	01031821 	addu	v1,t0,v1
a000e210:	90670010 	lbu	a3,16(v1)
a000e214:	90650011 	lbu	a1,17(v1)
a000e218:	00071a00 	sll	v1,a3,0x8
a000e21c:	00651825 	or	v1,v1,a1
a000e220:	00832021 	addu	a0,a0,v1
a000e224:	3084ffff 	andi	a0,a0,0xffff
						}
					}
				}
		}
		
		for (i=0; i<pHeader->len; i+=2){
a000e228:	24420002 	addiu	v0,v0,2
a000e22c:	0046282b 	sltu	a1,v0,a2
a000e230:	14a0fff6 	bnez	a1,a000e20c <check_system_image+0x250>
a000e234:	00401821 	move	v1,v0
#endif
		}	
#endif

#if defined(NEED_CHKSUM)			
		if ( sum ) {
a000e238:	14800007 	bnez	a0,a000e258 <check_system_image+0x29c>
a000e23c:	00000000 	nop
		{
		    //dprintf("[%s]:%d\n",__func__,__LINE__);
			unsigned char* target_add;
			target_add=pHeader->startAddr;
			//target_add= ((pHeader->startAddr)|0x20000000);
			memcpy(target_add,ptr_data+sizeof(IMG_HEADER_T),pHeader->len);		
a000e240:	8e240004 	lw	a0,4(s1)
a000e244:	3c05a0a0 	lui	a1,0xa0a0
a000e248:	0c002046 	jal	a0008118 <memcpy>
a000e24c:	34a50010 	ori	a1,a1,0x10
#endif		
	}
	//prom_printf("ret=%d  sys signature at %X!\n",ret,addr-FLASH_BASE);

	return (ret);
}
a000e250:	08003898 	j	a000e260 <check_system_image+0x2a4>
a000e254:	8fa2001c 	lw	v0,28(sp)
		{
		    //dprintf("[%s]:%d\n",__func__,__LINE__);
			unsigned char* target_add;
			target_add=pHeader->startAddr;
			//target_add= ((pHeader->startAddr)|0x20000000);
			memcpy(target_add,ptr_data+sizeof(IMG_HEADER_T),pHeader->len);		
a000e258:	afa0001c 	sw	zero,28(sp)
#endif		
	}
	//prom_printf("ret=%d  sys signature at %X!\n",ret,addr-FLASH_BASE);

	return (ret);
}
a000e25c:	8fa2001c 	lw	v0,28(sp)
a000e260:	8fbf0044 	lw	ra,68(sp)
a000e264:	8fbe0040 	lw	s8,64(sp)
a000e268:	8fb7003c 	lw	s7,60(sp)
a000e26c:	8fb60038 	lw	s6,56(sp)
a000e270:	8fb50034 	lw	s5,52(sp)
a000e274:	8fb40030 	lw	s4,48(sp)
a000e278:	8fb3002c 	lw	s3,44(sp)
a000e27c:	8fb20028 	lw	s2,40(sp)
a000e280:	8fb10024 	lw	s1,36(sp)
a000e284:	8fb00020 	lw	s0,32(sp)
a000e288:	03e00008 	jr	ra
a000e28c:	27bd0048 	addiu	sp,sp,72

a000e290 <check_image>:
#endif

//------------------------------------------------------------------------------------------

int check_image(IMG_HEADER_Tp pHeader,SETTING_HEADER_Tp psetting_header)
{
a000e290:	27bdffc8 	addiu	sp,sp,-56
a000e294:	afbf0034 	sw	ra,52(sp)
a000e298:	afbe0030 	sw	s8,48(sp)
a000e29c:	afb7002c 	sw	s7,44(sp)
a000e2a0:	afb60028 	sw	s6,40(sp)
a000e2a4:	afb50024 	sw	s5,36(sp)
a000e2a8:	afb40020 	sw	s4,32(sp)
a000e2ac:	afb3001c 	sw	s3,28(sp)
a000e2b0:	afb20018 	sw	s2,24(sp)
a000e2b4:	afb10014 	sw	s1,20(sp)
a000e2b8:	afb00010 	sw	s0,16(sp)
a000e2bc:	0080b821 	move	s7,a0
a000e2c0:	00a0f021 	move	s8,a1
a000e2c4:	3c100080 	lui	s0,0x80

#ifdef CONFIG_RTL_FLASH_MAPPING_ENABLE	
	i=CONFIG_LINUX_IMAGE_OFFSET_START;	
	while(i<=CONFIG_LINUX_IMAGE_OFFSET_END && (0==ret))
	{
		return_addr=(unsigned long)FLASH_BASE+i+bank_offset; 
a000e2c8:	3c12a001 	lui	s2,0xa001
		if(CODE_IMAGE_OFFSET == i || CODE_IMAGE_OFFSET2 == i || CODE_IMAGE_OFFSET3 == i){
a000e2cc:	3c130001 	lui	s3,0x1
			i += CONFIG_LINUX_IMAGE_OFFSET_STEP; 
			continue;
		}
		ret = check_system_image((unsigned long)FLASH_BASE+i+bank_offset, pHeader, psetting_header);
a000e2d0:	0000a821 	move	s5,zero
#ifdef CONFIG_RTL_FLASH_MAPPING_ENABLE	
	i=CONFIG_LINUX_IMAGE_OFFSET_START;	
	while(i<=CONFIG_LINUX_IMAGE_OFFSET_END && (0==ret))
	{
		return_addr=(unsigned long)FLASH_BASE+i+bank_offset; 
		if(CODE_IMAGE_OFFSET == i || CODE_IMAGE_OFFSET2 == i || CODE_IMAGE_OFFSET3 == i){
a000e2d4:	3c110002 	lui	s1,0x2
a000e2d8:	3c160003 	lui	s6,0x3
	}			
#endif

#ifdef CONFIG_RTL_FLASH_MAPPING_ENABLE	
	i=CONFIG_LINUX_IMAGE_OFFSET_START;	
	while(i<=CONFIG_LINUX_IMAGE_OFFSET_END && (0==ret))
a000e2dc:	3c140090 	lui	s4,0x90
	{
		return_addr=(unsigned long)FLASH_BASE+i+bank_offset; 
		if(CODE_IMAGE_OFFSET == i || CODE_IMAGE_OFFSET2 == i || CODE_IMAGE_OFFSET3 == i){
a000e2e0:	1213000a 	beq	s0,s3,a000e30c <check_image+0x7c>
a000e2e4:	ae507978 	sw	s0,31096(s2)
a000e2e8:	12110009 	beq	s0,s1,a000e310 <check_image+0x80>
a000e2ec:	02a01021 	move	v0,s5
a000e2f0:	12160007 	beq	s0,s6,a000e310 <check_image+0x80>
a000e2f4:	02002021 	move	a0,s0
			i += CONFIG_LINUX_IMAGE_OFFSET_STEP; 
			continue;
		}
		ret = check_system_image((unsigned long)FLASH_BASE+i+bank_offset, pHeader, psetting_header);
a000e2f8:	02e02821 	move	a1,s7
a000e2fc:	0c0037ef 	jal	a000dfbc <check_system_image>
a000e300:	03c03021 	move	a2,s8
a000e304:	080038c4 	j	a000e310 <check_image+0x80>
a000e308:	00000000 	nop
a000e30c:	02a01021 	move	v0,s5
	}			
#endif

#ifdef CONFIG_RTL_FLASH_MAPPING_ENABLE	
	i=CONFIG_LINUX_IMAGE_OFFSET_START;	
	while(i<=CONFIG_LINUX_IMAGE_OFFSET_END && (0==ret))
a000e310:	12140004 	beq	s0,s4,a000e324 <check_image+0x94>
a000e314:	24030002 	li	v1,2
a000e318:	1040fff1 	beqz	v0,a000e2e0 <check_image+0x50>
a000e31c:	02118021 	addu	s0,s0,s1
		ret = check_system_image((unsigned long)FLASH_BASE+i+bank_offset, pHeader, psetting_header);
		i += CONFIG_LINUX_IMAGE_OFFSET_STEP; 
	}
#endif

	if(ret==2)
a000e320:	24030002 	li	v1,2
a000e324:	14430006 	bne	v0,v1,a000e340 <check_image+0xb0>
a000e328:	8fbf0034 	lw	ra,52(sp)
                	ret=check_rootfs_image((unsigned long)FLASH_BASE+ROOT_FS_OFFSET+ROOT_FS_OFFSET_OP1+ROOT_FS_OFFSET_OP2+bank_offset);
#endif

#ifdef CONFIG_RTL_FLASH_MAPPING_ENABLE
		i = CONFIG_ROOT_IMAGE_OFFSET_START;
		while((i <= CONFIG_ROOT_IMAGE_OFFSET_END) && (0==ret))
a000e32c:	14400005 	bnez	v0,a000e344 <check_image+0xb4>
a000e330:	8fbe0030 	lw	s8,48(sp)
			    (ROOT_FS_OFFSET + ROOT_FS_OFFSET_OP1) == i ||
		            (ROOT_FS_OFFSET + ROOT_FS_OFFSET_OP1 + ROOT_FS_OFFSET_OP2) == i){
				i += CONFIG_ROOT_IMAGE_OFFSET_STEP;
				continue;
			}
			ret = check_rootfs_image((unsigned long)FLASH_BASE+i+bank_offset);
a000e334:	0c00378f 	jal	a000de3c <check_rootfs_image>
a000e338:	3c0400e0 	lui	a0,0xe0
 	#else
       	ret = check_dualbank_setting(IN_BOOTING_MODE);
	#endif
#endif //end of NFBI else
	return ret;
}
a000e33c:	8fbf0034 	lw	ra,52(sp)
a000e340:	8fbe0030 	lw	s8,48(sp)
a000e344:	8fb7002c 	lw	s7,44(sp)
a000e348:	8fb60028 	lw	s6,40(sp)
a000e34c:	8fb50024 	lw	s5,36(sp)
a000e350:	8fb40020 	lw	s4,32(sp)
a000e354:	8fb3001c 	lw	s3,28(sp)
a000e358:	8fb20018 	lw	s2,24(sp)
a000e35c:	8fb10014 	lw	s1,20(sp)
a000e360:	8fb00010 	lw	s0,16(sp)
a000e364:	03e00008 	jr	ra
a000e368:	27bd0038 	addiu	sp,sp,56
a000e36c:	00000000 	nop

a000e370 <__delay>:
//------------------------------------------------------------------------------

__inline__ void
__delay(unsigned long loops)
{
	__asm__ __volatile__ (
a000e370:	1480ffff 	bnez	a0,a000e370 <__delay>
a000e374:	2484ffff 	addiu	a0,a0,-1
		"1:\tbnez\t%0,1b\n\t"
		"subu\t%0,1\n\t"
		".set\treorder"
		:"=r" (loops)
		:"0" (loops));
}
a000e378:	03e00008 	jr	ra
a000e37c:	00000000 	nop

a000e380 <timer_interrupt>:
static void timer_interrupt(int num, void *ptr, struct pt_regs * reg)
{
	//dprintf("jiff=%x\r\n",jiffies);
	//flush_WBcache();
	//rtl_outl(TCIR,rtl_inl(TCIR));
	REG32(TCIR_REG)|=(1<<29);
a000e380:	3c02b800 	lui	v0,0xb800
a000e384:	34423114 	ori	v0,v0,0x3114
a000e388:	8c440000 	lw	a0,0(v0)
a000e38c:	3c032000 	lui	v1,0x2000
a000e390:	00831825 	or	v1,a0,v1
a000e394:	ac430000 	sw	v1,0(v0)

	//if(jiffies==0x80)
	//REG32(GIMR_REG)&= ~(1<<8);
	
	jiffies++;
a000e398:	3c02a002 	lui	v0,0xa002
a000e39c:	8c438960 	lw	v1,-30368(v0)
a000e3a0:	24630001 	addiu	v1,v1,1
a000e3a4:	ac438960 	sw	v1,-30368(v0)


}
a000e3a8:	03e00008 	jr	ra
a000e3ac:	00000000 	nop

a000e3b0 <get_timer_jiffies>:
volatile unsigned int get_timer_jiffies(void)
{

	return jiffies;
a000e3b0:	3c02a002 	lui	v0,0xa002
a000e3b4:	8c428960 	lw	v0,-30368(v0)
};
a000e3b8:	03e00008 	jr	ra
a000e3bc:	00000000 	nop

a000e3c0 <timer_init>:

//------------------------------------------------------------------------------
void timer_init(unsigned long lexra_clock)
{
    /* Set timer mode and Enable timer */
    REG32(TCCNR_REG) = (0<<31) | (0<<30);	//using time0
a000e3c0:	3c02b800 	lui	v0,0xb800
a000e3c4:	34433110 	ori	v1,v0,0x3110
a000e3c8:	ac600000 	sw	zero,0(v1)
    //REG32(TCCNR_REG) = (1<<31) | (0<<30);	//using counter0

	#define DIVISOR     0xE
	#define DIVF_OFFSET                         16		
    REG32(CDBR_REG) = (DIVISOR) << DIVF_OFFSET;
a000e3cc:	34453118 	ori	a1,v0,0x3118
a000e3d0:	3c06000e 	lui	a2,0xe
a000e3d4:	aca60000 	sw	a2,0(a1)
	#define TICK_10MS_FREQ  100  /* 100 Hz */
	#define TICK_1MS_FREQ   1000 /* 1K Hz */
	
	#define TICK_FREQ       TICK_10MS_FREQ	
   
      REG32(TC0DATA_REG) = (((SysClkRate / DIVISOR) / TICK_FREQ) + 1) <<4;
a000e3d8:	3c055d9f 	lui	a1,0x5d9f
a000e3dc:	34a57391 	ori	a1,a1,0x7391
a000e3e0:	00850018 	mult	a0,a1
a000e3e4:	00002810 	mfhi	a1
a000e3e8:	00052a43 	sra	a1,a1,0x9
a000e3ec:	000427c3 	sra	a0,a0,0x1f
a000e3f0:	00a42823 	subu	a1,a1,a0
a000e3f4:	24a50001 	addiu	a1,a1,1
a000e3f8:	00052900 	sll	a1,a1,0x4
a000e3fc:	34443100 	ori	a0,v0,0x3100
a000e400:	ac850000 	sw	a1,0(a0)

         
    /* Set timer mode and Enable timer */
    REG32(TCCNR_REG) = (1<<31) | (1<<30);	//using time0
a000e404:	3c04c000 	lui	a0,0xc000
a000e408:	ac640000 	sw	a0,0(v1)
    //REG32(GIMR_REG) |= (1<<8);	//request_irq() will set 

    /* Set interrupt routing register */
  // RTL8198
    //REG32(IRR1_REG) = 0x00050004;  //uart:IRQ5,  time0:IRQ4
    REG32(IRR1_REG) = 0x02;  
a000e40c:	3443300c 	ori	v1,v0,0x300c
a000e410:	24040002 	li	a0,2
a000e414:	ac640000 	sw	a0,0(v1)
   
    
    /* Enable timer interrupt */
    REG32(TCIR_REG) = (1<<31);
a000e418:	34423114 	ori	v0,v0,0x3114
a000e41c:	3c038000 	lui	v1,0x8000
a000e420:	ac430000 	sw	v1,0(v0)
}
a000e424:	03e00008 	jr	ra
a000e428:	00000000 	nop

a000e42c <rand2>:
    static unsigned int z = 521288629;
    static unsigned int c = 7654321;

    unsigned long long t, a= 698769069;

    x = 69069 * x + 12345;
a000e42c:	3c04a001 	lui	a0,0xa001
a000e430:	8c827938 	lw	v0,31032(a0)
a000e434:	00022880 	sll	a1,v0,0x2
a000e438:	00021900 	sll	v1,v0,0x4
a000e43c:	00a31821 	addu	v1,a1,v1
a000e440:	00032900 	sll	a1,v1,0x4
a000e444:	00a31823 	subu	v1,a1,v1
a000e448:	00621023 	subu	v0,v1,v0
a000e44c:	000218c0 	sll	v1,v0,0x3
a000e450:	00621023 	subu	v0,v1,v0
a000e454:	00021940 	sll	v1,v0,0x5
a000e458:	00431021 	addu	v0,v0,v1
a000e45c:	24423039 	addiu	v0,v0,12345
a000e460:	ac827938 	sw	v0,31032(a0)
    y ^= (y << 13); y ^= (y >> 17); y ^= (y << 5);
a000e464:	3c03a001 	lui	v1,0xa001
a000e468:	8c647934 	lw	a0,31028(v1)
a000e46c:	00043340 	sll	a2,a0,0xd
a000e470:	00c43026 	xor	a2,a2,a0
a000e474:	00062442 	srl	a0,a2,0x11
a000e478:	00863026 	xor	a2,a0,a2
a000e47c:	00062140 	sll	a0,a2,0x5
a000e480:	00863026 	xor	a2,a0,a2
a000e484:	ac667934 	sw	a2,31028(v1)
    t = a * z + c; c = (t >> 32); z = t;
a000e488:	3c07a001 	lui	a3,0xa001
a000e48c:	8ce37930 	lw	v1,31024(a3)
a000e490:	3c0429a6 	lui	a0,0x29a6
a000e494:	34845ead 	ori	a0,a0,0x5ead
a000e498:	00640019 	multu	v1,a0
a000e49c:	00002812 	mflo	a1
a000e4a0:	00002010 	mfhi	a0
a000e4a4:	3c08a001 	lui	t0,0xa001
a000e4a8:	8d03792c 	lw	v1,31020(t0)
a000e4ac:	00a31821 	addu	v1,a1,v1
a000e4b0:	0065482b 	sltu	t1,v1,a1
a000e4b4:	01242021 	addu	a0,t1,a0
a000e4b8:	ad04792c 	sw	a0,31020(t0)
a000e4bc:	ace37930 	sw	v1,31024(a3)
a000e4c0:	00621021 	addu	v0,v1,v0

    return x + y + z;
}
a000e4c4:	03e00008 	jr	ra
a000e4c8:	00461021 	addu	v0,v0,a2

a000e4cc <CmdWriteByte>:
	
}
#endif
//---------------------------------------------------------------------------
int CmdWriteByte( int argc, char* argv[] )
{
a000e4cc:	27bdffd8 	addiu	sp,sp,-40
a000e4d0:	afbf0024 	sw	ra,36(sp)
a000e4d4:	afb30020 	sw	s3,32(sp)
a000e4d8:	afb2001c 	sw	s2,28(sp)
a000e4dc:	afb10018 	sw	s1,24(sp)
a000e4e0:	afb00014 	sw	s0,20(sp)
a000e4e4:	00809821 	move	s3,a0
a000e4e8:	00a09021 	move	s2,a1
	
	unsigned long src;
	unsigned char value,i;
	
	src = strtoul((const char*)(argv[0]), (char **)NULL, 16);		
a000e4ec:	8ca40000 	lw	a0,0(a1)
a000e4f0:	00002821 	move	a1,zero
a000e4f4:	0c0020c4 	jal	a0008310 <strtoul>
a000e4f8:	24060010 	li	a2,16


	for(i=0;i<argc-1;i++,src++)
a000e4fc:	2673ffff 	addiu	s3,s3,-1
a000e500:	1a60000f 	blez	s3,a000e540 <CmdWriteByte+0x74>
a000e504:	00408021 	move	s0,v0
{
	
	unsigned long src;
	unsigned char value,i;
	
	src = strtoul((const char*)(argv[0]), (char **)NULL, 16);		
a000e508:	00008821 	move	s1,zero


	for(i=0;i<argc-1;i++,src++)
	{
		value= strtoul((const char*)(argv[i+1]), (char **)NULL, 16);	
a000e50c:	26310001 	addiu	s1,s1,1
a000e510:	00111080 	sll	v0,s1,0x2
a000e514:	02421021 	addu	v0,s2,v0
a000e518:	8c440000 	lw	a0,0(v0)
a000e51c:	00002821 	move	a1,zero
a000e520:	0c0020c4 	jal	a0008310 <strtoul>
a000e524:	24060010 	li	a2,16
a000e528:	304200ff 	andi	v0,v0,0xff
		*(volatile unsigned char *)(src) = value;
a000e52c:	a2020000 	sb	v0,0(s0)
	unsigned char value,i;
	
	src = strtoul((const char*)(argv[0]), (char **)NULL, 16);		


	for(i=0;i<argc-1;i++,src++)
a000e530:	323100ff 	andi	s1,s1,0xff
a000e534:	0233102a 	slt	v0,s1,s3
a000e538:	1440fff4 	bnez	v0,a000e50c <CmdWriteByte+0x40>
a000e53c:	26100001 	addiu	s0,s0,1
	{
		value= strtoul((const char*)(argv[i+1]), (char **)NULL, 16);	
		*(volatile unsigned char *)(src) = value;
	}
	
}
a000e540:	8fbf0024 	lw	ra,36(sp)
a000e544:	8fb30020 	lw	s3,32(sp)
a000e548:	8fb2001c 	lw	s2,28(sp)
a000e54c:	8fb10018 	lw	s1,24(sp)
a000e550:	8fb00014 	lw	s0,20(sp)
a000e554:	03e00008 	jr	ra
a000e558:	27bd0028 	addiu	sp,sp,40

a000e55c <CmdWriteHword>:
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------

int CmdWriteHword( int argc, char* argv[] )
{
a000e55c:	27bdffd8 	addiu	sp,sp,-40
a000e560:	afbf0024 	sw	ra,36(sp)
a000e564:	afb30020 	sw	s3,32(sp)
a000e568:	afb2001c 	sw	s2,28(sp)
a000e56c:	afb10018 	sw	s1,24(sp)
a000e570:	afb00014 	sw	s0,20(sp)
a000e574:	00809821 	move	s3,a0
a000e578:	00a09021 	move	s2,a1
	
	unsigned long src;
	unsigned short value,i;
	
	src = strtoul((const char*)(argv[0]), (char **)NULL, 16);		
a000e57c:	8ca40000 	lw	a0,0(a1)
a000e580:	00002821 	move	a1,zero
a000e584:	0c0020c4 	jal	a0008310 <strtoul>
a000e588:	24060010 	li	a2,16
	
	src &= 0xfffffffe;	

	for(i=0;i<argc-1;i++,src+=2)
a000e58c:	2673ffff 	addiu	s3,s3,-1
a000e590:	1a600010 	blez	s3,a000e5d4 <CmdWriteHword+0x78>
a000e594:	2410fffe 	li	s0,-2
	unsigned long src;
	unsigned short value,i;
	
	src = strtoul((const char*)(argv[0]), (char **)NULL, 16);		
	
	src &= 0xfffffffe;	
a000e598:	00508024 	and	s0,v0,s0
a000e59c:	00008821 	move	s1,zero

	for(i=0;i<argc-1;i++,src+=2)
	{
		value= strtoul((const char*)(argv[i+1]), (char **)NULL, 16);	
a000e5a0:	26310001 	addiu	s1,s1,1
a000e5a4:	00111080 	sll	v0,s1,0x2
a000e5a8:	02421021 	addu	v0,s2,v0
a000e5ac:	8c440000 	lw	a0,0(v0)
a000e5b0:	00002821 	move	a1,zero
a000e5b4:	0c0020c4 	jal	a0008310 <strtoul>
a000e5b8:	24060010 	li	a2,16
a000e5bc:	3042ffff 	andi	v0,v0,0xffff
		*(volatile unsigned short *)(src) = value;
a000e5c0:	a6020000 	sh	v0,0(s0)
	
	src = strtoul((const char*)(argv[0]), (char **)NULL, 16);		
	
	src &= 0xfffffffe;	

	for(i=0;i<argc-1;i++,src+=2)
a000e5c4:	3231ffff 	andi	s1,s1,0xffff
a000e5c8:	0233102a 	slt	v0,s1,s3
a000e5cc:	1440fff4 	bnez	v0,a000e5a0 <CmdWriteHword+0x44>
a000e5d0:	26100002 	addiu	s0,s0,2
	{
		value= strtoul((const char*)(argv[i+1]), (char **)NULL, 16);	
		*(volatile unsigned short *)(src) = value;
	}
	
}
a000e5d4:	8fbf0024 	lw	ra,36(sp)
a000e5d8:	8fb30020 	lw	s3,32(sp)
a000e5dc:	8fb2001c 	lw	s2,28(sp)
a000e5e0:	8fb10018 	lw	s1,24(sp)
a000e5e4:	8fb00014 	lw	s0,20(sp)
a000e5e8:	03e00008 	jr	ra
a000e5ec:	27bd0028 	addiu	sp,sp,40

a000e5f0 <CmdWriteWord>:
	ddump((unsigned char *)src,len);
}

//---------------------------------------------------------------------------
int CmdWriteWord( int argc, char* argv[] )
{
a000e5f0:	27bdffd8 	addiu	sp,sp,-40
a000e5f4:	afbf0024 	sw	ra,36(sp)
a000e5f8:	afb30020 	sw	s3,32(sp)
a000e5fc:	afb2001c 	sw	s2,28(sp)
a000e600:	afb10018 	sw	s1,24(sp)
a000e604:	afb00014 	sw	s0,20(sp)
a000e608:	00809821 	move	s3,a0
a000e60c:	00a08821 	move	s1,a1
	
	unsigned long src;
	unsigned int value,i;
	
	src = strtoul((const char*)(argv[0]), (char **)NULL, 16);		
a000e610:	8ca40000 	lw	a0,0(a1)
a000e614:	00002821 	move	a1,zero
a000e618:	0c0020c4 	jal	a0008310 <strtoul>
a000e61c:	24060010 	li	a2,16
a000e620:	00408021 	move	s0,v0
	while ( (src) & 0x03)
a000e624:	30420003 	andi	v0,v0,0x3
a000e628:	10400006 	beqz	v0,a000e644 <CmdWriteWord+0x54>
a000e62c:	00000000 	nop
		src++;
a000e630:	26100001 	addiu	s0,s0,1
	
	unsigned long src;
	unsigned int value,i;
	
	src = strtoul((const char*)(argv[0]), (char **)NULL, 16);		
	while ( (src) & 0x03)
a000e634:	32020003 	andi	v0,s0,0x3
a000e638:	1440fffe 	bnez	v0,a000e634 <CmdWriteWord+0x44>
a000e63c:	26100001 	addiu	s0,s0,1
a000e640:	2610ffff 	addiu	s0,s0,-1
		src++;

	for(i=0;i<argc-1;i++,src+=4)
a000e644:	2673ffff 	addiu	s3,s3,-1
a000e648:	1260000b 	beqz	s3,a000e678 <CmdWriteWord+0x88>
a000e64c:	00009021 	move	s2,zero
	{
		value= strtoul((const char*)(argv[i+1]), (char **)NULL, 16);	
a000e650:	26520001 	addiu	s2,s2,1
a000e654:	8e240004 	lw	a0,4(s1)
a000e658:	00002821 	move	a1,zero
a000e65c:	0c0020c4 	jal	a0008310 <strtoul>
a000e660:	24060010 	li	a2,16
		*(volatile unsigned int *)(src) = value;
a000e664:	ae020000 	sw	v0,0(s0)
	
	src = strtoul((const char*)(argv[0]), (char **)NULL, 16);		
	while ( (src) & 0x03)
		src++;

	for(i=0;i<argc-1;i++,src+=4)
a000e668:	26100004 	addiu	s0,s0,4
a000e66c:	0253102b 	sltu	v0,s2,s3
a000e670:	1440fff7 	bnez	v0,a000e650 <CmdWriteWord+0x60>
a000e674:	26310004 	addiu	s1,s1,4
	{
		value= strtoul((const char*)(argv[i+1]), (char **)NULL, 16);	
		*(volatile unsigned int *)(src) = value;
	}
	
}
a000e678:	8fbf0024 	lw	ra,36(sp)
a000e67c:	8fb30020 	lw	s3,32(sp)
a000e680:	8fb2001c 	lw	s2,28(sp)
a000e684:	8fb10018 	lw	s1,24(sp)
a000e688:	8fb00014 	lw	s0,20(sp)
a000e68c:	03e00008 	jr	ra
a000e690:	27bd0028 	addiu	sp,sp,40

a000e694 <CmdNANDR>:
               
}


int CmdNANDR(int argc, char* argv[])
{
a000e694:	27bdffd8 	addiu	sp,sp,-40
a000e698:	afbf0024 	sw	ra,36(sp)
a000e69c:	afb30020 	sw	s3,32(sp)
a000e6a0:	afb2001c 	sw	s2,28(sp)
a000e6a4:	afb10018 	sw	s1,24(sp)
a000e6a8:	afb00014 	sw	s0,20(sp)

    if(argc < 4 )
a000e6ac:	28840004 	slti	a0,a0,4
a000e6b0:	10800006 	beqz	a0,a000e6cc <CmdNANDR+0x38>
a000e6b4:	00a08021 	move	s0,a1
    {
        prom_printf("Parameters not enough!\n");
a000e6b8:	3c04a001 	lui	a0,0xa001
a000e6bc:	0c0023a7 	jal	a0008e9c <prom_printf>
a000e6c0:	248467a0 	addiu	a0,a0,26528
            src, *(unsigned long *)(src), *(unsigned long *)(src+4),
            *(unsigned long *)(src+8), *(unsigned long *)(src+12));
    }
#endif

}
a000e6c4:	080039d2 	j	a000e748 <CmdNANDR+0xb4>
a000e6c8:	24020001 	li	v0,1
        return 1;
    }

                 //rtk_nand_read_id();

    unsigned long flash_address= strtoul((const char*)(argv[0]), (char **)NULL, 16);
a000e6cc:	8ca40000 	lw	a0,0(a1)
a000e6d0:	00002821 	move	a1,zero
a000e6d4:	0c0020c4 	jal	a0008310 <strtoul>
a000e6d8:	24060010 	li	a2,16
a000e6dc:	00408821 	move	s1,v0
    unsigned char *image_addr = strtoul((const char*)(argv[1]), (char **)NULL, 16);
a000e6e0:	8e040004 	lw	a0,4(s0)
a000e6e4:	00002821 	move	a1,zero
a000e6e8:	0c0020c4 	jal	a0008310 <strtoul>
a000e6ec:	24060010 	li	a2,16
a000e6f0:	00409021 	move	s2,v0
    unsigned int image_size= strtoul((const char*)(argv[2]), (char **)NULL, 16);
a000e6f4:	8e040008 	lw	a0,8(s0)
a000e6f8:	00002821 	move	a1,zero
a000e6fc:	0c0020c4 	jal	a0008310 <strtoul>
a000e700:	24060010 	li	a2,16
a000e704:	00409821 	move	s3,v0
    char ecc_enable=strtoul((const char*)(argv[3]), (char **)NULL, 16);
a000e708:	8e04000c 	lw	a0,12(s0)
a000e70c:	00002821 	move	a1,zero
a000e710:	0c0020c4 	jal	a0008310 <strtoul>
a000e714:	24060010 	li	a2,16
a000e718:	00408021 	move	s0,v0

    prom_printf("Read NAND Flash from 0x%X to 0x%X with 0x%X bytes ?\n",flash_address,image_addr,image_size);
a000e71c:	3c04a001 	lui	a0,0xa001
a000e720:	248467b8 	addiu	a0,a0,26552
a000e724:	02202821 	move	a1,s1
a000e728:	02403021 	move	a2,s2
a000e72c:	0c0023a7 	jal	a0008e9c <prom_printf>
a000e730:	02603821 	move	a3,s3
    else
        prom_printf("Read NAND Flash Failed!\n");
    else
        prom_printf("Abort!\n");
#else
    rtk_read_ecc_page (flash_address, image_addr,image_size,ecc_enable);
a000e734:	02202021 	move	a0,s1
a000e738:	02402821 	move	a1,s2
a000e73c:	02603021 	move	a2,s3
a000e740:	0c0013d4 	jal	a0004f50 <rtk_read_ecc_page>
a000e744:	7c103c20 	seb	a3,s0
            src, *(unsigned long *)(src), *(unsigned long *)(src+4),
            *(unsigned long *)(src+8), *(unsigned long *)(src+12));
    }
#endif

}
a000e748:	8fbf0024 	lw	ra,36(sp)
a000e74c:	8fb30020 	lw	s3,32(sp)
a000e750:	8fb2001c 	lw	s2,28(sp)
a000e754:	8fb10018 	lw	s1,24(sp)
a000e758:	8fb00014 	lw	s0,20(sp)
a000e75c:	03e00008 	jr	ra
a000e760:	27bd0028 	addiu	sp,sp,40

a000e764 <CmdNAND_PIO_SINGLE_PAGE_READ>:




int CmdNAND_PIO_SINGLE_PAGE_READ(int argc, char* argv[])
{
a000e764:	27bdffe0 	addiu	sp,sp,-32
a000e768:	afbf001c 	sw	ra,28(sp)
a000e76c:	afb20018 	sw	s2,24(sp)
a000e770:	afb10014 	sw	s1,20(sp)
a000e774:	afb00010 	sw	s0,16(sp)
   if(argc< 3)
a000e778:	28840003 	slti	a0,a0,3
a000e77c:	1080000f 	beqz	a0,a000e7bc <CmdNAND_PIO_SINGLE_PAGE_READ+0x58>
a000e780:	00a08021 	move	s0,a1
   {	 		
		prom_printf("ex:NANDPIOR:<flash_Paddress><enable_page_content>\r\n");
a000e784:	3c04a001 	lui	a0,0xa001
a000e788:	0c0023a7 	jal	a0008e9c <prom_printf>
a000e78c:	248467f0 	addiu	a0,a0,26608
		prom_printf("<flash_Paddress>:NAND Flash's physical address\r\n");
a000e790:	3c04a001 	lui	a0,0xa001
a000e794:	0c0023a7 	jal	a0008e9c <prom_printf>
a000e798:	24846824 	addiu	a0,a0,26660
		prom_printf("<enable_page_content>:<1:show page content><0:show nothing>\r\n");
a000e79c:	3c04a001 	lui	a0,0xa001
a000e7a0:	0c0023a7 	jal	a0008e9c <prom_printf>
a000e7a4:	24846858 	addiu	a0,a0,26712
		prom_printf("<report_bad_block>:<1:report bad block><0:report nothing>\r\n");
a000e7a8:	3c04a001 	lui	a0,0xa001
a000e7ac:	0c0023a7 	jal	a0008e9c <prom_printf>
a000e7b0:	24846898 	addiu	a0,a0,26776
		
	     
		return;	
a000e7b4:	08003a07 	j	a000e81c <CmdNAND_PIO_SINGLE_PAGE_READ+0xb8>
a000e7b8:	8fbf001c 	lw	ra,28(sp)
   }   
 

    unsigned int flash_Paddress_start= strtoul((const char*)(argv[0]), (char **)NULL, 16);
a000e7bc:	8ca40000 	lw	a0,0(a1)
a000e7c0:	00002821 	move	a1,zero
a000e7c4:	0c0020c4 	jal	a0008310 <strtoul>
a000e7c8:	24060010 	li	a2,16
a000e7cc:	00408821 	move	s1,v0
    unsigned int enable_page_content= strtoul((const char*)(argv[1]), (char **)NULL, 16);
a000e7d0:	8e040004 	lw	a0,4(s0)
a000e7d4:	00002821 	move	a1,zero
a000e7d8:	0c0020c4 	jal	a0008310 <strtoul>
a000e7dc:	24060010 	li	a2,16
a000e7e0:	00409021 	move	s2,v0
    unsigned int report_bad_block= strtoul((const char*)(argv[2]), (char **)NULL, 16);
a000e7e4:	8e040008 	lw	a0,8(s0)
a000e7e8:	00002821 	move	a1,zero
a000e7ec:	0c0020c4 	jal	a0008310 <strtoul>
a000e7f0:	24060010 	li	a2,16
a000e7f4:	00408021 	move	s0,v0
  
    //unsigned int length= strtoul((const char*)(argv[1]), (char **)NULL, 16);  
 

    prom_printf("NAND flash PIO read from flash_Paddress 0x%X \n",flash_Paddress_start);
a000e7f8:	3c04a001 	lui	a0,0xa001
a000e7fc:	248468d4 	addiu	a0,a0,26836
a000e800:	0c0023a7 	jal	a0008e9c <prom_printf>
a000e804:	02202821 	move	a1,s1
   //{                 
   //NAND_Erase_Block_times=block_end_num-block_start_num; 
#if (defined(CONFIG_NAND_Flash_Small_Page_32MB_3cycles) || defined(CONFIG_NAND_Flash_Small_Page_64MB_4cycles))
       rtk_PIO_read_page (flash_Paddress_start,enable_page_content,report_bad_block);   //JSW 1block= 32(0x20) pages
#else
       rtk_PIO_read_page (flash_Paddress_start,enable_page_content,report_bad_block);   //JSW 1block= 64(0x40) pages
a000e808:	02202021 	move	a0,s1
a000e80c:	02402821 	move	a1,s2
a000e810:	0c001932 	jal	a00064c8 <rtk_PIO_read_page>
a000e814:	02003021 	move	a2,s0
#endif    
//   }

               
}
a000e818:	8fbf001c 	lw	ra,28(sp)
a000e81c:	8fb20018 	lw	s2,24(sp)
a000e820:	8fb10014 	lw	s1,20(sp)
a000e824:	8fb00010 	lw	s0,16(sp)
a000e828:	03e00008 	jr	ra
a000e82c:	27bd0020 	addiu	sp,sp,32

a000e830 <CmdNANDID>:
#endif

#if defined (CONFIG_NAND_FLASH) ||(CONFIG_NAND_FLASH_BOOTING)

int CmdNANDID(int argc, char* argv[])
{
a000e830:	27bdffe8 	addiu	sp,sp,-24
a000e834:	afbf0014 	sw	ra,20(sp)

    //rtk_nand_read_id();

    rtk_nand_probe();
a000e838:	0c0019cd 	jal	a0006734 <rtk_nand_probe>
a000e83c:	00000000 	nop
}
a000e840:	8fbf0014 	lw	ra,20(sp)
a000e844:	03e00008 	jr	ra
a000e848:	27bd0018 	addiu	sp,sp,24

a000e84c <CmdHelp>:
};


//==============================================================================
int CmdHelp( int argc, char* argv[] )
{
a000e84c:	27bdffd8 	addiu	sp,sp,-40
a000e850:	afbf0024 	sw	ra,36(sp)
a000e854:	afb30020 	sw	s3,32(sp)
a000e858:	afb2001c 	sw	s2,28(sp)
a000e85c:	afb10018 	sw	s1,24(sp)
a000e860:	afb00014 	sw	s0,20(sp)
	int	i ;

    printf("----------------- COMMAND MODE HELP ------------------\n");
a000e864:	3c04a001 	lui	a0,0xa001
a000e868:	0c002325 	jal	a0008c94 <dprintf>
a000e86c:	24846904 	addiu	a0,a0,26884
a000e870:	3c10a001 	lui	s0,0xa001
a000e874:	261076a8 	addiu	s0,s0,30376
#endif
};


//==============================================================================
int CmdHelp( int argc, char* argv[] )
a000e878:	3c11a001 	lui	s1,0xa001
a000e87c:	26317938 	addiu	s1,s1,31032
    printf("----------------- COMMAND MODE HELP ------------------\n");
	for( i=0  ; i < (sizeof(MainCmdTable) / sizeof(COMMAND_TABLE)) ; i++ )
	{
		if( MainCmdTable[i].msg )
		{
			printf( "%s\n", MainCmdTable[i].msg );
a000e880:	3c12a001 	lui	s2,0xa001
a000e884:	265345f8 	addiu	s3,s2,17912
	int	i ;

    printf("----------------- COMMAND MODE HELP ------------------\n");
	for( i=0  ; i < (sizeof(MainCmdTable) / sizeof(COMMAND_TABLE)) ; i++ )
	{
		if( MainCmdTable[i].msg )
a000e888:	8e050000 	lw	a1,0(s0)
a000e88c:	10a00003 	beqz	a1,a000e89c <CmdHelp+0x50>
a000e890:	00000000 	nop
		{
			printf( "%s\n", MainCmdTable[i].msg );
a000e894:	0c002325 	jal	a0008c94 <dprintf>
a000e898:	02602021 	move	a0,s3
a000e89c:	26100010 	addiu	s0,s0,16
int CmdHelp( int argc, char* argv[] )
{
	int	i ;

    printf("----------------- COMMAND MODE HELP ------------------\n");
	for( i=0  ; i < (sizeof(MainCmdTable) / sizeof(COMMAND_TABLE)) ; i++ )
a000e8a0:	1611fff9 	bne	s0,s1,a000e888 <CmdHelp+0x3c>
a000e8a4:	24020001 	li	v0,1
		}
	}
	/*Cyrus Tsai*/
    
	return TRUE ;
}
a000e8a8:	8fbf0024 	lw	ra,36(sp)
a000e8ac:	8fb30020 	lw	s3,32(sp)
a000e8b0:	8fb2001c 	lw	s2,28(sp)
a000e8b4:	8fb10018 	lw	s1,24(sp)
a000e8b8:	8fb00014 	lw	s0,20(sp)
a000e8bc:	03e00008 	jr	ra
a000e8c0:	27bd0028 	addiu	sp,sp,40

a000e8c4 <CmdLoad>:
#endif


//---------------------------------------------------------------------------
int CmdLoad(int argc, char* argv[])
{
a000e8c4:	27bdffe8 	addiu	sp,sp,-24
a000e8c8:	afbf0014 	sw	ra,20(sp)
	unsigned long addr;

	if(argc < 1) 
a000e8cc:	1c800007 	bgtz	a0,a000e8ec <CmdLoad+0x28>
a000e8d0:	3c04a001 	lui	a0,0xa001
	{
		printf("TFTP Load Addr 0x%x\n",image_address);
a000e8d4:	24846940 	addiu	a0,a0,26944
a000e8d8:	3c02a001 	lui	v0,0xa001
a000e8dc:	0c002325 	jal	a0008c94 <dprintf>
a000e8e0:	8c457218 	lw	a1,29208(v0)
	}

	
	image_address= strtoul((const char*)(argv[0]), (char **)NULL, 16);		
	printf("Set TFTP Load Addr 0x%x\n",image_address);
}
a000e8e4:	08003a45 	j	a000e914 <CmdLoad+0x50>
a000e8e8:	24020001 	li	v0,1
		printf("TFTP Load Addr 0x%x\n",image_address);
		return 1;
	}

	
	image_address= strtoul((const char*)(argv[0]), (char **)NULL, 16);		
a000e8ec:	8ca40000 	lw	a0,0(a1)
a000e8f0:	00002821 	move	a1,zero
a000e8f4:	0c0020c4 	jal	a0008310 <strtoul>
a000e8f8:	24060010 	li	a2,16
a000e8fc:	3c03a001 	lui	v1,0xa001
a000e900:	ac627218 	sw	v0,29208(v1)
	printf("Set TFTP Load Addr 0x%x\n",image_address);
a000e904:	3c04a001 	lui	a0,0xa001
a000e908:	2484693c 	addiu	a0,a0,26940
a000e90c:	0c002325 	jal	a0008c94 <dprintf>
a000e910:	00402821 	move	a1,v0
}
a000e914:	8fbf0014 	lw	ra,20(sp)
a000e918:	03e00008 	jr	ra
a000e91c:	27bd0018 	addiu	sp,sp,24

a000e920 <CmdAuto>:

//---------------------------------------------------------------------------
#ifndef RTL8197B
extern int autoBurn;
int CmdAuto(int argc, char* argv[])
{
a000e920:	27bdffe8 	addiu	sp,sp,-24
a000e924:	afbf0014 	sw	ra,20(sp)
	unsigned long addr;


	if(argv[0][0] == '0')
a000e928:	8ca20000 	lw	v0,0(a1)
a000e92c:	80430000 	lb	v1,0(v0)
a000e930:	24020030 	li	v0,48
a000e934:	14620004 	bne	v1,v0,a000e948 <CmdAuto+0x28>
a000e938:	24030001 	li	v1,1
		autoBurn = 0 ;
a000e93c:	3c02a001 	lui	v0,0xa001
a000e940:	08003a54 	j	a000e950 <CmdAuto+0x30>
a000e944:	ac4072c4 	sw	zero,29380(v0)
	else
		autoBurn = 1 ;
a000e948:	3c02a001 	lui	v0,0xa001
a000e94c:	ac4372c4 	sw	v1,29380(v0)
	printf("AutoBurning=%d\n",autoBurn);
a000e950:	3c04a001 	lui	a0,0xa001
a000e954:	24846958 	addiu	a0,a0,26968
a000e958:	3c02a001 	lui	v0,0xa001
a000e95c:	0c002325 	jal	a0008c94 <dprintf>
a000e960:	8c4572c4 	lw	a1,29380(v0)
}
a000e964:	8fbf0014 	lw	ra,20(sp)
a000e968:	03e00008 	jr	ra
a000e96c:	27bd0018 	addiu	sp,sp,24

a000e970 <CmdCmp>:
		*(volatile unsigned char *)(src) = value;
	}
	
}
int CmdCmp(int argc, char* argv[])
{
a000e970:	27bdffd0 	addiu	sp,sp,-48
a000e974:	afbf002c 	sw	ra,44(sp)
a000e978:	afb50028 	sw	s5,40(sp)
a000e97c:	afb40024 	sw	s4,36(sp)
a000e980:	afb30020 	sw	s3,32(sp)
a000e984:	afb2001c 	sw	s2,28(sp)
a000e988:	afb10018 	sw	s1,24(sp)
a000e98c:	afb00014 	sw	s0,20(sp)
	unsigned long dst,src;
	unsigned long dst_value, src_value;
	unsigned int length;
	unsigned long error;

	if(argc < 3) {
a000e990:	28840003 	slti	a0,a0,3
a000e994:	10800006 	beqz	a0,a000e9b0 <CmdCmp+0x40>
a000e998:	00a08021 	move	s0,a1
		printf("Parameters not enough!\n");
a000e99c:	3c04a001 	lui	a0,0xa001
a000e9a0:	0c002325 	jal	a0008c94 <dprintf>
a000e9a4:	248467a0 	addiu	a0,a0,26528
		}
	}
	if(!error)
		printf("No error found\n");

}
a000e9a8:	08003a95 	j	a000ea54 <CmdCmp+0xe4>
a000e9ac:	24020001 	li	v0,1

	if(argc < 3) {
		printf("Parameters not enough!\n");
		return 1;
	}
	dst = strtoul((const char*)(argv[0]), (char **)NULL, 16);
a000e9b0:	8ca40000 	lw	a0,0(a1)
a000e9b4:	00002821 	move	a1,zero
a000e9b8:	0c0020c4 	jal	a0008310 <strtoul>
a000e9bc:	24060010 	li	a2,16
a000e9c0:	00409021 	move	s2,v0
	src = strtoul((const char*)(argv[1]), (char **)NULL, 16);
a000e9c4:	8e040004 	lw	a0,4(s0)
a000e9c8:	00002821 	move	a1,zero
a000e9cc:	0c0020c4 	jal	a0008310 <strtoul>
a000e9d0:	24060010 	li	a2,16
a000e9d4:	00409821 	move	s3,v0
	length= strtoul((const char*)(argv[2]), (char **)NULL, 16);		
a000e9d8:	8e040008 	lw	a0,8(s0)
a000e9dc:	00002821 	move	a1,zero
a000e9e0:	0c0020c4 	jal	a0008310 <strtoul>
a000e9e4:	24060010 	li	a2,16
	error = 0;
	for(i=0;i<length;i+=4) {
a000e9e8:	10400017 	beqz	v0,a000ea48 <CmdCmp+0xd8>
a000e9ec:	00408821 	move	s1,v0
a000e9f0:	00001021 	move	v0,zero
a000e9f4:	00002021 	move	a0,zero
a000e9f8:	00008021 	move	s0,zero
		dst_value = *(volatile unsigned int *)(dst+i);
		src_value = *(volatile unsigned int *)(src+i);
		if(dst_value != src_value) {		
			printf("%dth data(%x %x) error\n",i, dst_value, src_value);
a000e9fc:	3c14a001 	lui	s4,0xa001
a000ea00:	26946968 	addiu	s4,s4,26984
a000ea04:	24150001 	li	s5,1
	dst = strtoul((const char*)(argv[0]), (char **)NULL, 16);
	src = strtoul((const char*)(argv[1]), (char **)NULL, 16);
	length= strtoul((const char*)(argv[2]), (char **)NULL, 16);		
	error = 0;
	for(i=0;i<length;i+=4) {
		dst_value = *(volatile unsigned int *)(dst+i);
a000ea08:	00521821 	addu	v1,v0,s2
a000ea0c:	8c660000 	lw	a2,0(v1)
		src_value = *(volatile unsigned int *)(src+i);
a000ea10:	00531021 	addu	v0,v0,s3
a000ea14:	8c470000 	lw	a3,0(v0)
		if(dst_value != src_value) {		
a000ea18:	10c70005 	beq	a2,a3,a000ea30 <CmdCmp+0xc0>
a000ea1c:	00000000 	nop
			printf("%dth data(%x %x) error\n",i, dst_value, src_value);
a000ea20:	02802021 	move	a0,s4
a000ea24:	0c002325 	jal	a0008c94 <dprintf>
a000ea28:	02002821 	move	a1,s0
a000ea2c:	02a02021 	move	a0,s5
	}
	dst = strtoul((const char*)(argv[0]), (char **)NULL, 16);
	src = strtoul((const char*)(argv[1]), (char **)NULL, 16);
	length= strtoul((const char*)(argv[2]), (char **)NULL, 16);		
	error = 0;
	for(i=0;i<length;i+=4) {
a000ea30:	26100004 	addiu	s0,s0,4
a000ea34:	0211182b 	sltu	v1,s0,s1
a000ea38:	1460fff3 	bnez	v1,a000ea08 <CmdCmp+0x98>
a000ea3c:	02001021 	move	v0,s0
		if(dst_value != src_value) {		
			printf("%dth data(%x %x) error\n",i, dst_value, src_value);
			error = 1;
		}
	}
	if(!error)
a000ea40:	14800005 	bnez	a0,a000ea58 <CmdCmp+0xe8>
a000ea44:	8fbf002c 	lw	ra,44(sp)
		printf("No error found\n");
a000ea48:	3c04a001 	lui	a0,0xa001
a000ea4c:	0c002325 	jal	a0008c94 <dprintf>
a000ea50:	24846980 	addiu	a0,a0,27008

}
a000ea54:	8fbf002c 	lw	ra,44(sp)
a000ea58:	8fb50028 	lw	s5,40(sp)
a000ea5c:	8fb40024 	lw	s4,36(sp)
a000ea60:	8fb30020 	lw	s3,32(sp)
a000ea64:	8fb2001c 	lw	s2,28(sp)
a000ea68:	8fb10018 	lw	s1,24(sp)
a000ea6c:	8fb00014 	lw	s0,20(sp)
a000ea70:	03e00008 	jr	ra
a000ea74:	27bd0030 	addiu	sp,sp,48

a000ea78 <CmdDumpWord>:
	prom_printf("Now your Host IP is %d.%d.%d.%d\n", ip[0],ip[1],ip[2],ip[3]);
#endif	
		
}	
int CmdDumpWord( int argc, char* argv[] )
{
a000ea78:	27bdffd0 	addiu	sp,sp,-48
a000ea7c:	afbf002c 	sw	ra,44(sp)
a000ea80:	afb30028 	sw	s3,40(sp)
a000ea84:	afb20024 	sw	s2,36(sp)
a000ea88:	afb10020 	sw	s1,32(sp)
a000ea8c:	afb0001c 	sw	s0,28(sp)
	
	unsigned long src;
	unsigned int len,i;

	if(argc<1)
a000ea90:	1c800006 	bgtz	a0,a000eaac <CmdDumpWord+0x34>
a000ea94:	00a08821 	move	s1,a1
	{	dprintf("Wrong argument number!\r\n");
a000ea98:	3c04a001 	lui	a0,0xa001
a000ea9c:	0c002325 	jal	a0008c94 <dprintf>
a000eaa0:	24846990 	addiu	a0,a0,27024
		return;
a000eaa4:	08003adc 	j	a000eb70 <CmdDumpWord+0xf8>
a000eaa8:	8fbf002c 	lw	ra,44(sp)
	}
	
	if(argv[0])	
a000eaac:	8ca40000 	lw	a0,0(a1)
a000eab0:	10800009 	beqz	a0,a000ead8 <CmdDumpWord+0x60>
a000eab4:	00000000 	nop
	{	src = strtoul((const char*)(argv[0]), (char **)NULL, 16);
a000eab8:	00002821 	move	a1,zero
a000eabc:	0c0020c4 	jal	a0008310 <strtoul>
a000eac0:	24060010 	li	a2,16
		if(src <0x80000000)
a000eac4:	04400009 	bltz	v0,a000eaec <CmdDumpWord+0x74>
a000eac8:	00408021 	move	s0,v0
			src|=0x80000000;
a000eacc:	3c028000 	lui	v0,0x8000
a000ead0:	08003abb 	j	a000eaec <CmdDumpWord+0x74>
a000ead4:	02028025 	or	s0,s0,v0
	}
	else
	{	dprintf("Wrong argument number!\r\n");
a000ead8:	3c04a001 	lui	a0,0xa001
a000eadc:	0c002325 	jal	a0008c94 <dprintf>
a000eae0:	24846990 	addiu	a0,a0,27024
		return;		
a000eae4:	08003adc 	j	a000eb70 <CmdDumpWord+0xf8>
a000eae8:	8fbf002c 	lw	ra,44(sp)
	}
				
	if(!argv[1])
a000eaec:	8e240004 	lw	a0,4(s1)
a000eaf0:	10800005 	beqz	a0,a000eb08 <CmdDumpWord+0x90>
a000eaf4:	24120001 	li	s2,1
		len = 1;
	else
	len= strtoul((const char*)(argv[1]), (char **)NULL, 10);			
a000eaf8:	00002821 	move	a1,zero
a000eafc:	0c0020c4 	jal	a0008310 <strtoul>
a000eb00:	2406000a 	li	a2,10
a000eb04:	00409021 	move	s2,v0
	while ( (src) & 0x03)
a000eb08:	32020003 	andi	v0,s0,0x3
a000eb0c:	10400006 	beqz	v0,a000eb28 <CmdDumpWord+0xb0>
a000eb10:	00000000 	nop
		src++;
a000eb14:	26100001 	addiu	s0,s0,1
				
	if(!argv[1])
		len = 1;
	else
	len= strtoul((const char*)(argv[1]), (char **)NULL, 10);			
	while ( (src) & 0x03)
a000eb18:	32020003 	andi	v0,s0,0x3
a000eb1c:	1440fffe 	bnez	v0,a000eb18 <CmdDumpWord+0xa0>
a000eb20:	26100001 	addiu	s0,s0,1
a000eb24:	2610ffff 	addiu	s0,s0,-1
		src++;

	for(i=0; i< len ; i+=4,src+=16)
a000eb28:	12400010 	beqz	s2,a000eb6c <CmdDumpWord+0xf4>
a000eb2c:	00008821 	move	s1,zero
	{	
		dprintf("%08X:	%08X	%08X	%08X	%08X\n",
a000eb30:	3c13a001 	lui	s3,0xa001
a000eb34:	267369ac 	addiu	s3,s3,27052
a000eb38:	8e060000 	lw	a2,0(s0)
a000eb3c:	8e070004 	lw	a3,4(s0)
a000eb40:	8e020008 	lw	v0,8(s0)
a000eb44:	afa20010 	sw	v0,16(sp)
a000eb48:	8e02000c 	lw	v0,12(s0)
a000eb4c:	afa20014 	sw	v0,20(sp)
a000eb50:	02602021 	move	a0,s3
a000eb54:	0c002325 	jal	a0008c94 <dprintf>
a000eb58:	02002821 	move	a1,s0
	else
	len= strtoul((const char*)(argv[1]), (char **)NULL, 10);			
	while ( (src) & 0x03)
		src++;

	for(i=0; i< len ; i+=4,src+=16)
a000eb5c:	26310004 	addiu	s1,s1,4
a000eb60:	0232102b 	sltu	v0,s1,s2
a000eb64:	1440fff4 	bnez	v0,a000eb38 <CmdDumpWord+0xc0>
a000eb68:	26100010 	addiu	s0,s0,16
		dprintf("%08X:	%08X	%08X	%08X	%08X\n",
		src, *(unsigned long *)(src), *(unsigned long *)(src+4), 
		*(unsigned long *)(src+8), *(unsigned long *)(src+12));
	}

}
a000eb6c:	8fbf002c 	lw	ra,44(sp)
a000eb70:	8fb30028 	lw	s3,40(sp)
a000eb74:	8fb20024 	lw	s2,36(sp)
a000eb78:	8fb10020 	lw	s1,32(sp)
a000eb7c:	8fb0001c 	lw	s0,28(sp)
a000eb80:	03e00008 	jr	ra
a000eb84:	27bd0030 	addiu	sp,sp,48

a000eb88 <YesOrNo>:

//---------------------------------------------------------------------------


int YesOrNo(void)
{
a000eb88:	27bdffe0 	addiu	sp,sp,-32
a000eb8c:	afbf001c 	sw	ra,28(sp)
	unsigned char iChar[2];

	GetLine( iChar, 2,1);
a000eb90:	27a40010 	addiu	a0,sp,16
a000eb94:	24050002 	li	a1,2
a000eb98:	0c002193 	jal	a000864c <GetLine>
a000eb9c:	24060001 	li	a2,1
	printf("\n");//vicadd
a000eba0:	3c04a001 	lui	a0,0xa001
a000eba4:	0c002325 	jal	a0008c94 <dprintf>
a000eba8:	248457b8 	addiu	a0,a0,22456
	if ((iChar[0] == 'Y') || (iChar[0] == 'y'))
a000ebac:	93a30010 	lbu	v1,16(sp)
a000ebb0:	24040059 	li	a0,89
a000ebb4:	10640003 	beq	v1,a0,a000ebc4 <YesOrNo+0x3c>
a000ebb8:	24020001 	li	v0,1
a000ebbc:	38620079 	xori	v0,v1,0x79
a000ebc0:	2c420001 	sltiu	v0,v0,1
		return 1;
	else
		return 0;
}
a000ebc4:	8fbf001c 	lw	ra,28(sp)
a000ebc8:	03e00008 	jr	ra
a000ebcc:	27bd0020 	addiu	sp,sp,32

a000ebd0 <CmdNANDBadBlockDetect>:

}


int  CmdNANDBadBlockDetect(int argc, char* argv[])
{
a000ebd0:	27bdffe0 	addiu	sp,sp,-32
a000ebd4:	afbf001c 	sw	ra,28(sp)
a000ebd8:	afb10018 	sw	s1,24(sp)
a000ebdc:	afb00014 	sw	s0,20(sp)
	 if(argc < 2 )
a000ebe0:	28840002 	slti	a0,a0,2
a000ebe4:	10800006 	beqz	a0,a000ec00 <CmdNANDBadBlockDetect+0x30>
a000ebe8:	00a08021 	move	s0,a1
    {
        prom_printf("Parameters not enough!\n");
a000ebec:	3c04a001 	lui	a0,0xa001
a000ebf0:	0c0023a7 	jal	a0008e9c <prom_printf>
a000ebf4:	248467a0 	addiu	a0,a0,26528
    else
    {
        prom_printf("Abort!\n");
    }

}
a000ebf8:	08003b1e 	j	a000ec78 <CmdNANDBadBlockDetect+0xa8>
a000ebfc:	24020001 	li	v0,1

    //unsigned long flash_address= strtoul((const char*)(argv[0]), (char **)NULL, 16);
    //unsigned char *image_addr = strtoul((const char*)(argv[1]), (char **)NULL, 16);
    //unsigned int image_size= strtoul((const char*)(argv[2]), (char **)NULL, 16);

   unsigned int block_start_cnt= strtoul((const char*)(argv[0]), (char **)NULL, 16);
a000ec00:	8ca40000 	lw	a0,0(a1)
a000ec04:	00002821 	move	a1,zero
a000ec08:	0c0020c4 	jal	a0008310 <strtoul>
a000ec0c:	24060010 	li	a2,16
a000ec10:	00408821 	move	s1,v0

   unsigned int block_end_cnt= strtoul((const char*)(argv[1]), (char **)NULL, 16);
a000ec14:	8e040004 	lw	a0,4(s0)
a000ec18:	00002821 	move	a1,zero
a000ec1c:	0c0020c4 	jal	a0008310 <strtoul>
a000ec20:	24060010 	li	a2,16
a000ec24:	00408021 	move	s0,v0

    prom_printf("NAND flash bad block detect from block:0x%X to block:0x%X ?\n",block_start_cnt,block_end_cnt);
a000ec28:	3c04a001 	lui	a0,0xa001
a000ec2c:	248469c8 	addiu	a0,a0,27080
a000ec30:	02202821 	move	a1,s1
a000ec34:	0c0023a7 	jal	a0008e9c <prom_printf>
a000ec38:	00403021 	move	a2,v0
    prom_printf("(Y)es, (N)o->");
a000ec3c:	3c04a001 	lui	a0,0xa001
a000ec40:	0c0023a7 	jal	a0008e9c <prom_printf>
a000ec44:	24846a08 	addiu	a0,a0,27144
   if (YesOrNo())
a000ec48:	0c003ae2 	jal	a000eb88 <YesOrNo>
a000ec4c:	00000000 	nop
a000ec50:	10400006 	beqz	v0,a000ec6c <CmdNANDBadBlockDetect+0x9c>
a000ec54:	00000000 	nop
    {
        isBadBlock(block_start_cnt,block_end_cnt);     
a000ec58:	02202021 	move	a0,s1
a000ec5c:	0c000fe5 	jal	a0003f94 <isBadBlock>
a000ec60:	02002821 	move	a1,s0
    else
    {
        prom_printf("Abort!\n");
    }

}
a000ec64:	08003b1f 	j	a000ec7c <CmdNANDBadBlockDetect+0xac>
a000ec68:	8fbf001c 	lw	ra,28(sp)
    {
        isBadBlock(block_start_cnt,block_end_cnt);     
    }
    else
    {
        prom_printf("Abort!\n");
a000ec6c:	3c04a001 	lui	a0,0xa001
a000ec70:	0c0023a7 	jal	a0008e9c <prom_printf>
a000ec74:	24846a18 	addiu	a0,a0,27160
    }

}
a000ec78:	8fbf001c 	lw	ra,28(sp)
a000ec7c:	8fb10018 	lw	s1,24(sp)
a000ec80:	8fb00014 	lw	s0,20(sp)
a000ec84:	03e00008 	jr	ra
a000ec88:	27bd0020 	addiu	sp,sp,32

a000ec8c <CmdNANDW>:

}


int CmdNANDW(int argc, char* argv[])
{
a000ec8c:	27bdffe0 	addiu	sp,sp,-32
a000ec90:	afbf001c 	sw	ra,28(sp)
a000ec94:	afb20018 	sw	s2,24(sp)
a000ec98:	afb10014 	sw	s1,20(sp)
a000ec9c:	afb00010 	sw	s0,16(sp)

    if(argc <3 )
a000eca0:	28840003 	slti	a0,a0,3
a000eca4:	10800006 	beqz	a0,a000ecc0 <CmdNANDW+0x34>
a000eca8:	00a08021 	move	s0,a1
    {
        prom_printf("Parameters not enough!\n");
a000ecac:	3c04a001 	lui	a0,0xa001
a000ecb0:	0c0023a7 	jal	a0008e9c <prom_printf>
a000ecb4:	248467a0 	addiu	a0,a0,26528
    else
    {
        prom_printf("Abort!\n");
    }

}
a000ecb8:	08003b54 	j	a000ed50 <CmdNANDW+0xc4>
a000ecbc:	24020001 	li	v0,1
    {
        prom_printf("Parameters not enough!\n");
        return 1;
    }

    unsigned long flash_address= strtoul((const char*)(argv[0]), (char **)NULL, 16);
a000ecc0:	8ca40000 	lw	a0,0(a1)
a000ecc4:	00002821 	move	a1,zero
a000ecc8:	0c0020c4 	jal	a0008310 <strtoul>
a000eccc:	24060010 	li	a2,16
a000ecd0:	00408821 	move	s1,v0
    unsigned char *image_addr = strtoul((const char*)(argv[1]), (char **)NULL, 16);
a000ecd4:	8e040004 	lw	a0,4(s0)
a000ecd8:	00002821 	move	a1,zero
a000ecdc:	0c0020c4 	jal	a0008310 <strtoul>
a000ece0:	24060010 	li	a2,16
a000ece4:	00409021 	move	s2,v0
    unsigned int image_size= strtoul((const char*)(argv[2]), (char **)NULL, 16);
a000ece8:	8e040008 	lw	a0,8(s0)
a000ecec:	00002821 	move	a1,zero
a000ecf0:	0c0020c4 	jal	a0008310 <strtoul>
a000ecf4:	24060010 	li	a2,16
a000ecf8:	00408021 	move	s0,v0

    prom_printf("Program NAND flash addr %X from %X with %X bytes ?\n",flash_address,image_addr,image_size);
a000ecfc:	3c04a001 	lui	a0,0xa001
a000ed00:	24846a20 	addiu	a0,a0,27168
a000ed04:	02202821 	move	a1,s1
a000ed08:	02403021 	move	a2,s2
a000ed0c:	0c0023a7 	jal	a0008e9c <prom_printf>
a000ed10:	00403821 	move	a3,v0
    prom_printf("(Y)es, (N)o->");
a000ed14:	3c04a001 	lui	a0,0xa001
a000ed18:	0c0023a7 	jal	a0008e9c <prom_printf>
a000ed1c:	24846a08 	addiu	a0,a0,27144
   if (YesOrNo())
a000ed20:	0c003ae2 	jal	a000eb88 <YesOrNo>
a000ed24:	00000000 	nop
a000ed28:	10400006 	beqz	v0,a000ed44 <CmdNANDW+0xb8>
a000ed2c:	02402821 	move	a1,s2
    {
        rtk_write_ecc_page (flash_address,image_addr, image_size);       
a000ed30:	02202021 	move	a0,s1
a000ed34:	0c0014a4 	jal	a0005290 <rtk_write_ecc_page>
a000ed38:	02003021 	move	a2,s0
    else
    {
        prom_printf("Abort!\n");
    }

}
a000ed3c:	08003b55 	j	a000ed54 <CmdNANDW+0xc8>
a000ed40:	8fbf001c 	lw	ra,28(sp)
    {
        rtk_write_ecc_page (flash_address,image_addr, image_size);       
    }
    else
    {
        prom_printf("Abort!\n");
a000ed44:	3c04a001 	lui	a0,0xa001
a000ed48:	0c0023a7 	jal	a0008e9c <prom_printf>
a000ed4c:	24846a18 	addiu	a0,a0,27160
    }

}
a000ed50:	8fbf001c 	lw	ra,28(sp)
a000ed54:	8fb20018 	lw	s2,24(sp)
a000ed58:	8fb10014 	lw	s1,20(sp)
a000ed5c:	8fb00010 	lw	s0,16(sp)
a000ed60:	03e00008 	jr	ra
a000ed64:	27bd0020 	addiu	sp,sp,32

a000ed68 <CmdNAND_PIO_WRITE>:




int CmdNAND_PIO_WRITE(int argc, char* argv[])
{
a000ed68:	27bdffd8 	addiu	sp,sp,-40
a000ed6c:	afbf0024 	sw	ra,36(sp)
a000ed70:	afb30020 	sw	s3,32(sp)
a000ed74:	afb2001c 	sw	s2,28(sp)
a000ed78:	afb10018 	sw	s1,24(sp)
a000ed7c:	afb00014 	sw	s0,20(sp)
   if(argc< 3)
a000ed80:	28840003 	slti	a0,a0,3
a000ed84:	1080000f 	beqz	a0,a000edc4 <CmdNAND_PIO_WRITE+0x5c>
a000ed88:	00a09021 	move	s2,a1
   {	 		
		prom_printf("ex:CmdNAND_PIO_WRITE:<flash_Paddress><image_addr><image_size>\r\n");
a000ed8c:	3c04a001 	lui	a0,0xa001
a000ed90:	0c0023a7 	jal	a0008e9c <prom_printf>
a000ed94:	24846a54 	addiu	a0,a0,27220
		prom_printf("<flash_Paddress>:NAND Flash's physical address\r\n");
a000ed98:	3c04a001 	lui	a0,0xa001
a000ed9c:	0c0023a7 	jal	a0008e9c <prom_printf>
a000eda0:	24846824 	addiu	a0,a0,26660
		prom_printf("<image_addr>:source data\r\n");
a000eda4:	3c04a001 	lui	a0,0xa001
a000eda8:	0c0023a7 	jal	a0008e9c <prom_printf>
a000edac:	24846a94 	addiu	a0,a0,27284
		prom_printf("<image_size>:data length\r\n");		
a000edb0:	3c04a001 	lui	a0,0xa001
a000edb4:	0c0023a7 	jal	a0008e9c <prom_printf>
a000edb8:	24846ab0 	addiu	a0,a0,27312
	     
		return;	
a000edbc:	08003b9d 	j	a000ee74 <CmdNAND_PIO_WRITE+0x10c>
a000edc0:	8fbf0024 	lw	ra,36(sp)
   }   
 

    unsigned int flash_Paddress_start= strtoul((const char*)(argv[0]), (char **)NULL, 16);
a000edc4:	8ca40000 	lw	a0,0(a1)
a000edc8:	00002821 	move	a1,zero
a000edcc:	0c0020c4 	jal	a0008310 <strtoul>
a000edd0:	24060010 	li	a2,16
a000edd4:	00408021 	move	s0,v0
    unsigned int image_addr= strtoul((const char*)(argv[1]), (char **)NULL, 16);
a000edd8:	8e440004 	lw	a0,4(s2)
a000eddc:	00002821 	move	a1,zero
a000ede0:	0c0020c4 	jal	a0008310 <strtoul>
a000ede4:	24060010 	li	a2,16
a000ede8:	00408821 	move	s1,v0
    unsigned int image_size= strtoul((const char*)(argv[2]), (char **)NULL, 16);
a000edec:	8e440008 	lw	a0,8(s2)
a000edf0:	00002821 	move	a1,zero
a000edf4:	0c0020c4 	jal	a0008310 <strtoul>
a000edf8:	24060010 	li	a2,16
a000edfc:	00409021 	move	s2,v0
  
    //unsigned int length= strtoul((const char*)(argv[1]), (char **)NULL, 16);  
 

    prom_printf("NAND flash PIO write size 0x%X from DRAM 0x%X to flash_Paddress 0x%X \n",image_size,image_addr,flash_Paddress_start);
a000ee00:	3c04a001 	lui	a0,0xa001
a000ee04:	24846acc 	addiu	a0,a0,27340
a000ee08:	00402821 	move	a1,v0
a000ee0c:	02203021 	move	a2,s1
a000ee10:	0c0023a7 	jal	a0008e9c <prom_printf>
a000ee14:	02003821 	move	a3,s0
    prom_printf("(Y)es, (N)o->");
a000ee18:	3c04a001 	lui	a0,0xa001
a000ee1c:	0c0023a7 	jal	a0008e9c <prom_printf>
a000ee20:	24846a08 	addiu	a0,a0,27144
   if (YesOrNo())
a000ee24:	0c003ae2 	jal	a000eb88 <YesOrNo>
a000ee28:	00000000 	nop
a000ee2c:	10400010 	beqz	v0,a000ee70 <CmdNAND_PIO_WRITE+0x108>
a000ee30:	3c133e0f 	lui	s3,0x3e0f
#if (defined(CONFIG_NAND_Flash_Small_Page_32MB_3cycles) || defined(CONFIG_NAND_Flash_Small_Page_64MB_4cycles))
       rtk_PIO_write_word (flash_Paddress_start,image_addr,image_size);   
#else
	   /*rtk_PIO_write_word seems can only write a page more safe,cl*/
	   int i;
	   for(i =0; i < (image_size)/2112;i++)
a000ee34:	367383e1 	ori	s3,s3,0x83e1
a000ee38:	02530019 	multu	s2,s3
a000ee3c:	00009810 	mfhi	s3
a000ee40:	00139a42 	srl	s3,s3,0x9
a000ee44:	1260000a 	beqz	s3,a000ee70 <CmdNAND_PIO_WRITE+0x108>
a000ee48:	00009021 	move	s2,zero
	   {
		   rtk_PIO_write_word (flash_Paddress_start,image_addr,2112); 
a000ee4c:	02002021 	move	a0,s0
a000ee50:	02202821 	move	a1,s1
a000ee54:	0c000fe7 	jal	a0003f9c <rtk_PIO_write_word>
a000ee58:	24060840 	li	a2,2112
		   flash_Paddress_start += 2112;
a000ee5c:	26100840 	addiu	s0,s0,2112
#if (defined(CONFIG_NAND_Flash_Small_Page_32MB_3cycles) || defined(CONFIG_NAND_Flash_Small_Page_64MB_4cycles))
       rtk_PIO_write_word (flash_Paddress_start,image_addr,image_size);   
#else
	   /*rtk_PIO_write_word seems can only write a page more safe,cl*/
	   int i;
	   for(i =0; i < (image_size)/2112;i++)
a000ee60:	26520001 	addiu	s2,s2,1
a000ee64:	0253102b 	sltu	v0,s2,s3
a000ee68:	1440fff8 	bnez	v0,a000ee4c <CmdNAND_PIO_WRITE+0xe4>
a000ee6c:	26310840 	addiu	s1,s1,2112
#endif    
	}


               
}
a000ee70:	8fbf0024 	lw	ra,36(sp)
a000ee74:	8fb30020 	lw	s3,32(sp)
a000ee78:	8fb2001c 	lw	s2,28(sp)
a000ee7c:	8fb10018 	lw	s1,24(sp)
a000ee80:	8fb00014 	lw	s0,20(sp)
a000ee84:	03e00008 	jr	ra
a000ee88:	27bd0028 	addiu	sp,sp,40

a000ee8c <CmdNANDBE>:
    rtk_nand_probe();
}


int CmdNANDBE(int argc, char* argv[])
{
a000ee8c:	27bdffe0 	addiu	sp,sp,-32
a000ee90:	afbf001c 	sw	ra,28(sp)
a000ee94:	afb20018 	sw	s2,24(sp)
a000ee98:	afb10014 	sw	s1,20(sp)
a000ee9c:	afb00010 	sw	s0,16(sp)

    if(argc < 2)
a000eea0:	28840002 	slti	a0,a0,2
a000eea4:	10800006 	beqz	a0,a000eec0 <CmdNANDBE+0x34>
a000eea8:	00a08021 	move	s0,a1
    {
        prom_printf("Parameters not enough!\n");
a000eeac:	3c04a001 	lui	a0,0xa001
a000eeb0:	0c0023a7 	jal	a0008e9c <prom_printf>
a000eeb4:	248467a0 	addiu	a0,a0,26528
   else
   {
	 prom_printf("Abort!\n");
   }
               
}
a000eeb8:	08003bd3 	j	a000ef4c <CmdNANDBE+0xc0>
a000eebc:	24020001 	li	v0,1
    {
        prom_printf("Parameters not enough!\n");
        return 1;
    }

    unsigned int block_start_num= strtoul((const char*)(argv[0]), (char **)NULL, 16);
a000eec0:	8ca40000 	lw	a0,0(a1)
a000eec4:	00002821 	move	a1,zero
a000eec8:	0c0020c4 	jal	a0008310 <strtoul>
a000eecc:	24060010 	li	a2,16
a000eed0:	00408821 	move	s1,v0
    unsigned int block_end_num= strtoul((const char*)(argv[1]), (char **)NULL, 16);
a000eed4:	8e040004 	lw	a0,4(s0)
a000eed8:	00002821 	move	a1,zero
a000eedc:	0c0020c4 	jal	a0008310 <strtoul>
a000eee0:	24060010 	li	a2,16
a000eee4:	00409021 	move	s2,v0
    unsigned int NAND_Erase_Block_num,NAND_Erase_Block_times;

     prom_printf("NAND flash block erase from block:0x%X to block:0x%X ?\n",block_start_num,block_end_num);
a000eee8:	3c04a001 	lui	a0,0xa001
a000eeec:	24846b14 	addiu	a0,a0,27412
a000eef0:	02202821 	move	a1,s1
a000eef4:	0c0023a7 	jal	a0008e9c <prom_printf>
a000eef8:	00403021 	move	a2,v0
    prom_printf("(Y)es, (N)o->");
a000eefc:	3c04a001 	lui	a0,0xa001
a000ef00:	0c0023a7 	jal	a0008e9c <prom_printf>
a000ef04:	24846a08 	addiu	a0,a0,27144
   if (YesOrNo())
a000ef08:	0c003ae2 	jal	a000eb88 <YesOrNo>
a000ef0c:	00000000 	nop
a000ef10:	1040000b 	beqz	v0,a000ef40 <CmdNANDBE+0xb4>
a000ef14:	0251102b 	sltu	v0,s2,s1
   {    

                 //NAND_Erase_Block_times=block_end_num-block_start_num;
    for (NAND_Erase_Block_num=block_start_num;NAND_Erase_Block_num<=block_end_num;NAND_Erase_Block_num++)
a000ef18:	1440000c 	bnez	v0,a000ef4c <CmdNANDBE+0xc0>
a000ef1c:	00118180 	sll	s0,s1,0x6
	#if (defined(CONFIG_NAND_Flash_Small_Page_32MB_3cycles) || defined(CONFIG_NAND_Flash_Small_Page_64MB_4cycles))
      	  rtk_erase_block (NAND_Erase_Block_num*32);   //JSW 1block= 32(0x20) pages
	#endif	

	#if (defined(CONFIG_NAND_Flash_Large_Page_256MBto1GB_5cycles) || defined(CONFIG_NAND_Flash_Large_Page_128MB_4cycles))
		 rtk_erase_block (NAND_Erase_Block_num*64);   //JSW 1block= 64(0x40) pages
a000ef20:	0c001455 	jal	a0005154 <rtk_erase_block>
a000ef24:	02002021 	move	a0,s0
    prom_printf("(Y)es, (N)o->");
   if (YesOrNo())
   {    

                 //NAND_Erase_Block_times=block_end_num-block_start_num;
    for (NAND_Erase_Block_num=block_start_num;NAND_Erase_Block_num<=block_end_num;NAND_Erase_Block_num++)
a000ef28:	26310001 	addiu	s1,s1,1
a000ef2c:	0251102b 	sltu	v0,s2,s1
a000ef30:	1040fffb 	beqz	v0,a000ef20 <CmdNANDBE+0x94>
a000ef34:	26100040 	addiu	s0,s0,64
   else
   {
	 prom_printf("Abort!\n");
   }
               
}
a000ef38:	08003bd4 	j	a000ef50 <CmdNANDBE+0xc4>
a000ef3c:	8fbf001c 	lw	ra,28(sp)

    }
   }
   else
   {
	 prom_printf("Abort!\n");
a000ef40:	3c04a001 	lui	a0,0xa001
a000ef44:	0c0023a7 	jal	a0008e9c <prom_printf>
a000ef48:	24846a18 	addiu	a0,a0,27160
   }
               
}
a000ef4c:	8fbf001c 	lw	ra,28(sp)
a000ef50:	8fb20018 	lw	s2,24(sp)
a000ef54:	8fb10014 	lw	s1,20(sp)
a000ef58:	8fb00010 	lw	s0,16(sp)
a000ef5c:	03e00008 	jr	ra
a000ef60:	27bd0020 	addiu	sp,sp,32

a000ef64 <monitor>:
#endif
	monitor_real(table_count);
}
#else
void monitor(void)
{
a000ef64:	27bdff38 	addiu	sp,sp,-200
a000ef68:	afbf00c4 	sw	ra,196(sp)
a000ef6c:	afbe00c0 	sw	s8,192(sp)
a000ef70:	afb700bc 	sw	s7,188(sp)
a000ef74:	afb600b8 	sw	s6,184(sp)
a000ef78:	afb500b4 	sw	s5,180(sp)
a000ef7c:	afb400b0 	sw	s4,176(sp)
a000ef80:	afb300ac 	sw	s3,172(sp)
a000ef84:	afb200a8 	sw	s2,168(sp)
a000ef88:	afb100a4 	sw	s1,164(sp)
a000ef8c:	afb000a0 	sw	s0,160(sp)
	{	
		 #if CONFIG_ESD_SUPPORT//patch for ESD
                         REG32(0xb800311c)|= (1<<23);
        	#endif
	
		printf( "%s", MAIN_PROMPT );
a000ef90:	3c17a001 	lui	s7,0xa001
a000ef94:	26f742bc 	addiu	s7,s7,17084
a000ef98:	3c1ea001 	lui	s8,0xa001
a000ef9c:	27de40d8 	addiu	s8,s8,16600
		memset( buffer, 0, MAX_MONITOR_BUFFER );
a000efa0:	27b40010 	addiu	s4,sp,16
		GetLine( buffer, MAX_MONITOR_BUFFER,1);
		printf( "\n" );
		argc = GetArgc( (const char *)buffer );
		argv = GetArgv( (const char *)buffer );
		if( argc < 1 ) continue ;
		StrUpr( argv[0] );
a000efa4:	3c16a001 	lui	s6,0xa001
a000efa8:	26d6769c 	addiu	s6,s6,30364
		for( i=0 ; i < (sizeof(MainCmdTable) / sizeof(COMMAND_TABLE)) ; i++ )
a000efac:	24130029 	li	s3,41
				retval = MainCmdTable[i].func( argc - 1 , argv+1 );
				memset(argv[0],0,sizeof(argv[0]));
				break;
			}
		}
		if(i==sizeof(MainCmdTable) / sizeof(COMMAND_TABLE)) printf("Unknown command !\r\n");
a000efb0:	3c02a001 	lui	v0,0xa001
a000efb4:	24426b4c 	addiu	v0,v0,27468
a000efb8:	afa20098 	sw	v0,152(sp)
	{	
		 #if CONFIG_ESD_SUPPORT//patch for ESD
                         REG32(0xb800311c)|= (1<<23);
        	#endif
	
		printf( "%s", MAIN_PROMPT );
a000efbc:	02e02021 	move	a0,s7
a000efc0:	0c002325 	jal	a0008c94 <dprintf>
a000efc4:	03c02821 	move	a1,s8
		memset( buffer, 0, MAX_MONITOR_BUFFER );
a000efc8:	02802021 	move	a0,s4
a000efcc:	00002821 	move	a1,zero
a000efd0:	0c00203d 	jal	a00080f4 <memset>
a000efd4:	24060080 	li	a2,128
		GetLine( buffer, MAX_MONITOR_BUFFER,1);
a000efd8:	02802021 	move	a0,s4
a000efdc:	24050080 	li	a1,128
a000efe0:	0c002193 	jal	a000864c <GetLine>
a000efe4:	24060001 	li	a2,1
		printf( "\n" );
a000efe8:	3c04a001 	lui	a0,0xa001
a000efec:	0c002325 	jal	a0008c94 <dprintf>
a000eff0:	248457b8 	addiu	a0,a0,22456
		argc = GetArgc( (const char *)buffer );
a000eff4:	0c002129 	jal	a00084a4 <GetArgc>
a000eff8:	02802021 	move	a0,s4
a000effc:	0040a821 	move	s5,v0
		argv = GetArgv( (const char *)buffer );
a000f000:	0c002161 	jal	a0008584 <GetArgv>
a000f004:	02802021 	move	a0,s4
		if( argc < 1 ) continue ;
a000f008:	1aa0ffec 	blez	s5,a000efbc <monitor+0x58>
a000f00c:	00409021 	move	s2,v0
		StrUpr( argv[0] );
a000f010:	0c002118 	jal	a0008460 <StrUpr>
a000f014:	8c440000 	lw	a0,0(v0)
a000f018:	02c08821 	move	s1,s6
a000f01c:	00008021 	move	s0,zero
		for( i=0 ; i < (sizeof(MainCmdTable) / sizeof(COMMAND_TABLE)) ; i++ )
		{
			
			if( ! strcmp( argv[0], MainCmdTable[i].cmd ) )
a000f020:	8e440000 	lw	a0,0(s2)
a000f024:	0c002015 	jal	a0008054 <strcmp>
a000f028:	8e250000 	lw	a1,0(s1)
a000f02c:	14400010 	bnez	v0,a000f070 <monitor+0x10c>
a000f030:	26100001 	addiu	s0,s0,1
a000f034:	2610ffff 	addiu	s0,s0,-1
				if (MainCmdTable[i].n_arg != (argc - 1))
					printf("%s\n", MainCmdTable[i].msg);
				else
					retval = MainCmdTable[i].func( argc - 1 , argv+1 );
#endif
				retval = MainCmdTable[i].func( argc - 1 , argv+1 );
a000f038:	00101100 	sll	v0,s0,0x4
a000f03c:	00561021 	addu	v0,v0,s6
a000f040:	8c420008 	lw	v0,8(v0)
a000f044:	26a4ffff 	addiu	a0,s5,-1
a000f048:	0040f809 	jalr	v0
a000f04c:	26450004 	addiu	a1,s2,4
				memset(argv[0],0,sizeof(argv[0]));
a000f050:	8e420000 	lw	v0,0(s2)
a000f054:	a0400000 	sb	zero,0(v0)
a000f058:	a0400001 	sb	zero,1(v0)
a000f05c:	a0400002 	sb	zero,2(v0)
				break;
			}
		}
		if(i==sizeof(MainCmdTable) / sizeof(COMMAND_TABLE)) printf("Unknown command !\r\n");
a000f060:	1613ffd6 	bne	s0,s3,a000efbc <monitor+0x58>
a000f064:	a0400003 	sb	zero,3(v0)
a000f068:	08003c1e 	j	a000f078 <monitor+0x114>
a000f06c:	00000000 	nop
		printf( "\n" );
		argc = GetArgc( (const char *)buffer );
		argv = GetArgv( (const char *)buffer );
		if( argc < 1 ) continue ;
		StrUpr( argv[0] );
		for( i=0 ; i < (sizeof(MainCmdTable) / sizeof(COMMAND_TABLE)) ; i++ )
a000f070:	1613ffeb 	bne	s0,s3,a000f020 <monitor+0xbc>
a000f074:	26310010 	addiu	s1,s1,16
				retval = MainCmdTable[i].func( argc - 1 , argv+1 );
				memset(argv[0],0,sizeof(argv[0]));
				break;
			}
		}
		if(i==sizeof(MainCmdTable) / sizeof(COMMAND_TABLE)) printf("Unknown command !\r\n");
a000f078:	0c002325 	jal	a0008c94 <dprintf>
a000f07c:	8fa40098 	lw	a0,152(sp)
	{	
		 #if CONFIG_ESD_SUPPORT//patch for ESD
                         REG32(0xb800311c)|= (1<<23);
        	#endif
	
		printf( "%s", MAIN_PROMPT );
a000f080:	08003bf0 	j	a000efc0 <monitor+0x5c>
a000f084:	02e02021 	move	a0,s7

a000f088 <CmdPHYregR>:

	return 0;
}

int CmdPHYregR(int argc, char* argv[])
{
a000f088:	27bdffd8 	addiu	sp,sp,-40
a000f08c:	afbf0024 	sw	ra,36(sp)
a000f090:	afb10020 	sw	s1,32(sp)
a000f094:	afb0001c 	sw	s0,28(sp)
a000f098:	00a08021 	move	s0,a1
    unsigned long phyid, regnum;
    unsigned int uid,tmp;

    phyid = strtoul((const char*)(argv[0]), (char **)NULL, 16);
a000f09c:	8ca40000 	lw	a0,0(a1)
a000f0a0:	00002821 	move	a1,zero
a000f0a4:	0c0020c4 	jal	a0008310 <strtoul>
a000f0a8:	24060010 	li	a2,16
a000f0ac:	00408821 	move	s1,v0
    regnum = strtoul((const char*)(argv[1]), (char **)NULL, 16);
a000f0b0:	8e040004 	lw	a0,4(s0)
a000f0b4:	00002821 	move	a1,zero
a000f0b8:	0c0020c4 	jal	a0008310 <strtoul>
a000f0bc:	24060010 	li	a2,16
a000f0c0:	00408021 	move	s0,v0

    rtl8651_getAsicEthernetPHYReg( phyid, regnum, &tmp );
a000f0c4:	02202021 	move	a0,s1
a000f0c8:	00402821 	move	a1,v0
a000f0cc:	0c000933 	jal	a00024cc <rtl8651_getAsicEthernetPHYReg>
a000f0d0:	27a60010 	addiu	a2,sp,16
    uid=tmp;
    dprintf("PHYID=0x%x, regID=0x%x, data=0x%x\r\n", phyid, regnum, uid);
a000f0d4:	3c04a001 	lui	a0,0xa001
a000f0d8:	24846b60 	addiu	a0,a0,27488
a000f0dc:	02202821 	move	a1,s1
a000f0e0:	02003021 	move	a2,s0
a000f0e4:	0c002325 	jal	a0008c94 <dprintf>
a000f0e8:	8fa70010 	lw	a3,16(sp)
	return 0;
}
a000f0ec:	00001021 	move	v0,zero
a000f0f0:	8fbf0024 	lw	ra,36(sp)
a000f0f4:	8fb10020 	lw	s1,32(sp)
a000f0f8:	8fb0001c 	lw	s0,28(sp)
a000f0fc:	03e00008 	jr	ra
a000f100:	27bd0028 	addiu	sp,sp,40

a000f104 <TestCmd_MDIOR>:
}
#endif
//---------------------------------------------------------------------------
#if SWITCH_CMD
int TestCmd_MDIOR( int argc, char* argv[] )
{
a000f104:	27bdffd0 	addiu	sp,sp,-48
a000f108:	afbf002c 	sw	ra,44(sp)
a000f10c:	afb40028 	sw	s4,40(sp)
a000f110:	afb30024 	sw	s3,36(sp)
a000f114:	afb20020 	sw	s2,32(sp)
a000f118:	afb1001c 	sw	s1,28(sp)
a000f11c:	afb00018 	sw	s0,24(sp)
	if(argc < 1) {
a000f120:	1c800005 	bgtz	a0,a000f138 <TestCmd_MDIOR+0x34>
a000f124:	3c04a001 	lui	a0,0xa001
		printf("Parameters not enough!\n");
a000f128:	0c002325 	jal	a0008c94 <dprintf>
a000f12c:	248467a0 	addiu	a0,a0,26528
		return 1;
a000f130:	08003c65 	j	a000f194 <TestCmd_MDIOR+0x90>
a000f134:	24020001 	li	v0,1
	}

//	unsigned int phyid = strtoul((const char*)(argv[0]), (char **)NULL, 16);		
	unsigned int reg = strtoul((const char*)(argv[0]), (char **)NULL, 10);		
a000f138:	8ca40000 	lw	a0,0(a1)
a000f13c:	00002821 	move	a1,zero
a000f140:	0c0020c4 	jal	a0008310 <strtoul>
a000f144:	2406000a 	li	a2,10
a000f148:	00408821 	move	s1,v0
a000f14c:	00008021 	move	s0,zero
	int i,phyid;
	for(i=0;i<32;i++)
	{
		phyid=i;
		//REG32(PABCDDAT_REG) =  0xffff<<8;
	rtl8651_getAsicEthernetPHYReg(phyid,reg,&data); 	
a000f150:	27b40010 	addiu	s4,sp,16
		//REG32(PABCDDAT_REG) =  0<<8;	
	dprintf("PhyID=0x%02x Reg=%02d Data =0x%04x\r\n", phyid, reg,data);
a000f154:	3c12a001 	lui	s2,0xa001
a000f158:	26526b84 	addiu	s2,s2,27524

//	unsigned int phyid = strtoul((const char*)(argv[0]), (char **)NULL, 16);		
	unsigned int reg = strtoul((const char*)(argv[0]), (char **)NULL, 10);		
	unsigned int data;
	int i,phyid;
	for(i=0;i<32;i++)
a000f15c:	24130020 	li	s3,32
	{
		phyid=i;
		//REG32(PABCDDAT_REG) =  0xffff<<8;
	rtl8651_getAsicEthernetPHYReg(phyid,reg,&data); 	
a000f160:	02002021 	move	a0,s0
a000f164:	02202821 	move	a1,s1
a000f168:	0c000933 	jal	a00024cc <rtl8651_getAsicEthernetPHYReg>
a000f16c:	02803021 	move	a2,s4
		//REG32(PABCDDAT_REG) =  0<<8;	
	dprintf("PhyID=0x%02x Reg=%02d Data =0x%04x\r\n", phyid, reg,data);
a000f170:	02402021 	move	a0,s2
a000f174:	02002821 	move	a1,s0
a000f178:	02203021 	move	a2,s1
a000f17c:	0c002325 	jal	a0008c94 <dprintf>
a000f180:	8fa70010 	lw	a3,16(sp)

//	unsigned int phyid = strtoul((const char*)(argv[0]), (char **)NULL, 16);		
	unsigned int reg = strtoul((const char*)(argv[0]), (char **)NULL, 10);		
	unsigned int data;
	int i,phyid;
	for(i=0;i<32;i++)
a000f184:	26100001 	addiu	s0,s0,1
a000f188:	1613fff6 	bne	s0,s3,a000f164 <TestCmd_MDIOR+0x60>
a000f18c:	02002021 	move	a0,s0
a000f190:	00001021 	move	v0,zero
		//REG32(PABCDDAT_REG) =  0<<8;	
	dprintf("PhyID=0x%02x Reg=%02d Data =0x%04x\r\n", phyid, reg,data);

	}
	return 0;
}
a000f194:	8fbf002c 	lw	ra,44(sp)
a000f198:	8fb40028 	lw	s4,40(sp)
a000f19c:	8fb30024 	lw	s3,36(sp)
a000f1a0:	8fb20020 	lw	s2,32(sp)
a000f1a4:	8fb1001c 	lw	s1,28(sp)
a000f1a8:	8fb00018 	lw	s0,24(sp)
a000f1ac:	03e00008 	jr	ra
a000f1b0:	27bd0030 	addiu	sp,sp,48

a000f1b4 <CmdPHY_Script>:
#endif

//===============================================================================
//========================================================
int CmdPHY_Script(int argc, char* argv[])
{
a000f1b4:	27bdff18 	addiu	sp,sp,-232
a000f1b8:	afbf00e4 	sw	ra,228(sp)
a000f1bc:	afbe00e0 	sw	s8,224(sp)
a000f1c0:	afb700dc 	sw	s7,220(sp)
a000f1c4:	afb600d8 	sw	s6,216(sp)
a000f1c8:	afb500d4 	sw	s5,212(sp)
a000f1cc:	afb400d0 	sw	s4,208(sp)
a000f1d0:	afb300cc 	sw	s3,204(sp)
a000f1d4:	afb200c8 	sw	s2,200(sp)
a000f1d8:	afb100c4 	sw	s1,196(sp)
a000f1dc:	afb000c0 	sw	s0,192(sp)
a000f1e0:	24130001 	li	s3,1
a000f1e4:	0000f021 	move	s8,zero
a000f1e8:	2416000a 	li	s6,10
a000f1ec:	afa000a0 	sw	zero,160(sp)
	
    while(1)
    {


	if(rec==1)
a000f1f0:	24140001 	li	s4,1
	{	
		memset(buffer,0,LEN);
a000f1f4:	27b20010 	addiu	s2,sp,16
		GetLine(buffer,LEN,1);
		printf("\n");
a000f1f8:	3c02a001 	lui	v0,0xa001
a000f1fc:	244257b8 	addiu	v0,v0,22456
a000f200:	afa200ac 	sw	v0,172(sp)
		len=strlen(buffer);
		
		memcpy(ptr+pidx,buffer, len); 
a000f204:	3c158050 	lui	s5,0x8050


	StrUpr(argv[0]);
	WDBG("cmd=%s\n", argv[0] );
	
	if( (rec==1)  &&  !strcmp(argv[0],  "PHYID") )
a000f208:	3c02a001 	lui	v0,0xa001
a000f20c:	24426bac 	addiu	v0,v0,27564
a000f210:	afa200b0 	sw	v0,176(sp)
	{
		phyid=strtoul((const char*)(argv[1]), (char **)NULL, 16);
		WDBG("id=%x\n", phyid);		
	}
	
	if(  (rec==1)  && !strcmp(argv[0],  "A") )
a000f214:	3c02a001 	lui	v0,0xa001
a000f218:	244250a0 	addiu	v0,v0,20640
a000f21c:	afa200b4 	sw	v0,180(sp)
	{
		cnt=strtoul((const char*)(argv[1]), (char **)NULL, 10);
		WDBG("rep=%x\n", cnt);		
	}
	if(  (rec==0)  && !strcmp(argv[0],  "W") )
a000f220:	3c02a001 	lui	v0,0xa001
a000f224:	24426fbc 	addiu	v0,v0,28604
a000f228:	afa200a4 	sw	v0,164(sp)
		val=(tmp&mask)|val;
		WDBG("W reg=%x\n",val);		
		rtl8651_setAsicEthernetPHYReg( phyid, reg,  val);	

	}
	if(  (rec==0)  && !strcmp(argv[0],  "R") )
a000f22c:	3c02a001 	lui	v0,0xa001
a000f230:	24426f78 	addiu	v0,v0,28536
a000f234:	afa200a8 	sw	v0,168(sp)
		WDBG("mask=%x\n", mask);
		
		rtl8651_getAsicEthernetPHYReg( phyid, reg, &tmp );	
		tmp=(tmp&mask)>>bit1;
		WDBG("val=%x\n",tmp);
		printf("0x%x\n", tmp);
a000f238:	3c02a001 	lui	v0,0xa001
a000f23c:	2442432c 	addiu	v0,v0,17196
a000f240:	afa200bc 	sw	v0,188(sp)
	}	
	if( !strcmp(argv[0],  "PHY_END") )
a000f244:	3c17a001 	lui	s7,0xa001
a000f248:	26f76bb4 	addiu	s7,s7,27572
	
    while(1)
    {


	if(rec==1)
a000f24c:	16740024 	bne	s3,s4,a000f2e0 <CmdPHY_Script+0x12c>
a000f250:	00002821 	move	a1,zero
	{	
		memset(buffer,0,LEN);
a000f254:	02402021 	move	a0,s2
a000f258:	0c00203d 	jal	a00080f4 <memset>
a000f25c:	24060080 	li	a2,128
		GetLine(buffer,LEN,1);
a000f260:	02402021 	move	a0,s2
a000f264:	24050080 	li	a1,128
a000f268:	0c002193 	jal	a000864c <GetLine>
a000f26c:	02803021 	move	a2,s4
		printf("\n");
a000f270:	0c002325 	jal	a0008c94 <dprintf>
a000f274:	8fa400ac 	lw	a0,172(sp)
		len=strlen(buffer);
a000f278:	0c002033 	jal	a00080cc <strlen>
a000f27c:	02402021 	move	a0,s2
a000f280:	00408021 	move	s0,v0
		
		memcpy(ptr+pidx,buffer, len); 
a000f284:	03d52021 	addu	a0,s8,s5
a000f288:	02402821 	move	a1,s2
a000f28c:	0c002046 	jal	a0008118 <memcpy>
a000f290:	00403021 	move	a2,v0
		ptr[pidx+len]=0x0a;
a000f294:	021ef021 	addu	s8,s0,s8
a000f298:	02be1021 	addu	v0,s5,s8
a000f29c:	2403000a 	li	v1,10
a000f2a0:	a0430000 	sb	v1,0(v0)
		pidx+=(len+1);
a000f2a4:	27de0001 	addiu	s8,s8,1
			ExtractACmdLine(ptr, buffer, 0);
	}

	
	WDBG("\n");
	argc = GetArgc( (const char *)buffer );
a000f2a8:	0c002129 	jal	a00084a4 <GetArgc>
a000f2ac:	02402021 	move	a0,s2
	argv = GetArgv( (const char *)buffer );
a000f2b0:	0c002161 	jal	a0008584 <GetArgv>
a000f2b4:	02402021 	move	a0,s2
a000f2b8:	00408821 	move	s1,v0


	StrUpr(argv[0]);
a000f2bc:	0c002118 	jal	a0008460 <StrUpr>
a000f2c0:	8c440000 	lw	a0,0(v0)
	WDBG("cmd=%s\n", argv[0] );
	
	if( (rec==1)  &&  !strcmp(argv[0],  "PHYID") )
a000f2c4:	8e240000 	lw	a0,0(s1)
a000f2c8:	0c002015 	jal	a0008054 <strcmp>
a000f2cc:	8fa500b0 	lw	a1,176(sp)
a000f2d0:	1440008c 	bnez	v0,a000f504 <CmdPHY_Script+0x350>
a000f2d4:	00000000 	nop
	{
		phyid=strtoul((const char*)(argv[1]), (char **)NULL, 16);
a000f2d8:	08003cc5 	j	a000f314 <CmdPHY_Script+0x160>
a000f2dc:	8e240004 	lw	a0,4(s1)
		ptr[pidx+len]=0x0a;
		pidx+=(len+1);
	}
	else
	{		
			ExtractACmdLine(ptr, buffer, 0);
a000f2e0:	02a02021 	move	a0,s5
a000f2e4:	02402821 	move	a1,s2
a000f2e8:	0c002d33 	jal	a000b4cc <ExtractACmdLine>
a000f2ec:	00003021 	move	a2,zero
	}

	
	WDBG("\n");
	argc = GetArgc( (const char *)buffer );
a000f2f0:	0c002129 	jal	a00084a4 <GetArgc>
a000f2f4:	02402021 	move	a0,s2
	argv = GetArgv( (const char *)buffer );
a000f2f8:	0c002161 	jal	a0008584 <GetArgv>
a000f2fc:	02402021 	move	a0,s2
a000f300:	00408821 	move	s1,v0


	StrUpr(argv[0]);
a000f304:	0c002118 	jal	a0008460 <StrUpr>
a000f308:	8c440000 	lw	a0,0(v0)
a000f30c:	08003ccf 	j	a000f33c <CmdPHY_Script+0x188>
a000f310:	00000000 	nop
	WDBG("cmd=%s\n", argv[0] );
	
	if( (rec==1)  &&  !strcmp(argv[0],  "PHYID") )
	{
		phyid=strtoul((const char*)(argv[1]), (char **)NULL, 16);
a000f314:	00002821 	move	a1,zero
a000f318:	0c0020c4 	jal	a0008310 <strtoul>
a000f31c:	24060010 	li	a2,16
a000f320:	08003d41 	j	a000f504 <CmdPHY_Script+0x350>
a000f324:	afa200a0 	sw	v0,160(sp)
		WDBG("id=%x\n", phyid);		
	}
	
	if(  (rec==1)  && !strcmp(argv[0],  "A") )
	{
		cnt=strtoul((const char*)(argv[1]), (char **)NULL, 10);
a000f328:	00002821 	move	a1,zero
a000f32c:	0c0020c4 	jal	a0008310 <strtoul>
a000f330:	2406000a 	li	a2,10
a000f334:	08003d24 	j	a000f490 <CmdPHY_Script+0x2dc>
a000f338:	0040b021 	move	s6,v0
		WDBG("rep=%x\n", cnt);		
	}
	if(  (rec==0)  && !strcmp(argv[0],  "W") )
a000f33c:	16600054 	bnez	s3,a000f490 <CmdPHY_Script+0x2dc>
a000f340:	00000000 	nop
a000f344:	8e240000 	lw	a0,0(s1)
a000f348:	0c002015 	jal	a0008054 <strcmp>
a000f34c:	8fa500a4 	lw	a1,164(sp)
a000f350:	14400073 	bnez	v0,a000f520 <CmdPHY_Script+0x36c>
a000f354:	00002821 	move	a1,zero
	{
		unsigned int reg,bit2,bit1,i,mask=0,val,tmp;
		reg=strtoul((const char*)(argv[1]), (char **)NULL, 10);
a000f358:	8e240004 	lw	a0,4(s1)
a000f35c:	0c0020c4 	jal	a0008310 <strtoul>
a000f360:	2406000a 	li	a2,10
a000f364:	afa20098 	sw	v0,152(sp)
		bit2=strtoul((const char*)(argv[2]), (char **)NULL, 10);
a000f368:	8e240008 	lw	a0,8(s1)
a000f36c:	00002821 	move	a1,zero
a000f370:	0c0020c4 	jal	a0008310 <strtoul>
a000f374:	2406000a 	li	a2,10
a000f378:	afa200b8 	sw	v0,184(sp)
		bit1=strtoul((const char*)(argv[3]), (char **)NULL, 10);
a000f37c:	8e24000c 	lw	a0,12(s1)
a000f380:	00002821 	move	a1,zero
a000f384:	0c0020c4 	jal	a0008310 <strtoul>
a000f388:	2406000a 	li	a2,10
a000f38c:	00408021 	move	s0,v0
		val=strtoul((const char*)(argv[4]), (char **)NULL, 16);
a000f390:	8e240010 	lw	a0,16(s1)
a000f394:	00002821 	move	a1,zero
a000f398:	0c0020c4 	jal	a0008310 <strtoul>
a000f39c:	24060010 	li	a2,16
a000f3a0:	afa2009c 	sw	v0,156(sp)

		for(i=0; i<=(bit2-bit1); i++)
a000f3a4:	8fa200b8 	lw	v0,184(sp)
a000f3a8:	00502823 	subu	a1,v0,s0
a000f3ac:	00001821 	move	v1,zero
a000f3b0:	00001021 	move	v0,zero
			mask= (mask<<1)|1;
a000f3b4:	00031840 	sll	v1,v1,0x1
		reg=strtoul((const char*)(argv[1]), (char **)NULL, 10);
		bit2=strtoul((const char*)(argv[2]), (char **)NULL, 10);
		bit1=strtoul((const char*)(argv[3]), (char **)NULL, 10);
		val=strtoul((const char*)(argv[4]), (char **)NULL, 16);

		for(i=0; i<=(bit2-bit1); i++)
a000f3b8:	24420001 	addiu	v0,v0,1
a000f3bc:	00a2202b 	sltu	a0,a1,v0
a000f3c0:	1080fffc 	beqz	a0,a000f3b4 <CmdPHY_Script+0x200>
a000f3c4:	34630001 	ori	v1,v1,0x1
			mask= (mask<<1)|1;
		mask=0xffffffff-(mask<<bit1);
a000f3c8:	02038004 	sllv	s0,v1,s0
		
		rtl8651_getAsicEthernetPHYReg( phyid, reg, &tmp );	
a000f3cc:	8fa400a0 	lw	a0,160(sp)
a000f3d0:	8fa50098 	lw	a1,152(sp)
a000f3d4:	0c000933 	jal	a00024cc <rtl8651_getAsicEthernetPHYReg>
a000f3d8:	27a60090 	addiu	a2,sp,144
		WDBG("mask=%x\n", mask);
		val=(tmp&mask)|val;
		WDBG("W reg=%x\n",val);		
		rtl8651_setAsicEthernetPHYReg( phyid, reg,  val);	
a000f3dc:	00108027 	nor	s0,zero,s0
a000f3e0:	8fa20090 	lw	v0,144(sp)
a000f3e4:	02023024 	and	a2,s0,v0
a000f3e8:	8fa400a0 	lw	a0,160(sp)
a000f3ec:	8fa50098 	lw	a1,152(sp)
a000f3f0:	8fa3009c 	lw	v1,156(sp)
a000f3f4:	0c000941 	jal	a0002504 <rtl8651_setAsicEthernetPHYReg>
a000f3f8:	00c33025 	or	a2,a2,v1

	}
	if(  (rec==0)  && !strcmp(argv[0],  "R") )
a000f3fc:	08003d49 	j	a000f524 <CmdPHY_Script+0x370>
a000f400:	8e240000 	lw	a0,0(s1)
	{
		unsigned int reg,bit2,bit1,mask=0,i,val,tmp;
		reg=strtoul((const char*)(argv[1]), (char **)NULL, 10);
a000f404:	00002821 	move	a1,zero
a000f408:	0c0020c4 	jal	a0008310 <strtoul>
a000f40c:	2406000a 	li	a2,10
a000f410:	afa2009c 	sw	v0,156(sp)
		bit2=strtoul((const char*)(argv[2]), (char **)NULL, 10);
a000f414:	8e240008 	lw	a0,8(s1)
a000f418:	00002821 	move	a1,zero
a000f41c:	0c0020c4 	jal	a0008310 <strtoul>
a000f420:	2406000a 	li	a2,10
a000f424:	00408021 	move	s0,v0
		bit1=strtoul((const char*)(argv[3]), (char **)NULL, 10);		
a000f428:	8e24000c 	lw	a0,12(s1)
a000f42c:	00002821 	move	a1,zero
a000f430:	0c0020c4 	jal	a0008310 <strtoul>
a000f434:	2406000a 	li	a2,10
a000f438:	afa20098 	sw	v0,152(sp)


		for(i=0; i<=(bit2-bit1); i++)
a000f43c:	02022023 	subu	a0,s0,v0
a000f440:	00001021 	move	v0,zero
a000f444:	00008021 	move	s0,zero
			mask= (mask<<1)|1;
a000f448:	00108040 	sll	s0,s0,0x1
		reg=strtoul((const char*)(argv[1]), (char **)NULL, 10);
		bit2=strtoul((const char*)(argv[2]), (char **)NULL, 10);
		bit1=strtoul((const char*)(argv[3]), (char **)NULL, 10);		


		for(i=0; i<=(bit2-bit1); i++)
a000f44c:	24420001 	addiu	v0,v0,1
a000f450:	0082182b 	sltu	v1,a0,v0
a000f454:	1060fffc 	beqz	v1,a000f448 <CmdPHY_Script+0x294>
a000f458:	36100001 	ori	s0,s0,0x1
			mask= (mask<<1)|1;
		mask=mask<<bit1;
		WDBG("mask=%x\n", mask);
		
		rtl8651_getAsicEthernetPHYReg( phyid, reg, &tmp );	
a000f45c:	8fa400a0 	lw	a0,160(sp)
a000f460:	8fa5009c 	lw	a1,156(sp)
a000f464:	0c000933 	jal	a00024cc <rtl8651_getAsicEthernetPHYReg>
a000f468:	27a60090 	addiu	a2,sp,144
		tmp=(tmp&mask)>>bit1;
a000f46c:	8fa20098 	lw	v0,152(sp)
a000f470:	00502804 	sllv	a1,s0,v0
a000f474:	8fa20090 	lw	v0,144(sp)
a000f478:	00a22824 	and	a1,a1,v0
a000f47c:	8fa30098 	lw	v1,152(sp)
a000f480:	00652806 	srlv	a1,a1,v1
a000f484:	afa50090 	sw	a1,144(sp)
		WDBG("val=%x\n",tmp);
		printf("0x%x\n", tmp);
a000f488:	0c002325 	jal	a0008c94 <dprintf>
a000f48c:	8fa400bc 	lw	a0,188(sp)
	}	
	if( !strcmp(argv[0],  "PHY_END") )
a000f490:	8e240000 	lw	a0,0(s1)
a000f494:	0c002015 	jal	a0008054 <strcmp>
a000f498:	02e02821 	move	a1,s7
a000f49c:	1440ff6b 	bnez	v0,a000f24c <CmdPHY_Script+0x98>
a000f4a0:	00000000 	nop
	{	
		if(rec==1)
a000f4a4:	16740006 	bne	s3,s4,a000f4c0 <CmdPHY_Script+0x30c>
a000f4a8:	02a02021 	move	a0,s5
		{

			ExtractACmdLine(ptr, buffer, 1);
a000f4ac:	02402821 	move	a1,s2
a000f4b0:	0c002d33 	jal	a000b4cc <ExtractACmdLine>
a000f4b4:	02803021 	move	a2,s4
a000f4b8:	08003c93 	j	a000f24c <CmdPHY_Script+0x98>
a000f4bc:	00009821 	move	s3,zero
			rec=0;
		}
		else
		{
			ExtractACmdLine(ptr, buffer, 1);
a000f4c0:	02402821 	move	a1,s2
a000f4c4:	0c002d33 	jal	a000b4cc <ExtractACmdLine>
a000f4c8:	02803021 	move	a2,s4
			cnt--;
a000f4cc:	26d6ffff 	addiu	s6,s6,-1
			if(cnt==0)
a000f4d0:	16c0ff5e 	bnez	s6,a000f24c <CmdPHY_Script+0x98>
a000f4d4:	8fbf00e4 	lw	ra,228(sp)
	}	

	
    }

}
a000f4d8:	8fbe00e0 	lw	s8,224(sp)
a000f4dc:	8fb700dc 	lw	s7,220(sp)
a000f4e0:	8fb600d8 	lw	s6,216(sp)
a000f4e4:	8fb500d4 	lw	s5,212(sp)
a000f4e8:	8fb400d0 	lw	s4,208(sp)
a000f4ec:	8fb300cc 	lw	s3,204(sp)
a000f4f0:	8fb200c8 	lw	s2,200(sp)
a000f4f4:	8fb100c4 	lw	s1,196(sp)
a000f4f8:	8fb000c0 	lw	s0,192(sp)
a000f4fc:	03e00008 	jr	ra
a000f500:	27bd00e8 	addiu	sp,sp,232
	{
		phyid=strtoul((const char*)(argv[1]), (char **)NULL, 16);
		WDBG("id=%x\n", phyid);		
	}
	
	if(  (rec==1)  && !strcmp(argv[0],  "A") )
a000f504:	8e240000 	lw	a0,0(s1)
a000f508:	0c002015 	jal	a0008054 <strcmp>
a000f50c:	8fa500b4 	lw	a1,180(sp)
a000f510:	1440ff8a 	bnez	v0,a000f33c <CmdPHY_Script+0x188>
a000f514:	00000000 	nop
	{
		cnt=strtoul((const char*)(argv[1]), (char **)NULL, 10);
a000f518:	08003cca 	j	a000f328 <CmdPHY_Script+0x174>
a000f51c:	8e240004 	lw	a0,4(s1)
		val=(tmp&mask)|val;
		WDBG("W reg=%x\n",val);		
		rtl8651_setAsicEthernetPHYReg( phyid, reg,  val);	

	}
	if(  (rec==0)  && !strcmp(argv[0],  "R") )
a000f520:	8e240000 	lw	a0,0(s1)
a000f524:	0c002015 	jal	a0008054 <strcmp>
a000f528:	8fa500a8 	lw	a1,168(sp)
a000f52c:	1440ffd8 	bnez	v0,a000f490 <CmdPHY_Script+0x2dc>
a000f530:	00000000 	nop
	{
		unsigned int reg,bit2,bit1,mask=0,i,val,tmp;
		reg=strtoul((const char*)(argv[1]), (char **)NULL, 10);
a000f534:	08003d01 	j	a000f404 <CmdPHY_Script+0x250>
a000f538:	8e240004 	lw	a0,4(s1)

a000f53c <CmdPhyPageRegW>:
    dprintf("PHYID=0x%x, regID=0x%x, data=0x%x\r\n", phyid, regnum, uid);
	return 0;
}

int CmdPhyPageRegW(int argc, char* argv[])
{
a000f53c:	27bdffd0 	addiu	sp,sp,-48
a000f540:	afbf002c 	sw	ra,44(sp)
a000f544:	afb30028 	sw	s3,40(sp)
a000f548:	afb20024 	sw	s2,36(sp)
a000f54c:	afb10020 	sw	s1,32(sp)
a000f550:	afb0001c 	sw	s0,28(sp)
a000f554:	00a08821 	move	s1,a1
    unsigned long phyid, regnum, page;
    unsigned long data;
    unsigned int uid;

    phyid = strtoul((const char*)(argv[0]), (char **)NULL, 16);
a000f558:	8ca40000 	lw	a0,0(a1)
a000f55c:	00002821 	move	a1,zero
a000f560:	0c0020c4 	jal	a0008310 <strtoul>
a000f564:	24060010 	li	a2,16
a000f568:	00408021 	move	s0,v0
    page = strtoul((const char*)(argv[1]), (char **)NULL, 16);
a000f56c:	8e240004 	lw	a0,4(s1)
a000f570:	00002821 	move	a1,zero
a000f574:	0c0020c4 	jal	a0008310 <strtoul>
a000f578:	24060010 	li	a2,16
a000f57c:	00409821 	move	s3,v0
    regnum = strtoul((const char*)(argv[2]), (char **)NULL, 16);
a000f580:	8e240008 	lw	a0,8(s1)
a000f584:	00002821 	move	a1,zero
a000f588:	0c0020c4 	jal	a0008310 <strtoul>
a000f58c:	24060010 	li	a2,16
a000f590:	00409021 	move	s2,v0
    data= strtoul((const char*)(argv[3]), (char **)NULL, 16);
a000f594:	8e24000c 	lw	a0,12(s1)
a000f598:	00002821 	move	a1,zero
a000f59c:	0c0020c4 	jal	a0008310 <strtoul>
a000f5a0:	24060010 	li	a2,16
a000f5a4:	00408821 	move	s1,v0

	if (phyid == 0) phyid = 8;
a000f5a8:	24020008 	li	v0,8
	if(page > 0)
a000f5ac:	12600013 	beqz	s3,a000f5fc <CmdPhyPageRegW+0xc0>
a000f5b0:	0050800a 	movz	s0,v0,s0
		rtl8651_setAsicEthernetPHYReg( phyid, 31, page  );
a000f5b4:	02002021 	move	a0,s0
a000f5b8:	2405001f 	li	a1,31
a000f5bc:	0c000941 	jal	a0002504 <rtl8651_setAsicEthernetPHYReg>
a000f5c0:	02603021 	move	a2,s3

    rtl8651_setAsicEthernetPHYReg( phyid, regnum, data );
a000f5c4:	02002021 	move	a0,s0
a000f5c8:	02402821 	move	a1,s2
a000f5cc:	0c000941 	jal	a0002504 <rtl8651_setAsicEthernetPHYReg>
a000f5d0:	02203021 	move	a2,s1
    rtl8651_getAsicEthernetPHYReg( phyid, regnum, &uid );
a000f5d4:	02002021 	move	a0,s0
a000f5d8:	02402821 	move	a1,s2
a000f5dc:	0c000933 	jal	a00024cc <rtl8651_getAsicEthernetPHYReg>
a000f5e0:	27a60010 	addiu	a2,sp,16

	if(page > 0)
		rtl8651_setAsicEthernetPHYReg( phyid, 31, 0  );
a000f5e4:	02002021 	move	a0,s0
a000f5e8:	2405001f 	li	a1,31
a000f5ec:	0c000941 	jal	a0002504 <rtl8651_setAsicEthernetPHYReg>
a000f5f0:	00003021 	move	a2,zero

    dprintf("PHYID=0x%x ,regID=0x%x, read back data=0x%x\r\n", phyid, regnum, uid);
a000f5f4:	08003d88 	j	a000f620 <CmdPhyPageRegW+0xe4>
a000f5f8:	3c04a001 	lui	a0,0xa001

	if (phyid == 0) phyid = 8;
	if(page > 0)
		rtl8651_setAsicEthernetPHYReg( phyid, 31, page  );

    rtl8651_setAsicEthernetPHYReg( phyid, regnum, data );
a000f5fc:	02002021 	move	a0,s0
a000f600:	02402821 	move	a1,s2
a000f604:	0c000941 	jal	a0002504 <rtl8651_setAsicEthernetPHYReg>
a000f608:	02203021 	move	a2,s1
    rtl8651_getAsicEthernetPHYReg( phyid, regnum, &uid );
a000f60c:	02002021 	move	a0,s0
a000f610:	02402821 	move	a1,s2
a000f614:	0c000933 	jal	a00024cc <rtl8651_getAsicEthernetPHYReg>
a000f618:	27a60010 	addiu	a2,sp,16

	if(page > 0)
		rtl8651_setAsicEthernetPHYReg( phyid, 31, 0  );

    dprintf("PHYID=0x%x ,regID=0x%x, read back data=0x%x\r\n", phyid, regnum, uid);
a000f61c:	3c04a001 	lui	a0,0xa001
a000f620:	24846bbc 	addiu	a0,a0,27580
a000f624:	02002821 	move	a1,s0
a000f628:	02403021 	move	a2,s2
a000f62c:	0c002325 	jal	a0008c94 <dprintf>
a000f630:	8fa70010 	lw	a3,16(sp)
	return 0;
}
a000f634:	00001021 	move	v0,zero
a000f638:	8fbf002c 	lw	ra,44(sp)
a000f63c:	8fb30028 	lw	s3,40(sp)
a000f640:	8fb20024 	lw	s2,36(sp)
a000f644:	8fb10020 	lw	s1,32(sp)
a000f648:	8fb0001c 	lw	s0,28(sp)
a000f64c:	03e00008 	jr	ra
a000f650:	27bd0030 	addiu	sp,sp,48

a000f654 <CmdPhyPageRegR>:
    dprintf("PHYID=0x%x ,regID=0x%x, read back data=0x%x\r\n", phyid, regnum, uid);
	return 0;
}

int CmdPhyPageRegR(int argc, char* argv[])
{
a000f654:	27bdffd8 	addiu	sp,sp,-40
a000f658:	afbf0024 	sw	ra,36(sp)
a000f65c:	afb20020 	sw	s2,32(sp)
a000f660:	afb1001c 	sw	s1,28(sp)
a000f664:	afb00018 	sw	s0,24(sp)
a000f668:	00a08821 	move	s1,a1
    unsigned long phyid, regnum, page;
    unsigned int uid;

    phyid = strtoul((const char*)(argv[0]), (char **)NULL, 16);
a000f66c:	8ca40000 	lw	a0,0(a1)
a000f670:	00002821 	move	a1,zero
a000f674:	0c0020c4 	jal	a0008310 <strtoul>
a000f678:	24060010 	li	a2,16
a000f67c:	00408021 	move	s0,v0
    page = strtoul((const char*)(argv[1]), (char **)NULL, 16);
a000f680:	8e240004 	lw	a0,4(s1)
a000f684:	00002821 	move	a1,zero
a000f688:	0c0020c4 	jal	a0008310 <strtoul>
a000f68c:	24060010 	li	a2,16
a000f690:	00409021 	move	s2,v0
    regnum = strtoul((const char*)(argv[2]), (char **)NULL, 16);
a000f694:	8e240008 	lw	a0,8(s1)
a000f698:	00002821 	move	a1,zero
a000f69c:	0c0020c4 	jal	a0008310 <strtoul>
a000f6a0:	24060010 	li	a2,16
a000f6a4:	00408821 	move	s1,v0

	if (phyid == 0) phyid = 8;
a000f6a8:	24020008 	li	v0,8
	if(page > 0)
a000f6ac:	1240000f 	beqz	s2,a000f6ec <CmdPhyPageRegR+0x98>
a000f6b0:	0050800a 	movz	s0,v0,s0
		rtl8651_setAsicEthernetPHYReg( phyid, 31, page  );
a000f6b4:	02002021 	move	a0,s0
a000f6b8:	2405001f 	li	a1,31
a000f6bc:	0c000941 	jal	a0002504 <rtl8651_setAsicEthernetPHYReg>
a000f6c0:	02403021 	move	a2,s2
	
    rtl8651_getAsicEthernetPHYReg( phyid, regnum, &uid );
a000f6c4:	02002021 	move	a0,s0
a000f6c8:	02202821 	move	a1,s1
a000f6cc:	0c000933 	jal	a00024cc <rtl8651_getAsicEthernetPHYReg>
a000f6d0:	27a60010 	addiu	a2,sp,16

	if(page > 0)
		rtl8651_setAsicEthernetPHYReg( phyid, 31, 0  );
a000f6d4:	02002021 	move	a0,s0
a000f6d8:	2405001f 	li	a1,31
a000f6dc:	0c000941 	jal	a0002504 <rtl8651_setAsicEthernetPHYReg>
a000f6e0:	00003021 	move	a2,zero
	
    dprintf("PHYID=0x%x, regID=0x%x, data=0x%x\r\n", phyid, regnum, uid);
a000f6e4:	08003dc0 	j	a000f700 <CmdPhyPageRegR+0xac>
a000f6e8:	3c04a001 	lui	a0,0xa001

	if (phyid == 0) phyid = 8;
	if(page > 0)
		rtl8651_setAsicEthernetPHYReg( phyid, 31, page  );
	
    rtl8651_getAsicEthernetPHYReg( phyid, regnum, &uid );
a000f6ec:	02002021 	move	a0,s0
a000f6f0:	02202821 	move	a1,s1
a000f6f4:	0c000933 	jal	a00024cc <rtl8651_getAsicEthernetPHYReg>
a000f6f8:	27a60010 	addiu	a2,sp,16

	if(page > 0)
		rtl8651_setAsicEthernetPHYReg( phyid, 31, 0  );
	
    dprintf("PHYID=0x%x, regID=0x%x, data=0x%x\r\n", phyid, regnum, uid);
a000f6fc:	3c04a001 	lui	a0,0xa001
a000f700:	24846b60 	addiu	a0,a0,27488
a000f704:	02002821 	move	a1,s0
a000f708:	02203021 	move	a2,s1
a000f70c:	0c002325 	jal	a0008c94 <dprintf>
a000f710:	8fa70010 	lw	a3,16(sp)
	return 0;
}
a000f714:	00001021 	move	v0,zero
a000f718:	8fbf0024 	lw	ra,36(sp)
a000f71c:	8fb20020 	lw	s2,32(sp)
a000f720:	8fb1001c 	lw	s1,28(sp)
a000f724:	8fb00018 	lw	s0,24(sp)
a000f728:	03e00008 	jr	ra
a000f72c:	27bd0028 	addiu	sp,sp,40

a000f730 <CmdPHYregW>:
    dprintf("PHYID=0x%x, regID=0x%x, data=0x%x\r\n", phyid, regnum, uid);
	return 0;
}

int CmdPHYregW(int argc, char* argv[])
{
a000f730:	27bdffd8 	addiu	sp,sp,-40
a000f734:	afbf0024 	sw	ra,36(sp)
a000f738:	afb20020 	sw	s2,32(sp)
a000f73c:	afb1001c 	sw	s1,28(sp)
a000f740:	afb00018 	sw	s0,24(sp)
a000f744:	00a08021 	move	s0,a1
    unsigned long phyid, regnum;
    unsigned long data;
    unsigned int uid,tmp;

    phyid = strtoul((const char*)(argv[0]), (char **)NULL, 16);
a000f748:	8ca40000 	lw	a0,0(a1)
a000f74c:	00002821 	move	a1,zero
a000f750:	0c0020c4 	jal	a0008310 <strtoul>
a000f754:	24060010 	li	a2,16
a000f758:	00408821 	move	s1,v0
    regnum = strtoul((const char*)(argv[1]), (char **)NULL, 16);
a000f75c:	8e040004 	lw	a0,4(s0)
a000f760:	00002821 	move	a1,zero
a000f764:	0c0020c4 	jal	a0008310 <strtoul>
a000f768:	24060010 	li	a2,16
a000f76c:	00409021 	move	s2,v0
    data= strtoul((const char*)(argv[2]), (char **)NULL, 16);
a000f770:	8e040008 	lw	a0,8(s0)
a000f774:	00002821 	move	a1,zero
a000f778:	0c0020c4 	jal	a0008310 <strtoul>
a000f77c:	24060010 	li	a2,16

    rtl8651_setAsicEthernetPHYReg( phyid, regnum, data );
a000f780:	02202021 	move	a0,s1
a000f784:	02402821 	move	a1,s2
a000f788:	0c000941 	jal	a0002504 <rtl8651_setAsicEthernetPHYReg>
a000f78c:	00403021 	move	a2,v0
    rtl8651_getAsicEthernetPHYReg( phyid, regnum, &tmp );
a000f790:	02202021 	move	a0,s1
a000f794:	02402821 	move	a1,s2
a000f798:	0c000933 	jal	a00024cc <rtl8651_getAsicEthernetPHYReg>
a000f79c:	27a60010 	addiu	a2,sp,16
    uid=tmp;
    dprintf("PHYID=0x%x ,regID=0x%x, read back data=0x%x\r\n", phyid, regnum, uid);
a000f7a0:	3c04a001 	lui	a0,0xa001
a000f7a4:	24846bbc 	addiu	a0,a0,27580
a000f7a8:	02202821 	move	a1,s1
a000f7ac:	02403021 	move	a2,s2
a000f7b0:	0c002325 	jal	a0008c94 <dprintf>
a000f7b4:	8fa70010 	lw	a3,16(sp)
	return 0;
}
a000f7b8:	00001021 	move	v0,zero
a000f7bc:	8fbf0024 	lw	ra,36(sp)
a000f7c0:	8fb20020 	lw	s2,32(sp)
a000f7c4:	8fb1001c 	lw	s1,28(sp)
a000f7c8:	8fb00018 	lw	s0,24(sp)
a000f7cc:	03e00008 	jr	ra
a000f7d0:	27bd0028 	addiu	sp,sp,40

a000f7d4 <TestCmd_MDIOW>:
	}
	return 0;
}

int TestCmd_MDIOW( int argc, char* argv[] )
{
a000f7d4:	27bdffe0 	addiu	sp,sp,-32
a000f7d8:	afbf001c 	sw	ra,28(sp)
a000f7dc:	afb20018 	sw	s2,24(sp)
a000f7e0:	afb10014 	sw	s1,20(sp)
a000f7e4:	afb00010 	sw	s0,16(sp)
	if(argc < 3) {
a000f7e8:	28840003 	slti	a0,a0,3
a000f7ec:	10800006 	beqz	a0,a000f808 <TestCmd_MDIOW+0x34>
a000f7f0:	00a08021 	move	s0,a1
		printf("Parameters not enough!\n");
a000f7f4:	3c04a001 	lui	a0,0xa001
a000f7f8:	0c002325 	jal	a0008c94 <dprintf>
a000f7fc:	248467a0 	addiu	a0,a0,26528
		return 1;
a000f800:	08003e1c 	j	a000f870 <TestCmd_MDIOW+0x9c>
a000f804:	24020001 	li	v0,1
	}
	
	unsigned int phyid = strtoul((const char*)(argv[0]), (char **)NULL, 16);		
a000f808:	8ca40000 	lw	a0,0(a1)
a000f80c:	00002821 	move	a1,zero
a000f810:	0c0020c4 	jal	a0008310 <strtoul>
a000f814:	24060010 	li	a2,16
a000f818:	00408821 	move	s1,v0
	unsigned int reg = strtoul((const char*)(argv[1]), (char **)NULL, 10);		
a000f81c:	8e040004 	lw	a0,4(s0)
a000f820:	00002821 	move	a1,zero
a000f824:	0c0020c4 	jal	a0008310 <strtoul>
a000f828:	2406000a 	li	a2,10
a000f82c:	00409021 	move	s2,v0
	unsigned int data = strtoul((const char*)(argv[2]), (char **)NULL, 16);		
a000f830:	8e040008 	lw	a0,8(s0)
a000f834:	00002821 	move	a1,zero
a000f838:	0c0020c4 	jal	a0008310 <strtoul>
a000f83c:	24060010 	li	a2,16
a000f840:	00408021 	move	s0,v0

	dprintf("Write PhyID=0x%x Reg=%02d data=0x%x\r\n",phyid, reg,data);
a000f844:	3c04a001 	lui	a0,0xa001
a000f848:	24846bec 	addiu	a0,a0,27628
a000f84c:	02202821 	move	a1,s1
a000f850:	02403021 	move	a2,s2
a000f854:	0c002325 	jal	a0008c94 <dprintf>
a000f858:	00403821 	move	a3,v0
	rtl8651_setAsicEthernetPHYReg(phyid,reg,data); 
a000f85c:	02202021 	move	a0,s1
a000f860:	02402821 	move	a1,s2
a000f864:	0c000941 	jal	a0002504 <rtl8651_setAsicEthernetPHYReg>
a000f868:	02003021 	move	a2,s0
a000f86c:	00001021 	move	v0,zero

	return 0;
}
a000f870:	8fbf001c 	lw	ra,28(sp)
a000f874:	8fb20018 	lw	s2,24(sp)
a000f878:	8fb10014 	lw	s1,20(sp)
a000f87c:	8fb00010 	lw	s0,16(sp)
a000f880:	03e00008 	jr	ra
a000f884:	27bd0020 	addiu	sp,sp,32

a000f888 <CmdTest>:

}
//============================================================================

int CmdTest(int argc, char* argv[])
{
a000f888:	27bdffc8 	addiu	sp,sp,-56
a000f88c:	afbf0034 	sw	ra,52(sp)
a000f890:	afb60030 	sw	s6,48(sp)
a000f894:	afb5002c 	sw	s5,44(sp)
a000f898:	afb40028 	sw	s4,40(sp)
a000f89c:	afb30024 	sw	s3,36(sp)
a000f8a0:	afb20020 	sw	s2,32(sp)
a000f8a4:	afb1001c 	sw	s1,28(sp)
a000f8a8:	afb00018 	sw	s0,24(sp)


#if 1
	int i,j,s,size,loop,st=0,ed=0;

	if( argc < 1 ) 
a000f8ac:	1c800006 	bgtz	a0,a000f8c8 <CmdTest+0x40>
a000f8b0:	00a08021 	move	s0,a1
	{
		dprintf("Usage: test <len> <loop>\n");		
a000f8b4:	3c04a001 	lui	a0,0xa001
a000f8b8:	0c002325 	jal	a0008c94 <dprintf>
a000f8bc:	24846c14 	addiu	a0,a0,27668
		return;	
a000f8c0:	08003e60 	j	a000f980 <CmdTest+0xf8>
a000f8c4:	8fbf0034 	lw	ra,52(sp)
	}
	size = strtoul((const char*)(argv[0]), (char **)NULL, 16);
a000f8c8:	8ca40000 	lw	a0,0(a1)
a000f8cc:	00002821 	move	a1,zero
a000f8d0:	0c0020c4 	jal	a0008310 <strtoul>
a000f8d4:	24060010 	li	a2,16
a000f8d8:	0040a821 	move	s5,v0
	loop = strtoul((const char*)(argv[1]), (char **)NULL, 16);
a000f8dc:	8e040004 	lw	a0,4(s0)
a000f8e0:	00002821 	move	a1,zero
a000f8e4:	0c0020c4 	jal	a0008310 <strtoul>
a000f8e8:	24060010 	li	a2,16



	flush_cache();
a000f8ec:	0c001eae 	jal	a0007ab8 <flush_cache>
a000f8f0:	00409821 	move	s3,v0
a000f8f4:	40098002 	mfc0	t1,c0_config2
	//disable L2
	s=(1<<12);
	write_32bit_cp0_register_sel(16, s, 2);
	printf("Disable L2 cache\n");
#else
	s=read_32bit_cp0_register_sel(16,  2);
a000f8f8:	01292825 	or	a1,t1,t1
	printf("L2 cache ByPass=%d\n", (s&(1<<12))>>12);
a000f8fc:	3c04a001 	lui	a0,0xa001
a000f900:	24846c30 	addiu	a0,a0,27696
a000f904:	0c002325 	jal	a0008c94 <dprintf>
a000f908:	7ca50300 	ext	a1,a1,0xc,0x1
#endif

	for(j=0; j<loop; j++)
a000f90c:	1a60001b 	blez	s3,a000f97c <CmdTest+0xf4>
a000f910:	00008821 	move	s1,zero
	{
		st=jiffies;
a000f914:	3c12a002 	lui	s2,0xa002
		for(i=0x80300000;i<0x80300000+size; i+=4)    //seq
		{
			REG32(i)=REG32(i);
		}
*/
		for(i=0x80300000;i<0x80300000+size; i+=32)   //cacheline
a000f918:	3c148030 	lui	s4,0x8030
a000f91c:	02b48021 	addu	s0,s5,s4
a000f920:	36950001 	ori	s5,s4,0x1
a000f924:	0215a82b 	sltu	s5,s0,s5
			REG32(i)=REG32(i);
		}

		
		ed=jiffies;
		printf("loop=%d, st=%d, ed=%d, spend j=%d\n", j, st,ed,ed-st);		
a000f928:	3c16a001 	lui	s6,0xa001
a000f92c:	26d66c44 	addiu	s6,s6,27716
	printf("L2 cache ByPass=%d\n", (s&(1<<12))>>12);
#endif

	for(j=0; j<loop; j++)
	{
		st=jiffies;
a000f930:	8e468960 	lw	a2,-30368(s2)
		for(i=0x80300000;i<0x80300000+size; i+=4)    //seq
		{
			REG32(i)=REG32(i);
		}
*/
		for(i=0x80300000;i<0x80300000+size; i+=32)   //cacheline
a000f934:	16a00007 	bnez	s5,a000f954 <CmdTest+0xcc>
a000f938:	02801021 	move	v0,s4
		{
			REG32(i)=REG32(i);
a000f93c:	8c430000 	lw	v1,0(v0)
a000f940:	ac430000 	sw	v1,0(v0)
		for(i=0x80300000;i<0x80300000+size; i+=4)    //seq
		{
			REG32(i)=REG32(i);
		}
*/
		for(i=0x80300000;i<0x80300000+size; i+=32)   //cacheline
a000f944:	24420020 	addiu	v0,v0,32
a000f948:	0050182b 	sltu	v1,v0,s0
a000f94c:	1460fffb 	bnez	v1,a000f93c <CmdTest+0xb4>
a000f950:	00000000 	nop
		{
			REG32(i)=REG32(i);
		}

		
		ed=jiffies;
a000f954:	8e478960 	lw	a3,-30368(s2)
		printf("loop=%d, st=%d, ed=%d, spend j=%d\n", j, st,ed,ed-st);		
a000f958:	00e61023 	subu	v0,a3,a2
a000f95c:	afa20010 	sw	v0,16(sp)
a000f960:	02c02021 	move	a0,s6
a000f964:	0c002325 	jal	a0008c94 <dprintf>
a000f968:	02202821 	move	a1,s1
#else
	s=read_32bit_cp0_register_sel(16,  2);
	printf("L2 cache ByPass=%d\n", (s&(1<<12))>>12);
#endif

	for(j=0; j<loop; j++)
a000f96c:	26310001 	addiu	s1,s1,1
a000f970:	0233102a 	slt	v0,s1,s3
a000f974:	1440ffee 	bnez	v0,a000f930 <CmdTest+0xa8>
a000f978:	00000000 	nop

	
#endif

	
}
a000f97c:	8fbf0034 	lw	ra,52(sp)
a000f980:	8fb60030 	lw	s6,48(sp)
a000f984:	8fb5002c 	lw	s5,44(sp)
a000f988:	8fb40028 	lw	s4,40(sp)
a000f98c:	8fb30024 	lw	s3,36(sp)
a000f990:	8fb20020 	lw	s2,32(sp)
a000f994:	8fb1001c 	lw	s1,28(sp)
a000f998:	8fb00018 	lw	s0,24(sp)
a000f99c:	03e00008 	jr	ra
a000f9a0:	27bd0038 	addiu	sp,sp,56

a000f9a4 <CmdXModem>:
//==============================================================

//------------------------------------------------------------------------
#ifndef CONFIG_RTL8196E
int CmdXModem(int argc, char* argv[])
{
a000f9a4:	27bdffd8 	addiu	sp,sp,-40
a000f9a8:	afbf0024 	sw	ra,36(sp)
a000f9ac:	afb30020 	sw	s3,32(sp)
a000f9b0:	afb2001c 	sw	s2,28(sp)
a000f9b4:	afb10018 	sw	s1,24(sp)
a000f9b8:	afb00014 	sw	s0,20(sp)
a000f9bc:	00808021 	move	s0,a0
	unsigned char *load_buf = (char*)0x80300000;
	unsigned int jump=0;
	//unsigned char *dest_buf = (char*)0xbd000000;

	if( argc < 1 ) 
a000f9c0:	1c800006 	bgtz	a0,a000f9dc <CmdXModem+0x38>
a000f9c4:	00a08821 	move	s1,a1
	{
		dprintf("Usage: xmodem <buf_addr> [jump]\n");		
a000f9c8:	3c04a001 	lui	a0,0xa001
a000f9cc:	0c002325 	jal	a0008c94 <dprintf>
a000f9d0:	24846c68 	addiu	a0,a0,27752
		flush_cache(); 
		prom_printf("\nJump to.......\n");

		jumpF();
	}
}; 
a000f9d4:	08003ea6 	j	a000fa98 <CmdXModem+0xf4>
a000f9d8:	8fbf0024 	lw	ra,36(sp)
	if( argc < 1 ) 
	{
		dprintf("Usage: xmodem <buf_addr> [jump]\n");		
		return;	
	}
	load_buf = strtoul((const char*)(argv[0]), (char **)NULL, 16);
a000f9dc:	8ca40000 	lw	a0,0(a1)
a000f9e0:	00002821 	move	a1,zero
a000f9e4:	0c0020c4 	jal	a0008310 <strtoul>
a000f9e8:	24060010 	li	a2,16
a000f9ec:	00409021 	move	s2,v0
	
	if(argc>1)	
a000f9f0:	2a100002 	slti	s0,s0,2
a000f9f4:	16000006 	bnez	s0,a000fa10 <CmdXModem+0x6c>
a000f9f8:	00009821 	move	s3,zero
	jump = strtoul((const char*)(argv[1]), (char **)NULL, 16);	
a000f9fc:	8e240004 	lw	a0,4(s1)
a000fa00:	00002821 	move	a1,zero
a000fa04:	0c0020c4 	jal	a0008310 <strtoul>
a000fa08:	24060010 	li	a2,16
a000fa0c:	00409821 	move	s3,v0
	

	int len;
	len=xmodem_receive(load_buf);
a000fa10:	0c0035b5 	jal	a000d6d4 <xmodem_receive>
a000fa14:	02402021 	move	a0,s2
		if(len!=0)
a000fa18:	10400007 	beqz	v0,a000fa38 <CmdXModem+0x94>
a000fa1c:	00408021 	move	s0,v0
		{	printf("Rx len=%d \n", len);			
a000fa20:	3c04a001 	lui	a0,0xa001
a000fa24:	24846c8c 	addiu	a0,a0,27788
a000fa28:	0c002325 	jal	a0008c94 <dprintf>
a000fa2c:	00402821 	move	a1,v0
a000fa30:	08003ea5 	j	a000fa94 <CmdXModem+0xf0>
a000fa34:	02001021 	move	v0,s0
			return  len;			
		}
		else
			printf("Download failed!!\n");
a000fa38:	3c04a001 	lui	a0,0xa001
a000fa3c:	0c002325 	jal	a0008c94 <dprintf>
a000fa40:	24846c98 	addiu	a0,a0,27800


	if(jump)
a000fa44:	12600014 	beqz	s3,a000fa98 <CmdXModem+0xf4>
a000fa48:	8fbf0024 	lw	ra,36(sp)
	{	
		void (*jumpF)(void);
		jumpF = (void *)(load_buf);
	
		REG32(GIMR_REG)=0; // mask all interrupt	    
a000fa4c:	3c02b800 	lui	v0,0xb800
a000fa50:	34423000 	ori	v0,v0,0x3000
a000fa54:	ac400000 	sw	zero,0(v0)
a000fa58:	40016000 	mfc0	at,c0_status
a000fa5c:	34210001 	ori	at,at,0x1
a000fa60:	38210001 	xori	at,at,0x1
a000fa64:	40816000 	mtc0	at,c0_status
a000fa68:	000000c0 	ehb
	...
		cli();
	
		flush_cache(); 
a000fa78:	0c001eae 	jal	a0007ab8 <flush_cache>
a000fa7c:	00000000 	nop
		prom_printf("\nJump to.......\n");
a000fa80:	3c04a001 	lui	a0,0xa001
a000fa84:	0c0023a7 	jal	a0008e9c <prom_printf>
a000fa88:	24846cac 	addiu	a0,a0,27820

		jumpF();
a000fa8c:	0240f809 	jalr	s2
a000fa90:	00000000 	nop
	}
}; 
a000fa94:	8fbf0024 	lw	ra,36(sp)
a000fa98:	8fb30020 	lw	s3,32(sp)
a000fa9c:	8fb2001c 	lw	s2,28(sp)
a000faa0:	8fb10018 	lw	s1,24(sp)
a000faa4:	8fb00014 	lw	s0,20(sp)
a000faa8:	03e00008 	jr	ra
a000faac:	27bd0028 	addiu	sp,sp,40

a000fab0 <MxSpdupThanLexra>:
//==============================================================



void MxSpdupThanLexra()
{
a000fab0:	27bdffe8 	addiu	sp,sp,-24
a000fab4:	afbf0014 	sw	ra,20(sp)

	//printf("MxSpdupThanLexra\n");

	#define GET_BITVAL(v,bitpos,pat) ((v& ((unsigned int)pat<<bitpos))>>bitpos)
	#define RANG5  0x1f
	unsigned char m2x_freq_sel=GET_BITVAL(REG32(SYS_HW_STRAP), 10, RANG5);
a000fab8:	3c02b800 	lui	v0,0xb800
a000fabc:	34420008 	ori	v0,v0,0x8
a000fac0:	8c420000 	lw	v0,0(v0)
	

	if(m2x_freq_sel>= 0x0f)           // M2x > lexra=200M   
a000fac4:	7c422280 	ext	v0,v0,0xa,0x5
a000fac8:	2c42000f 	sltiu	v0,v0,15
a000facc:	14400026 	bnez	v0,a000fb68 <MxSpdupThanLexra+0xb8>
a000fad0:	8fbf0014 	lw	ra,20(sp)
		printf("Mx clk > Lexra clk\n");
a000fad4:	3c04a001 	lui	a0,0xa001
a000fad8:	0c002325 	jal	a0008c94 <dprintf>
a000fadc:	24846cc0 	addiu	a0,a0,27840
	else
		return ;

	//-------------------------
  	request_IRQ(8, &irq_timer, NULL); 
a000fae0:	24040008 	li	a0,8
a000fae4:	3c05a001 	lui	a1,0xa001
a000fae8:	24a57680 	addiu	a1,a1,30336
a000faec:	0c000274 	jal	a00009d0 <request_IRQ>
a000faf0:	00003021 	move	a2,zero


	extern long glexra_clock;
       timer_init(glexra_clock);	   //run 10msec
a000faf4:	3c02a001 	lui	v0,0xa001
a000faf8:	0c0038f0 	jal	a000e3c0 <timer_init>
a000fafc:	8c447670 	lw	a0,30320(v0)
	//--------------------------
	
	#define SYS_HS0_CTRL 0xb80000a0
	#define BIT(x)	(1 << x)	
	REG32(SYS_HS0_CTRL) |= BIT(0) | BIT(1) | BIT(2);   // LX0 > Mx clock
a000fb00:	3c02b800 	lui	v0,0xb800
a000fb04:	344300a0 	ori	v1,v0,0xa0
a000fb08:	8c640000 	lw	a0,0(v1)
a000fb0c:	34840007 	ori	a0,a0,0x7
a000fb10:	ac640000 	sw	a0,0(v1)
	
	
		#if 1			
			//printf("llx0\n");
			REG32(SYS_BIST_CTRL) |= (1<<2) ;	  //lock bus arb2
a000fb14:	34420014 	ori	v0,v0,0x14
a000fb18:	8c430000 	lw	v1,0(v0)
a000fb1c:	34630004 	ori	v1,v1,0x4
a000fb20:	ac430000 	sw	v1,0(v0)
			while( (REG32(SYS_BIST_DONE)&(1<<0))==0)  {}; //wait bit to 1, is mean lock ok	
a000fb24:	3c03b800 	lui	v1,0xb800
a000fb28:	34630020 	ori	v1,v1,0x20
a000fb2c:	8c620000 	lw	v0,0(v1)
a000fb30:	30420001 	andi	v0,v0,0x1
a000fb34:	1040fffd 	beqz	v0,a000fb2c <MxSpdupThanLexra+0x7c>
a000fb38:	3c02b800 	lui	v0,0xb800
	//	__asm__ volatile("nop");


		#if 1
			//printf("ulx0\n");	
			REG32(SYS_BIST_CTRL) &= ~(1<<2);	//unlock
a000fb3c:	34420014 	ori	v0,v0,0x14
a000fb40:	8c440000 	lw	a0,0(v0)
a000fb44:	2403fffb 	li	v1,-5
a000fb48:	00831824 	and	v1,a0,v1
a000fb4c:	ac430000 	sw	v1,0(v0)
			while( (REG32(SYS_BIST_DONE)&(1<<0))==(1<<0)) {};  //wait bit to 0  unlock
a000fb50:	3c03b800 	lui	v1,0xb800
a000fb54:	34630020 	ori	v1,v1,0x20
a000fb58:	8c620000 	lw	v0,0(v1)
a000fb5c:	30420001 	andi	v0,v0,0x1
a000fb60:	1440fffd 	bnez	v0,a000fb58 <MxSpdupThanLexra+0xa8>
a000fb64:	8fbf0014 	lw	ra,20(sp)
			//while( (REG32(SYS_BIST_DONE)&(1<<2))==(1<<2)) {};  //wait bit to 0  unlock				
		#endif

			//printf("done\n");

}
a000fb68:	03e00008 	jr	ra
a000fb6c:	27bd0018 	addiu	sp,sp,24

a000fb70 <check_cpu_speed>:
#else
unsigned long loops_per_sec = 0x1db000 * HZ;	// @CPU 390MHz, DDR 195 MHz (this will be update in check_cpu_speed())
#endif

int check_cpu_speed(void)
{
a000fb70:	27bdffd8 	addiu	sp,sp,-40
a000fb74:	afbf0024 	sw	ra,36(sp)
a000fb78:	afb20020 	sw	s2,32(sp)
a000fb7c:	afb1001c 	sw	s1,28(sp)
a000fb80:	afb00018 	sw	s0,24(sp)

	unsigned volatile long ticks, loopbit;
	int lps_precision = LPS_PREC;
      
  // RTL8198
  	request_IRQ(14, &irq_timer, NULL); 
a000fb84:	2404000e 	li	a0,14
a000fb88:	3c05a001 	lui	a1,0xa001
a000fb8c:	24a57680 	addiu	a1,a1,30336
a000fb90:	0c000274 	jal	a00009d0 <request_IRQ>
a000fb94:	00003021 	move	a2,zero

	extern long glexra_clock;
//	printf("timer init\n");
    timer_init(glexra_clock);	
a000fb98:	3c02a001 	lui	v0,0xa001
a000fb9c:	0c0038f0 	jal	a000e3c0 <timer_init>
a000fba0:	8c447670 	lw	a0,30320(v0)

//return 999;

	loops_per_jiffy = (1<<12);
a000fba4:	24031000 	li	v1,4096
a000fba8:	3c02a001 	lui	v0,0xa001
a000fbac:	ac43793c 	sw	v1,31036(v0)
	while (loops_per_jiffy <<= 1) {
a000fbb0:	00408821 	move	s1,v0
a000fbb4:	08003f01 	j	a000fc04 <check_cpu_speed+0x94>
a000fbb8:	3c10a002 	lui	s0,0xa002
		/* wait for "start of" clock tick */
		ticks = jiffies;
a000fbbc:	8e028960 	lw	v0,-30368(s0)
a000fbc0:	afa20010 	sw	v0,16(sp)
		while (ticks == jiffies)
a000fbc4:	8fa30010 	lw	v1,16(sp)
a000fbc8:	8e028960 	lw	v0,-30368(s0)
a000fbcc:	1062fffd 	beq	v1,v0,a000fbc4 <check_cpu_speed+0x54>
a000fbd0:	00000000 	nop
			/* nothing */;
		/* Go .. */
		ticks = jiffies;
a000fbd4:	8e028960 	lw	v0,-30368(s0)
a000fbd8:	afa20010 	sw	v0,16(sp)
		__delay(loops_per_jiffy);
a000fbdc:	8e24793c 	lw	a0,31036(s1)
a000fbe0:	0c0038dc 	jal	a000e370 <__delay>
a000fbe4:	00000000 	nop
		ticks = jiffies - ticks;
a000fbe8:	8e038960 	lw	v1,-30368(s0)
a000fbec:	8fa20010 	lw	v0,16(sp)
a000fbf0:	00621023 	subu	v0,v1,v0
a000fbf4:	afa20010 	sw	v0,16(sp)
		if (ticks)
a000fbf8:	8fa20010 	lw	v0,16(sp)
a000fbfc:	14400007 	bnez	v0,a000fc1c <check_cpu_speed+0xac>
a000fc00:	3c02a001 	lui	v0,0xa001
    timer_init(glexra_clock);	

//return 999;

	loops_per_jiffy = (1<<12);
	while (loops_per_jiffy <<= 1) {
a000fc04:	8e22793c 	lw	v0,31036(s1)
a000fc08:	00021040 	sll	v0,v0,0x1
a000fc0c:	ae22793c 	sw	v0,31036(s1)
a000fc10:	8e22793c 	lw	v0,31036(s1)
a000fc14:	1440ffe9 	bnez	v0,a000fbbc <check_cpu_speed+0x4c>
a000fc18:	3c02a001 	lui	v0,0xa001
		if (ticks)
			break;
	}
/* Do a binary approximation to get loops_per_jiffy set to equal one clock
   (up to lps_precision bits) */
	loops_per_jiffy >>= 1;
a000fc1c:	8c43793c 	lw	v1,31036(v0)
a000fc20:	00031842 	srl	v1,v1,0x1
a000fc24:	ac43793c 	sw	v1,31036(v0)
	loopbit = loops_per_jiffy;
a000fc28:	8c42793c 	lw	v0,31036(v0)
a000fc2c:	afa20014 	sw	v0,20(sp)
a000fc30:	24120007 	li	s2,7
	while ( lps_precision-- && (loopbit >>= 1) ) 
	{
		loops_per_jiffy |= loopbit;
a000fc34:	3c11a001 	lui	s1,0xa001
		ticks = jiffies;
a000fc38:	08003f2a 	j	a000fca8 <check_cpu_speed+0x138>
a000fc3c:	3c10a002 	lui	s0,0xa002
   (up to lps_precision bits) */
	loops_per_jiffy >>= 1;
	loopbit = loops_per_jiffy;
	while ( lps_precision-- && (loopbit >>= 1) ) 
	{
		loops_per_jiffy |= loopbit;
a000fc40:	8e22793c 	lw	v0,31036(s1)
a000fc44:	8fa30014 	lw	v1,20(sp)
a000fc48:	00621025 	or	v0,v1,v0
a000fc4c:	ae22793c 	sw	v0,31036(s1)
		ticks = jiffies;
a000fc50:	8e028960 	lw	v0,-30368(s0)
a000fc54:	afa20010 	sw	v0,16(sp)
		while (ticks == jiffies);
a000fc58:	8fa30010 	lw	v1,16(sp)
a000fc5c:	8e028960 	lw	v0,-30368(s0)
a000fc60:	1062fffd 	beq	v1,v0,a000fc58 <check_cpu_speed+0xe8>
a000fc64:	00000000 	nop
		ticks = jiffies;
a000fc68:	8e028960 	lw	v0,-30368(s0)
a000fc6c:	afa20010 	sw	v0,16(sp)
		__delay(loops_per_jiffy);
a000fc70:	8e24793c 	lw	a0,31036(s1)
a000fc74:	0c0038dc 	jal	a000e370 <__delay>
a000fc78:	00000000 	nop
		if (jiffies != ticks)	/* longer than 1 tick */
a000fc7c:	8e038960 	lw	v1,-30368(s0)
a000fc80:	8fa20010 	lw	v0,16(sp)
a000fc84:	10620006 	beq	v1,v0,a000fca0 <check_cpu_speed+0x130>
a000fc88:	00000000 	nop
			loops_per_jiffy &= ~loopbit;
a000fc8c:	8fa20014 	lw	v0,20(sp)
a000fc90:	8e23793c 	lw	v1,31036(s1)
a000fc94:	00021027 	nor	v0,zero,v0
a000fc98:	00431024 	and	v0,v0,v1
a000fc9c:	ae22793c 	sw	v0,31036(s1)
	}
/* Do a binary approximation to get loops_per_jiffy set to equal one clock
   (up to lps_precision bits) */
	loops_per_jiffy >>= 1;
	loopbit = loops_per_jiffy;
	while ( lps_precision-- && (loopbit >>= 1) ) 
a000fca0:	12400007 	beqz	s2,a000fcc0 <check_cpu_speed+0x150>
a000fca4:	2652ffff 	addiu	s2,s2,-1
a000fca8:	8fa20014 	lw	v0,20(sp)
a000fcac:	00021042 	srl	v0,v0,0x1
a000fcb0:	afa20014 	sw	v0,20(sp)
a000fcb4:	8fa20014 	lw	v0,20(sp)
a000fcb8:	1440ffe1 	bnez	v0,a000fc40 <check_cpu_speed+0xd0>
a000fcbc:	00000000 	nop
	
	//timer_stop();	//wei del, because not close timer
	//free_IRQ(8);
	//prom_printf("cpu run %d.%d MIPS\n", loops_per_jiffy/(500000/HZ),      (loops_per_jiffy/(5000/HZ)) % 100);
//	return ((loops_per_jiffy/(500000/HZ))+1);
	return ((loops_per_jiffy/(500000/HZ))+1)*2;	 //for 1074k 
a000fcc0:	3c02a001 	lui	v0,0xa001
a000fcc4:	8c43793c 	lw	v1,31036(v0)
a000fcc8:	3c02d1b7 	lui	v0,0xd1b7
a000fccc:	34421759 	ori	v0,v0,0x1759
a000fcd0:	00620019 	multu	v1,v0
a000fcd4:	00001010 	mfhi	v0
a000fcd8:	00021302 	srl	v0,v0,0xc
a000fcdc:	24420001 	addiu	v0,v0,1
	
}
a000fce0:	00021040 	sll	v0,v0,0x1
a000fce4:	8fbf0024 	lw	ra,36(sp)
a000fce8:	8fb20020 	lw	s2,32(sp)
a000fcec:	8fb1001c 	lw	s1,28(sp)
a000fcf0:	8fb00018 	lw	s0,24(sp)
a000fcf4:	03e00008 	jr	ra
a000fcf8:	27bd0028 	addiu	sp,sp,40

a000fcfc <CmdTimerInit>:


//============================================================================

int CmdTimerInit(int argc, char* argv[])
{
a000fcfc:	27bdffe8 	addiu	sp,sp,-24
a000fd00:	afbf0014 	sw	ra,20(sp)
		}
	}
#endif
	
#else
	int clk=check_cpu_speed();
a000fd04:	0c003edc 	jal	a000fb70 <check_cpu_speed>
a000fd08:	00000000 	nop
	printf("CPU=%d MHz\n", clk);
a000fd0c:	3c04a001 	lui	a0,0xa001
a000fd10:	24846cd4 	addiu	a0,a0,27860
a000fd14:	0c002325 	jal	a0008c94 <dprintf>
a000fd18:	00402821 	move	a1,v0
#endif




}
a000fd1c:	8fbf0014 	lw	ra,20(sp)
a000fd20:	03e00008 	jr	ra
a000fd24:	27bd0018 	addiu	sp,sp,24

a000fd28 <CmdDumpByte>:

}

//---------------------------------------------------------------------------
int CmdDumpByte( int argc, char* argv[] )
{
a000fd28:	27bdffe0 	addiu	sp,sp,-32
a000fd2c:	afbf001c 	sw	ra,28(sp)
a000fd30:	afb10018 	sw	s1,24(sp)
a000fd34:	afb00014 	sw	s0,20(sp)
	
	unsigned long src;
	unsigned int len,i;

	if(argc<1)
a000fd38:	1c800006 	bgtz	a0,a000fd54 <CmdDumpByte+0x2c>
a000fd3c:	00a08021 	move	s0,a1
	{	dprintf("Wrong argument number!\r\n");
a000fd40:	3c04a001 	lui	a0,0xa001
a000fd44:	0c002325 	jal	a0008c94 <dprintf>
a000fd48:	24846990 	addiu	a0,a0,27024
		return;
a000fd4c:	08003f64 	j	a000fd90 <CmdDumpByte+0x68>
a000fd50:	8fbf001c 	lw	ra,28(sp)
	}
	
	src = strtoul((const char*)(argv[0]), (char **)NULL, 16);		
a000fd54:	8ca40000 	lw	a0,0(a1)
a000fd58:	00002821 	move	a1,zero
a000fd5c:	0c0020c4 	jal	a0008310 <strtoul>
a000fd60:	24060010 	li	a2,16
a000fd64:	00408821 	move	s1,v0
	if(!argv[1])
a000fd68:	8e040004 	lw	a0,4(s0)
a000fd6c:	10800005 	beqz	a0,a000fd84 <CmdDumpByte+0x5c>
a000fd70:	24050010 	li	a1,16
		len = 16;
	else
	len= strtoul((const char*)(argv[1]), (char **)NULL, 10);			
a000fd74:	00002821 	move	a1,zero
a000fd78:	0c0020c4 	jal	a0008310 <strtoul>
a000fd7c:	2406000a 	li	a2,10
a000fd80:	00402821 	move	a1,v0


	ddump((unsigned char *)src,len);
a000fd84:	0c002332 	jal	a0008cc8 <ddump>
a000fd88:	02202021 	move	a0,s1
}
a000fd8c:	8fbf001c 	lw	ra,28(sp)
a000fd90:	8fb10018 	lw	s1,24(sp)
a000fd94:	8fb00014 	lw	s0,20(sp)
a000fd98:	03e00008 	jr	ra
a000fd9c:	27bd0020 	addiu	sp,sp,32

a000fda0 <CmdIp>:
//---------------------------------------------------------------------------
/* This command can be used to configure host ip and target ip	*/

extern char eth0_mac[6];
int CmdIp(int argc, char* argv[])
{
a000fda0:	27bdffc8 	addiu	sp,sp,-56
a000fda4:	afbf0034 	sw	ra,52(sp)
a000fda8:	afb20030 	sw	s2,48(sp)
a000fdac:	afb1002c 	sw	s1,44(sp)
a000fdb0:	afb00028 	sw	s0,40(sp)
	unsigned char  *ptr;
	unsigned int i;
	int  ip[4];
	
	if (argc==0)
a000fdb4:	1480000d 	bnez	a0,a000fdec <CmdIp+0x4c>
a000fdb8:	27b10018 	addiu	s1,sp,24
	{	
		printf(" Target Address=%d.%d.%d.%d\n",
a000fdbc:	3c02a002 	lui	v0,0xa002
a000fdc0:	90458bf0 	lbu	a1,-29712(v0)
a000fdc4:	24428bf0 	addiu	v0,v0,-29712
a000fdc8:	90460001 	lbu	a2,1(v0)
a000fdcc:	90470002 	lbu	a3,2(v0)
a000fdd0:	90420003 	lbu	v0,3(v0)
a000fdd4:	afa20010 	sw	v0,16(sp)
a000fdd8:	3c04a001 	lui	a0,0xa001
a000fddc:	0c002325 	jal	a0008c94 <dprintf>
a000fde0:	24846ce0 	addiu	a0,a0,27872
#ifdef HTTP_SERVER
		printf("   Http Address=%d.%d.%d.%d\n",
		arptable_tftp[HTTPD_ARPENTRY].ipaddr.ip[0], arptable_tftp[HTTPD_ARPENTRY].ipaddr.ip[1], 
		arptable_tftp[HTTPD_ARPENTRY].ipaddr.ip[2], arptable_tftp[HTTPD_ARPENTRY].ipaddr.ip[3]);
#endif
		return;	 
a000fde4:	08003fa9 	j	a000fea4 <CmdIp+0x104>
a000fde8:	8fbf0034 	lw	ra,52(sp)
	}			
	
	ptr = argv[0];
a000fdec:	8cb00000 	lw	s0,0(a1)
#if defined(CONFIG_BOOT_DEBUG_ENABLE)	
//---------------------------------------------------------------------------
/* This command can be used to configure host ip and target ip	*/

extern char eth0_mac[6];
int CmdIp(int argc, char* argv[])
a000fdf0:	27b20028 	addiu	s2,sp,40
	
	ptr = argv[0];

	for(i=0; i< 4; i++)
	{
		ip[i]=strtol((const char *)ptr,(char **)NULL, 10);		
a000fdf4:	02002021 	move	a0,s0
a000fdf8:	00002821 	move	a1,zero
a000fdfc:	0c002090 	jal	a0008240 <strtol>
a000fe00:	2406000a 	li	a2,10
a000fe04:	ae220000 	sw	v0,0(s1)
		ptr = strchr(ptr, '.');
a000fe08:	02002021 	move	a0,s0
a000fe0c:	0c00201f 	jal	a000807c <strchr>
a000fe10:	2405002e 	li	a1,46
		ptr++;
a000fe14:	26310004 	addiu	s1,s1,4
		return;	 
	}			
	
	ptr = argv[0];

	for(i=0; i< 4; i++)
a000fe18:	1632fff6 	bne	s1,s2,a000fdf4 <CmdIp+0x54>
a000fe1c:	24500001 	addiu	s0,v0,1
	{
		ip[i]=strtol((const char *)ptr,(char **)NULL, 10);		
		ptr = strchr(ptr, '.');
		ptr++;
	}
	arptable_tftp[TFTP_SERVER].ipaddr.ip[0]=ip[0];
a000fe20:	8fa50018 	lw	a1,24(sp)
a000fe24:	3c02a002 	lui	v0,0xa002
a000fe28:	a0458bf0 	sb	a1,-29712(v0)
	arptable_tftp[TFTP_SERVER].ipaddr.ip[1]=ip[1];
a000fe2c:	8fa6001c 	lw	a2,28(sp)
a000fe30:	24428bf0 	addiu	v0,v0,-29712
a000fe34:	a0460001 	sb	a2,1(v0)
	arptable_tftp[TFTP_SERVER].ipaddr.ip[2]=ip[2];
a000fe38:	8fa70020 	lw	a3,32(sp)
a000fe3c:	a0470002 	sb	a3,2(v0)
	arptable_tftp[TFTP_SERVER].ipaddr.ip[3]=ip[3];
a000fe40:	8fa40024 	lw	a0,36(sp)
a000fe44:	a0440003 	sb	a0,3(v0)
/*replace the MAC address middle 4 bytes.*/
	eth0_mac[1]=ip[0];
a000fe48:	7c054c20 	seb	t1,a1
a000fe4c:	3c08a001 	lui	t0,0xa001
a000fe50:	250374f0 	addiu	v1,t0,29936
a000fe54:	a0690001 	sb	t1,1(v1)
	eth0_mac[2]=ip[1];
a000fe58:	7c065420 	seb	t2,a2
a000fe5c:	a06a0002 	sb	t2,2(v1)
	eth0_mac[3]=ip[2];
a000fe60:	7c075c20 	seb	t3,a3
a000fe64:	a06b0003 	sb	t3,3(v1)
	eth0_mac[4]=ip[3];
a000fe68:	7c046420 	seb	t4,a0
a000fe6c:	a06c0004 	sb	t4,4(v1)
	arptable_tftp[TFTP_SERVER].node[5]=eth0_mac[5];
a000fe70:	90630005 	lbu	v1,5(v1)
a000fe74:	a0430009 	sb	v1,9(v0)
	arptable_tftp[TFTP_SERVER].node[4]=eth0_mac[4];
a000fe78:	a04c0008 	sb	t4,8(v0)
	arptable_tftp[TFTP_SERVER].node[3]=eth0_mac[3];
a000fe7c:	a04b0007 	sb	t3,7(v0)
	arptable_tftp[TFTP_SERVER].node[2]=eth0_mac[2];
a000fe80:	a04a0006 	sb	t2,6(v0)
	arptable_tftp[TFTP_SERVER].node[1]=eth0_mac[1];
a000fe84:	a0490005 	sb	t1,5(v0)
	arptable_tftp[TFTP_SERVER].node[0]=eth0_mac[0];
a000fe88:	910374f0 	lbu	v1,29936(t0)
a000fe8c:	a0430004 	sb	v1,4(v0)
	prom_printf("Now your Target IP is %d.%d.%d.%d\n", ip[0],ip[1],ip[2],ip[3]);
a000fe90:	afa40010 	sw	a0,16(sp)
a000fe94:	3c04a001 	lui	a0,0xa001
a000fe98:	0c0023a7 	jal	a0008e9c <prom_printf>
a000fe9c:	24846d00 	addiu	a0,a0,27904
	arptable[ARP_SERVER].ipaddr.ip[2]=ip[2];
	arptable[ARP_SERVER].ipaddr.ip[3]=ip[3];
	prom_printf("Now your Host IP is %d.%d.%d.%d\n", ip[0],ip[1],ip[2],ip[3]);
#endif	
		
}	
a000fea0:	8fbf0034 	lw	ra,52(sp)
a000fea4:	8fb20030 	lw	s2,48(sp)
a000fea8:	8fb1002c 	lw	s1,44(sp)
a000feac:	8fb00028 	lw	s0,40(sp)
a000feb0:	03e00008 	jr	ra
a000feb4:	27bd0038 	addiu	sp,sp,56

a000feb8 <CmdCfn>:



extern unsigned long ETH0_ADD;
int CmdCfn(int argc, char* argv[])
{
a000feb8:	27bdffe0 	addiu	sp,sp,-32
a000febc:	afbf001c 	sw	ra,28(sp)
a000fec0:	afb00018 	sw	s0,24(sp)
	unsigned long		Address;
	void	(*jump)(void);
	if( argc > 0 )
a000fec4:	1880000c 	blez	a0,a000fef8 <CmdCfn+0x40>
a000fec8:	3c04a001 	lui	a0,0xa001
	{
		if(!Hex2Val( argv[0], &Address ))
a000fecc:	8ca40000 	lw	a0,0(a1)
a000fed0:	0c00213e 	jal	a00084f8 <Hex2Val>
a000fed4:	27a50010 	addiu	a1,sp,16
a000fed8:	14400006 	bnez	v0,a000fef4 <CmdCfn+0x3c>
a000fedc:	00000000 	nop
		{
			printf(" Invalid Address(HEX) value.\n");
a000fee0:	3c04a001 	lui	a0,0xa001
a000fee4:	0c002325 	jal	a0008c94 <dprintf>
a000fee8:	24846d24 	addiu	a0,a0,27940
#endif
#endif
	//flush_cache();
	jump();	
	
}
a000feec:	08003fd4 	j	a000ff50 <CmdCfn+0x98>
a000fef0:	00001021 	move	v0,zero
			printf(" Invalid Address(HEX) value.\n");
			return FALSE ;
		}
	}

	dprintf("---Jump to address=%X\n",Address);
a000fef4:	3c04a001 	lui	a0,0xa001
a000fef8:	24846d44 	addiu	a0,a0,27972
a000fefc:	0c002325 	jal	a0008c94 <dprintf>
a000ff00:	8fa50010 	lw	a1,16(sp)
	jump = (void *)(Address);
a000ff04:	8fb00010 	lw	s0,16(sp)
a000ff08:	3c03b800 	lui	v1,0xb800
a000ff0c:	00001021 	move	v0,zero
a000ff10:	ac623000 	sw	v0,12288(v1)
a000ff14:	40016000 	mfc0	at,c0_status
a000ff18:	34210001 	ori	at,at,0x1
a000ff1c:	38210001 	xori	at,at,0x1
a000ff20:	40816000 	mtc0	at,c0_status
a000ff24:	000000c0 	ehb
	...
	outl(0,GIMR0); // mask all interrupt
	cli(); 
	flush_cache(); 
a000ff34:	0c001eae 	jal	a0007ab8 <flush_cache>
a000ff38:	00000000 	nop
	prom_printf("\nreboot.......\n");
a000ff3c:	3c04a001 	lui	a0,0xa001
a000ff40:	0c0023a7 	jal	a0008e9c <prom_printf>
a000ff44:	24844074 	addiu	a0,a0,16500
     	}
#endif
#endif
#endif
	//flush_cache();
	jump();	
a000ff48:	0200f809 	jalr	s0
a000ff4c:	00000000 	nop
	
}
a000ff50:	8fbf001c 	lw	ra,28(sp)
a000ff54:	8fb00018 	lw	s0,24(sp)
a000ff58:	03e00008 	jr	ra
a000ff5c:	27bd0020 	addiu	sp,sp,32
a000ff60:	a0001154 	sb	zero,4436(zero)
a000ff64:	a0001040 	sb	zero,4160(zero)
a000ff68:	a0001058 	sb	zero,4184(zero)
a000ff6c:	a00010d0 	sb	zero,4304(zero)
a000ff70:	a0001124 	sb	zero,4388(zero)
a000ff74:	a0001038 	sb	zero,4152(zero)
a000ff78:	a00010e8 	sb	zero,4328(zero)

a000ff7c <BootStateEvent>:
a000ff7c:	a0001220 a0000d9c a0001570 a00017bc     ... .......p....
a000ff8c:	a0001164 a0001164 a0001164 a0001164     ...d...d...d...d
a000ff9c:	a0001220 a0000d9c a0001570 a0000d80     ... .......p....
a000ffac:	a0001f3c a0001444 a0000d80 a0000d80     ...<...D........
a000ffbc:	a0001220 a0000d9c a0000d80 a00017bc     ... ............
a000ffcc:	a0001f3c a0001444 a0000d80 a0000d80     ...<...D........

a000ffdc <__FUNCTION__.2368>:
a000ffdc:	63686563 6b417574 6f466c61 7368696e     checkAutoFlashin
a000ffec:	67000000                                g...

a000fff0 <fidHashTable>:
a000fff0:	000ff0ff 00000000 00000000 00000000     ................
a0010000:	a0003d20 a0003d20 a0003d44 a0003ddc     ..= ..= ..=D..=.
a0010010:	a0003d64 a0003ddc a0003ddc a0003ddc     ..=d..=...=...=.
a0010020:	a0003d84 00000000 00000000 00000000     ..=.............

a0010030 <nand_device>:
a0010030:	a001502c ecd514b6 80000000 80000000     ..P,............
a0010040:	08000000 00004000 00020000 00400100     ......@......@..
a0010050:	74000000 a0015038 ecd35195 40000000     t.....P8..Q.@...
a0010060:	40000000 08000000 00002000 00020000     @......... .....
a0010070:	00400100 58000000 a0015044 ecdc1095     .@..X.....PD....
a0010080:	20000000 20000000 08000000 00001000      ... ...........
a0010090:	00020000 00400100 54000000 a0015050     .....@..T.....PP
a00100a0:	ecda1095 10000000 10000000 08000000     ................
a00100b0:	00000800 00020000 00400100 44000000     .........@..D...
a00100c0:	a001505c ecf10095 08000000 08000000     ..P\............
a00100d0:	08000000 00000400 00020000 00400100     .............@..
a00100e0:	00000000 a0015068 c2f1801d 08000000     ......Ph........
a00100f0:	08000000 08000000 00000400 00020000     ................
a0010100:	00400100 00000000 a0015074 2cf18095     .@........Pt,...
a0010110:	08000000 08000000 08000000 00000400     ................
a0010120:	00020000 00400100 00000000 a0015088     .....@........P.
a0010130:	adf1801d 08000000 08000000 08000000     ................
a0010140:	00000400 00020000 00400100 00000000     .........@......
a0010150:	a0015098 92f18095 00000080 08000000     ..P.............
a0010160:	08000000 00000400 00020000 00400100     .............@..
a0010170:	00000000 a00150a4 c8dc9095 20000000     ......P..... ...
a0010180:	20000000 08000000 00001000 00020000      ...............
a0010190:	00400100 00000000 a00150b0 01f1801d     .@........P.....
a00101a0:	00000080 08000000 08000000 00000400     ................
a00101b0:	00020000 00400100 00000000 a00150c4     .....@........P.
a00101c0:	ec765a3f 04000000 04000000 02000000     .vZ?............
a00101d0:	00001000 00004000 00100100 00000000     ......@.........
a00101e0:	a00150d0 ec75a5bd 02000000 02000000     ..P..u..........
a00101f0:	02000000 00000800 00004000 00100100     ..........@.....
a0010200:	00000000 a00150dc ad75ad75 02000000     ......P..u.u....
a0010210:	02000000 02000000 00000800 00004000     ..............@.
a0010220:	00100100 00000000 a00150ec 01da9095     ..........P.....
a0010230:	10000000 10000000 08000000 00000800     ................
a0010240:	00020000 00400100 44000000              .....@..D...

a001024c <__FUNCTION__.3092>:
a001024c:	72746b5f 75706461 74655f62 62740000     rtk_update_bbt..

a001025c <__FUNCTION__.2999>:
a001025c:	72746b5f 6e616e64 5f736361 6e5f6262     rtk_nand_scan_bb
a001026c:	74000000                                t...

a0010270 <__FUNCTION__.2783>:
a0010270:	72746b5f 63726561 74655f62 62740000     rtk_create_bbt..

a0010280 <__func__.2778>:
a0010280:	72746b5f 63726561 74655f62 62740000     rtk_create_bbt..

a0010290 <__FUNCTION__.2704>:
a0010290:	7363616e 5f6c6173 745f6469 655f4242     scan_last_die_BB
a00102a0:	00000000                                ....

a00102a4 <__func__.2692>:
a00102a4:	7363616e 5f6c6173 745f6469 655f4242     scan_last_die_BB
a00102b4:	00000000                                ....

a00102b8 <__FUNCTION__.2901>:
a00102b8:	72746b5f 7363616e 5f763272 5f626274     rtk_scan_v2r_bbt
a00102c8:	00000000                                ....

a00102cc <__FUNCTION__.2841>:
a00102cc:	63726561 74655f76 32725f72 656d6170     create_v2r_remap
a00102dc:	70696e67 00000000                       ping....

a00102e4 <__func__.2828>:
a00102e4:	63726561 74655f76 32725f72 656d6170     create_v2r_remap
a00102f4:	70696e67 00000000                       ping....

a00102fc <__func__.2563>:
a00102fc:	72746b5f 77726974 655f6563 635f7061     rtk_write_ecc_pa
a001030c:	67655f61 00000000                       ge_a....

a0010314 <__func__.2494>:
a0010314:	72746b5f 65726173 655f626c 6f636b5f     rtk_erase_block_
a0010324:	61000000                                a...

a0010328 <__FUNCTION__.2447>:
a0010328:	63686563 6b5f4242 54000000              check_BBT...

a0010334 <__FUNCTION__.2344>:
a0010334:	72746b5f 626c6f63 6b5f6973 62616400     rtk_block_isbad.

a0010344 <__FUNCTION__.2182>:
a0010344:	72746b5f 63686563 6b5f7061 67654461     rtk_check_pageDa
a0010354:	74610000                                ta..

a0010358 <__FUNCTION__.2148>:
a0010358:	72746b5f 50494f5f 72656164 5f626173     rtk_PIO_read_bas
a0010368:	69630000                                ic..

a001036c <__FUNCTION__.2120>:
a001036c:	72746b5f 63686563 6b5f616c 6c6f6e65     rtk_check_allone
a001037c:	00000000                                ....

a0010380 <__FUNCTION__.1839>:
a0010380:	6e616e64 5f777269 74655f65 63635f6f     nand_write_ecc_o
a0010390:	62000000                                b...

a0010394 <__FUNCTION__.2466>:
a0010394:	64756d70 5f424254 00000000              dump_BBT....

a00103a0 <__FUNCTION__.1680>:
a00103a0:	6e616e64 5f726561 645f6563 635f6f62     nand_read_ecc_ob
a00103b0:	00000000                                ....

a00103b4 <__func__.1573>:
a00103b4:	72746b5f 77726974 655f6563 635f7061     rtk_write_ecc_pa
a00103c4:	67650000                                ge..

a00103c8 <__FUNCTION__.1400>:
a00103c8:	6e616e64 5f657261 73655f6e 616e6400     nand_erase_nand.

a00103d8 <__func__.1346>:
a00103d8:	72746b5f 65726173 655f626c 6f636b00     rtk_erase_block.
	...

a00103f0 <tiddles.2020>:
a00103f0:	2d5c7c2f 00000000 00000000 00000000     -\|/............

a0010400 <cpu_clksel_table>:
a0010400:	000001c2 000001f4 00000226 00000258     ...........&...X
a0010410:	0000028a 000002bc 000002ee 00000320     ............... 
a0010420:	00000352 00000384 000003b6 000003e8     ...R............
a0010430:	0000041a 0000044c 0000047e 000004b0     .......L...~....

a0010440 <m2x_clksel_table>:
a0010440:	000000fa 0000010e 00000122 00000136     ..........."...6
a0010450:	0000014a 0000015e 00000172 00000235     ...J...^...r...5
a0010460:	0000019a 000001ae 000001c2 000001d6     ................
a0010470:	000001ea 000001fe 00000212 00000226     ...............&
a0010480:	00000186 00000244 00000253 00000262     .......D...S...b
a0010490:	00000271 00000280 0000028f 0000029e     ...q............
a00104a0:	000002ad 000002bc 000002d0 000002e4     ................
a00104b0:	000002f3 00000302 00000311 00000320     ............... 
a00104c0:	a000d758 a000d7ac a000d7e8 a000d92c     ...X...........,
a00104d0:	a000d93c 00000000 00000000 00000000     ...<............
	...
