
./Output/wboot.out:     file format elf32-tradbigmips

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00014000  80000000  80000000  00010000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .reginfo      00000018  80014000  80014000  00024000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA, LINK_ONCE_SAME_SIZE
  2 .rodata.str1.4 00003290  80014018  80014018  00024018  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .data         0000bb94  800172b0  800172b0  000272b0  2**4
                  CONTENTS, ALLOC, LOAD, DATA
  4 .sbss         00000064  80022e44  80022e44  00032e44  2**2
                  ALLOC
  5 .bss          000450f8  80022eb0  80022eb0  00032e44  2**4
                  ALLOC
  6 .pdr          00001d60  00000000  00000000  00032e44  2**2
                  CONTENTS, READONLY
  7 .comment      0000002b  00000000  00000000  00034ba4  2**0
                  CONTENTS, READONLY
  8 .gnu.attributes 00000010  00000000  00000000  00034bcf  2**0
                  CONTENTS, READONLY
  9 .debug_line   00002c45  00000000  00000000  00034bdf  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   0000b950  00000000  00000000  00037824  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 00002e70  00000000  00000000  00043174  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_aranges 00000360  00000000  00000000  00045fe8  2**3
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  00001bec  00000000  00000000  00046348  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    00007461  00000000  00000000  00047f34  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_pubnames 00001735  00000000  00000000  0004f395  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    00003960  00000000  00000000  00050aca  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_ranges 00000268  00000000  00000000  0005442a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

80000000 <start>:
	 * FIXME: Use the initcode feature to get rid of unused handler
	 * variants.
	 */

#if 1
	b check_self_exist
80000000:	10000102 	b	8000040c <check_self_exist>
	nop
80000004:	00000000 	nop
	...

8000040c <check_self_exist>:


reset:

	/* Clear watch registers */
	mtc0	zero, CP0_WATCHLO
8000040c:	40809000 	mtc0	zero,c0_watchlo
	mtc0	zero, CP0_WATCHHI
80000410:	40809800 	mtc0	zero,c0_watchhi

	/* WP(Watch Pending), SW0/1 should be cleared */
	mtc0	zero, CP0_CAUSE
80000414:	40806800 	mtc0	zero,c0_cause
	

	mfc0	t0, CP0_STATUS
80000418:	40086000 	mfc0	t0,c0_status
	or	t0, ST0_CU0 | 0x1f  
8000041c:	3c011000 	lui	at,0x1000
80000420:	3421001f 	ori	at,at,0x1f
80000424:	01014025 	or	t0,t0,at
	xor	t0, 0x1f 
80000428:	3908001f 	xori	t0,t0,0x1f
	mtc0	t0, CP0_STATUS
8000042c:	40886000 	mtc0	t0,c0_status
	.set	noreorder
	sll	zero, 3				# ehb
80000430:	000000c0 	ehb


	/* Init Timer */
	mtc0	zero, CP0_COUNT
80000434:	40804800 	mtc0	zero,c0_count
	mtc0	zero, CP0_COMPARE
80000438:	40805800 	mtc0	zero,c0_compare



#if 1 //wei add for 1074k core 1
        mfc0    v1, CP0_PRID, 1
8000043c:	40037801 	mfc0	v1,c0_ebase
        andi    v1, 0x3ff
80000440:	306303ff 	andi	v1,v1,0x3ff
        beqz    v1, 1f   //ID=0 go out
80000444:	10600014 	beqz	v1,80000498 <loop+0x10>
 //       bnez    v1, 1f        //ID!=0 go out
        nop
80000448:	00000000 	nop


		REG32_W(0xb8002000, '2'<<24);	  //Secondary CPU			
8000044c:	3c0e3200 	lui	t6,0x3200
80000450:	3c0fb800 	lui	t7,0xb800
80000454:	35ef2000 	ori	t7,t7,0x2000
80000458:	adee0000 	sw	t6,0(t7)
8000045c:	00000000 	nop
		REG32_W(0xb8002000, '2'<<24);	  //Secondary CPU			
80000460:	3c0e3200 	lui	t6,0x3200
80000464:	3c0fb800 	lui	t7,0xb800
80000468:	35ef2000 	ori	t7,t7,0x2000
8000046c:	adee0000 	sw	t6,0(t7)
80000470:	00000000 	nop
		REG32_W(0xb8002000, '2'<<24);	  //Secondary CPU			
80000474:	3c0e3200 	lui	t6,0x3200
80000478:	3c0fb800 	lui	t7,0xb800
8000047c:	35ef2000 	ori	t7,t7,0x2000
80000480:	adee0000 	sw	t6,0(t7)
80000484:	00000000 	nop

80000488 <loop>:
	...
loop:
		
        nop
        nop
        b loop
80000490:	1000fffd 	b	80000488 <loop>
        nop
80000494:	00000000 	nop
		nop		
#else
#ifdef CONFIG_NAND_FLASH_BOOTING
		//li sp,0x80700000
		//li sp,0x80500000
		li sp,0xa0500000
80000498:	3c1da050 	lui	sp,0xa050
	...
	nop
#endif
	nop
	nop

	jal	init_arch  	                                          
800004a8:	0c001e97 	jal	80007a5c <init_arch>
	nop  
800004ac:	00000000 	nop
	nop
800004b0:	00000000 	nop

800004b4 <romReserved>:
	
//==========================================================
#if 1
romReserved:
        b       romReserved
800004b4:	1000ffff 	b	800004b4 <romReserved>
        nop
800004b8:	00000000 	nop

800004bc <romExcHandle>:

romExcHandle:
        b       romExcHandle
800004bc:	1000ffff 	b	800004bc <romExcHandle>
		nop
800004c0:	00000000 	nop

800004c4 <ramExcHandle>:

ramExcHandle:
		b	ramExcHandle
800004c4:	1000ffff 	b	800004c4 <ramExcHandle>
		nop
800004c8:	00000000 	nop

800004cc <flush_cache_r>:
800004cc:	4080e802 	mtc0	zero,c0_taghi1
		sll zero,zero,1
		
	//----------------------------------------
//init_L1_dcahe:

	MTC0_SEL_OPCODE( 0, 29, 2 )   //R_C0_DTagHi
800004d0:	00000040 	ssnop
800004d4:	00000040 	ssnop
800004d8:	00000040 	ssnop
800004dc:	00000040 	ssnop
800004e0:	4080e002 	mtc0	zero,c0_taglo1
	MTC0_SEL_OPCODE( 0, 28, 2 )
800004e4:	00000040 	ssnop
800004e8:	00000040 	ssnop
800004ec:	00000040 	ssnop
800004f0:	00000040 	ssnop

0:	
	li	a2, START_ADDR
800004f4:	3c068000 	lui	a2,0x8000
	li  a1,_CACHELINE_SIZE
800004f8:	24050020 	li	a1,32
	li  a3,START_ADDR+_DCACHE_SIZE-_CACHELINE_SIZE
800004fc:	3c078000 	lui	a3,0x8000
80000500:	34e77fe0 	ori	a3,a3,0x7fe0


	/* Loop through all lines, invalidating each of them */
1:	

	cache	DCACHE_INDEX_STORE_TAG, 0(a2)	/* clear tag */
80000504:	bcc90000 	cache	0x9,0(a2)


	bne	a2, a3, 1b
80000508:	14c7fffe 	bne	a2,a3,80000504 <flush_cache_r+0x38>
	addu	a2, a1
8000050c:	00c53021 	addu	a2,a2,a1
80000510:	4080e800 	mtc0	zero,c0_taghi


	//--------------------------------------------
//init_L1_icahe:	
	MTC0_SEL_OPCODE( 0, 29, 0 )   //R_C0_ITagHi
80000514:	00000040 	ssnop
80000518:	00000040 	ssnop
8000051c:	00000040 	ssnop
80000520:	00000040 	ssnop
80000524:	4080e000 	mtc0	zero,c0_taglo
	MTC0_SEL_OPCODE( 0, 28, 0 )
80000528:	00000040 	ssnop
8000052c:	00000040 	ssnop
80000530:	00000040 	ssnop
80000534:	00000040 	ssnop

0:	
	li	a2, START_ADDR
80000538:	3c068000 	lui	a2,0x8000
	li  a1,_CACHELINE_SIZE
8000053c:	24050020 	li	a1,32
	li  a3,START_ADDR+_ICACHE_SIZE-_CACHELINE_SIZE
80000540:	3c078000 	lui	a3,0x8000
80000544:	34e7ffe0 	ori	a3,a3,0xffe0


	/* Loop through all lines, invalidating each of them */
1:	

	cache	ICACHE_INDEX_STORE_TAG, 0(a2)	/* clear tag */
80000548:	bcc80000 	cache	0x8,0(a2)


	bne	a2, a3, 1b
8000054c:	14c7fffe 	bne	a2,a3,80000548 <flush_cache_r+0x7c>
	addu	a2, a1
80000550:	00c53021 	addu	a2,a2,a1

80000554 <init_L2_cache>:
	//disable L2 cache
	li t0,(1<<12)
	MTC0_SEL_OPCODE( 8,16,  2);
#else	
#define RTL98_V0 0x8198C000
	nop
80000554:	00000000 	nop
        REG32_R(0xb8000000,t8);
80000558:	3c0fb800 	lui	t7,0xb800
8000055c:	8df80000 	lw	t8,0(t7)
	...
        nop
	nop
//	IF_EQ(t8, RTL98_V0, lab_disSC); //jason
        nop
	nop
	li t0,(0<<12)
80000574:	24080000 	li	t0,0
80000578:	4080e004 	mtc0	zero,c0_taglo2
	MTC0_SEL_OPCODE( 0, 28, 4 )  //R_C0_SelL23TagLo
8000057c:	00000040 	ssnop
80000580:	00000040 	ssnop
80000584:	00000040 	ssnop
80000588:	00000040 	ssnop
	...
	nop
	nop
0:
	li	a2, START_ADDR
80000594:	3c068000 	lui	a2,0x8000
	li  a1,_CACHELINE_SIZE
80000598:	24050020 	li	a1,32
	li  a3,START_ADDR+_SCACHE_SIZE-_CACHELINE_SIZE
8000059c:	3c078007 	lui	a3,0x8007
800005a0:	34e7ffe0 	ori	a3,a3,0xffe0
	

	/* Loop through all lines, invalidating each of them */
1:	

	cache	SCACHE_INDEX_STORE_TAG, 0(a2)	/* clear tag */
800005a4:	bccb0000 	cache	0xb,0(a2)

	bne	a2, a3, 1b
800005a8:	14c7fffe 	bne	a2,a3,800005a4 <init_L2_cache+0x50>
	addu	a2, a1
800005ac:	00c53021 	addu	a2,a2,a1
	...
	nop
	nop
	j SC_EXIT
800005b8:	08000177 	j	800005dc <SC_EXIT>

800005bc <lab_disSC>:
lab_disSC:
	//disable L2 cache
	li t0,(1<<12)
800005bc:	24081000 	li	t0,4096
800005c0:	40888002 	mtc0	t0,c0_config2
	MTC0_SEL_OPCODE( 8,16,  2);
800005c4:	00000040 	ssnop
800005c8:	00000040 	ssnop
800005cc:	00000040 	ssnop
800005d0:	00000040 	ssnop
	...

800005dc <SC_EXIT>:
	nop
	nop
	
#endif
SC_EXIT:
	nop
800005dc:	00000000 	nop
	
	j ra
800005e0:	03e00008 	jr	ra
	nop
800005e4:	00000000 	nop
	...

80000600 <exception_matrix>:
	
	//copy this body to 0x80000180
		NESTED(exception_matrix, 0, sp)
#if 1

		mfc0	k1, CP0_CAUSE	
80000600:	401b6800 	mfc0	k1,c0_cause
	...
		nop
		nop
		la	k0, (exception_handlers)
8000060c:	3c1a8002 	lui	k0,0x8002
80000610:	275a3e70 	addiu	k0,k0,15984
	...
		nop
		nop		
		andi	k1, k1, 0x7c
8000061c:	337b007c 	andi	k1,k1,0x7c
		addu	k0, k0, k1
80000620:	035bd021 	addu	k0,k0,k1
		lw	k0, (k0)
80000624:	8f5a0000 	lw	k0,0(k0)
		jr	k0
80000628:	03400008 	jr	k0
8000062c:	00000000 	nop
	...

80000640 <IRQ_finder>:
	.text
	.set	noreorder
	.set	noat
	.align	5
	NESTED(IRQ_finder, PT_SIZE, sp)
	SAVE_ALL
80000640:	401a6000 	mfc0	k0,c0_status
80000644:	001ad0c0 	sll	k0,k0,0x3
80000648:	07400003 	bltz	k0,80000658 <IRQ_finder+0x18>
8000064c:	03a0d821 	move	k1,sp
80000650:	3c1b8002 	lui	k1,0x8002
80000654:	8f7b2e80 	lw	k1,11904(k1)
80000658:	03a0d021 	move	k0,sp
8000065c:	277dff50 	addiu	sp,k1,-176
80000660:	afba008c 	sw	k0,140(sp)
80000664:	afa30024 	sw	v1,36(sp)
80000668:	afa00018 	sw	zero,24(sp)
8000066c:	40036000 	mfc0	v1,c0_status
80000670:	afa20020 	sw	v0,32(sp)
80000674:	afa300a8 	sw	v1,168(sp)
80000678:	afa40028 	sw	a0,40(sp)
8000067c:	40036800 	mfc0	v1,c0_cause
80000680:	afa5002c 	sw	a1,44(sp)
80000684:	afa300ac 	sw	v1,172(sp)
80000688:	afa60030 	sw	a2,48(sp)
8000068c:	40037000 	mfc0	v1,c0_epc
80000690:	afa70034 	sw	a3,52(sp)
80000694:	afa300a0 	sw	v1,160(sp)
80000698:	afb9007c 	sw	t9,124(sp)
8000069c:	afbc0088 	sw	gp,136(sp)
800006a0:	afbf0094 	sw	ra,148(sp)
800006a4:	37bc1fff 	ori	gp,sp,0x1fff
800006a8:	3b9c1fff 	xori	gp,gp,0x1fff
800006ac:	afa1001c 	sw	at,28(sp)
800006b0:	00001810 	mfhi	v1
800006b4:	afa80038 	sw	t0,56(sp)
800006b8:	afa9003c 	sw	t1,60(sp)
800006bc:	afa3009c 	sw	v1,156(sp)
800006c0:	00001812 	mflo	v1
800006c4:	afaa0040 	sw	t2,64(sp)
800006c8:	afab0044 	sw	t3,68(sp)
800006cc:	afa30098 	sw	v1,152(sp)
800006d0:	afac0048 	sw	t4,72(sp)
800006d4:	afad004c 	sw	t5,76(sp)
800006d8:	afae0050 	sw	t6,80(sp)
800006dc:	afaf0054 	sw	t7,84(sp)
800006e0:	afb80078 	sw	t8,120(sp)
800006e4:	afb00058 	sw	s0,88(sp)
800006e8:	afb1005c 	sw	s1,92(sp)
800006ec:	afb20060 	sw	s2,96(sp)
800006f0:	afb30064 	sw	s3,100(sp)
800006f4:	afb40068 	sw	s4,104(sp)
800006f8:	afb5006c 	sw	s5,108(sp)
800006fc:	afb60070 	sw	s6,112(sp)
80000700:	afb70074 	sw	s7,116(sp)
80000704:	afbe0090 	sw	s8,144(sp)
	CLI
80000708:	40086000 	mfc0	t0,c0_status
8000070c:	3c091000 	lui	t1,0x1000
80000710:	3529001f 	ori	t1,t1,0x1f
80000714:	01094025 	or	t0,t0,t1
80000718:	3908001f 	xori	t0,t0,0x1f
8000071c:	40886000 	mtc0	t0,c0_status
80000720:	000000c0 	ehb
	.set	at
	
		mfc0    t0, CP0_CAUSE       #get pending interrupts
80000724:	40086800 	mfc0	t0,c0_cause
	...
        nop
        nop
        
        mfc0    t2, CP0_STATUS
80000730:	400a6000 	mfc0	t2,c0_status
	...
        nop
        nop
        
        and     t0, t2              #isolate allowed ones
8000073c:	010a4024 	and	t0,t0,t2
        nop
80000740:	00000000 	nop
        and    t2, t0, 0xfc00      #CT: just look at the Hardware INT bit 10-15
80000744:	310afc00 	andi	t2,t0,0xfc00
        nop
80000748:	00000000 	nop
        
        bne     t2, zero, handle_it #it shows there are pending interrupt, jump to Handler.
8000074c:	1540000c 	bnez	t2,80000780 <handle_it>
        nop
80000750:	00000000 	nop
        nop
80000754:	00000000 	nop
1:        
        li      t0,( UART_THR + 0xb8000000)
80000758:	3c08b800 	lui	t0,0xb800
8000075c:	35082000 	ori	t0,t0,0x2000
        li      t1,'m'		    #it shows m, that is not reasonable to come here.
80000760:	2409006d 	li	t1,109
        nop
80000764:	00000000 	nop
        sb      t1, 0(t0)
80000768:	a1090000 	sb	t1,0(t0)
	...
     	nop
     	nop
	 		            #just hang here.
      	b	1b 
80000774:	1000fff8 	b	80000758 <IRQ_finder+0x118>
        nop
80000778:	00000000 	nop
        nop
8000077c:	00000000 	nop

80000780 <handle_it>:

handle_it:  
//see GIC
        la      t0, (GIC_BASE_ADDR+0x480)
80000780:	3c08bbdc 	lui	t0,0xbbdc
80000784:	35080480 	ori	t0,t0,0x480
        la      t1, (GIC_BASE_ADDR+0x400)
80000788:	3c09bbdc 	lui	t1,0xbbdc
8000078c:	35290400 	ori	t1,t1,0x400
	
        lw      a0, 0(t0)  	    
80000790:	8d040000 	lw	a0,0(t0)
        lw      a1, 0(t1)	    
80000794:	8d250000 	lw	a1,0(t1)
        nop
80000798:	00000000 	nop
        and     a0, a1		   
8000079c:	00852024 	and	a0,a0,a1
        

        la      t0, (GIC_BASE_ADDR+0x484)
800007a0:	3c08bbdc 	lui	t0,0xbbdc
800007a4:	35080484 	ori	t0,t0,0x484
        la      t1, (GIC_BASE_ADDR+0x404)	
800007a8:	3c09bbdc 	lui	t1,0xbbdc
800007ac:	35290404 	ori	t1,t1,0x404
        lw      a2, 0(t0)  	    
800007b0:	8d060000 	lw	a2,0(t0)
        lw      a1, 0(t1)	    
800007b4:	8d250000 	lw	a1,0(t1)
        nop        
800007b8:	00000000 	nop
        and     a1, a2		    
800007bc:	00a62824 	and	a1,a1,a2
        nop
        sb      t1, 0(t0)
	//----------------------------------------------------------
#endif
        
	jal irq_dispatch        #this will lead to real ISR 
800007c0:	0c00032c 	jal	80000cb0 <irq_dispatch>
	nop
800007c4:	00000000 	nop
	nop
800007c8:	00000000 	nop
        li      t1,'o'		   
        nop
        sb      t1, 0(t0)
	//----------------------------------------------------------
#endif
        move   a1,sp
800007cc:	03a02821 	move	a1,sp
	RESTORE_ALL_AND_RET
800007d0:	40086000 	mfc0	t0,c0_status
800007d4:	3508001f 	ori	t0,t0,0x1f
800007d8:	3908001f 	xori	t0,t0,0x1f
800007dc:	40886000 	mtc0	t0,c0_status
800007e0:	3403ff00 	li	v1,0xff00
800007e4:	01034024 	and	t0,t0,v1
800007e8:	8fa200a8 	lw	v0,168(sp)
800007ec:	00031827 	nor	v1,zero,v1
800007f0:	00431024 	and	v0,v0,v1
800007f4:	00481025 	or	v0,v0,t0
800007f8:	40826000 	mtc0	v0,c0_status
800007fc:	8fbf0094 	lw	ra,148(sp)
80000800:	8fbc0088 	lw	gp,136(sp)
80000804:	8fb9007c 	lw	t9,124(sp)
80000808:	8fa70034 	lw	a3,52(sp)
8000080c:	8fa60030 	lw	a2,48(sp)
80000810:	8fa5002c 	lw	a1,44(sp)
80000814:	8fa40028 	lw	a0,40(sp)
80000818:	8fa30024 	lw	v1,36(sp)
8000081c:	8fa20020 	lw	v0,32(sp)
80000820:	8fa1001c 	lw	at,28(sp)
80000824:	8fb80098 	lw	t8,152(sp)
80000828:	8fa80038 	lw	t0,56(sp)
8000082c:	8fa9003c 	lw	t1,60(sp)
80000830:	03000013 	mtlo	t8
80000834:	8fb8009c 	lw	t8,156(sp)
80000838:	8faa0040 	lw	t2,64(sp)
8000083c:	8fab0044 	lw	t3,68(sp)
80000840:	03000011 	mthi	t8
80000844:	8fac0048 	lw	t4,72(sp)
80000848:	8fad004c 	lw	t5,76(sp)
8000084c:	8fae0050 	lw	t6,80(sp)
80000850:	8faf0054 	lw	t7,84(sp)
80000854:	8fb80078 	lw	t8,120(sp)
80000858:	8fb00058 	lw	s0,88(sp)
8000085c:	8fb1005c 	lw	s1,92(sp)
80000860:	8fb20060 	lw	s2,96(sp)
80000864:	8fb30064 	lw	s3,100(sp)
80000868:	8fb40068 	lw	s4,104(sp)
8000086c:	8fb5006c 	lw	s5,108(sp)
80000870:	8fb60070 	lw	s6,112(sp)
80000874:	8fb70074 	lw	s7,116(sp)
80000878:	8fbe0090 	lw	s8,144(sp)
8000087c:	8fba00a0 	lw	k0,160(sp)
80000880:	8fbd008c 	lw	sp,140(sp)
80000884:	409a7000 	mtc0	k0,c0_epc
80000888:	42000018 	eret
	...

800008a0 <clear_cp0_status>:
inline unsigned int					
clear_cp0_status(unsigned int clear)				
{								
	unsigned int res;					
								
	res = read_32bit_cp0_register(CP0_STATUS);		
800008a0:	40026000 	mfc0	v0,c0_status
	res &= ~clear;						
	write_32bit_cp0_register(CP0_STATUS, res);		
800008a4:	00042027 	nor	a0,zero,a0
800008a8:	00442024 	and	a0,v0,a0
800008ac:	40846000 	mtc0	a0,c0_status
800008b0:	00000040 	ssnop
800008b4:	00000040 	ssnop
800008b8:	00000040 	ssnop
800008bc:	00000040 	ssnop
800008c0:	000000c0 	ehb
	SPECIAL_EHB();	
}								
800008c4:	03e00008 	jr	ra
800008c8:	00000000 	nop

800008cc <change_cp0_status>:
inline unsigned int					
change_cp0_status(unsigned int change, unsigned int newvalue)	
{								
	unsigned int res;					
								
	res = read_32bit_cp0_register(CP0_STATUS);		
800008cc:	40036000 	mfc0	v1,c0_status
	res &= ~change;						
800008d0:	00041027 	nor	v0,zero,a0
800008d4:	00621024 	and	v0,v1,v0
	res |= (newvalue & change);					
800008d8:	00a42024 	and	a0,a1,a0
800008dc:	00441025 	or	v0,v0,a0
	write_32bit_cp0_register(CP0_STATUS, res);		
800008e0:	40826000 	mtc0	v0,c0_status
800008e4:	00000040 	ssnop
800008e8:	00000040 	ssnop
800008ec:	00000040 	ssnop
800008f0:	00000040 	ssnop
800008f4:	000000c0 	ehb
	SPECIAL_EHB();							
	return res;						
}
800008f8:	03e00008 	jr	ra
800008fc:	00000000 	nop

80000900 <GIC_GIMR_enable>:
//------------------------------------------------------------------------------
//============================================================================
GIC_GIMR_enable(int irq)
{
	
	if(irq<32)
80000900:	28820020 	slti	v0,a0,32
80000904:	10400007 	beqz	v0,80000924 <GIC_GIMR_enable+0x24>
80000908:	24030001 	li	v1,1
	{
		REG32(GIC_BASE_ADDR+0x380)=(1<<irq);
8000090c:	00831804 	sllv	v1,v1,a0
80000910:	3c02bbdc 	lui	v0,0xbbdc
80000914:	34420380 	ori	v0,v0,0x380
80000918:	ac430000 	sw	v1,0(v0)
	{		
		REG32(GIC_BASE_ADDR+0x384)=(1<<(irq-32));		
	}

	//map2pin
	REG32(GIC_BASE_ADDR+0x500+irq*4)=0x80000000;	
8000091c:	0800024e 	j	80000938 <GIC_GIMR_enable+0x38>
80000920:	3c022ef7 	lui	v0,0x2ef7
	{
		REG32(GIC_BASE_ADDR+0x380)=(1<<irq);
	}
	else
	{		
		REG32(GIC_BASE_ADDR+0x384)=(1<<(irq-32));		
80000924:	00831804 	sllv	v1,v1,a0
80000928:	3c02bbdc 	lui	v0,0xbbdc
8000092c:	34420384 	ori	v0,v0,0x384
80000930:	ac430000 	sw	v1,0(v0)
	}

	//map2pin
	REG32(GIC_BASE_ADDR+0x500+irq*4)=0x80000000;	
80000934:	3c022ef7 	lui	v0,0x2ef7
80000938:	34420140 	ori	v0,v0,0x140
8000093c:	00821021 	addu	v0,a0,v0
80000940:	00021080 	sll	v0,v0,0x2
80000944:	3c038000 	lui	v1,0x8000
80000948:	ac430000 	sw	v1,0(v0)

	//map2vpe
	REG32(GIC_BASE_ADDR+0x2000+irq*0x20)=0x1;		
8000094c:	3c0205de 	lui	v0,0x5de
80000950:	3442e100 	ori	v0,v0,0xe100
80000954:	00822021 	addu	a0,a0,v0
80000958:	00042140 	sll	a0,a0,0x5
8000095c:	24020001 	li	v0,1
80000960:	ac820000 	sw	v0,0(a0)
}
80000964:	03e00008 	jr	ra
80000968:	00000000 	nop

8000096c <setup_IRQ>:
    struct irqaction *old, **p;
    unsigned long flags;

    p = irq_action + irq;
//    prom_printf("IRQ action=%x,%x\n",irq_action,irq);
    save_and_cli(flags);
8000096c:	40026000 	mfc0	v0,c0_status
80000970:	34410001 	ori	at,v0,0x1
80000974:	38210001 	xori	at,at,0x1
80000978:	40816000 	mtc0	at,c0_status
8000097c:	000000c0 	ehb
	...
    *p = new;
8000098c:	00042080 	sll	a0,a0,0x2
80000990:	3c038002 	lui	v1,0x8002
80000994:	24632eb4 	addiu	v1,v1,11956
80000998:	00642021 	addu	a0,v1,a0
8000099c:	ac850000 	sw	a1,0(a0)
    
    restore_flags(flags);
800009a0:	40016000 	mfc0	at,c0_status
800009a4:	30420001 	andi	v0,v0,0x1
800009a8:	34210001 	ori	at,at,0x1
800009ac:	38210001 	xori	at,at,0x1
800009b0:	00411025 	or	v0,v0,at
800009b4:	40826000 	mtc0	v0,c0_status
800009b8:	000000c0 	ehb
	...
    
    return 0;
}
800009c8:	03e00008 	jr	ra
800009cc:	00001021 	move	v0,zero

800009d0 <request_IRQ>:

#endif


int request_IRQ(unsigned long irq, struct irqaction *action, void* dev_id)
{
800009d0:	27bdffe0 	addiu	sp,sp,-32
800009d4:	afbf001c 	sw	ra,28(sp)
800009d8:	afb10018 	sw	s1,24(sp)
800009dc:	afb00014 	sw	s0,20(sp)
800009e0:	00808821 	move	s1,a0

    int retval;
      
 //   prom_printf("IRQ No=%x,%x\n",irq,NR_IRQS);
    if (irq >= NR_IRQS)
800009e4:	2c820040 	sltiu	v0,a0,64
800009e8:	10400008 	beqz	v0,80000a0c <request_IRQ+0x3c>
800009ec:	2410ffea 	li	s0,-22
		return -EINVAL;

	action->dev_id = dev_id;
	
    retval = setup_IRQ(irq, action);
800009f0:	0c00025b 	jal	8000096c <setup_IRQ>
800009f4:	aca60010 	sw	a2,16(a1)
800009f8:	00408021 	move	s0,v0
 //   prom_printf("devid & retval =%x,%x\n",dev_id,retval);
 	
	//GIMR_enable_irq(irq);
	GIC_GIMR_enable(irq);
800009fc:	0c000240 	jal	80000900 <GIC_GIMR_enable>
80000a00:	02202021 	move	a0,s1
	
    if (retval)
80000a04:	12000003 	beqz	s0,80000a14 <request_IRQ+0x44>
80000a08:	8fbf001c 	lw	ra,28(sp)

	    return retval;
}
80000a0c:	02001021 	move	v0,s0
80000a10:	8fbf001c 	lw	ra,28(sp)
80000a14:	8fb10018 	lw	s1,24(sp)
80000a18:	8fb00014 	lw	s0,20(sp)
80000a1c:	03e00008 	jr	ra
80000a20:	27bd0020 	addiu	sp,sp,32

80000a24 <free_IRQ>:
//------------------------------------------------------------------------------

static void  GIMR_disable_irq(unsigned int irq)
{

	REG32(GIMR_REG) &= ~(1<<irq);	
80000a24:	3c02b800 	lui	v0,0xb800
80000a28:	34423000 	ori	v0,v0,0x3000
80000a2c:	8c430000 	lw	v1,0(v0)
80000a30:	24050001 	li	a1,1
80000a34:	00852804 	sllv	a1,a1,a0
80000a38:	00052827 	nor	a1,zero,a1
80000a3c:	00a31824 	and	v1,a1,v1
80000a40:	ac430000 	sw	v1,0(v0)

int	free_IRQ(unsigned long irq)
{
	GIMR_disable_irq(irq);	
	
}
80000a44:	03e00008 	jr	ra
80000a48:	00000000 	nop

80000a4c <set_except_vector>:

//------------------------------------------------------------------------------
void set_except_vector(int n, void *addr)
{
	unsigned handler = (unsigned long) addr;
	exception_handlers[n] = handler;
80000a4c:	00042080 	sll	a0,a0,0x2
80000a50:	3c028002 	lui	v0,0x8002
80000a54:	24423e70 	addiu	v0,v0,15984
80000a58:	00822021 	addu	a0,a0,v0
}
80000a5c:	03e00008 	jr	ra
80000a60:	ac850000 	sw	a1,0(a0)

80000a64 <init_IRQ>:
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------


void  init_IRQ(void)
{
80000a64:	27bdffe8 	addiu	sp,sp,-24
80000a68:	afbf0014 	sw	ra,20(sp)
inline unsigned int					
change_cp0_status(unsigned int change, unsigned int newvalue)	
{								
	unsigned int res;					
								
	res = read_32bit_cp0_register(CP0_STATUS);		
80000a6c:	40036000 	mfc0	v1,c0_status
	res &= ~change;						
	res |= (newvalue & change);					
	write_32bit_cp0_register(CP0_STATUS, res);		
80000a70:	3c02ffff 	lui	v0,0xffff
80000a74:	344200ff 	ori	v0,v0,0xff
80000a78:	00621024 	and	v0,v1,v0
80000a7c:	40826000 	mtc0	v0,c0_status
80000a80:	00000040 	ssnop
80000a84:	00000040 	ssnop
80000a88:	00000040 	ssnop
80000a8c:	00000040 	ssnop
80000a90:	000000c0 	ehb
	change_cp0_status(ST0_IM, 0x00);
	

	/* Set up the external interrupt exception vector */
	/* First exception is Interrupt*/
	set_except_vector(0, IRQ_finder);
80000a94:	00002021 	move	a0,zero
80000a98:	3c058000 	lui	a1,0x8000
80000a9c:	0c000293 	jal	80000a4c <set_except_vector>
80000aa0:	24a50640 	addiu	a1,a1,1600
inline unsigned int					
change_cp0_status(unsigned int change, unsigned int newvalue)	
{								
	unsigned int res;					
								
	res = read_32bit_cp0_register(CP0_STATUS);		
80000aa4:	40036000 	mfc0	v1,c0_status
	res &= ~change;						
80000aa8:	3c02ffff 	lui	v0,0xffff
80000aac:	344200ff 	ori	v0,v0,0xff
80000ab0:	00621024 	and	v0,v1,v0
	res |= (newvalue & change);					
	write_32bit_cp0_register(CP0_STATUS, res);		
80000ab4:	34427c00 	ori	v0,v0,0x7c00
80000ab8:	40826000 	mtc0	v0,c0_status
80000abc:	00000040 	ssnop
80000ac0:	00000040 	ssnop
80000ac4:	00000040 	ssnop
80000ac8:	00000040 	ssnop
80000acc:	000000c0 	ehb
	/* First exception is Interrupt*/
	set_except_vector(0, IRQ_finder);

	/* Enable all interrupts */
	change_cp0_status(ST0_IM, ALLINTS);
}
80000ad0:	8fbf0014 	lw	ra,20(sp)
80000ad4:	03e00008 	jr	ra
80000ad8:	27bd0018 	addiu	sp,sp,24

80000adc <init_exception>:
}

unsigned long ebase_reg = 0;
//------------------------------------------------------------------------------
void  init_exception(void)
{
80000adc:	27bdffe0 	addiu	sp,sp,-32
80000ae0:	afbf001c 	sw	ra,28(sp)
80000ae4:	afb20018 	sw	s2,24(sp)
80000ae8:	afb10014 	sw	s1,20(sp)
80000aec:	afb00010 	sw	s0,16(sp)
inline unsigned int					
clear_cp0_status(unsigned int clear)				
{								
	unsigned int res;					
								
	res = read_32bit_cp0_register(CP0_STATUS);		
80000af0:	40036000 	mfc0	v1,c0_status
	res &= ~clear;						
	write_32bit_cp0_register(CP0_STATUS, res);		
80000af4:	3c02ffbf 	lui	v0,0xffbf
80000af8:	3442ffff 	ori	v0,v0,0xffff
80000afc:	00621024 	and	v0,v1,v0
80000b00:	40826000 	mtc0	v0,c0_status
80000b04:	00000040 	ssnop
80000b08:	00000040 	ssnop
80000b0c:	00000040 	ssnop
80000b10:	00000040 	ssnop
80000b14:	000000c0 	ehb
	SPECIAL_EHB();	
80000b18:	00008021 	move	s0,zero

	unsigned long i;
	clear_cp0_status(ST0_BEV);

	for (i = 0; i <= 31; i++)
		set_except_vector(i, do_reserved);
80000b1c:	3c118000 	lui	s1,0x8000
80000b20:	26310c40 	addiu	s1,s1,3136
	extern char exception_matrix;

	unsigned long i;
	clear_cp0_status(ST0_BEV);

	for (i = 0; i <= 31; i++)
80000b24:	24120020 	li	s2,32
		set_except_vector(i, do_reserved);
80000b28:	02002021 	move	a0,s0
80000b2c:	0c000293 	jal	80000a4c <set_except_vector>
80000b30:	02202821 	move	a1,s1
	extern char exception_matrix;

	unsigned long i;
	clear_cp0_status(ST0_BEV);

	for (i = 0; i <= 31; i++)
80000b34:	26100001 	addiu	s0,s0,1
80000b38:	1612fffc 	bne	s0,s2,80000b2c <init_exception+0x50>
80000b3c:	02002021 	move	a0,s0
		set_except_vector(i, do_reserved);

#ifdef CONFIG_NAND_FLASH_BOOTING
	ebase_reg = 0xa0000000;
80000b40:	3c03a000 	lui	v1,0xa000
80000b44:	3c028002 	lui	v0,0x8002
80000b48:	ac432eb0 	sw	v1,11952(v0)
	write_c0_ebase(ebase_reg);
80000b4c:	3c02a000 	lui	v0,0xa000
80000b50:	40827801 	mtc0	v0,c0_ebase
    memcpy((void *)(KSEG1 + 0x180), &exception_matrix, 0x80);
80000b54:	3c038000 	lui	v1,0x8000
80000b58:	24630600 	addiu	v1,v1,1536
80000b5c:	34420180 	ori	v0,v0,0x180
80000b60:	24680080 	addiu	t0,v1,128
80000b64:	88670000 	lwl	a3,0(v1)
80000b68:	98670003 	lwr	a3,3(v1)
80000b6c:	88660004 	lwl	a2,4(v1)
80000b70:	98660007 	lwr	a2,7(v1)
80000b74:	88650008 	lwl	a1,8(v1)
80000b78:	9865000b 	lwr	a1,11(v1)
80000b7c:	8864000c 	lwl	a0,12(v1)
80000b80:	9864000f 	lwr	a0,15(v1)
80000b84:	a8470000 	swl	a3,0(v0)
80000b88:	b8470003 	swr	a3,3(v0)
80000b8c:	a8460004 	swl	a2,4(v0)
80000b90:	b8460007 	swr	a2,7(v0)
80000b94:	a8450008 	swl	a1,8(v0)
80000b98:	b845000b 	swr	a1,11(v0)
80000b9c:	a844000c 	swl	a0,12(v0)
80000ba0:	b844000f 	swr	a0,15(v0)
80000ba4:	24630010 	addiu	v1,v1,16
80000ba8:	1468ffee 	bne	v1,t0,80000b64 <init_exception+0x88>
80000bac:	24420010 	addiu	v0,v0,16
#else
    memcpy((void *)(KSEG0 + 0x180), &exception_matrix, 0x80);
#endif
    flush_cache();
80000bb0:	0c001eae 	jal	80007ab8 <flush_cache>
80000bb4:	00000000 	nop
}
80000bb8:	8fbf001c 	lw	ra,28(sp)
80000bbc:	8fb20018 	lw	s2,24(sp)
80000bc0:	8fb10014 	lw	s1,20(sp)
80000bc4:	8fb00010 	lw	s0,16(sp)
80000bc8:	03e00008 	jr	ra
80000bcc:	27bd0020 	addiu	sp,sp,32

80000bd0 <initInterrupt>:

//============================================================================

// init interrupt 
void initInterrupt(void)
{
80000bd0:	27bdffe8 	addiu	sp,sp,-24
80000bd4:	afbf0014 	sw	ra,20(sp)
	//printf("=>init interrupt...\n");
	REG32(GIMR_REG)=0x00;/*mask all interrupt*/
80000bd8:	3c02b800 	lui	v0,0xb800
80000bdc:	34433000 	ori	v1,v0,0x3000
80000be0:	ac600000 	sw	zero,0(v1)
	
		REG32(0xb8003114)=0;  //disable timer interrupt
80000be4:	34433114 	ori	v1,v0,0x3114
80000be8:	ac600000 	sw	zero,0(v1)
		REG32(0xb8000010)&=~(1<<11);
80000bec:	34420010 	ori	v0,v0,0x10
80000bf0:	8c440000 	lw	a0,0(v0)
80000bf4:	2403f7ff 	li	v1,-2049
80000bf8:	00831824 	and	v1,a0,v1
80000bfc:	ac430000 	sw	v1,0(v0)
		
		REG32(0xbbdc0300)=0xFFFFFFFF;
80000c00:	3c03bbdc 	lui	v1,0xbbdc
80000c04:	34640300 	ori	a0,v1,0x300
80000c08:	2402ffff 	li	v0,-1
80000c0c:	ac820000 	sw	v0,0(a0)
		REG32(0xbbdc0304)=0xFFFFFFFF;
80000c10:	34630304 	ori	v1,v1,0x304
	
   /*setup the BEV0,and IRQ */
	init_exception();/*Copy handler to 0x80000080*/
80000c14:	0c0002b7 	jal	80000adc <init_exception>
80000c18:	ac620000 	sw	v0,0(v1)
	init_IRQ();      /*Allocate IRQfinder to Exception 0*/
80000c1c:	0c000299 	jal	80000a64 <init_IRQ>
80000c20:	00000000 	nop


extern __inline__ void
__sti(void)
{
	__asm__ __volatile__(
80000c24:	40016000 	mfc0	at,c0_status
80000c28:	34210001 	ori	at,at,0x1
80000c2c:	40816000 	mtc0	at,c0_status
80000c30:	000000c0 	ehb
	sti();
}
80000c34:	8fbf0014 	lw	ra,20(sp)
80000c38:	03e00008 	jr	ra
80000c3c:	27bd0018 	addiu	sp,sp,24

80000c40 <do_reserved>:
	exception_handlers[n] = handler;
}
//------------------------------------------------------------------------------

void do_reserved(struct pt_regs *regs)
{
80000c40:	27bdffe8 	addiu	sp,sp,-24
80000c44:	afbf0014 	sw	ra,20(sp)
	/*fatal hard/software error*/
	int i;
	prom_printf("Undefined Exception happen.");	
80000c48:	3c048001 	lui	a0,0x8001
80000c4c:	0c0023a7 	jal	80008e9c <prom_printf>
80000c50:	24844018 	addiu	a0,a0,16408
80000c54:	08000315 	j	80000c54 <do_reserved+0x14>
80000c58:	00000000 	nop

80000c5c <do_IRQ>:
}

//------------------------------------------------------------------------------

void do_IRQ(int irqnr)
{
80000c5c:	27bdffe8 	addiu	sp,sp,-24
80000c60:	afbf0014 	sw	ra,20(sp)
    struct irqaction *action;
	unsigned long i;

	//printf("Got irq %d\n", irqnr);
	
    action = *(irqnr + irq_action);
80000c64:	00041880 	sll	v1,a0,0x2
80000c68:	3c028002 	lui	v0,0x8002
80000c6c:	24422eb4 	addiu	v0,v0,11956
80000c70:	00431021 	addu	v0,v0,v1
80000c74:	8c430000 	lw	v1,0(v0)
        	
	if (action) 
80000c78:	10600008 	beqz	v1,80000c9c <do_IRQ+0x40>
80000c7c:	00802821 	move	a1,a0
    {
    	//printf("Do ISR=%x\n", action->handler);
	    action->handler(irqnr, action->dev_id, NULL);
80000c80:	8c620000 	lw	v0,0(v1)
80000c84:	8c650010 	lw	a1,16(v1)
80000c88:	0040f809 	jalr	v0
80000c8c:	00003021 	move	a2,zero
	else
	{    
		prom_printf("Fail, you got irq=%X, but not have ISR\n", irqnr);
		for(;;);
	}			
}	
80000c90:	8fbf0014 	lw	ra,20(sp)
80000c94:	03e00008 	jr	ra
80000c98:	27bd0018 	addiu	sp,sp,24
    	//printf("Do ISR=%x\n", action->handler);
	    action->handler(irqnr, action->dev_id, NULL);
    }
	else
	{    
		prom_printf("Fail, you got irq=%X, but not have ISR\n", irqnr);
80000c9c:	3c048001 	lui	a0,0x8001
80000ca0:	0c0023a7 	jal	80008e9c <prom_printf>
80000ca4:	24844034 	addiu	a0,a0,16436
80000ca8:	0800032a 	j	80000ca8 <do_IRQ+0x4c>
80000cac:	00000000 	nop

80000cb0 <irq_dispatch>:

extern  void do_IRQ(int irq);
//------------------------------------------------------------------------------

void irq_dispatch(int irq_nr, int irq_nr2)
{
80000cb0:	27bdffd0 	addiu	sp,sp,-48
80000cb4:	afbf002c 	sw	ra,44(sp)
80000cb8:	afb50028 	sw	s5,40(sp)
80000cbc:	afb40024 	sw	s4,36(sp)
80000cc0:	afb30020 	sw	s3,32(sp)
80000cc4:	afb2001c 	sw	s2,28(sp)
80000cc8:	afb10018 	sw	s1,24(sp)
80000ccc:	afb00014 	sw	s0,20(sp)
80000cd0:	00808821 	move	s1,a0
80000cd4:	00a09021 	move	s2,a1
80000cd8:	00008021 	move	s0,zero
	int i,irq=0;
	//prom_printf("irq.c : irq_nr=%x  irq_nr2=%x  \n",irq_nr, irq_nr2);
	
	//Low 32bit
    for (i=0; i<=31; i++)
80000cdc:	24130020 	li	s3,32
    {
        if (irq_nr & 0x01)
80000ce0:	32220001 	andi	v0,s1,0x1
80000ce4:	10400003 	beqz	v0,80000cf4 <irq_dispatch+0x44>
80000ce8:	00000000 	nop
		{
			//prom_printf("do irq=%x\n",irq);
			do_IRQ(irq);
80000cec:	0c000317 	jal	80000c5c <do_IRQ>
80000cf0:	02002021 	move	a0,s0
{
	int i,irq=0;
	//prom_printf("irq.c : irq_nr=%x  irq_nr2=%x  \n",irq_nr, irq_nr2);
	
	//Low 32bit
    for (i=0; i<=31; i++)
80000cf4:	26100001 	addiu	s0,s0,1
80000cf8:	1613fff9 	bne	s0,s3,80000ce0 <irq_dispatch+0x30>
80000cfc:	00118843 	sra	s1,s1,0x1
			//prom_printf("do irq=%x\n",irq);
			do_IRQ(irq);

		}  
        irq++;
        irq_nr = irq_nr >> 1;
80000d00:	24100020 	li	s0,32
	//High 32bit
    for (i=0; i<=31; i++)
    {
        if (irq_nr2 & 0x01)
		{
			if(irq==43)
80000d04:	2413002b 	li	s3,43
   			{
    				if(REG32(0xbbdc2560)==2)   //for core 1, not process.
80000d08:	3c14bbdc 	lui	s4,0xbbdc
80000d0c:	36942560 	ori	s4,s4,0x2560
80000d10:	24150002 	li	s5,2
        irq++;
        irq_nr = irq_nr >> 1;
    }

	//High 32bit
    for (i=0; i<=31; i++)
80000d14:	2411003f 	li	s1,63
    {
        if (irq_nr2 & 0x01)
80000d18:	32420001 	andi	v0,s2,0x1
80000d1c:	10400008 	beqz	v0,80000d40 <irq_dispatch+0x90>
80000d20:	00000000 	nop
		{
			if(irq==43)
80000d24:	16130004 	bne	s0,s3,80000d38 <irq_dispatch+0x88>
80000d28:	00000000 	nop
   			{
    				if(REG32(0xbbdc2560)==2)   //for core 1, not process.
80000d2c:	8e820000 	lw	v0,0(s4)
80000d30:	10550008 	beq	v0,s5,80000d54 <irq_dispatch+0xa4>
80000d34:	8fbf002c 	lw	ra,44(sp)
     				return;
   			}		
	
					//prom_printf("do irq=%x\n",irq);
			do_IRQ(irq);
80000d38:	0c000317 	jal	80000c5c <do_IRQ>
80000d3c:	02002021 	move	a0,s0
        irq++;
        irq_nr = irq_nr >> 1;
    }

	//High 32bit
    for (i=0; i<=31; i++)
80000d40:	12110003 	beq	s0,s1,80000d50 <irq_dispatch+0xa0>
80000d44:	26100001 	addiu	s0,s0,1
					//prom_printf("do irq=%x\n",irq);
			do_IRQ(irq);

		}  
        irq++;
        irq_nr2 = irq_nr2 >> 1;
80000d48:	08000346 	j	80000d18 <irq_dispatch+0x68>
80000d4c:	00129043 	sra	s2,s2,0x1
    }
}
80000d50:	8fbf002c 	lw	ra,44(sp)
80000d54:	8fb50028 	lw	s5,40(sp)
80000d58:	8fb40024 	lw	s4,36(sp)
80000d5c:	8fb30020 	lw	s3,32(sp)
80000d60:	8fb2001c 	lw	s2,28(sp)
80000d64:	8fb10018 	lw	s1,24(sp)
80000d68:	8fb00014 	lw	s0,20(sp)
80000d6c:	03e00008 	jr	ra
80000d70:	27bd0030 	addiu	sp,sp,48
	...

80000d80 <errorTFTP>:
/*error in boot state machine*/	
}
//----------------------------------------------------------------------------------------
static void errorTFTP(void)
{
    if (!tftpd_is_ready)
80000d80:	3c028002 	lui	v0,0x8002
80000d84:	8c422fc4 	lw	v0,12228(v0)
80000d88:	10400002 	beqz	v0,80000d94 <errorTFTP+0x14>
80000d8c:	3c028002 	lui	v0,0x8002
		dprintf("[errcode from TFTP server:] %d\n",errcode);
		dprintf("[errmsg from TFTP server:] %s\n",errmsg);
		tftp_client_recvdone = 1;
	}
#endif
bootState=BOOT_STATE0_INIT_ARP;
80000d90:	ac402e58 	sw	zero,11864(v0)
80000d94:	03e00008 	jr	ra
80000d98:	00000000 	nop

80000d9c <updateARPTable>:
			//dprintf("--send rrq to TFTP server--, [filename:] %s, image_address = 0x%x\n",TEST_FILENAME,image_address);
		}
	 }
 }
#endif 
}
80000d9c:	03e00008 	jr	ra
80000da0:	00000000 	nop

80000da4 <Patch_TFTP_SDR_2M>:
	#define RANG2 3
	#define RANG3  7
	#define RANG4 0xf	
	
	#define SYS_HW_STRAP   (0xb8000000 +0x08)
	unsigned int v=REG32(SYS_HW_STRAP);
80000da4:	3c02b800 	lui	v0,0xb800
80000da8:	34420008 	ori	v0,v0,0x8
80000dac:	8c420000 	lw	v0,0(v0)

	unsigned char boot_sel=GET_BITVAL(v, 0, RANG3);
	unsigned char dramtype_sel=GET_BITVAL(v, 4, RANG1);

	
	if( (boot_sel==0x7) && (dramtype_sel==0) )   //ROM4, SDR type =2M
80000db0:	30440007 	andi	a0,v0,0x7
80000db4:	24030007 	li	v1,7
80000db8:	14830005 	bne	a0,v1,80000dd0 <Patch_TFTP_SDR_2M+0x2c>
80000dbc:	7c420100 	ext	v0,v0,0x4,0x1
80000dc0:	14400003 	bnez	v0,80000dd0 <Patch_TFTP_SDR_2M+0x2c>
80000dc4:	3c038018 	lui	v1,0x8018
		image_address=0x80180000;
80000dc8:	3c028001 	lui	v0,0x8001
80000dcc:	ac4372b8 	sw	v1,29368(v0)
80000dd0:	03e00008 	jr	ra
80000dd4:	00000000 	nop

80000dd8 <tftpd_entry>:
#ifdef SUPPORT_TFTP_CLIENT
void tftpd_entry(int is_client_mode)
#else
void tftpd_entry(void)
#endif
{
80000dd8:	27bdffe8 	addiu	sp,sp,-24
80000ddc:	afbf0014 	sw	ra,20(sp)
 int i,j;
 
#if 1 //ROM code need
		Patch_TFTP_SDR_2M();
80000de0:	0c000369 	jal	80000da4 <Patch_TFTP_SDR_2M>
80000de4:	00000000 	nop
	arptable_tftp[TFTP_SERVER].ipaddr.s_addr = *ptr2;	
else
	arptable_tftp[TFTP_SERVER].ipaddr.s_addr = IPTOUL(192,168,1,97);

#else
arptable_tftp[TFTP_SERVER].ipaddr.s_addr = IPTOUL(192,168,1,6);
80000de8:	3c028002 	lui	v0,0x8002
80000dec:	3c03c0a8 	lui	v1,0xc0a8
80000df0:	34630106 	ori	v1,v1,0x106
80000df4:	ac4340f0 	sw	v1,16624(v0)
#endif

arptable_tftp[TFTP_CLIENT].ipaddr.s_addr = IPTOUL(192,162,1,116);
80000df8:	244240f0 	addiu	v0,v0,16624
80000dfc:	3c03c0a2 	lui	v1,0xc0a2
80000e00:	34630174 	ori	v1,v1,0x174
80000e04:	ac43000c 	sw	v1,12(v0)
 /*This is ETH0. we treat ETH0 as the TFTP server*/
 /*char eth0_mac[6]={0x56, 0xaa, 0xa5, 0x5a, 0x7d, 0xe8};*/
arptable_tftp[TFTP_SERVER].node[5]=eth0_mac[5];
80000e08:	3c048001 	lui	a0,0x8001
80000e0c:	24837590 	addiu	v1,a0,30096
80000e10:	90650005 	lbu	a1,5(v1)
80000e14:	a0450009 	sb	a1,9(v0)
arptable_tftp[TFTP_SERVER].node[4]=eth0_mac[4];
80000e18:	90650004 	lbu	a1,4(v1)
80000e1c:	a0450008 	sb	a1,8(v0)
arptable_tftp[TFTP_SERVER].node[3]=eth0_mac[3];
80000e20:	90650003 	lbu	a1,3(v1)
80000e24:	a0450007 	sb	a1,7(v0)
arptable_tftp[TFTP_SERVER].node[2]=eth0_mac[2];
80000e28:	90650002 	lbu	a1,2(v1)
80000e2c:	a0450006 	sb	a1,6(v0)
arptable_tftp[TFTP_SERVER].node[1]=eth0_mac[1];
80000e30:	90630001 	lbu	v1,1(v1)
80000e34:	a0430005 	sb	v1,5(v0)
arptable_tftp[TFTP_SERVER].node[0]=eth0_mac[0];
80000e38:	90837590 	lbu	v1,30096(a0)
80000e3c:	a0430004 	sb	v1,4(v0)
//arptable_tftp[TFTP_SERVER].node[1]=0xaa;
//arptable_tftp[TFTP_SERVER].node[0]=0x56;


 /*intialize boot state*/	
 bootState=BOOT_STATE0_INIT_ARP;
80000e40:	3c028002 	lui	v0,0x8002
80000e44:	ac402e58 	sw	zero,11864(v0)
 /*this nic is the expected data structure to be processed.*/
 nic.packet=eth_packet;
80000e48:	3c028002 	lui	v0,0x8002
80000e4c:	3c038002 	lui	v1,0x8002
80000e50:	24634114 	addiu	v1,v1,16660
80000e54:	ac432e4c 	sw	v1,11852(v0)
 nic.packetlen=0;
80000e58:	24422e4c 	addiu	v0,v0,11852
80000e5c:	ac400004 	sw	zero,4(v0)

 block_expected=0;
80000e60:	3c028002 	lui	v0,0x8002
80000e64:	a4402e48 	sh	zero,11848(v0)
 one_tftp_lock=0;
80000e68:	3c028002 	lui	v0,0x8002
80000e6c:	a0402fcc 	sb	zero,12236(v0)
 it_is_EOF=0;
80000e70:	3c028002 	lui	v0,0x8002
80000e74:	ac402fd0 	sw	zero,12240(v0)

//prom_printf("line=%d:		block_expected=%d\n", __LINE__,  block_expected); // for debug

 
 //image_address=FILESTART; //sc_yang
 address_to_store=image_address;
80000e78:	3c028001 	lui	v0,0x8001
80000e7c:	8c4372b8 	lw	v1,29368(v0)
80000e80:	3c028002 	lui	v0,0x8002
80000e84:	ac432e44 	sw	v1,11844(v0)
 
 file_length_to_server=0;
80000e88:	3c028002 	lui	v0,0x8002
80000e8c:	ac402e64 	sw	zero,11876(v0)
 file_length_to_client=0;
80000e90:	3c028002 	lui	v0,0x8002
80000e94:	ac402e5c 	sw	zero,11868(v0)
#ifdef SUPPORT_TFTP_CLIENT
 if (is_client_mode)
	 SERVER_port=69; 	
 else
#endif 	
 SERVER_port=2098;
80000e98:	24030832 	li	v1,2098
80000e9c:	3c028002 	lui	v0,0x8002
80000ea0:	a4432e54 	sh	v1,11860(v0)

#ifndef CONFIG_FPGA_PLATFORM
    tftpd_is_ready = 1;
80000ea4:	24030001 	li	v1,1
80000ea8:	3c028002 	lui	v0,0x8002
80000eac:	ac432fc4 	sw	v1,12228(v0)
	tftp_client_enabled = 1;	
 }
 else	
	tftp_client_enabled = 0;
#endif
}
80000eb0:	8fbf0014 	lw	ra,20(sp)
80000eb4:	03e00008 	jr	ra
80000eb8:	27bd0018 	addiu	sp,sp,24

80000ebc <ipheader_chksum>:
            break;/*ptype=IP*/ 
    }
}
//----------------------------------------------------------------------------------------
Int16 ipheader_chksum(Int16*ip,int len)
{
80000ebc:	00052843 	sra	a1,a1,0x1
80000ec0:	00001021 	move	v0,zero
 Int32 sum = 0;
 len >>= 1;
 while (len--)
 {
  sum += *(ip++);
  if (sum > 0xFFFF)
80000ec4:	3c080001 	lui	t0,0x1
  sum -= 0xFFFF;
80000ec8:	3c07ffff 	lui	a3,0xffff
//----------------------------------------------------------------------------------------
Int16 ipheader_chksum(Int16*ip,int len)
{
 Int32 sum = 0;
 len >>= 1;
 while (len--)
80000ecc:	080003bc 	j	80000ef0 <ipheader_chksum+0x34>
80000ed0:	34e70001 	ori	a3,a3,0x1
 {
  sum += *(ip++);
80000ed4:	94830000 	lhu	v1,0(a0)
80000ed8:	00431021 	addu	v0,v0,v1
  if (sum > 0xFFFF)
80000edc:	0048302b 	sltu	a2,v0,t0
  sum -= 0xFFFF;
80000ee0:	00471821 	addu	v1,v0,a3
80000ee4:	0066100a 	movz	v0,v1,a2
{
 Int32 sum = 0;
 len >>= 1;
 while (len--)
 {
  sum += *(ip++);
80000ee8:	24840002 	addiu	a0,a0,2
80000eec:	24a5ffff 	addiu	a1,a1,-1
//----------------------------------------------------------------------------------------
Int16 ipheader_chksum(Int16*ip,int len)
{
 Int32 sum = 0;
 len >>= 1;
 while (len--)
80000ef0:	14a0fff8 	bnez	a1,80000ed4 <ipheader_chksum+0x18>
80000ef4:	00000000 	nop
80000ef8:	00021027 	nor	v0,zero,v0
  sum += *(ip++);
  if (sum > 0xFFFF)
  sum -= 0xFFFF;
 }                           /*Correct return 0*/
 return((~sum) & 0x0000FFFF);/*only 2 bytes*/
}
80000efc:	03e00008 	jr	ra
80000f00:	3042ffff 	andi	v0,v0,0xffff

80000f04 <kick_tftpd>:
 prepare_txpkt(0,FRAME_IP,arptable_tftp[TFTP_CLIENT].node,(Int8*)&tftp_tx,(Int16)sizeof(struct iphdr)+sizeof(struct udphdr)+length+4);
}
               
//----------------------------------------------------------------------------------------
void kick_tftpd(void)
{
80000f04:	27bdffe8 	addiu	sp,sp,-24
80000f08:	afbf0014 	sw	ra,20(sp)
80000f0c:	afb00010 	sw	s0,16(sp)
    BootEvent_t  kick_event=NUM_OF_BOOT_EVENTS;
      
    Int32 UDPIPETHheader = ETH_HLEN + sizeof(struct iphdr)  + sizeof(struct udphdr);		 
    
    
    if (nic.packetlen >= ETH_HLEN+sizeof(struct arprequest)) {
80000f10:	3c028002 	lui	v0,0x8002
80000f14:	8c422e50 	lw	v0,11856(v0)
80000f18:	2c43002a 	sltiu	v1,v0,42
80000f1c:	1460008d 	bnez	v1,80001154 <kick_tftpd+0x250>
80000f20:	3c038002 	lui	v1,0x8002
    	 pkttype =( (Int16)(nic.packet[12]<< 8)  |(Int16)(nic.packet[13])   );   /*This BIG byte shifts right 8*/             
80000f24:	8c702e4c 	lw	s0,11852(v1)
    } 

    switch (pkttype) {
80000f28:	8203000c 	lb	v1,12(s0)
80000f2c:	8204000d 	lb	a0,13(s0)
80000f30:	00031a00 	sll	v1,v1,0x8
80000f34:	00641825 	or	v1,v1,a0
80000f38:	3063ffff 	andi	v1,v1,0xffff
80000f3c:	24040800 	li	a0,2048
80000f40:	10640015 	beq	v1,a0,80000f98 <kick_tftpd+0x94>
80000f44:	2c42002b 	sltiu	v0,v0,43
80000f48:	24020806 	li	v0,2054
80000f4c:	14620081 	bne	v1,v0,80001154 <kick_tftpd+0x250>
80000f50:	2610000e 	addiu	s0,s0,14
			/*keep parsing, check the opcode is request or reply*/
			arppacket = (struct arprequest *)&nic.packet[ETH_HLEN];
			/*Parse the opcode, 01->req, 02 ->reply*/ 	
			arpopcode = arppacket->opcode;
						  
            switch(arpopcode) {
80000f54:	96020006 	lhu	v0,6(s0)
80000f58:	24030001 	li	v1,1
80000f5c:	10430005 	beq	v0,v1,80000f74 <kick_tftpd+0x70>
80000f60:	24030002 	li	v1,2
80000f64:	1443007b 	bne	v0,v1,80001154 <kick_tftpd+0x250>
80000f68:	24030001 	li	v1,1
                    break;
            }
            //wei del
            if (kick_event!=NUM_OF_BOOT_EVENTS) {
                jump = (void *)(*BootStateEvent[bootState][kick_event]);
                jump();
80000f6c:	0800043d 	j	800010f4 <kick_tftpd+0x1f0>
80000f70:	3c028002 	lui	v0,0x8002
			arpopcode = arppacket->opcode;
						  
            switch(arpopcode) {
                case htons(ARP_REQUEST):     														
				    // check dst ip, david+2007-12-26											
                    if (!memcmp(arppacket->tipaddr, &arptable_tftp[TFTP_SERVER].ipaddr, 4)
80000f74:	26040018 	addiu	a0,s0,24
80000f78:	3c058002 	lui	a1,0x8002
80000f7c:	24a540f0 	addiu	a1,a1,16624
80000f80:	0c002051 	jal	80008144 <memcmp>
80000f84:	24060004 	li	a2,4
80000f88:	10400059 	beqz	v0,800010f0 <kick_tftpd+0x1ec>
80000f8c:	00001821 	move	v1,zero
                    }
                }
            }
            break;/*ptype=IP*/ 
    }
}
80000f90:	08000456 	j	80001158 <kick_tftpd+0x254>
80000f94:	8fbf0014 	lw	ra,20(sp)
            break;/*ptype=ARP*/

        //--------------------------------------------------------------------------	
        case htons(FRAME_IP):
            //dprintf("rx ip packet\n");	//wei add
            ipheader = (struct iphdr *)&nic.packet[ETH_HLEN];
80000f98:	2610000e 	addiu	s0,s0,14
            // word alignment
            //Cyrus Dick
            ip_addr.ip[0] = ipheader->dest.ip[0];
80000f9c:	92060010 	lbu	a2,16(s0)
            ip_addr.ip[1] = ipheader->dest.ip[1];
80000fa0:	92050011 	lbu	a1,17(s0)
            ip_addr.ip[2] = ipheader->dest.ip[2];
80000fa4:	92040012 	lbu	a0,18(s0)
            //source_ip_addr.ip[1] = ipheader->src.ip[1];
            //source_ip_addr.ip[2] = ipheader->src.ip[2];
            //source_ip_addr.ip[3] = ipheader->src.ip[3];
            //Cyrus Dick
            /*Even type is IP, but the total payload must at least UDPH+IPH*/
            if (nic.packetlen > UDPIPETHheader) {
80000fa8:	1440006a 	bnez	v0,80001154 <kick_tftpd+0x250>
80000fac:	92030013 	lbu	v1,19(s0)
                /*keep parsing, check the TCP/UDP, here is meaningful*/
                if (ipheader->verhdrlen==0x45) {
80000fb0:	82070000 	lb	a3,0(s0)
80000fb4:	24020045 	li	v0,69
80000fb8:	14e20067 	bne	a3,v0,80001158 <kick_tftpd+0x254>
80000fbc:	8fbf0014 	lw	ra,20(sp)
        case htons(FRAME_IP):
            //dprintf("rx ip packet\n");	//wei add
            ipheader = (struct iphdr *)&nic.packet[ETH_HLEN];
            // word alignment
            //Cyrus Dick
            ip_addr.ip[0] = ipheader->dest.ip[0];
80000fc0:	00001021 	move	v0,zero
80000fc4:	7cc2fe04 	ins	v0,a2,0x18,0x8
            ip_addr.ip[1] = ipheader->dest.ip[1];
80000fc8:	7ca2bc04 	ins	v0,a1,0x10,0x8
            ip_addr.ip[2] = ipheader->dest.ip[2];
80000fcc:	7c827a04 	ins	v0,a0,0x8,0x8
            ip_addr.ip[3] = ipheader->dest.ip[3];
80000fd0:	7c623804 	ins	v0,v1,0x0,0x8
                        || ip_addr.s_addr  == arptable_tftp[HTTPD_ARPENTRY].ipaddr.s_addr 
#endif
                        ) {					

#else					
                    if (ip_addr.s_addr==arptable_tftp[TFTP_SERVER].ipaddr.s_addr 
80000fd4:	3c038002 	lui	v1,0x8002
80000fd8:	8c6340f0 	lw	v1,16624(v1)
80000fdc:	1443005e 	bne	v0,v1,80001158 <kick_tftpd+0x254>
80000fe0:	02002021 	move	a0,s0
#endif
                        ) {
#endif                        
                        //if(source_ip_addr.s_addr==arptable_tftp[TFTP_CLIENT].ipaddr.s_addr)
                        //Cyrus Dick
                        if (!ipheader_chksum((Int16*)ipheader,sizeof(struct iphdr))) {
80000fe4:	0c0003af 	jal	80000ebc <ipheader_chksum>
80000fe8:	24050014 	li	a1,20
80000fec:	14400059 	bnez	v0,80001154 <kick_tftpd+0x250>
80000ff0:	24020011 	li	v0,17
                            if (ipheader->protocol==IP_UDP) {                                                 
80000ff4:	82030009 	lb	v1,9(s0)
80000ff8:	14620057 	bne	v1,v0,80001158 <kick_tftpd+0x254>
80000ffc:	8fbf0014 	lw	ra,20(sp)
                                }
#endif
                                /*All we care is TFTP protocol, no other  protocol*/
                                tftppacket = (struct tftp_t *)&nic.packet[ETH_HLEN];
                                tftpopcode  = tftppacket->opcode;      
                                switch (tftpopcode) {
80001000:	3c028002 	lui	v0,0x8002
80001004:	8c422e4c 	lw	v0,11852(v0)
80001008:	9443002a 	lhu	v1,42(v0)
8000100c:	2c630007 	sltiu	v1,v1,7
80001010:	10600051 	beqz	v1,80001158 <kick_tftpd+0x254>
80001014:	00000000 	nop
80001018:	9443002a 	lhu	v1,42(v0)
8000101c:	00031880 	sll	v1,v1,0x2
80001020:	3c028001 	lui	v0,0x8001
80001024:	24420010 	addiu	v0,v0,16
80001028:	00431021 	addu	v0,v0,v1
8000102c:	8c420000 	lw	v0,0(v0)
80001030:	00400008 	jr	v0
80001034:	00000000 	nop
80001038:	0800044a 	j	80001128 <kick_tftpd+0x224>
8000103c:	24020006 	li	v0,6
                                    case htons(TFTP_RRQ):
                                        if (one_tftp_lock==0)
80001040:	3c028002 	lui	v0,0x8002
80001044:	90432fcc 	lbu	v1,12236(v0)
80001048:	10600037 	beqz	v1,80001128 <kick_tftpd+0x224>
8000104c:	24020002 	li	v0,2
                    }
                }
            }
            break;/*ptype=IP*/ 
    }
}
80001050:	08000456 	j	80001158 <kick_tftpd+0x254>
80001054:	8fbf0014 	lw	ra,20(sp)
                                        if (one_tftp_lock==0)
                                            kick_event= BOOT_EVENT2_TFTP_RRQ;                 
                                        break;                     
                                    case htons(TFTP_WRQ):
#if 1
                                        if (one_tftp_lock==0) {
80001058:	3c028002 	lui	v0,0x8002
8000105c:	90422fcc 	lbu	v0,12236(v0)
80001060:	14400007 	bnez	v0,80001080 <kick_tftpd+0x17c>
80001064:	00000000 	nop
                                            kick_event = BOOT_EVENT3_TFTP_WRQ; 
                                            rx_kickofftime = get_timer_jiffies(); //wei add
80001068:	0c0038f0 	jal	8000e3c0 <get_timer_jiffies>
8000106c:	00000000 	nop
80001070:	3c038002 	lui	v1,0x8002
80001074:	ac622fc8 	sw	v0,12232(v1)
80001078:	0800044a 	j	80001128 <kick_tftpd+0x224>
8000107c:	24020003 	li	v0,3
                                        }
                                        else {
                                           // prom_printf("TFTP_WRQ: one_tftp_lock=%d block_expected=%d\n",one_tftp_lock, block_expected);
                                            //fix TFTP WRQ retransmit issue and add timout mechanism for second TFTP WRQ coming issue
                                            if ((block_expected == 1) || ((get_timer_jiffies() - rx_kickofftime) > 2000)) { //wait 20sec, unit is 10ms
80001080:	3c028002 	lui	v0,0x8002
80001084:	94432e48 	lhu	v1,11848(v0)
80001088:	3063ffff 	andi	v1,v1,0xffff
8000108c:	24020001 	li	v0,1
80001090:	10620009 	beq	v1,v0,800010b8 <kick_tftpd+0x1b4>
80001094:	00000000 	nop
80001098:	0c0038f0 	jal	8000e3c0 <get_timer_jiffies>
8000109c:	00000000 	nop
800010a0:	3c038002 	lui	v1,0x8002
800010a4:	8c632fc8 	lw	v1,12232(v1)
800010a8:	00431823 	subu	v1,v0,v1
800010ac:	2c6307d1 	sltiu	v1,v1,2001
800010b0:	14600029 	bnez	v1,80001158 <kick_tftpd+0x254>
800010b4:	8fbf0014 	lw	ra,20(sp)
                                                kick_event = BOOT_EVENT3_TFTP_WRQ;
                                                rx_kickofftime = get_timer_jiffies();
800010b8:	0c0038f0 	jal	8000e3c0 <get_timer_jiffies>
800010bc:	00000000 	nop
800010c0:	3c038002 	lui	v1,0x8002
800010c4:	ac622fc8 	sw	v0,12232(v1)
800010c8:	0800044a 	j	80001128 <kick_tftpd+0x224>
800010cc:	24020003 	li	v0,3
#endif
                                        //setTFTP_WRQ();
                                        break;
                                    case htons(TFTP_DATA):
                                        kick_event= BOOT_EVENT4_TFTP_DATA;
                                        rx_kickofftime = get_timer_jiffies();
800010d0:	0c0038f0 	jal	8000e3c0 <get_timer_jiffies>
800010d4:	00000000 	nop
800010d8:	3c038002 	lui	v1,0x8002
800010dc:	ac622fc8 	sw	v0,12232(v1)
                                        //	prepareACK();
                                        break;
800010e0:	0800044a 	j	80001128 <kick_tftpd+0x224>
800010e4:	24020004 	li	v0,4
800010e8:	0800044a 	j	80001128 <kick_tftpd+0x224>
800010ec:	24020007 	li	v0,7
                    break;
            }
            //wei del
            if (kick_event!=NUM_OF_BOOT_EVENTS) {
                jump = (void *)(*BootStateEvent[bootState][kick_event]);
                jump();
800010f0:	3c028002 	lui	v0,0x8002
800010f4:	8c422e58 	lw	v0,11864(v0)
800010f8:	000210c0 	sll	v0,v0,0x3
800010fc:	00431821 	addu	v1,v0,v1
80001100:	00031880 	sll	v1,v1,0x2
80001104:	3c028001 	lui	v0,0x8001
80001108:	2442002c 	addiu	v0,v0,44
8000110c:	00621821 	addu	v1,v1,v0
80001110:	8c620000 	lw	v0,0(v1)
80001114:	0040f809 	jalr	v0
80001118:	00000000 	nop
                    }
                }
            }
            break;/*ptype=IP*/ 
    }
}
8000111c:	08000456 	j	80001158 <kick_tftpd+0x254>
80001120:	8fbf0014 	lw	ra,20(sp)
                    break;
            }
            //wei del
            if (kick_event!=NUM_OF_BOOT_EVENTS) {
                jump = (void *)(*BootStateEvent[bootState][kick_event]);
                jump();
80001124:	24020005 	li	v0,5
                                        break;
                                }
				
                                if (kick_event!=NUM_OF_BOOT_EVENTS) {
                                    jump = (void *)(*BootStateEvent[bootState][kick_event]);
                                    jump();
80001128:	3c038002 	lui	v1,0x8002
8000112c:	8c632e58 	lw	v1,11864(v1)
80001130:	000318c0 	sll	v1,v1,0x3
80001134:	00621021 	addu	v0,v1,v0
80001138:	00021080 	sll	v0,v0,0x2
8000113c:	3c038001 	lui	v1,0x8001
80001140:	2463002c 	addiu	v1,v1,44
80001144:	00431021 	addu	v0,v0,v1
80001148:	8c420000 	lw	v0,0(v0)
8000114c:	0040f809 	jalr	v0
80001150:	00000000 	nop
                    }
                }
            }
            break;/*ptype=IP*/ 
    }
}
80001154:	8fbf0014 	lw	ra,20(sp)
80001158:	8fb00010 	lw	s0,16(sp)
8000115c:	03e00008 	jr	ra
80001160:	27bd0018 	addiu	sp,sp,24

80001164 <errorDrop>:
#endif // SUPPORT_TFTP_CLIENT


//----------------------------------------------------------------------------------------
static void errorDrop(void)
{
80001164:	27bdffe8 	addiu	sp,sp,-24
80001168:	afbf0014 	sw	ra,20(sp)
    if (!tftpd_is_ready)
8000116c:	3c028002 	lui	v0,0x8002
80001170:	8c422fc4 	lw	v0,12228(v0)
80001174:	10400009 	beqz	v0,8000119c <errorDrop+0x38>
80001178:	8fbf0014 	lw	ra,20(sp)
        return;
/*no need to change boot state*/
prom_printf("Boot state error,%d,%d\n",bootState,bootEvent);
8000117c:	3c048001 	lui	a0,0x8001
80001180:	2484405c 	addiu	a0,a0,16476
80001184:	3c028002 	lui	v0,0x8002
80001188:	8c452e58 	lw	a1,11864(v0)
8000118c:	3c028002 	lui	v0,0x8002
80001190:	0c002325 	jal	80008c94 <dprintf>
80001194:	8c462e68 	lw	a2,11880(v0)
//bootState=BOOT_STATE0_INIT_ARP;
/*error in boot state machine*/	
}
80001198:	8fbf0014 	lw	ra,20(sp)
8000119c:	03e00008 	jr	ra
800011a0:	27bd0018 	addiu	sp,sp,24

800011a4 <autoreboot>:
	return found;
}
#endif

void autoreboot()
{
800011a4:	27bdffe8 	addiu	sp,sp,-24
800011a8:	afbf0014 	sw	ra,20(sp)
        extern unsigned int ComSrlCmd_EX4B(unsigned char ucChip, unsigned int uiLen);
        ComSrlCmd_EX4B(0,4);

        #endif

	jumpF = (void *)(0xbfc00000);
800011ac:	3c03bfc0 	lui	v1,0xbfc0
800011b0:	3c028002 	lui	v0,0x8002
800011b4:	ac432e60 	sw	v1,11872(v0)
__IN(unsigned short,h,w)
__IN(unsigned int,w,l)

__OUT(b,b)
__OUT(h,w)
__OUT(w,l)
800011b8:	3c03b800 	lui	v1,0xb800
800011bc:	00001021 	move	v0,zero
800011c0:	ac623000 	sw	v0,12288(v1)
 * no nops at all.
 */
extern __inline__ void
__cli(void)
{
	__asm__ __volatile__(
800011c4:	40016000 	mfc0	at,c0_status
800011c8:	34210001 	ori	at,at,0x1
800011cc:	38210001 	xori	at,at,0x1
800011d0:	40816000 	mtc0	at,c0_status
800011d4:	000000c0 	ehb
	...
	outl(0,GIMR0); // mask all interrupt	    
	cli();

	flush_cache(); 
800011e4:	0c001eae 	jal	80007ab8 <flush_cache>
800011e8:	00000000 	nop
	prom_printf("\nreboot.......\n");
800011ec:	3c048001 	lui	a0,0x8001
800011f0:	0c002325 	jal	80008c94 <dprintf>
800011f4:	24844074 	addiu	a0,a0,16500
#if defined(RTL865X) || defined(RTL8198)
	/* this is to enable 865xc watch dog reset */
	*(volatile unsigned long *)(0xB800311c)=0; 
800011f8:	3c02b800 	lui	v0,0xb800
800011fc:	3442311c 	ori	v0,v0,0x311c
80001200:	ac400000 	sw	zero,0(v0)
	#ifndef CONFIG_NAND_FLASH_BOOTING
	for(;;);
	#endif
#endif
 	/* reboot */
	jumpF();	
80001204:	3c028002 	lui	v0,0x8002
80001208:	8c422e60 	lw	v0,11872(v0)
8000120c:	0040f809 	jalr	v0
80001210:	00000000 	nop
}
80001214:	8fbf0014 	lw	ra,20(sp)
80001218:	03e00008 	jr	ra
8000121c:	27bd0018 	addiu	sp,sp,24

80001220 <doARPReply>:
	}
#endif
}
//----------------------------------------------------------------------------------------
static void doARPReply(void)
{
80001220:	27bdffc0 	addiu	sp,sp,-64
80001224:	afbf003c 	sw	ra,60(sp)
 Int8 checkIP[4];
 Int32 targetIP; 

//dprintf("execute ARP reply function\n");

 arppacket=(struct arprequest *) &(nic.packet[ETH_HLEN]);
80001228:	3c028002 	lui	v0,0x8002
8000122c:	8c422e4c 	lw	v0,11852(v0)
80001230:	2446000e 	addiu	a2,v0,14

//memcpy(arptable_tftp[TFTP_CLIENT].ipaddr.ip, arppacket->sipaddr, sizeof(in_addr)); 
 //prom_printf("DoARPRpy 2.:update CLIENT ip address %x\n",arptable_tftp[TFTP_CLIENT].ipaddr.s_addr);
 
 memcpy(&targetIP,arppacket->tipaddr,4);
80001234:	24420026 	addiu	v0,v0,38
80001238:	88430000 	lwl	v1,0(v0)
8000123c:	98430003 	lwr	v1,3(v0)
80001240:	00601021 	move	v0,v1
80001244:	afa30034 	sw	v1,52(sp)

#ifdef SUPPORT_TFTP_CLIENT
 if ((tftp_client_enabled && (targetIP==arptable_tftp[TFTP_CLIENT].ipaddr.s_addr)) ||  	
	  (!tftp_client_enabled && (targetIP==arptable_tftp[TFTP_SERVER].ipaddr.s_addr)))
#else
 if(targetIP==arptable_tftp[TFTP_SERVER].ipaddr.s_addr)/*that is us*/
80001248:	3c038002 	lui	v1,0x8002
8000124c:	8c6340f0 	lw	v1,16624(v1)
80001250:	14620025 	bne	v1,v0,800012e8 <doARPReply+0xc8>
80001254:	8fbf003c 	lw	ra,60(sp)
#endif 	
 {
#if 1
    /*Fill in the arp reply payload.*/
    arpreply.hwtype = htons(1);
80001258:	24020001 	li	v0,1
8000125c:	a7a20018 	sh	v0,24(sp)
    arpreply.protocol = htons(FRAME_IP);/*that is 0x0800*/
80001260:	24020800 	li	v0,2048
80001264:	a7a2001a 	sh	v0,26(sp)
    arpreply.hwlen = ETH_ALEN;
80001268:	24020006 	li	v0,6
8000126c:	a3a2001c 	sb	v0,28(sp)
    arpreply.protolen = 4;
80001270:	24020004 	li	v0,4
80001274:	a3a2001d 	sb	v0,29(sp)
    arpreply.opcode = htons(ARP_REPLY);
80001278:	24020002 	li	v0,2
8000127c:	a7a2001e 	sh	v0,30(sp)
	    memcpy(&(arpreply.sipaddr), &(arptable_tftp[TFTP_CLIENT].ipaddr), sizeof(in_addr));		
	}
	else
#endif
	{
    memcpy(&(arpreply.shwaddr), &(arptable_tftp[TFTP_SERVER].node), ETH_ALEN);
80001280:	3c028002 	lui	v0,0x8002
80001284:	244340f0 	addiu	v1,v0,16624
80001288:	8c640004 	lw	a0,4(v1)
8000128c:	afa40020 	sw	a0,32(sp)
80001290:	94630008 	lhu	v1,8(v1)
80001294:	a7a30024 	sh	v1,36(sp)
    memcpy(&(arpreply.sipaddr), &(arptable_tftp[TFTP_SERVER].ipaddr), sizeof(in_addr));
80001298:	8c4240f0 	lw	v0,16624(v0)
8000129c:	aba20026 	swl	v0,38(sp)
800012a0:	bba20029 	swr	v0,41(sp)
	}		
    memcpy(&(arpreply.thwaddr), arppacket->shwaddr, ETH_ALEN);
800012a4:	94c40008 	lhu	a0,8(a2)
800012a8:	94c3000a 	lhu	v1,10(a2)
800012ac:	94c2000c 	lhu	v0,12(a2)
800012b0:	a7a4002a 	sh	a0,42(sp)
800012b4:	a7a3002c 	sh	v1,44(sp)
800012b8:	a7a2002e 	sh	v0,46(sp)
    memcpy(&(arpreply.tipaddr), arppacket->sipaddr, sizeof(in_addr));
800012bc:	88c2000e 	lwl	v0,14(a2)
800012c0:	98c20011 	lwr	v0,17(a2)
800012c4:	afa20030 	sw	v0,48(sp)

    prepare_txpkt(0,FRAME_ARP,arppacket->shwaddr,(Int8*)&arpreply,(Int16)sizeof(arpreply));
800012c8:	2402001c 	li	v0,28
800012cc:	afa20010 	sw	v0,16(sp)
800012d0:	00002021 	move	a0,zero
800012d4:	24050806 	li	a1,2054
800012d8:	24c60008 	addiu	a2,a2,8
800012dc:	0c000880 	jal	80002200 <prepare_txpkt>
800012e0:	27a70018 	addiu	a3,sp,24
    memcpy(&(arpreply.tipaddr), &(arptable_tftp[TFTP_CLIENT].ipaddr), sizeof(in_addr));

    prepare_txpkt(0,FRAME_ARP,arptable_tftp[TFTP_CLIENT].node,(Int8*)&arpreply,(Int16)sizeof(arpreply));
#endif
   } 
}
800012e4:	8fbf003c 	lw	ra,60(sp)
800012e8:	03e00008 	jr	ra
800012ec:	27bd0040 	addiu	sp,sp,64

800012f0 <tftpd_send_data>:
#endif  
 prepare_txpkt(0,FRAME_IP,arptable_tftp[TFTP_CLIENT].node,(Int8*)&tftp_tx,(Int16)sizeof(struct iphdr)+sizeof(struct udphdr)+4);
}
//----------------------------------------------------------------------------------------
void tftpd_send_data(char* filename, Int16 block_number)
{
800012f0:	27bdfa20 	addiu	sp,sp,-1504
800012f4:	afbf05dc 	sw	ra,1500(sp)
800012f8:	afb205d8 	sw	s2,1496(sp)
800012fc:	afb105d4 	sw	s1,1492(sp)
80001300:	afb005d0 	sw	s0,1488(sp)
80001304:	30b0ffff 	andi	s0,a1,0xffff
 Int32* data; 
 int length;


 /********************************************/  
   data=(Int32 *)(image_address+ 512*(block_number-1));
80001308:	02002821 	move	a1,s0
8000130c:	3c028001 	lui	v0,0x8001
   //prom_printf("send data start at %x\n",data);
 if (512* block_number==(file_length_to_client+512))
80001310:	00102240 	sll	a0,s0,0x9
80001314:	3c038002 	lui	v1,0x8002
80001318:	8c632e5c 	lw	v1,11868(v1)
8000131c:	24660200 	addiu	a2,v1,512
80001320:	14860006 	bne	a0,a2,8000133c <tftpd_send_data+0x4c>
80001324:	8c4272b8 	lw	v0,29368(v0)
    {
    /*it is over that means a length=0 data is required*/
    length=0;
    //prom_printf("TFTP RRQ last NULL data to send\n");
    it_is_EOF=1;
80001328:	24040001 	li	a0,1
8000132c:	3c038002 	lui	v1,0x8002
80001330:	ac642fd0 	sw	a0,12240(v1)
80001334:	080004d8 	j	80001360 <tftpd_send_data+0x70>
80001338:	00008821 	move	s1,zero
    }
 else if( 512* block_number > file_length_to_client)
8000133c:	0064202b 	sltu	a0,v1,a0
80001340:	10800007 	beqz	a0,80001360 <tftpd_send_data+0x70>
80001344:	24110200 	li	s1,512
    { 
     length=file_length_to_client-512*(block_number-1);
80001348:	24040001 	li	a0,1
8000134c:	00908823 	subu	s1,a0,s0
80001350:	00118a40 	sll	s1,s1,0x9
80001354:	02238821 	addu	s1,s1,v1
     //prom_printf("TFTP RRQ last data to send\n");
     it_is_EOF=1;
80001358:	3c038002 	lui	v1,0x8002
8000135c:	ac642fd0 	sw	a0,12240(v1)
 else
    length=512;
 
 /********************************************/
 /*generate the TFTP body*/
 tftp_tx.opcode=htons(TFTP_DATA);
80001360:	24030003 	li	v1,3
80001364:	a7a30034 	sh	v1,52(sp)
 memcpy(tftp_tx.u.data.download,(Int8*)data,length);
80001368:	24a5ffff 	addiu	a1,a1,-1
8000136c:	00052a40 	sll	a1,a1,0x9
80001370:	27a40038 	addiu	a0,sp,56
80001374:	00a22821 	addu	a1,a1,v0
80001378:	0c002046 	jal	80008118 <memcpy>
8000137c:	02203021 	move	a2,s1
 tftp_tx.u.data.block=htons(block_number);
80001380:	a7b00036 	sh	s0,54(sp)
 
 ip = (struct iphdr *)&tftp_tx;
 udp = (struct udphdr *)((Int8*)&tftp_tx + sizeof(struct iphdr));
 
 /*generate the IP header*/
 ip->verhdrlen = 0x45;
80001384:	24020045 	li	v0,69
80001388:	a3a20018 	sb	v0,24(sp)
 ip->service = 0;
8000138c:	a3a00019 	sb	zero,25(sp)
 ip->len = htons(32+length);
80001390:	3231ffff 	andi	s1,s1,0xffff
80001394:	26300020 	addiu	s0,s1,32
80001398:	3210ffff 	andi	s0,s0,0xffff
8000139c:	a7b0001a 	sh	s0,26(sp)
 ip->ident = 0;
800013a0:	a7a0001c 	sh	zero,28(sp)
 ip->frags = 0;
800013a4:	a7a0001e 	sh	zero,30(sp)
 ip->ttl = 60;
800013a8:	2402003c 	li	v0,60
800013ac:	a3a20020 	sb	v0,32(sp)
 ip->protocol = IP_UDP;
800013b0:	24020011 	li	v0,17
800013b4:	a3a20021 	sb	v0,33(sp)
 ip->chksum = 0;
800013b8:	a7a00022 	sh	zero,34(sp)
 ip->src.s_addr = arptable_tftp[TFTP_SERVER].ipaddr.s_addr;
800013bc:	3c028002 	lui	v0,0x8002
800013c0:	8c4340f0 	lw	v1,16624(v0)
800013c4:	afa30024 	sw	v1,36(sp)
 ip->dest.s_addr = arptable_tftp[TFTP_CLIENT].ipaddr.s_addr;
800013c8:	244240f0 	addiu	v0,v0,16624
800013cc:	8c42000c 	lw	v0,12(v0)
800013d0:	afa20028 	sw	v0,40(sp)
 ip->chksum = ipheader_chksum((Int16 *)&tftp_tx, sizeof(struct iphdr));
800013d4:	27b20018 	addiu	s2,sp,24
800013d8:	02402021 	move	a0,s2
800013dc:	0c0003af 	jal	80000ebc <ipheader_chksum>
800013e0:	24050014 	li	a1,20
800013e4:	a7a20022 	sh	v0,34(sp)
 /*generate the UDP header*/
 udp->src  = htons(SERVER_port);
800013e8:	3c028002 	lui	v0,0x8002
800013ec:	94422e54 	lhu	v0,11860(v0)
800013f0:	a7a2002c 	sh	v0,44(sp)
 udp->dest = htons(CLIENT_port);
800013f4:	3c028002 	lui	v0,0x8002
800013f8:	94422e56 	lhu	v0,11862(v0)
800013fc:	a7a2002e 	sh	v0,46(sp)
 udp->len  = htons(length+4+8);
80001400:	2631000c 	addiu	s1,s1,12
80001404:	a7b10030 	sh	s1,48(sp)
 udp->chksum = 0;
 
 /*use twiddle here*/
 twiddle();
80001408:	0c00225d 	jal	80008974 <twiddle>
8000140c:	a7a00032 	sh	zero,50(sp)
 //prom_printf(" -> ");
 
 prepare_txpkt(0,FRAME_IP,arptable_tftp[TFTP_CLIENT].node,(Int8*)&tftp_tx,(Int16)sizeof(struct iphdr)+sizeof(struct udphdr)+length+4);
80001410:	afb00010 	sw	s0,16(sp)
80001414:	00002021 	move	a0,zero
80001418:	24050800 	li	a1,2048
8000141c:	3c068002 	lui	a2,0x8002
80001420:	24c64100 	addiu	a2,a2,16640
80001424:	0c000880 	jal	80002200 <prepare_txpkt>
80001428:	02403821 	move	a3,s2
}
8000142c:	8fbf05dc 	lw	ra,1500(sp)
80001430:	8fb205d8 	lw	s2,1496(sp)
80001434:	8fb105d4 	lw	s1,1492(sp)
80001438:	8fb005d0 	lw	s0,1488(sp)
8000143c:	03e00008 	jr	ra
80001440:	27bd05e0 	addiu	sp,sp,1504

80001444 <prepareDATA>:

}
//----------------------------------------------------------------------------------------
/*Why we prepare DATA, because we receive the ACK*/
static void prepareDATA(void)
{
80001444:	27bdffe8 	addiu	sp,sp,-24
80001448:	afbf0014 	sw	ra,20(sp)
 struct tftp_t *tftppacket;
 Int16 tftpopcode;
 Int32 tftpdata_length;
 Int16 block_received=0;

    if (!tftpd_is_ready)
8000144c:	3c028002 	lui	v0,0x8002
80001450:	8c422fc4 	lw	v0,12228(v0)
80001454:	10400043 	beqz	v0,80001564 <prepareDATA+0x120>
80001458:	3c028002 	lui	v0,0x8002
        return;
 udpheader = (struct udphdr *)&nic.packet[ETH_HLEN+ sizeof(struct iphdr)];
8000145c:	8c422e4c 	lw	v0,11852(v0)
80001460:	24430022 	addiu	v1,v0,34
 if(udpheader->dest==htons(SERVER_port))
80001464:	94650002 	lhu	a1,2(v1)
80001468:	3c048002 	lui	a0,0x8002
8000146c:	94842e54 	lhu	a0,11860(a0)
80001470:	14a4003d 	bne	a1,a0,80001568 <prepareDATA+0x124>
80001474:	8fbf0014 	lw	ra,20(sp)
   {
    /*memorize CLIENT port*/
    CLIENT_port=  ntohs(udpheader->src); 
80001478:	94640000 	lhu	a0,0(v1)
8000147c:	3c038002 	lui	v1,0x8002
80001480:	a4642e56 	sh	a0,11862(v1)
    tftppacket = (struct tftp_t *)&nic.packet[ETH_HLEN];
    /*no need to check opcode, this is a ACK packet*/     
    /*parse the TFTP ACK number*/	
    block_received=tftppacket->u.ack.block;
    if(block_received != (block_expected))
80001484:	3c038002 	lui	v1,0x8002
80001488:	94632e48 	lhu	v1,11848(v1)
8000148c:	3063ffff 	andi	v1,v1,0xffff
    /*memorize CLIENT port*/
    CLIENT_port=  ntohs(udpheader->src); 
    tftppacket = (struct tftp_t *)&nic.packet[ETH_HLEN];
    /*no need to check opcode, this is a ACK packet*/     
    /*parse the TFTP ACK number*/	
    block_received=tftppacket->u.ack.block;
80001490:	9442002c 	lhu	v0,44(v0)
80001494:	1043000c 	beq	v0,v1,800014c8 <prepareDATA+0x84>
80001498:	3c028002 	lui	v0,0x8002
    if(block_received != (block_expected))
    {
     //prom_printf("line=%d: block_received=%d, block_expected=%d\n", __LINE__,  block_received,  block_expected); // for debug
     prom_printf("\n**TFTP #\n");
8000149c:	3c048001 	lui	a0,0x8001
800014a0:	0c002325 	jal	80008c94 <dprintf>
800014a4:	24844084 	addiu	a0,a0,16516
     tftpd_send_data(filename,block_expected);
800014a8:	3c028002 	lui	v0,0x8002
800014ac:	94452e48 	lhu	a1,11848(v0)
800014b0:	3c048002 	lui	a0,0x8002
800014b4:	24843ef0 	addiu	a0,a0,16112
800014b8:	0c0004bc 	jal	800012f0 <tftpd_send_data>
800014bc:	30a5ffff 	andi	a1,a1,0xffff
   }
//else 
//   prom_printf("\n**TFTP port number error\n");   
  

}                               
800014c0:	0800055a 	j	80001568 <prepareDATA+0x124>
800014c4:	8fbf0014 	lw	ra,20(sp)
     prom_printf("\n**TFTP #\n");
     tftpd_send_data(filename,block_expected);
    }
    else 
     {      
      block_expected=block_expected+1;      
800014c8:	94432e48 	lhu	v1,11848(v0)
800014cc:	24630001 	addiu	v1,v1,1
800014d0:	3063ffff 	andi	v1,v1,0xffff
800014d4:	a4432e48 	sh	v1,11848(v0)
      if(!(it_is_EOF))
800014d8:	3c028002 	lui	v0,0x8002
800014dc:	8c422fd0 	lw	v0,12240(v0)
800014e0:	14400009 	bnez	v0,80001508 <prepareDATA+0xc4>
800014e4:	3c028002 	lui	v0,0x8002
          tftpd_send_data(filename,block_expected);     
800014e8:	3c028002 	lui	v0,0x8002
800014ec:	94452e48 	lhu	a1,11848(v0)
800014f0:	3c048002 	lui	a0,0x8002
800014f4:	24843ef0 	addiu	a0,a0,16112
800014f8:	0c0004bc 	jal	800012f0 <tftpd_send_data>
800014fc:	30a5ffff 	andi	a1,a1,0xffff
   }
//else 
//   prom_printf("\n**TFTP port number error\n");   
  

}                               
80001500:	0800055a 	j	80001568 <prepareDATA+0x124>
80001504:	8fbf0014 	lw	ra,20(sp)
      if(!(it_is_EOF))
          tftpd_send_data(filename,block_expected);     
      else 
         {
         /*After we receive the last ACK then we can go on.*/	
          bootState=BOOT_STATE0_INIT_ARP;  
80001508:	ac402e58 	sw	zero,11864(v0)
          one_tftp_lock=0; 
8000150c:	3c028002 	lui	v0,0x8002
80001510:	a0402fcc 	sb	zero,12236(v0)
          //prom_printf("\n**TFTP Client Upload Success! File Size = %X Bytes\n",file_length_to_server);                        
          prom_printf("\n*TFTP Client Download Success! File Size = %X Bytes\n",file_length_to_client);          
80001514:	3c048001 	lui	a0,0x8001
80001518:	24844090 	addiu	a0,a0,16528
8000151c:	3c028002 	lui	v0,0x8002
80001520:	0c002325 	jal	80008c94 <dprintf>
80001524:	8c452e5c 	lw	a1,11868(v0)
          prom_printf( ".Success!\n%s", "<RealTek>" );         
80001528:	3c048001 	lui	a0,0x8001
8000152c:	248440c8 	addiu	a0,a0,16584
80001530:	3c058001 	lui	a1,0x8001
80001534:	0c002325 	jal	80008c94 <dprintf>
80001538:	24a540d8 	addiu	a1,a1,16600
          nic.packet = eth_packet;
8000153c:	3c028002 	lui	v0,0x8002
80001540:	3c038002 	lui	v1,0x8002
80001544:	24634114 	addiu	v1,v1,16660
80001548:	ac432e4c 	sw	v1,11852(v0)
          nic.packetlen = 0;        
8000154c:	24422e4c 	addiu	v0,v0,11852
80001550:	ac400004 	sw	zero,4(v0)
          block_expected =0;       
80001554:	3c028002 	lui	v0,0x8002
80001558:	a4402e48 	sh	zero,11848(v0)
//prom_printf("line=%d:		block_expected=%d\n", __LINE__,  block_expected); // for debug
          
          it_is_EOF=0;
8000155c:	3c028002 	lui	v0,0x8002
80001560:	ac402fd0 	sw	zero,12240(v0)
   }
//else 
//   prom_printf("\n**TFTP port number error\n");   
  

}                               
80001564:	8fbf0014 	lw	ra,20(sp)
80001568:	03e00008 	jr	ra
8000156c:	27bd0018 	addiu	sp,sp,24

80001570 <setTFTP_RRQ>:
 }
#endif 
}
//----------------------------------------------------------------------------------------
static void setTFTP_RRQ(void)
{
80001570:	27bdffe0 	addiu	sp,sp,-32
80001574:	afbf001c 	sw	ra,28(sp)
80001578:	afb10018 	sw	s1,24(sp)
8000157c:	afb00014 	sw	s0,20(sp)
 struct tftp_t *tftppacket;
 
 Int16 tftpopcode;
 int find_zero;

    if (!tftpd_is_ready)
80001580:	3c028002 	lui	v0,0x8002
80001584:	8c422fc4 	lw	v0,12228(v0)
80001588:	10400055 	beqz	v0,800016e0 <setTFTP_RRQ+0x170>
8000158c:	3c028002 	lui	v0,0x8002
        return;
 udpheader = (struct udphdr *)&nic.packet[ETH_HLEN+ sizeof(struct iphdr)];
80001590:	8c502e4c 	lw	s0,11852(v0)
80001594:	26100022 	addiu	s0,s0,34
 if( udpheader->dest==htons(TFTP_PORT) )
80001598:	96030002 	lhu	v1,2(s0)
8000159c:	24020045 	li	v0,69
800015a0:	14620050 	bne	v1,v0,800016e4 <setTFTP_RRQ+0x174>
800015a4:	8fbf001c 	lw	ra,28(sp)
   {
   	
    prom_printf("\nFile Start: %x,length=%x\n",image_address,file_length_to_client);
800015a8:	3c048001 	lui	a0,0x8001
800015ac:	248440e4 	addiu	a0,a0,16612
800015b0:	3c028001 	lui	v0,0x8001
800015b4:	8c4572b8 	lw	a1,29368(v0)
800015b8:	3c028002 	lui	v0,0x8002
800015bc:	0c002325 	jal	80008c94 <dprintf>
800015c0:	8c462e5c 	lw	a2,11868(v0)
                    nic.packet[ETH_HLEN+14]&0xff, nic.packet[ETH_HLEN+15]&0xff
                    );
    }
    */
    /*memorize CLIENT IP address*/
    memcpy(&(arptable_tftp[TFTP_CLIENT].ipaddr.s_addr),(Int8*)&nic.packet[ETH_HLEN+12],4);
800015c4:	3c028002 	lui	v0,0x8002
800015c8:	8c452e4c 	lw	a1,11852(v0)
800015cc:	24a2001a 	addiu	v0,a1,26
800015d0:	88430000 	lwl	v1,0(v0)
800015d4:	98430003 	lwr	v1,3(v0)
800015d8:	3c028002 	lui	v0,0x8002
800015dc:	ac4340fc 	sw	v1,16636(v0)

    /*memorize CLIENT mac address*/
    memcpy(arptable_tftp[TFTP_CLIENT].node,(Int8*)&(nic.packet[ETH_ALEN]),ETH_ALEN);
800015e0:	3c038002 	lui	v1,0x8002
800015e4:	24a20006 	addiu	v0,a1,6
800015e8:	88440000 	lwl	a0,0(v0)
800015ec:	98440003 	lwr	a0,3(v0)
800015f0:	ac644100 	sw	a0,16640(v1)
800015f4:	24634100 	addiu	v1,v1,16640
800015f8:	90440004 	lbu	a0,4(v0)
800015fc:	a0640004 	sb	a0,4(v1)
80001600:	90420005 	lbu	v0,5(v0)
80001604:	a0620005 	sb	v0,5(v1)

    /*memorize CLIENT port*/
    CLIENT_port=  ntohs(udpheader->src); 
80001608:	96030000 	lhu	v1,0(s0)
8000160c:	3c028002 	lui	v0,0x8002
80001610:	a4432e56 	sh	v1,11862(v0)
    tftppacket = (struct tftp_t *)&nic.packet[ETH_HLEN];
    tftpopcode = tftppacket->opcode;      
    
    
    for(find_zero=0;find_zero<TFTP_DEFAULTSIZE_PACKET;find_zero++)
        if( *( (Int8*)(tftppacket->u.rrq)+find_zero ) ==0 )
80001614:	24a5002c 	addiu	a1,a1,44
80001618:	90a20000 	lbu	v0,0(a1)
8000161c:	24100001 	li	s0,1
80001620:	14400003 	bnez	v0,80001630 <setTFTP_RRQ+0xc0>
80001624:	24030200 	li	v1,512
80001628:	08000593 	j	8000164c <setTFTP_RRQ+0xdc>
8000162c:	00008021 	move	s0,zero
80001630:	00b01021 	addu	v0,a1,s0
80001634:	90420000 	lbu	v0,0(v0)
80001638:	10400005 	beqz	v0,80001650 <setTFTP_RRQ+0xe0>
8000163c:	3c118002 	lui	s1,0x8002
    CLIENT_port=  ntohs(udpheader->src); 
    tftppacket = (struct tftp_t *)&nic.packet[ETH_HLEN];
    tftpopcode = tftppacket->opcode;      
    
    
    for(find_zero=0;find_zero<TFTP_DEFAULTSIZE_PACKET;find_zero++)
80001640:	26100001 	addiu	s0,s0,1
80001644:	1603fffb 	bne	s0,v1,80001634 <setTFTP_RRQ+0xc4>
80001648:	00b01021 	addu	v0,a1,s0
        if( *( (Int8*)(tftppacket->u.rrq)+find_zero ) ==0 )
           break;
    
    memcpy(filename,tftppacket->u.rrq,find_zero);
8000164c:	3c118002 	lui	s1,0x8002
80001650:	26313ef0 	addiu	s1,s1,16112
80001654:	02202021 	move	a0,s1
80001658:	0c002046 	jal	80008118 <memcpy>
8000165c:	02003021 	move	a2,s0
    filename[find_zero]='\0';
80001660:	02118021 	addu	s0,s0,s1
80001664:	a2000000 	sb	zero,0(s0)
             nic.packet[ETH_ALEN+2]&0xff, nic.packet[ETH_ALEN+3]&0xff,
             nic.packet[ETH_ALEN+4]&0xff, nic.packet[ETH_ALEN+5]&0xff
             );
    }
    */
    memcpy(arptable_tftp[TFTP_CLIENT].node,(Int8*)&(nic.packet[ETH_ALEN]), ETH_ALEN); 
80001668:	3c038002 	lui	v1,0x8002
8000166c:	3c028002 	lui	v0,0x8002
80001670:	8c422e4c 	lw	v0,11852(v0)
80001674:	24420006 	addiu	v0,v0,6
80001678:	88440000 	lwl	a0,0(v0)
8000167c:	98440003 	lwr	a0,3(v0)
80001680:	ac644100 	sw	a0,16640(v1)
80001684:	24634100 	addiu	v1,v1,16640
80001688:	90440004 	lbu	a0,4(v0)
8000168c:	a0640004 	sb	a0,4(v1)
80001690:	90420005 	lbu	v0,5(v0)
80001694:	a0620005 	sb	v0,5(v1)
   
    prom_printf("\n**TFTP GET File %s,Size %X Byte\n",filename,file_length_to_client);                
80001698:	3c048001 	lui	a0,0x8001
8000169c:	24844100 	addiu	a0,a0,16640
800016a0:	02202821 	move	a1,s1
800016a4:	3c028002 	lui	v0,0x8002
800016a8:	0c002325 	jal	80008c94 <dprintf>
800016ac:	8c462e5c 	lw	a2,11868(v0)
    /*Initialziation of RRQ file*/   
    //image_address=FILESTART; //sc_yang
    /*now we can use fiile_length_to_client, if we have meet WRQ*/
    one_tftp_lock=1;
800016b0:	24030001 	li	v1,1
800016b4:	3c028002 	lui	v0,0x8002
800016b8:	a0432fcc 	sb	v1,12236(v0)
    /*we should send a data block numbered 1, waiting for number 1 ACK.*/
    tftpd_send_data(filename,0x0001);
800016bc:	02202021 	move	a0,s1
800016c0:	0c0004bc 	jal	800012f0 <tftpd_send_data>
800016c4:	24050001 	li	a1,1
    block_expected=1;
800016c8:	24030001 	li	v1,1
800016cc:	3c028002 	lui	v0,0x8002
800016d0:	a4432e48 	sh	v1,11848(v0)
//prom_printf("line=%d:		block_expected=%d\n", __LINE__,  block_expected); // for debug
		
    /*now change state to RRQ*/
    bootState=BOOT_STATE1_TFTP_CLIENT_RRQ; 
800016d4:	24030001 	li	v1,1
800016d8:	3c028002 	lui	v0,0x8002
800016dc:	ac432e58 	sw	v1,11864(v0)
   }
#else
    prom_printf("\ntftp read request is not supported\n");              
#endif
}
800016e0:	8fbf001c 	lw	ra,28(sp)
800016e4:	8fb10018 	lw	s1,24(sp)
800016e8:	8fb00014 	lw	s0,20(sp)
800016ec:	03e00008 	jr	ra
800016f0:	27bd0020 	addiu	sp,sp,32

800016f4 <tftpd_send_ack>:
	tftp_client_enabled = 0;
#endif
}
//----------------------------------------------------------------------------------------
void tftpd_send_ack(Int16 number)
{
800016f4:	27bdfa28 	addiu	sp,sp,-1496
800016f8:	afbf05d4 	sw	ra,1492(sp)
800016fc:	afb005d0 	sw	s0,1488(sp)
 /*UDP target port: CLIENT_port*/
 struct iphdr *ip;
 struct udphdr *udp;
 struct tftp_t tftp_tx;
 /*generate the TFTP body*/
 tftp_tx.opcode=htons(TFTP_ACK);
80001700:	24020004 	li	v0,4
80001704:	a7a20034 	sh	v0,52(sp)
 tftp_tx.u.ack.block=htons(number);
80001708:	a7a40036 	sh	a0,54(sp)
 
 ip = (struct iphdr *)&tftp_tx;
 udp = (struct udphdr *)((Int8*)&tftp_tx + sizeof(struct iphdr));
 
 /*IP header*/
 ip->verhdrlen = 0x45;
8000170c:	24020045 	li	v0,69
80001710:	a3a20018 	sb	v0,24(sp)
 ip->service = 0;
80001714:	a3a00019 	sb	zero,25(sp)
 ip->len = htons(32);
80001718:	24020020 	li	v0,32
8000171c:	a7a2001a 	sh	v0,26(sp)
 ip->ident = 0;
80001720:	a7a0001c 	sh	zero,28(sp)
 ip->frags = 0;
80001724:	a7a0001e 	sh	zero,30(sp)
 ip->ttl = 60;
80001728:	2402003c 	li	v0,60
8000172c:	a3a20020 	sb	v0,32(sp)
 ip->protocol = IP_UDP;
80001730:	24020011 	li	v0,17
80001734:	a3a20021 	sb	v0,33(sp)
 ip->chksum = 0;
80001738:	a7a00022 	sh	zero,34(sp)
	 ip->dest.s_addr = arptable_tftp[TFTP_SERVER].ipaddr.s_addr; 	
 }
 else
#endif
 {
 ip->src.s_addr = arptable_tftp[TFTP_SERVER].ipaddr.s_addr;
8000173c:	3c028002 	lui	v0,0x8002
80001740:	8c4340f0 	lw	v1,16624(v0)
80001744:	afa30024 	sw	v1,36(sp)
 ip->dest.s_addr = arptable_tftp[TFTP_CLIENT].ipaddr.s_addr;
80001748:	244240f0 	addiu	v0,v0,16624
8000174c:	8c42000c 	lw	v0,12(v0)
80001750:	afa20028 	sw	v0,40(sp)
 }
 ip->chksum = ipheader_chksum((Int16 *)&tftp_tx, sizeof(struct iphdr));
80001754:	27b00018 	addiu	s0,sp,24
80001758:	02002021 	move	a0,s0
8000175c:	0c0003af 	jal	80000ebc <ipheader_chksum>
80001760:	24050014 	li	a1,20
80001764:	a7a20022 	sh	v0,34(sp)
	 udp->dest = htons(SERVER_port); 	
 }
 else
#endif  
 {
 udp->src  = htons(SERVER_port);
80001768:	3c028002 	lui	v0,0x8002
8000176c:	94422e54 	lhu	v0,11860(v0)
80001770:	a7a2002c 	sh	v0,44(sp)
 udp->dest = htons(CLIENT_port);
80001774:	3c028002 	lui	v0,0x8002
80001778:	94422e56 	lhu	v0,11862(v0)
8000177c:	a7a2002e 	sh	v0,46(sp)
 }
 udp->len  = htons(32 - sizeof(struct iphdr));/*TFTP IP packet is 32 bytes.*/
80001780:	2402000c 	li	v0,12
80001784:	a7a20030 	sh	v0,48(sp)
 udp->chksum = 0;
80001788:	a7a00032 	sh	zero,50(sp)
#ifdef SUPPORT_TFTP_CLIENT
 if (tftp_client_enabled)
	 prepare_txpkt(0,FRAME_IP,arptable_tftp[TFTP_SERVER].node,(Int8*)&tftp_tx,(Int16)sizeof(struct iphdr)+sizeof(struct udphdr)+4); 
 else
#endif  
 prepare_txpkt(0,FRAME_IP,arptable_tftp[TFTP_CLIENT].node,(Int8*)&tftp_tx,(Int16)sizeof(struct iphdr)+sizeof(struct udphdr)+4);
8000178c:	24020020 	li	v0,32
80001790:	afa20010 	sw	v0,16(sp)
80001794:	00002021 	move	a0,zero
80001798:	24050800 	li	a1,2048
8000179c:	3c068002 	lui	a2,0x8002
800017a0:	24c64100 	addiu	a2,a2,16640
800017a4:	0c000880 	jal	80002200 <prepare_txpkt>
800017a8:	02003821 	move	a3,s0
}
800017ac:	8fbf05d4 	lw	ra,1492(sp)
800017b0:	8fb005d0 	lw	s0,1488(sp)
800017b4:	03e00008 	jr	ra
800017b8:	27bd05d8 	addiu	sp,sp,1496

800017bc <setTFTP_WRQ>:
/*DEBUG*/
//int upload_start=0;
/*DEBUG*/
//----------------------------------------------------------------------------------------
static void setTFTP_WRQ(void)
{
800017bc:	27bdffe8 	addiu	sp,sp,-24
800017c0:	afbf0014 	sw	ra,20(sp)
800017c4:	afb00010 	sw	s0,16(sp)
 struct udphdr *udpheader;
 
 struct tftp_t *tftppacket;
 Int16 tftpopcode;

    if (!tftpd_is_ready)
800017c8:	3c028002 	lui	v0,0x8002
800017cc:	8c422fc4 	lw	v0,12228(v0)
800017d0:	10400045 	beqz	v0,800018e8 <setTFTP_WRQ+0x12c>
800017d4:	3c028002 	lui	v0,0x8002
        return;

//dprintf("Receive TFTP WRQ\n");
  
 udpheader = (struct udphdr *)&nic.packet[ETH_HLEN+ sizeof(struct iphdr)];
800017d8:	8c502e4c 	lw	s0,11852(v0)
800017dc:	26020022 	addiu	v0,s0,34
 if( udpheader->dest==htons(TFTP_PORT) )
800017e0:	94440002 	lhu	a0,2(v0)
800017e4:	24030045 	li	v1,69
800017e8:	14830040 	bne	a0,v1,800018ec <setTFTP_WRQ+0x130>
800017ec:	8fbf0014 	lw	ra,20(sp)
   {
     /*memorize CLIENT port*/
    CLIENT_port=  ntohs(udpheader->src); 
800017f0:	94430000 	lhu	v1,0(v0)
800017f4:	3c028002 	lui	v0,0x8002
800017f8:	a4432e56 	sh	v1,11862(v0)
    tftppacket = (struct tftp_t *)&nic.packet[ETH_HLEN];
    
    /*memorize CLIENT mac address*/
    memcpy(arptable_tftp[TFTP_CLIENT].node,(Int8*)&(nic.packet[ETH_ALEN]),ETH_ALEN);
800017fc:	3c038002 	lui	v1,0x8002
80001800:	26020006 	addiu	v0,s0,6
80001804:	88440000 	lwl	a0,0(v0)
80001808:	98440003 	lwr	a0,3(v0)
8000180c:	ac644100 	sw	a0,16640(v1)
80001810:	24634100 	addiu	v1,v1,16640
80001814:	90440004 	lbu	a0,4(v0)
80001818:	a0640004 	sb	a0,4(v1)
8000181c:	90420005 	lbu	v0,5(v0)
80001820:	a0620005 	sb	v0,5(v1)
    /*memorize CLIENT IP address*/
    memcpy(&(arptable_tftp[TFTP_CLIENT].ipaddr.s_addr),(Int8*)&nic.packet[ETH_HLEN+12],4);
80001824:	3c028002 	lui	v0,0x8002
80001828:	8c422e4c 	lw	v0,11852(v0)
8000182c:	2442001a 	addiu	v0,v0,26
80001830:	88430000 	lwl	v1,0(v0)
80001834:	98430003 	lwr	v1,3(v0)
80001838:	3c028002 	lui	v0,0x8002
8000183c:	ac4340fc 	sw	v1,16636(v0)
    /*here we can parse the file name if required.*/
    prom_printf("\n**TFTP Client Upload, File Name: %s\n",tftppacket->u.wrq);   
80001840:	2610002c 	addiu	s0,s0,44
80001844:	3c048001 	lui	a0,0x8001
80001848:	24844124 	addiu	a0,a0,16676
8000184c:	0c002325 	jal	80008c94 <dprintf>
80001850:	02002821 	move	a1,s0
    /*initializaiton of writing file.*/


//#if 0
//    if(!strcmp(tftppacket->u.wrq,TEST_FILENAME))
    if(strstr(tftppacket->u.wrq,TEST_FILENAME))
80001854:	02002021 	move	a0,s0
80001858:	3c058001 	lui	a1,0x8001
8000185c:	0c002067 	jal	8000819c <strstr>
80001860:	24a5414c 	addiu	a1,a1,16716
80001864:	10400004 	beqz	v0,80001878 <setTFTP_WRQ+0xbc>
80001868:	24030001 	li	v1,1
    {
       jump_to_test=1;
8000186c:	3c028002 	lui	v0,0x8002
80001870:	0800062a 	j	800018a8 <setTFTP_WRQ+0xec>
80001874:	ac432fc0 	sw	v1,12224(v0)
       //image_address=TESTSTART;
    }
    else if(!strcmp(tftppacket->u.wrq,BOOT_FILENAME))
80001878:	02002021 	move	a0,s0
8000187c:	3c058001 	lui	a1,0x8001
80001880:	0c002015 	jal	80008054 <strcmp>
80001884:	24a54154 	addiu	a1,a1,16724
80001888:	14400008 	bnez	v0,800018ac <setTFTP_WRQ+0xf0>
8000188c:	3c028001 	lui	v0,0x8001
    {
       jump_to_test=1;
80001890:	24030001 	li	v1,1
80001894:	3c028002 	lui	v0,0x8002
80001898:	ac432fc0 	sw	v1,12224(v0)
       image_address=BOOTSTART;
8000189c:	3c038000 	lui	v1,0x8000
800018a0:	3c028001 	lui	v0,0x8001
800018a4:	ac4372b8 	sw	v1,29368(v0)
#endif
//#endif  
#if defined(CONFIG_TFTP_COMMAND)
	memset(image_address,0,MAX_CMD_LEN);
#endif
    address_to_store=image_address;
800018a8:	3c028001 	lui	v0,0x8001
800018ac:	8c4372b8 	lw	v1,29368(v0)
800018b0:	3c028002 	lui	v0,0x8002
800018b4:	ac432e44 	sw	v1,11844(v0)
    file_length_to_server=0;  
800018b8:	3c028002 	lui	v0,0x8002
800018bc:	ac402e64 	sw	zero,11876(v0)
    /*now send one ACK out, to identify this.*/
    tftpd_send_ack(0x0000);/*Block number 0*/
800018c0:	0c0005bd 	jal	800016f4 <tftpd_send_ack>
800018c4:	00002021 	move	a0,zero
    block_expected=1;/*later client will send an Data number 1*/
800018c8:	24020001 	li	v0,1
800018cc:	3c038002 	lui	v1,0x8002
800018d0:	a4622e48 	sh	v0,11848(v1)
    //prom_printf("line=%d:		block_expected=%d\n", __LINE__,  block_expected); // for debug
		
	//now lock the tftp..till upload finished
	one_tftp_lock=1;
800018d4:	3c038002 	lui	v1,0x8002
800018d8:	a0622fcc 	sb	v0,12236(v1)
    /*Change state to WRQ state.*/
    bootState=BOOT_STATE2_TFTP_CLIENT_WRQ;
800018dc:	24030002 	li	v1,2
800018e0:	3c028002 	lui	v0,0x8002
800018e4:	ac432e58 	sw	v1,11864(v0)
   }
}
800018e8:	8fbf0014 	lw	ra,20(sp)
800018ec:	8fb00010 	lw	s0,16(sp)
800018f0:	03e00008 	jr	ra
800018f4:	27bd0018 	addiu	sp,sp,24

800018f8 <checkAutoFlashing>:
}
#endif

#if ! (defined(CONFIG_NFBI) || defined(CONFIG_NONE_FLASH))
void checkAutoFlashing(unsigned long startAddr, int len)
{
800018f8:	27bdff78 	addiu	sp,sp,-136
800018fc:	afbf0084 	sw	ra,132(sp)
80001900:	afbe0080 	sw	s8,128(sp)
80001904:	afb7007c 	sw	s7,124(sp)
80001908:	afb60078 	sw	s6,120(sp)
8000190c:	afb50074 	sw	s5,116(sp)
80001910:	afb40070 	sw	s4,112(sp)
80001914:	afb3006c 	sw	s3,108(sp)
80001918:	afb20068 	sw	s2,104(sp)
8000191c:	afb10064 	sw	s1,100(sp)
80001920:	afb00060 	sw	s0,96(sp)
80001924:	afa40088 	sw	a0,136(sp)
80001928:	afa5008c 	sw	a1,140(sp)
8000192c:	afa0003c 	sw	zero,60(sp)
80001930:	afa00044 	sw	zero,68(sp)
80001934:	afa00038 	sw	zero,56(sp)
				prom_printf("%s imgage checksum error at %X!\n"
				, Header.signature, startAddr+head_offset);
				return ;
			}
		}
		prom_printf("checksum Ok !\n");
80001938:	3c028001 	lui	v0,0x8001
8000193c:	244241bc 	addiu	v0,v0,16828
80001940:	afa20048 	sw	v0,72(sp)
		   	    prom_printf("it's special wrt image need add 4 byte to burnlen =%8x!\n",burnLen);
			    burnLen += 4;
			}
		}
		
		prom_printf("burn Addr =0x%x! srcAddr=0x%x len =0x%x \n", Header.burnAddr, srcAddr, burnLen);
80001944:	3c028001 	lui	v0,0x8001
80001948:	24424208 	addiu	v0,v0,16904
8000194c:	afa2004c 	sw	v0,76(sp)
				 int block_count=0;
				 //printf("original src_len %d dest 0x%x\n\r",src_len, dest);
				 //debug cl
				//block_count = (len+(block_size-1))/block_size;
	    		//len = block_count*block_size;
				block_count = (burnLen+(block_size-1))/block_size;
80001950:	3c148001 	lui	s4,0x8001
					unsigned int start_block=0;
					unsigned int addr=0, page=0;
					unsigned char *tmp_oob;


					tmp_oob = (unsigned char*)malloc((sizeof(char)*ppb*oob_size));
80001954:	3c158001 	lui	s5,0x8001
}
FINISH_GO:
	
#endif
		if(trueorfalse)
			prom_printf("\nFlash Write Successed!\n%s", "<RealTek>");
80001958:	3c028001 	lui	v0,0x8001
8000195c:	244242a4 	addiu	v0,v0,17060
80001960:	afa20050 	sw	v0,80(sp)
80001964:	3c028001 	lui	v0,0x8001
80001968:	244240d8 	addiu	v0,v0,16600
8000196c:	afa20054 	sw	v0,84(sp)
								start_page = ((Header.burnAddr+burn_offset)/page_size)-ppb;
							}					
							
							#ifdef CONFIG_RTK_NAND_BBT											
							                    //dprintf("[%s]:%d\n",__func__,__LINE__);
												start_block = ((Header.burnAddr+burn_offset) >> block_shift);
80001970:	3c178002 	lui	s7,0x8002
										if(nand_erase_nand(addr, block_size)){
											printf("%s: erase blockv:%x pagev:%x fail!\n",__FUNCTION__, i, page);
											break;
										}
										if(nand_write_ecc_ob(addr, block_size, srcAddr+offset, tmp_oob)){
												printf("%s: nand_write_ecc addrv :%x error\n",__FUNCTION__, addr);
80001974:	3c028001 	lui	v0,0x8001
80001978:	24424280 	addiu	v0,v0,17024
8000197c:	afa2005c 	sw	v0,92(sp)
80001980:	3c028001 	lui	v0,0x8001
80001984:	2442008c 	addiu	v0,v0,140
80001988:	afa20058 	sw	v0,88(sp)
#endif		
	while( (head_offset + sizeof(IMG_HEADER_T)) <  len){
		sum=0; sum1=0;
		memcpy(&Header, ((char *)startAddr + head_offset), sizeof(IMG_HEADER_T));
		
		if (!skip_check_signature) {
8000198c:	3c028001 	lui	v0,0x8001
80001990:	244272bc 	addiu	v0,v0,29372
#endif

#ifdef CONFIG_RTL_FLASH_DUAL_IMAGE_ENABLE	
	check_dualbank_setting(0); //must do check image to get current boot_bank.......
#endif		
	while( (head_offset + sizeof(IMG_HEADER_T)) <  len){
80001994:	080007b8 	j	80001ee0 <checkAutoFlashing+0x5e8>
80001998:	afa20040 	sw	v0,64(sp)
		sum=0; sum1=0;
		memcpy(&Header, ((char *)startAddr + head_offset), sizeof(IMG_HEADER_T));
8000199c:	8fa30088 	lw	v1,136(sp)
800019a0:	00438021 	addu	s0,v0,v1
800019a4:	8a050000 	lwl	a1,0(s0)
800019a8:	9a050003 	lwr	a1,3(s0)
800019ac:	8a040004 	lwl	a0,4(s0)
800019b0:	9a040007 	lwr	a0,7(s0)
800019b4:	8a030008 	lwl	v1,8(s0)
800019b8:	9a03000b 	lwr	v1,11(s0)
800019bc:	8a02000c 	lwl	v0,12(s0)
800019c0:	9a02000f 	lwr	v0,15(s0)
800019c4:	afa50010 	sw	a1,16(sp)
800019c8:	afa40014 	sw	a0,20(sp)
800019cc:	afa30018 	sw	v1,24(sp)
800019d0:	afa2001c 	sw	v0,28(sp)
		
		if (!skip_check_signature) {
800019d4:	8fa4003c 	lw	a0,60(sp)
800019d8:	14800034 	bnez	a0,80001aac <checkAutoFlashing+0x1b4>
800019dc:	27a40010 	addiu	a0,sp,16
800019e0:	8fb10040 	lw	s1,64(sp)
800019e4:	00009021 	move	s2,zero
			for(i=0 ;i < MAX_SIG_TBL ; i++) {
			
				if(!memcmp(Header.signature, (char *)sign_tbl[i].signature, sign_tbl[i].sig_len))
800019e8:	27be0010 	addiu	s8,sp,16
	while( (head_offset + sizeof(IMG_HEADER_T)) <  len){
		sum=0; sum1=0;
		memcpy(&Header, ((char *)startAddr + head_offset), sizeof(IMG_HEADER_T));
		
		if (!skip_check_signature) {
			for(i=0 ;i < MAX_SIG_TBL ; i++) {
800019ec:	24160007 	li	s6,7
			
				if(!memcmp(Header.signature, (char *)sign_tbl[i].signature, sign_tbl[i].sig_len))
800019f0:	03c02021 	move	a0,s8
800019f4:	8e250000 	lw	a1,0(s1)
800019f8:	0c002051 	jal	80008144 <memcmp>
800019fc:	8e260008 	lw	a2,8(s1)
80001a00:	10400006 	beqz	v0,80001a1c <checkAutoFlashing+0x124>
80001a04:	24020007 	li	v0,7
	while( (head_offset + sizeof(IMG_HEADER_T)) <  len){
		sum=0; sum1=0;
		memcpy(&Header, ((char *)startAddr + head_offset), sizeof(IMG_HEADER_T));
		
		if (!skip_check_signature) {
			for(i=0 ;i < MAX_SIG_TBL ; i++) {
80001a08:	26520001 	addiu	s2,s2,1
80001a0c:	1656fff8 	bne	s2,s6,800019f0 <checkAutoFlashing+0xf8>
80001a10:	26310018 	addiu	s1,s1,24
					break;			
				
		
			}
			if(i == MAX_SIG_TBL){
				head_offset += Header.len + sizeof(IMG_HEADER_T);
80001a14:	0800068a 	j	80001a28 <checkAutoFlashing+0x130>
80001a18:	8fb3001c 	lw	s3,28(sp)
				if(!memcmp(Header.signature, (char *)sign_tbl[i].signature, sign_tbl[i].sig_len))
					break;			
				
		
			}
			if(i == MAX_SIG_TBL){
80001a1c:	16420006 	bne	s2,v0,80001a38 <checkAutoFlashing+0x140>
80001a20:	00121040 	sll	v0,s2,0x1
				head_offset += Header.len + sizeof(IMG_HEADER_T);
80001a24:	8fb3001c 	lw	s3,28(sp)
80001a28:	26730010 	addiu	s3,s3,16
80001a2c:	8fa20038 	lw	v0,56(sp)
				continue ;
80001a30:	080007b7 	j	80001edc <checkAutoFlashing+0x5e4>
80001a34:	02629821 	addu	s3,s3,v0
			}			
			skip_header = sign_tbl[i].skip ;
80001a38:	00521021 	addu	v0,v0,s2
80001a3c:	24420001 	addiu	v0,v0,1
80001a40:	000210c0 	sll	v0,v0,0x3
80001a44:	8fa30040 	lw	v1,64(sp)
80001a48:	00621021 	addu	v0,v1,v0
80001a4c:	8c420004 	lw	v0,4(v0)
80001a50:	10400004 	beqz	v0,80001a64 <checkAutoFlashing+0x16c>
80001a54:	00000000 	nop
			if(skip_header){
				srcAddr = startAddr + head_offset + sizeof(IMG_HEADER_T);
80001a58:	261e0010 	addiu	s8,s0,16
					burnLen = Header.len; // +checksum
80001a5c:	0800069c 	j	80001a70 <checkAutoFlashing+0x178>
80001a60:	8fb1001c 	lw	s1,28(sp)
			}else{
				srcAddr = startAddr + head_offset ;
				burnLen = Header.len + sizeof(IMG_HEADER_T) ;
80001a64:	8fb1001c 	lw	s1,28(sp)
80001a68:	26310010 	addiu	s1,s1,16
80001a6c:	0200f021 	move	s8,s0
			}	
			reboot |= sign_tbl[i].reboot;
80001a70:	001210c0 	sll	v0,s2,0x3
80001a74:	00129140 	sll	s2,s2,0x5
80001a78:	02429023 	subu	s2,s2,v0
80001a7c:	8fa40040 	lw	a0,64(sp)
80001a80:	00929021 	addu	s2,a0,s2
80001a84:	8e420014 	lw	v0,20(s2)
80001a88:	8fa30044 	lw	v1,68(sp)
80001a8c:	00621825 	or	v1,v1,v0
80001a90:	afa30044 	sw	v1,68(sp)
			prom_printf("\n%s upgrade.\n", sign_tbl[i].comment);
80001a94:	3c048001 	lui	a0,0x8001
80001a98:	24844160 	addiu	a0,a0,16736
80001a9c:	0c002325 	jal	80008c94 <dprintf>
80001aa0:	8e450004 	lw	a1,4(s2)

#ifdef CONFIG_NAND_FLASH_BOOTING
		//add by cl for NAND DMA ALIGED,in case linux.bin or rootfs.bin start address in fw.bin not 4Byte aligned.
		//now 0x80a00000 just tmp for dma write.
		#define DRAM_BURN_TMP_ADDR        0xa0a00000 //this address will also use in boot read image from nand.
		if(srcAddr%4 != 0)
80001aa4:	080006be 	j	80001af8 <checkAutoFlashing+0x200>
80001aa8:	33c20003 	andi	v0,s8,0x3
			}	
			reboot |= sign_tbl[i].reboot;
			prom_printf("\n%s upgrade.\n", sign_tbl[i].comment);
		}
		else {
			if(!memcmp(Header.signature, BOOT_SIGNATURE, SIG_LEN))
80001aac:	3c058001 	lui	a1,0x8001
80001ab0:	24a54170 	addiu	a1,a1,16752
80001ab4:	0c002051 	jal	80008144 <memcmp>
80001ab8:	24060004 	li	a2,4
80001abc:	10400008 	beqz	v0,80001ae0 <checkAutoFlashing+0x1e8>
80001ac0:	261e0010 	addiu	s8,s0,16
				skip_header = 1;
			else {
				unsigned char *pRoot =((unsigned char *)startAddr) + head_offset + sizeof(IMG_HEADER_T);
				if (!memcmp(pRoot, SQSH_SIGNATURE, SIG_LEN))
80001ac4:	26040010 	addiu	a0,s0,16
80001ac8:	3c058001 	lui	a1,0x8001
80001acc:	24a54178 	addiu	a1,a1,16760
80001ad0:	0c002051 	jal	80008144 <memcmp>
80001ad4:	24060004 	li	a2,4
					skip_header = 1;
				else				
					skip_header = 0;
			}				
			if(skip_header){
80001ad8:	14400003 	bnez	v0,80001ae8 <checkAutoFlashing+0x1f0>
80001adc:	261e0010 	addiu	s8,s0,16
				srcAddr = startAddr + head_offset + sizeof(IMG_HEADER_T);
				burnLen = Header.len ; // +checksum
80001ae0:	080006bd 	j	80001af4 <checkAutoFlashing+0x1fc>
80001ae4:	8fb1001c 	lw	s1,28(sp)

			}else{
				srcAddr = startAddr + head_offset ;
				burnLen = Header.len + sizeof(IMG_HEADER_T) ;
80001ae8:	8fb1001c 	lw	s1,28(sp)
80001aec:	26310010 	addiu	s1,s1,16
80001af0:	0200f021 	move	s8,s0

#ifdef CONFIG_NAND_FLASH_BOOTING
		//add by cl for NAND DMA ALIGED,in case linux.bin or rootfs.bin start address in fw.bin not 4Byte aligned.
		//now 0x80a00000 just tmp for dma write.
		#define DRAM_BURN_TMP_ADDR        0xa0a00000 //this address will also use in boot read image from nand.
		if(srcAddr%4 != 0)
80001af4:	33c20003 	andi	v0,s8,0x3
80001af8:	10400007 	beqz	v0,80001b18 <checkAutoFlashing+0x220>
80001afc:	8fa4003c 	lw	a0,60(sp)
		{
		    //dprintf("[%s]:%d address not aligned,now use aligned address for NAND DMA\n",__func__,__LINE__);
		    memcpy((void *)DRAM_BURN_TMP_ADDR,(void*)srcAddr,burnLen); 
80001b00:	3c04a0a0 	lui	a0,0xa0a0
80001b04:	03c02821 	move	a1,s8
80001b08:	0c002046 	jal	80008118 <memcpy>
80001b0c:	02203021 	move	a2,s1
80001b10:	3c1ea0a0 	lui	s8,0xa0a0
		    srcAddr = DRAM_BURN_TMP_ADDR;
		}
#endif

		if(skip_check_signature || 
80001b14:	8fa4003c 	lw	a0,60(sp)
80001b18:	1480000c 	bnez	a0,80001b4c <checkAutoFlashing+0x254>
80001b1c:	27a40010 	addiu	a0,sp,16
			memcmp(Header.signature, WEB_SIGNATURE, 3)){
80001b20:	3c058001 	lui	a1,0x8001
80001b24:	24a54180 	addiu	a1,a1,16768
80001b28:	0c002051 	jal	80008144 <memcmp>
80001b2c:	24060003 	li	a2,3
		    memcpy((void *)DRAM_BURN_TMP_ADDR,(void*)srcAddr,burnLen); 
		    srcAddr = DRAM_BURN_TMP_ADDR;
		}
#endif

		if(skip_check_signature || 
80001b30:	14400006 	bnez	v0,80001b4c <checkAutoFlashing+0x254>
80001b34:	27a40010 	addiu	a0,sp,16
				continue;		
			}						
		}else
		{  //web page use different checksum algorimth

			for (i=0; i< Header.len; i++)
80001b38:	8fa6001c 	lw	a2,28(sp)
80001b3c:	14c0004f 	bnez	a2,80001c7c <checkAutoFlashing+0x384>
80001b40:	00002021 	move	a0,zero
80001b44:	08000731 	j	80001cc4 <checkAutoFlashing+0x3cc>
80001b48:	00000000 	nop
#endif

		if(skip_check_signature || 
			memcmp(Header.signature, WEB_SIGNATURE, 3)){
			//calculate checksum
			if(!memcmp(Header.signature, ALL1_SIGNATURE, SIG_LEN) ||
80001b4c:	3c058001 	lui	a1,0x8001
80001b50:	24a54188 	addiu	a1,a1,16776
80001b54:	0c002051 	jal	80008144 <memcmp>
80001b58:	24060004 	li	a2,4
80001b5c:	14400007 	bnez	v0,80001b7c <checkAutoFlashing+0x284>
80001b60:	27a40010 	addiu	a0,sp,16
					!memcmp(Header.signature, ALL2_SIGNATURE, SIG_LEN)) {										
				for (i=0; i< Header.len+sizeof(IMG_HEADER_T); i+=2) {
80001b64:	8fa6001c 	lw	a2,28(sp)
80001b68:	24c60010 	addiu	a2,a2,16
80001b6c:	14c0000b 	bnez	a2,80001b9c <checkAutoFlashing+0x2a4>
80001b70:	00001821 	move	v1,zero
			if ( sum ) {
				prom_printf("%s imgage checksum error at %X!\n"
				, Header.signature, startAddr+head_offset);
				return ;
			}
			if(!memcmp(Header.signature, ALL1_SIGNATURE, SIG_LEN)){
80001b74:	08000711 	j	80001c44 <checkAutoFlashing+0x34c>
80001b78:	27a40010 	addiu	a0,sp,16

		if(skip_check_signature || 
			memcmp(Header.signature, WEB_SIGNATURE, 3)){
			//calculate checksum
			if(!memcmp(Header.signature, ALL1_SIGNATURE, SIG_LEN) ||
					!memcmp(Header.signature, ALL2_SIGNATURE, SIG_LEN)) {										
80001b7c:	3c058001 	lui	a1,0x8001
80001b80:	24a54190 	addiu	a1,a1,16784
80001b84:	0c002051 	jal	80008144 <memcmp>
80001b88:	24060004 	li	a2,4
#endif

		if(skip_check_signature || 
			memcmp(Header.signature, WEB_SIGNATURE, 3)){
			//calculate checksum
			if(!memcmp(Header.signature, ALL1_SIGNATURE, SIG_LEN) ||
80001b8c:	1040fff6 	beqz	v0,80001b68 <checkAutoFlashing+0x270>
80001b90:	8fa6001c 	lw	a2,28(sp)
				}				
			}	
				else 
				{
					unsigned char x=0,y=0;
					unsigned short temp=0;
80001b94:	080006f3 	j	80001bcc <checkAutoFlashing+0x2d4>
80001b98:	a7a00020 	sh	zero,32(sp)
#endif

		if(skip_check_signature || 
			memcmp(Header.signature, WEB_SIGNATURE, 3)){
			//calculate checksum
			if(!memcmp(Header.signature, ALL1_SIGNATURE, SIG_LEN) ||
80001b9c:	00002021 	move	a0,zero
80001ba0:	00001021 	move	v0,zero
					!memcmp(Header.signature, ALL2_SIGNATURE, SIG_LEN)) {										
				for (i=0; i< Header.len+sizeof(IMG_HEADER_T); i+=2) {
					sum += *((unsigned short *)(startAddr+ head_offset + i));
80001ba4:	00902021 	addu	a0,a0,s0
80001ba8:	94840000 	lhu	a0,0(a0)
80001bac:	00641821 	addu	v1,v1,a0
80001bb0:	3063ffff 	andi	v1,v1,0xffff
		if(skip_check_signature || 
			memcmp(Header.signature, WEB_SIGNATURE, 3)){
			//calculate checksum
			if(!memcmp(Header.signature, ALL1_SIGNATURE, SIG_LEN) ||
					!memcmp(Header.signature, ALL2_SIGNATURE, SIG_LEN)) {										
				for (i=0; i< Header.len+sizeof(IMG_HEADER_T); i+=2) {
80001bb4:	24420002 	addiu	v0,v0,2
80001bb8:	0046282b 	sltu	a1,v0,a2
80001bbc:	14a0fff9 	bnez	a1,80001ba4 <checkAutoFlashing+0x2ac>
80001bc0:	00402021 	move	a0,v0
80001bc4:	08000707 	j	80001c1c <checkAutoFlashing+0x324>
80001bc8:	00000000 	nop
				else 
				{
					unsigned char x=0,y=0;
					unsigned short temp=0;
					
					for (i=0; i< Header.len; i+=2) 
80001bcc:	8fa2001c 	lw	v0,28(sp)
80001bd0:	1040001b 	beqz	v0,80001c40 <checkAutoFlashing+0x348>
80001bd4:	00002021 	move	a0,zero
80001bd8:	00001821 	move	v1,zero
80001bdc:	00001021 	move	v0,zero
					{
						
#if  defined(RTL8198)																		
#if 1				
						//sum +=*((unsigned short *)(startAddr+ head_offset + sizeof(IMG_HEADER_T) + i));
						memcpy(&temp, (startAddr+ head_offset + sizeof(IMG_HEADER_T) + i), 2); // for alignment issue
80001be0:	27a50020 	addiu	a1,sp,32
80001be4:	26070010 	addiu	a3,s0,16
80001be8:	00e42021 	addu	a0,a3,a0
80001bec:	90860000 	lbu	a2,0(a0)
80001bf0:	a0a60000 	sb	a2,0(a1)
80001bf4:	90840001 	lbu	a0,1(a0)
80001bf8:	a0a40001 	sb	a0,1(a1)
						sum+=temp;
80001bfc:	97a40020 	lhu	a0,32(sp)
80001c00:	00641821 	addu	v1,v1,a0
80001c04:	3063ffff 	andi	v1,v1,0xffff
				else 
				{
					unsigned char x=0,y=0;
					unsigned short temp=0;
					
					for (i=0; i< Header.len; i+=2) 
80001c08:	24420002 	addiu	v0,v0,2
80001c0c:	8fa6001c 	lw	a2,28(sp)
80001c10:	0046302b 	sltu	a2,v0,a2
80001c14:	14c0fff4 	bnez	a2,80001be8 <checkAutoFlashing+0x2f0>
80001c18:	00402021 	move	a0,v0
#else
				sum += *((unsigned short *)(startAddr+ head_offset + sizeof(IMG_HEADER_T) + i));
#endif	// defined(RTL8198)
				}
			}
			if ( sum ) {
80001c1c:	10600009 	beqz	v1,80001c44 <checkAutoFlashing+0x34c>
80001c20:	27a40010 	addiu	a0,sp,16
				prom_printf("%s imgage checksum error at %X!\n"
80001c24:	3c048001 	lui	a0,0x8001
80001c28:	24844198 	addiu	a0,a0,16792
80001c2c:	27a50010 	addiu	a1,sp,16
80001c30:	0c002325 	jal	80008c94 <dprintf>
80001c34:	02003021 	move	a2,s0
				, Header.signature, startAddr+head_offset);
				return ;
80001c38:	080007c4 	j	80001f10 <checkAutoFlashing+0x618>
80001c3c:	8fbf0084 	lw	ra,132(sp)
			}
			if(!memcmp(Header.signature, ALL1_SIGNATURE, SIG_LEN)){
80001c40:	27a40010 	addiu	a0,sp,16
80001c44:	3c058001 	lui	a1,0x8001
80001c48:	24a54188 	addiu	a1,a1,16776
80001c4c:	0c002051 	jal	80008144 <memcmp>
80001c50:	24060004 	li	a2,4
80001c54:	104000a1 	beqz	v0,80001edc <checkAutoFlashing+0x5e4>
80001c58:	27a40010 	addiu	a0,sp,16
				head_offset += sizeof(IMG_HEADER_T);
				continue;		
			}		
			if(!memcmp(Header.signature, ALL2_SIGNATURE, SIG_LEN)){
80001c5c:	3c058001 	lui	a1,0x8001
80001c60:	24a54190 	addiu	a1,a1,16784
80001c64:	0c002051 	jal	80008144 <memcmp>
80001c68:	24060004 	li	a2,4
80001c6c:	1040009a 	beqz	v0,80001ed8 <checkAutoFlashing+0x5e0>
80001c70:	24030001 	li	v1,1
80001c74:	08000731 	j	80001cc4 <checkAutoFlashing+0x3cc>
80001c78:	00000000 	nop
80001c7c:	00001821 	move	v1,zero
80001c80:	00001021 	move	v0,zero
			}						
		}else
		{  //web page use different checksum algorimth

			for (i=0; i< Header.len; i++)
			       sum1 += *((unsigned char *)(startAddr+ head_offset + sizeof(IMG_HEADER_T) + i));
80001c84:	00902021 	addu	a0,a0,s0
80001c88:	90840010 	lbu	a0,16(a0)
80001c8c:	00641821 	addu	v1,v1,a0
80001c90:	306300ff 	andi	v1,v1,0xff
				continue;		
			}						
		}else
		{  //web page use different checksum algorimth

			for (i=0; i< Header.len; i++)
80001c94:	24420001 	addiu	v0,v0,1
80001c98:	0046282b 	sltu	a1,v0,a2
80001c9c:	14a0fff9 	bnez	a1,80001c84 <checkAutoFlashing+0x38c>
80001ca0:	00402021 	move	a0,v0
			       sum1 += *((unsigned char *)(startAddr+ head_offset + sizeof(IMG_HEADER_T) + i));
			if ( sum1 ) {
80001ca4:	10600007 	beqz	v1,80001cc4 <checkAutoFlashing+0x3cc>
80001ca8:	3c048001 	lui	a0,0x8001
				prom_printf("%s imgage checksum error at %X!\n"
80001cac:	24844198 	addiu	a0,a0,16792
80001cb0:	27a50010 	addiu	a1,sp,16
80001cb4:	0c002325 	jal	80008c94 <dprintf>
80001cb8:	02003021 	move	a2,s0
				, Header.signature, startAddr+head_offset);
				return ;
80001cbc:	080007c4 	j	80001f10 <checkAutoFlashing+0x618>
80001cc0:	8fbf0084 	lw	ra,132(sp)
			}
		}
		prom_printf("checksum Ok !\n");
80001cc4:	0c002325 	jal	80008c94 <dprintf>
80001cc8:	8fa40048 	lw	a0,72(sp)
		
		if( (burnLen % 0x1000) == 0) //mean 4k alignemnt
80001ccc:	32220fff 	andi	v0,s1,0xfff
80001cd0:	1440000c 	bnez	v0,80001d04 <checkAutoFlashing+0x40c>
80001cd4:	8fa30088 	lw	v1,136(sp)
		{
			if( (*((unsigned int *)(startAddr+burnLen))) == 0xdeadc0de ) //wrt jffs2 endof mark
80001cd8:	02231021 	addu	v0,s1,v1
80001cdc:	8c430000 	lw	v1,0(v0)
80001ce0:	3c02dead 	lui	v0,0xdead
80001ce4:	3442c0de 	ori	v0,v0,0xc0de
80001ce8:	14620006 	bne	v1,v0,80001d04 <checkAutoFlashing+0x40c>
80001cec:	00000000 	nop

		 	    prom_printf("dual image burn_offset =0x%x \n", burn_offset); //mark_boot
			    //update bootinfo 
			    rtk_update_bootbank(next_bank);  //if bank is bank1 not bank0 ,then need add offset	
#endif		
		   	    prom_printf("it's special wrt image need add 4 byte to burnlen =%8x!\n",burnLen);
80001cf0:	3c048001 	lui	a0,0x8001
80001cf4:	248441cc 	addiu	a0,a0,16844
80001cf8:	0c002325 	jal	80008c94 <dprintf>
80001cfc:	02202821 	move	a1,s1
			    burnLen += 4;
80001d00:	26310004 	addiu	s1,s1,4
			}
		}
		
		prom_printf("burn Addr =0x%x! srcAddr=0x%x len =0x%x \n", Header.burnAddr, srcAddr, burnLen);
80001d04:	8fa4004c 	lw	a0,76(sp)
80001d08:	8fa50018 	lw	a1,24(sp)
80001d0c:	03c03021 	move	a2,s8
80001d10:	0c002325 	jal	80008c94 <dprintf>
80001d14:	02203821 	move	a3,s1
				 int block_count=0;
				 //printf("original src_len %d dest 0x%x\n\r",src_len, dest);
				 //debug cl
				//block_count = (len+(block_size-1))/block_size;
	    		//len = block_count*block_size;
				block_count = (burnLen+(block_size-1))/block_size;
80001d18:	8e9075c4 	lw	s0,30148(s4)
					unsigned int start_block=0;
					unsigned int addr=0, page=0;
					unsigned char *tmp_oob;


					tmp_oob = (unsigned char*)malloc((sizeof(char)*ppb*oob_size));
80001d1c:	3c028001 	lui	v0,0x8001
80001d20:	8c4475e8 	lw	a0,30184(v0)
80001d24:	8ea275ec 	lw	v0,30188(s5)
80001d28:	0c001f55 	jal	80007d54 <malloc>
80001d2c:	70822002 	mul	a0,a0,v0
					if(!tmp_oob){
80001d30:	14400006 	bnez	v0,80001d4c <checkAutoFlashing+0x454>
80001d34:	afa20028 	sw	v0,40(sp)
						printf("can't alloc memory for tmp_oob buf!!!\n\r");
80001d38:	3c048001 	lui	a0,0x8001
80001d3c:	0c002325 	jal	80008c94 <dprintf>
80001d40:	24844234 	addiu	a0,a0,16948
						return -1;
80001d44:	080007c4 	j	80001f10 <checkAutoFlashing+0x618>
80001d48:	8fbf0084 	lw	ra,132(sp)
				 int block_count=0;
				 //printf("original src_len %d dest 0x%x\n\r",src_len, dest);
				 //debug cl
				//block_count = (len+(block_size-1))/block_size;
	    		//len = block_count*block_size;
				block_count = (burnLen+(block_size-1))/block_size;
80001d4c:	2602ffff 	addiu	v0,s0,-1
80001d50:	00518821 	addu	s1,v0,s1
80001d54:	0230001b 	divu	zero,s1,s0
80001d58:	020001f4 	teq	s0,zero,0x7
80001d5c:	00008812 	mflo	s1
					if(!tmp_oob){
						printf("can't alloc memory for tmp_oob buf!!!\n\r");
						return -1;
					}
						//printf("(sizeof(char)*ppb*oob_size) %d!!!\n\r", (sizeof(char)*ppb*oob_size));
					memset(tmp_oob,0xff,(sizeof(char)*ppb*oob_size));
80001d60:	3c028001 	lui	v0,0x8001
80001d64:	8c4675e8 	lw	a2,30184(v0)
80001d68:	8ea275ec 	lw	v0,30188(s5)
80001d6c:	8fa40028 	lw	a0,40(sp)
80001d70:	240500ff 	li	a1,255
80001d74:	0c00203d 	jal	800080f4 <memset>
80001d78:	70c23002 	mul	a2,a2,v0
					rtk_scan_v2r_bbt();
80001d7c:	0c0017c5 	jal	80005f14 <rtk_scan_v2r_bbt>
80001d80:	00000000 	nop
					rtk_nand_scan_bbt();
80001d84:	0c0015e8 	jal	800057a0 <rtk_nand_scan_bbt>
80001d88:	00000000 	nop
										start_block = (IMG_BACKUP_ADDR >> block_shift);
					#endif
						offset = 0;
					}else{
							//printf("Header.burnAddr:%x burn_offset:%x\n\r",Header.burnAddr,burn_offset);
							if((Header.burnAddr+burn_offset)==0){
80001d8c:	8fa20018 	lw	v0,24(sp)
80001d90:	14400007 	bnez	v0,80001db0 <checkAutoFlashing+0x4b8>
80001d94:	8ee23d70 	lw	v0,15728(s7)
									//continue;
									//while(1); //debug cl
									//debug boot.bin
									//Header.burnAddr = 0x100440;
									//burn_offset = 0;
									if (rtk_write_ecc_page(Header.burnAddr+burn_offset, srcAddr, burnLen))
80001d98:	00002021 	move	a0,zero
80001d9c:	03c02821 	move	a1,s8
80001da0:	0c0014a4 	jal	80005290 <rtk_write_ecc_page>
80001da4:	72303002 	mul	a2,s1,s0
80001da8:	1440003d 	bnez	v0,80001ea0 <checkAutoFlashing+0x5a8>
80001dac:	8ee23d70 	lw	v0,15728(s7)
								start_page = ((Header.burnAddr+burn_offset)/page_size)-ppb;
							}					
							
							#ifdef CONFIG_RTK_NAND_BBT											
							                    //dprintf("[%s]:%d\n",__func__,__LINE__);
												start_block = ((Header.burnAddr+burn_offset) >> block_shift);
80001db0:	8fb00018 	lw	s0,24(sp)
80001db4:	00508006 	srlv	s0,s0,v0
												//debug cl
												//continue;
												//while(1);
									
									//printf("start blockv:%x start_page:%x block_count:%x\n\r",start_block,start_page,block_count);
									for(i=start_block;i<block_count+start_block;i++){ //caculate how many block.
80001db8:	02308821 	addu	s1,s1,s0
80001dbc:	afb1002c 	sw	s1,44(sp)
80001dc0:	0211102b 	sltu	v0,s0,s1
80001dc4:	10400034 	beqz	v0,80001e98 <checkAutoFlashing+0x5a0>
80001dc8:	0000b021 	move	s6,zero
										if(nand_write_ecc_ob(addr, block_size, srcAddr+offset, tmp_oob)){
												printf("%s: nand_write_ecc addrv :%x error\n",__FUNCTION__, addr);
												break;
										}	
										offset += block_size;//shift buffer ptr one block each time.
										if(i==(block_count+start_block-1)){
80001dcc:	2622ffff 	addiu	v0,s1,-1
80001dd0:	afa20034 	sw	v0,52(sp)
80001dd4:	afbe0030 	sw	s8,48(sp)
80001dd8:	02c0f021 	move	s8,s6
80001ddc:	02008821 	move	s1,s0
80001de0:	02009821 	move	s3,s0
									
									//printf("start blockv:%x start_page:%x block_count:%x\n\r",start_block,start_page,block_count);
									for(i=start_block;i<block_count+start_block;i++){ //caculate how many block.
										//real_addr = (bbt_v2r[i].block_r << block_shift);
										//real_page = bbt_v2r[i].block_r * ppb;
										addr = (i << block_shift);
80001de4:	8ef23d70 	lw	s2,15728(s7)
80001de8:	02519004 	sllv	s2,s1,s2
										page = i * ppb;
80001dec:	8eb075ec 	lw	s0,30188(s5)
80001df0:	72708002 	mul	s0,s3,s0
										//printf("addrv:%x pagev:%x block_count:%x i:%d\n\r",addr, page,block_count,i);
								 
										//if(rtk_erase_block(real_page))
										if(nand_erase_nand(addr, block_size)){
80001df4:	02402021 	move	a0,s2
80001df8:	0c001d2e 	jal	800074b8 <nand_erase_nand>
80001dfc:	8e8575c4 	lw	a1,30148(s4)
80001e00:	1040000b 	beqz	v0,80001e30 <checkAutoFlashing+0x538>
80001e04:	02402021 	move	a0,s2
80001e08:	02009021 	move	s2,s0
80001e0c:	03c0b021 	move	s6,s8
											printf("%s: erase blockv:%x pagev:%x fail!\n",__FUNCTION__, i, page);
80001e10:	3c048001 	lui	a0,0x8001
80001e14:	2484425c 	addiu	a0,a0,16988
80001e18:	8fa50058 	lw	a1,88(sp)
80001e1c:	02203021 	move	a2,s1
80001e20:	0c002325 	jal	80008c94 <dprintf>
80001e24:	02403821 	move	a3,s2
											break;
80001e28:	080007a6 	j	80001e98 <checkAutoFlashing+0x5a0>
80001e2c:	00000000 	nop
										}
										if(nand_write_ecc_ob(addr, block_size, srcAddr+offset, tmp_oob)){
80001e30:	8e8575c4 	lw	a1,30148(s4)
80001e34:	8fa20030 	lw	v0,48(sp)
80001e38:	02c23021 	addu	a2,s6,v0
80001e3c:	0c001a4e 	jal	80006938 <nand_write_ecc_ob>
80001e40:	8fa70028 	lw	a3,40(sp)
80001e44:	10400008 	beqz	v0,80001e68 <checkAutoFlashing+0x570>
80001e48:	8e8375c4 	lw	v1,30148(s4)
80001e4c:	03c0b021 	move	s6,s8
												printf("%s: nand_write_ecc addrv :%x error\n",__FUNCTION__, addr);
80001e50:	8fa4005c 	lw	a0,92(sp)
80001e54:	8fa50058 	lw	a1,88(sp)
80001e58:	0c002325 	jal	80008c94 <dprintf>
80001e5c:	02403021 	move	a2,s2
												break;
80001e60:	080007a6 	j	80001e98 <checkAutoFlashing+0x5a0>
80001e64:	00000000 	nop
										}	
										offset += block_size;//shift buffer ptr one block each time.
										if(i==(block_count+start_block-1)){
80001e68:	8fa40034 	lw	a0,52(sp)
80001e6c:	02649826 	xor	s3,s3,a0
80001e70:	24020001 	li	v0,1
80001e74:	0053f00a 	movz	s8,v0,s3
												//debug cl
												//continue;
												//while(1);
									
									//printf("start blockv:%x start_page:%x block_count:%x\n\r",start_block,start_page,block_count);
									for(i=start_block;i<block_count+start_block;i++){ //caculate how many block.
80001e78:	26310001 	addiu	s1,s1,1
80001e7c:	8fa4002c 	lw	a0,44(sp)
80001e80:	0224102b 	sltu	v0,s1,a0
80001e84:	10400003 	beqz	v0,80001e94 <checkAutoFlashing+0x59c>
80001e88:	02209821 	move	s3,s1
										}
										if(nand_write_ecc_ob(addr, block_size, srcAddr+offset, tmp_oob)){
												printf("%s: nand_write_ecc addrv :%x error\n",__FUNCTION__, addr);
												break;
										}	
										offset += block_size;//shift buffer ptr one block each time.
80001e8c:	08000779 	j	80001de4 <checkAutoFlashing+0x4ec>
80001e90:	02c3b021 	addu	s6,s6,v1
80001e94:	03c0b021 	move	s6,s8

}
FINISH_GO:
	
#endif
		if(trueorfalse)
80001e98:	12c00009 	beqz	s6,80001ec0 <checkAutoFlashing+0x5c8>
80001e9c:	3c048001 	lui	a0,0x8001
			prom_printf("\nFlash Write Successed!\n%s", "<RealTek>");
80001ea0:	8fa40050 	lw	a0,80(sp)
80001ea4:	0c002325 	jal	80008c94 <dprintf>
80001ea8:	8fa50054 	lw	a1,84(sp)
		else{
			prom_printf("\nFlash Write Failed!\n%s", "<RealTek>");
			return ;
		}

		head_offset += Header.len + sizeof(IMG_HEADER_T);
80001eac:	8fb3001c 	lw	s3,28(sp)
80001eb0:	26730010 	addiu	s3,s3,16
80001eb4:	8fa20038 	lw	v0,56(sp)
80001eb8:	080007b7 	j	80001edc <checkAutoFlashing+0x5e4>
80001ebc:	02629821 	addu	s3,s3,v0
	
#endif
		if(trueorfalse)
			prom_printf("\nFlash Write Successed!\n%s", "<RealTek>");
		else{
			prom_printf("\nFlash Write Failed!\n%s", "<RealTek>");
80001ec0:	248442c0 	addiu	a0,a0,17088
80001ec4:	3c058001 	lui	a1,0x8001
80001ec8:	0c002325 	jal	80008c94 <dprintf>
80001ecc:	24a540d8 	addiu	a1,a1,16600
			return ;
80001ed0:	080007c4 	j	80001f10 <checkAutoFlashing+0x618>
80001ed4:	8fbf0084 	lw	ra,132(sp)
80001ed8:	afa3003c 	sw	v1,60(sp)
80001edc:	afb30038 	sw	s3,56(sp)
#endif

#ifdef CONFIG_RTL_FLASH_DUAL_IMAGE_ENABLE	
	check_dualbank_setting(0); //must do check image to get current boot_bank.......
#endif		
	while( (head_offset + sizeof(IMG_HEADER_T)) <  len){
80001ee0:	8fa40038 	lw	a0,56(sp)
80001ee4:	24930010 	addiu	s3,a0,16
80001ee8:	8fa3008c 	lw	v1,140(sp)
80001eec:	0263102b 	sltu	v0,s3,v1
80001ef0:	1440feaa 	bnez	v0,8000199c <checkAutoFlashing+0xa4>
80001ef4:	8fa20038 	lw	v0,56(sp)
			return ;
		}

		head_offset += Header.len + sizeof(IMG_HEADER_T);
	} //while
	if(reboot){
80001ef8:	8fa40044 	lw	a0,68(sp)
80001efc:	10800004 	beqz	a0,80001f10 <checkAutoFlashing+0x618>
80001f00:	8fbf0084 	lw	ra,132(sp)
	    	autoreboot();
80001f04:	0c000469 	jal	800011a4 <autoreboot>
80001f08:	00000000 	nop
	}
		
}
80001f0c:	8fbf0084 	lw	ra,132(sp)
80001f10:	8fbe0080 	lw	s8,128(sp)
80001f14:	8fb7007c 	lw	s7,124(sp)
80001f18:	8fb60078 	lw	s6,120(sp)
80001f1c:	8fb50074 	lw	s5,116(sp)
80001f20:	8fb40070 	lw	s4,112(sp)
80001f24:	8fb3006c 	lw	s3,108(sp)
80001f28:	8fb20068 	lw	s2,104(sp)
80001f2c:	8fb10064 	lw	s1,100(sp)
80001f30:	8fb00060 	lw	s0,96(sp)
80001f34:	03e00008 	jr	ra
80001f38:	27bd0088 	addiu	sp,sp,136

80001f3c <prepareACK>:
	}
    return NULL;
}
#endif
static void prepareACK(void)
{
80001f3c:	27bdffd8 	addiu	sp,sp,-40
80001f40:	afbf0024 	sw	ra,36(sp)
80001f44:	afb10020 	sw	s1,32(sp)
80001f48:	afb0001c 	sw	s0,28(sp)
 struct udphdr *udpheader;
 struct tftp_t *tftppacket;
 Int16 tftpopcode;
 Int32 tftpdata_length;
 volatile Int16 block_received=0;
80001f4c:	a7a00010 	sh	zero,16(sp)
    IMG_HEADER_T header;
    int ret;
    extern int check_system_image(unsigned long addr, IMG_HEADER_Tp pHeader);
#endif

    if (!tftpd_is_ready)
80001f50:	3c028002 	lui	v0,0x8002
80001f54:	8c422fc4 	lw	v0,12228(v0)
80001f58:	104000a2 	beqz	v0,800021e4 <prepareACK+0x2a8>
80001f5c:	3c028002 	lui	v0,0x8002
        return;

	//dprintf("Receive TFTP Data\n");
 
 udpheader = (struct udphdr *)&nic.packet[ETH_HLEN+ sizeof(struct iphdr)];
80001f60:	8c422e4c 	lw	v0,11852(v0)
80001f64:	24420022 	addiu	v0,v0,34
#ifdef SUPPORT_TFTP_CLIENT
 if((tftp_client_enabled && (udpheader->dest==htons(CLIENT_port))) || 	
	 (!tftp_client_enabled && (udpheader->dest==htons(SERVER_port))))
#else	
 if(udpheader->dest==htons(SERVER_port))
80001f68:	94440002 	lhu	a0,2(v0)
80001f6c:	3c038002 	lui	v1,0x8002
80001f70:	94632e54 	lhu	v1,11860(v1)
80001f74:	1483009c 	bne	a0,v1,800021e8 <prepareACK+0x2ac>
80001f78:	8fbf0024 	lw	ra,36(sp)
   	if (tftp_client_enabled)
		SERVER_port = ntohs(udpheader->src); 
	else
#endif		
          /*memorize CLIENT port*/
          CLIENT_port=  ntohs(udpheader->src); 
80001f7c:	94440000 	lhu	a0,0(v0)
80001f80:	3c038002 	lui	v1,0x8002
80001f84:	a4642e56 	sh	a0,11862(v1)
    tftppacket = (struct tftp_t *)&nic.packet[ETH_HLEN];
80001f88:	3c038002 	lui	v1,0x8002
80001f8c:	8c652e4c 	lw	a1,11852(v1)
80001f90:	24a5000e 	addiu	a1,a1,14
    /*no need to check opcode, this is a Data packet*/     
    /*parse the TFTP block number*/	
    block_received=tftppacket->u.data.block;
80001f94:	94a3001e 	lhu	v1,30(a1)
80001f98:	a7a30010 	sh	v1,16(sp)
//prom_printf("line=%d:		block_received=%d\n", __LINE__,  block_received); // for debug
    
    if(block_received != (block_expected))
80001f9c:	97a40010 	lhu	a0,16(sp)
80001fa0:	3084ffff 	andi	a0,a0,0xffff
80001fa4:	3c038002 	lui	v1,0x8002
80001fa8:	94632e48 	lhu	v1,11848(v1)
80001fac:	3063ffff 	andi	v1,v1,0xffff
80001fb0:	1083000b 	beq	a0,v1,80001fe0 <prepareACK+0xa4>
80001fb4:	3c108002 	lui	s0,0x8002
    {
     //prom_printf("line=%d: block_received=%d, block_expected=%d\n", __LINE__,  block_received,  block_expected); // for debug
     prom_printf("TFTP #\n");
80001fb8:	3c048001 	lui	a0,0x8001
80001fbc:	0c002325 	jal	80008c94 <dprintf>
80001fc0:	248442d8 	addiu	a0,a0,17112
     /*restore the block number*/
     tftpd_send_ack(block_expected-1);    
80001fc4:	3c028002 	lui	v0,0x8002
80001fc8:	94442e48 	lhu	a0,11848(v0)
80001fcc:	2484ffff 	addiu	a0,a0,-1
80001fd0:	0c0005bd 	jal	800016f4 <tftpd_send_ack>
80001fd4:	3084ffff 	andi	a0,a0,0xffff
     }
   }
//else 
//   prom_printf("\n**TFTP port number error");   

}
80001fd8:	0800087a 	j	800021e8 <prepareACK+0x2ac>
80001fdc:	8fbf0024 	lw	ra,36(sp)
     tftpd_send_ack(block_expected-1);    
    }
    else 
     {      
          
      tftpdata_length=ntohs(udpheader->len)-4-sizeof(struct udphdr);
80001fe0:	94510004 	lhu	s1,4(v0)
80001fe4:	2631fff4 	addiu	s1,s1,-12
      /*put the image into memory address*/
      memcpy((void *)address_to_store, tftppacket->u.data.download, tftpdata_length);
80001fe8:	8e042e44 	lw	a0,11844(s0)
80001fec:	24a50020 	addiu	a1,a1,32
80001ff0:	0c002046 	jal	80008118 <memcpy>
80001ff4:	02203021 	move	a2,s1
	//flush_cache_range(address_to_store,tftpdata_length);
	// ddump(address_to_store, tftpdata_length);
      //prom_printf("a %x. l %x\n",address_to_store,tftpdata_length);
      
      address_to_store=address_to_store+tftpdata_length;
80001ff8:	8e022e44 	lw	v0,11844(s0)
80001ffc:	02221021 	addu	v0,s1,v0
80002000:	ae022e44 	sw	v0,11844(s0)
      /*use this to count the image bytes*/
      file_length_to_server=file_length_to_server+tftpdata_length;
80002004:	3c028002 	lui	v0,0x8002
80002008:	8c432e64 	lw	v1,11876(v0)
8000200c:	02231821 	addu	v1,s1,v1
      /*this is for receiving one packet*/
      //prom_printf("%x.\n",address_to_store);
      twiddle();
80002010:	0c00225d 	jal	80008974 <twiddle>
80002014:	ac432e64 	sw	v1,11876(v0)
      //prom_printf(" <- ");
      //prom_printf("%x. %x. %x\n",block_expected,address_to_store,tftpdata_length);
      
      tftpd_send_ack(block_expected);               
80002018:	3c108002 	lui	s0,0x8002
8000201c:	96042e48 	lhu	a0,11848(s0)
80002020:	0c0005bd 	jal	800016f4 <tftpd_send_ack>
80002024:	3084ffff 	andi	a0,a0,0xffff
      block_expected=block_expected+1;
80002028:	96022e48 	lhu	v0,11848(s0)
8000202c:	24420001 	addiu	v0,v0,1
80002030:	3042ffff 	andi	v0,v0,0xffff
80002034:	a6022e48 	sh	v0,11848(s0)
//prom_printf("line=%d:		block_expected=%d\n", __LINE__,  block_expected); // for debug
      
      /*remember to check if it is the last packet*/      
      if(tftpdata_length < TFTP_DEFAULTSIZE_PACKET)
80002038:	2e310200 	sltiu	s1,s1,512
8000203c:	1220006a 	beqz	s1,800021e8 <prepareACK+0x2ac>
80002040:	8fbf0024 	lw	ra,36(sp)
        {
         prom_printf("\n**TFTP Client Upload File Size = %X Bytes at %X\n",file_length_to_server,image_address);          
80002044:	3c118002 	lui	s1,0x8002
80002048:	3c108001 	lui	s0,0x8001
8000204c:	3c048001 	lui	a0,0x8001
80002050:	248442e0 	addiu	a0,a0,17120
80002054:	8e252e64 	lw	a1,11876(s1)
80002058:	0c002325 	jal	80008c94 <dprintf>
8000205c:	8e0672b8 	lw	a2,29368(s0)
         /*change the boot state back to orignal, and some variables also*/
         nic.packet = eth_packet;
80002060:	3c028002 	lui	v0,0x8002
80002064:	3c038002 	lui	v1,0x8002
80002068:	24634114 	addiu	v1,v1,16660
8000206c:	ac432e4c 	sw	v1,11852(v0)
         nic.packetlen = 0;        
80002070:	24422e4c 	addiu	v0,v0,11852
80002074:	ac400004 	sw	zero,4(v0)
         block_expected =0;   
80002078:	3c028002 	lui	v0,0x8002
8000207c:	a4402e48 	sh	zero,11848(v0)
//prom_printf("line=%d:		block_expected=%d\n", __LINE__,  block_expected); // for debug
				 
         /*reset the file position*/
         //image_address=FILESTART;
         address_to_store=image_address;
80002080:	8e0372b8 	lw	v1,29368(s0)
80002084:	3c028002 	lui	v0,0x8002
80002088:	ac432e44 	sw	v1,11844(v0)
         file_length_to_client=file_length_to_server;
8000208c:	8e232e64 	lw	v1,11876(s1)
80002090:	3c028002 	lui	v0,0x8002
80002094:	ac432e5c 	sw	v1,11868(v0)
         /*file_length_to_server can not be reset,only when another WRQ */
         /*and export to file_length_to_client for our SDRAM direct RRQ*/
         it_is_EOF=0;
80002098:	3c028002 	lui	v0,0x8002
8000209c:	ac402fd0 	sw	zero,12240(v0)
#if defined(SUPPORT_TFTP_CLIENT)
		if(tftp_from_command)
		    tftp_client_recvdone = 1;
#endif
         bootState=BOOT_STATE0_INIT_ARP;
800020a0:	3c028002 	lui	v0,0x8002
800020a4:	ac402e58 	sw	zero,11864(v0)
         /*Cyrus Tsai*/
         one_tftp_lock=0; 
800020a8:	3c028002 	lui	v0,0x8002
800020ac:	a0402fcc 	sb	zero,12236(v0)
         SERVER_port++;
800020b0:	3c028002 	lui	v0,0x8002
800020b4:	94432e54 	lhu	v1,11860(v0)
800020b8:	24630001 	addiu	v1,v1,1
800020bc:	a4432e54 	sh	v1,11860(v0)
#if defined(SUPPORT_TFTP_CLIENT)
     if(tftp_from_command)
		prom_printf( "\nSuccess!\n");
	 else
#endif
		prom_printf( "\nSuccess!\n%s", "<RealTek>" );
800020c0:	3c048001 	lui	a0,0x8001
800020c4:	24844314 	addiu	a0,a0,17172
800020c8:	3c058001 	lui	a1,0x8001
800020cc:	0c002325 	jal	80008c94 <dprintf>
800020d0:	24a540d8 	addiu	a1,a1,16600
		
		jump_to_test = 1;  //wei add
	}
#endif  //CONFIG_NFBI

         if(jump_to_test==1)
800020d4:	3c028002 	lui	v0,0x8002
800020d8:	8c432fc0 	lw	v1,12224(v0)
800020dc:	24020001 	li	v0,1
800020e0:	14620038 	bne	v1,v0,800021c4 <prepareACK+0x288>
800020e4:	3c028001 	lui	v0,0x8001
           {
            jump_to_test=0;
800020e8:	3c028002 	lui	v0,0x8002
800020ec:	ac402fc0 	sw	zero,12224(v0)
	    /*we should clear all irq mask.*/
	    //jumpF = (void *)(TESTSTART); //sc_yang
	 REG32(0xb8000010)=REG32(0xb8000010) &(~(1<<11)); //disable switch IRQ
800020f0:	3c02b800 	lui	v0,0xb800
800020f4:	34420010 	ori	v0,v0,0x10
800020f8:	8c440000 	lw	a0,0(v0)
800020fc:	2403f7ff 	li	v1,-2049
80002100:	00831824 	and	v1,a0,v1
80002104:	ac430000 	sw	v1,0(v0)
		image_address &= ~0x20000000;
80002108:	8e0472b8 	lw	a0,29368(s0)
8000210c:	3c02dfff 	lui	v0,0xdfff
80002110:	3442ffff 	ori	v0,v0,0xffff
80002114:	00821024 	and	v0,a0,v0
80002118:	ae0272b8 	sw	v0,29368(s0)
	    jumpF = (void *)(image_address);
8000211c:	3c038002 	lui	v1,0x8002
80002120:	ac622e60 	sw	v0,11872(v1)
80002124:	3c03b800 	lui	v1,0xb800
80002128:	00001021 	move	v0,zero
8000212c:	ac623000 	sw	v0,12288(v1)
80002130:	40016000 	mfc0	at,c0_status
80002134:	34210001 	ori	at,at,0x1
80002138:	38210001 	xori	at,at,0x1
8000213c:	40816000 	mtc0	at,c0_status
80002140:	000000c0 	ehb
	...
	    /*we should clear all irq mask.*/
	    
		outl(0,GIMR0); // mask all interrupt	    
	   cli();
		REG32(0xb8003114)=0;  //disable timer interrupt
80002150:	3c02b800 	lui	v0,0xb800
80002154:	34433114 	ori	v1,v0,0x3114
80002158:	ac600000 	sw	zero,0(v1)
		REG32(0xb8000010)&=~(1<<11);
8000215c:	34420010 	ori	v0,v0,0x10
80002160:	8c440000 	lw	a0,0(v0)
80002164:	2403f7ff 	li	v1,-2049
80002168:	00831824 	and	v1,a0,v1
8000216c:	ac430000 	sw	v1,0(v0)
		
		REG32(0xbbdc0300)=0xFFFFFFFF;
80002170:	3c03bbdc 	lui	v1,0xbbdc
80002174:	34640300 	ori	a0,v1,0x300
80002178:	2402ffff 	li	v0,-1
8000217c:	ac820000 	sw	v0,0(a0)
		REG32(0xbbdc0304)=0xFFFFFFFF;
80002180:	34630304 	ori	v1,v1,0x304
80002184:	ac620000 	sw	v0,0(v1)
		dprintf("Jump to 0x%x\n", image_address);
80002188:	3c048001 	lui	a0,0x8001
8000218c:	24844324 	addiu	a0,a0,17188
80002190:	3c028001 	lui	v0,0x8001
80002194:	0c002325 	jal	80008c94 <dprintf>
80002198:	8c4572b8 	lw	a1,29368(v0)
		flush_cache();
8000219c:	0c001eae 	jal	80007ab8 <flush_cache>
800021a0:	00000000 	nop
		invalidate_cache();
800021a4:	0c001eac 	jal	80007ab0 <invalidate_cache>
800021a8:	00000000 	nop
	    jumpF();	
800021ac:	3c028002 	lui	v0,0x8002
800021b0:	8c422e60 	lw	v0,11872(v0)
800021b4:	0040f809 	jalr	v0
800021b8:	00000000 	nop
     }
   }
//else 
//   prom_printf("\n**TFTP port number error");   

}
800021bc:	0800087a 	j	800021e8 <prepareACK+0x2ac>
800021c0:	8fbf0024 	lw	ra,36(sp)
		flush_cache();
		invalidate_cache();
	    jumpF();	
           }
#if !(defined( CONFIG_NFBI) || defined(CONFIG_NONE_FLASH))
	   else if(autoBurn)
800021c4:	8c427364 	lw	v0,29540(v0)
800021c8:	10400007 	beqz	v0,800021e8 <prepareACK+0x2ac>
800021cc:	8fbf0024 	lw	ra,36(sp)
	   {
	   	checkAutoFlashing(image_address, file_length_to_server);
800021d0:	3c028001 	lui	v0,0x8001
800021d4:	8c4472b8 	lw	a0,29368(v0)
800021d8:	3c028002 	lui	v0,0x8002
800021dc:	0c00063e 	jal	800018f8 <checkAutoFlashing>
800021e0:	8c452e64 	lw	a1,11876(v0)
     }
   }
//else 
//   prom_printf("\n**TFTP port number error");   

}
800021e4:	8fbf0024 	lw	ra,36(sp)
800021e8:	8fb10020 	lw	s1,32(sp)
800021ec:	8fb0001c 	lw	s0,28(sp)
800021f0:	03e00008 	jr	ra
800021f4:	27bd0028 	addiu	sp,sp,40
	...

80002200 <prepare_txpkt>:
}

//----------------------------------------------------------------------------------------
/*Just a start address, and the data length*/
void prepare_txpkt(int etherport, Int16 type, Int8* destaddr, Int8* data, Int16 len) 
{
80002200:	27bdffd8 	addiu	sp,sp,-40
80002204:	afbf0024 	sw	ra,36(sp)
80002208:	afb10020 	sw	s1,32(sp)
8000220c:	afb0001c 	sw	s0,28(sp)
80002210:	30a5ffff 	andi	a1,a1,0xffff
80002214:	97b1003a 	lhu	s1,58(sp)
	char *tx_buffer=&ETH0_tx_buf[0][0];
80002218:	3c108002 	lui	s0,0x8002
8000221c:	26102fec 	addiu	s0,s0,12268
 	Int16 nstype;	
	int Length=len;
	
	memcpy(tx_buffer,destaddr,6);
80002220:	88c20000 	lwl	v0,0(a2)
80002224:	98c20003 	lwr	v0,3(a2)
80002228:	aa020000 	swl	v0,0(s0)
8000222c:	ba020003 	swr	v0,3(s0)
80002230:	90c20004 	lbu	v0,4(a2)
80002234:	a2020004 	sb	v0,4(s0)
80002238:	90c20005 	lbu	v0,5(a2)
8000223c:	a2020005 	sb	v0,5(s0)

	/*Source Address*/
	memcpy(tx_buffer+6,eth0_mac,6);
80002240:	26020006 	addiu	v0,s0,6
80002244:	3c038001 	lui	v1,0x8001
80002248:	8c647590 	lw	a0,30096(v1)
8000224c:	a8440000 	swl	a0,0(v0)
80002250:	b8440003 	swr	a0,3(v0)
80002254:	24637590 	addiu	v1,v1,30096
80002258:	90640004 	lbu	a0,4(v1)
8000225c:	a0440004 	sb	a0,4(v0)
80002260:	90630005 	lbu	v1,5(v1)
80002264:	a0430005 	sb	v1,5(v0)

	/*Payload type*/
	nstype = htons(type);
80002268:	a7a50010 	sh	a1,16(sp)
	memcpy(tx_buffer + 12,(Int8*)&nstype,2);
8000226c:	2602000c 	addiu	v0,s0,12
80002270:	00051a02 	srl	v1,a1,0x8
80002274:	a0430000 	sb	v1,0(v0)
80002278:	a0450001 	sb	a1,1(v0)

	/*Payload */
	memcpy(tx_buffer + 14,(Int8*)data,Length);
8000227c:	2604000e 	addiu	a0,s0,14
80002280:	00e02821 	move	a1,a3
80002284:	0c002046 	jal	80008118 <memcpy>
80002288:	02203021 	move	a2,s1
	Length += 14;

//	printf("tx pkt\n");
	swNic_send(tx_buffer,Length);
8000228c:	02002021 	move	a0,s0
80002290:	0c000d2c 	jal	800034b0 <swNic_send>
80002294:	2625000e 	addiu	a1,s1,14
}
80002298:	8fbf0024 	lw	ra,36(sp)
8000229c:	8fb10020 	lw	s1,32(sp)
800022a0:	8fb0001c 	lw	s0,28(sp)
800022a4:	03e00008 	jr	ra
800022a8:	27bd0028 	addiu	sp,sp,40

800022ac <eth_startup>:
}

#endif
//----------------------------------------------------------------------------------------
void eth_startup(int etherport)
{
800022ac:	27bdff90 	addiu	sp,sp,-112
800022b0:	afbf006c 	sw	ra,108(sp)
#ifdef CONFIG_HTTP_SERVER
	getmacandip(eth0_mac_httpd,eth0_ip_httpd);
#endif
#endif

	if (swCore_init()) {  	
800022b4:	0c000adc 	jal	80002b70 <swCore_init>
800022b8:	00000000 	nop
800022bc:	10400006 	beqz	v0,800022d8 <eth_startup+0x2c>
800022c0:	24020004 	li	v0,4
		dprintf("\nSwitch core initialization failed!\n");        
800022c4:	3c048001 	lui	a0,0x8001
800022c8:	0c002325 	jal	80008c94 <dprintf>
800022cc:	248443c0 	addiu	a0,a0,17344
		return;
800022d0:	080008ff 	j	800023fc <eth_startup+0x150>
800022d4:	8fbf006c 	lw	ra,108(sp)
	}

    	//avoid download bin checksum error
	uint32 rx[6] = {4, 0, 0, 0, 0, 0};
800022d8:	afa20010 	sw	v0,16(sp)
800022dc:	afa00014 	sw	zero,20(sp)
800022e0:	afa00018 	sw	zero,24(sp)
800022e4:	afa0001c 	sw	zero,28(sp)
800022e8:	afa00020 	sw	zero,32(sp)
800022ec:	afa00024 	sw	zero,36(sp)
#if defined(CONFIG_RTL8196D) || defined(CONFIG_RTL8196E)||defined(CONFIG_RTL8881A)
        uint32 tx[4] = {4, 2, 2, 2};
800022f0:	afa20028 	sw	v0,40(sp)
800022f4:	24020002 	li	v0,2
800022f8:	afa2002c 	sw	v0,44(sp)
800022fc:	afa20030 	sw	v0,48(sp)
80002300:	afa20034 	sw	v0,52(sp)
#else
        uint32 tx[2] = {4, 2};
#endif

	/* Initialize NIC module */
	if (swNic_init(rx, 4, tx, MBUF_LEN)) {
80002304:	27a40010 	addiu	a0,sp,16
80002308:	24050004 	li	a1,4
8000230c:	27a60028 	addiu	a2,sp,40
80002310:	0c000b85 	jal	80002e14 <swNic_init>
80002314:	24070800 	li	a3,2048
80002318:	10400006 	beqz	v0,80002334 <eth_startup+0x88>
8000231c:	27a50044 	addiu	a1,sp,68
		dprintf("\nSwitch nic initialization failed!\n");            
80002320:	3c048001 	lui	a0,0x8001
80002324:	0c002325 	jal	80008c94 <dprintf>
80002328:	248443e8 	addiu	a0,a0,17384
		return;
8000232c:	080008ff 	j	800023fc <eth_startup+0x150>
80002330:	8fbf006c 	lw	ra,108(sp)
	rtl_netif_param_t np;
	rtl_acl_param_t ap;

	/* Create Netif */
#if !(defined(CONFIG_RTL_LAN_WAN_ISOLATION) || defined(CONFIG_RTL_ALL_PORT_ISOLATION))
	bzero((void *) &np, sizeof(rtl_netif_param_t));
80002334:	aca00004 	sw	zero,4(a1)
	np.vid = 8;
80002338:	24020008 	li	v0,8
8000233c:	a7a2004e 	sh	v0,78(sp)
	np.valid = 1;
80002340:	24020001 	li	v0,1
	np.enableRoute = 0;
80002344:	00021f80 	sll	v1,v0,0x1e
80002348:	7c03ffc4 	ins	v1,zero,0x1f,0x1
8000234c:	afa30064 	sw	v1,100(sp)
	np.inAclEnd = 0;
80002350:	afa00054 	sw	zero,84(sp)
	np.inAclStart = 0;
80002354:	afa00050 	sw	zero,80(sp)
	np.outAclEnd = 0;
80002358:	afa0005c 	sw	zero,92(sp)
	np.outAclStart = 0;
8000235c:	afa00058 	sw	zero,88(sp)
	memcpy(&np.gMac, &eth0_mac[0], 6);
80002360:	3c038001 	lui	v1,0x8001
80002364:	8c647590 	lw	a0,30096(v1)
80002368:	aca40000 	sw	a0,0(a1)
8000236c:	24637590 	addiu	v1,v1,30096
80002370:	94630004 	lhu	v1,4(v1)
80002374:	a4a30004 	sh	v1,4(a1)

	np.macAddrNumber = 1;
80002378:	a7a2004c 	sh	v0,76(sp)
	np.mtu = 1500;
8000237c:	240205dc 	li	v0,1500
80002380:	afa20060 	sw	v0,96(sp)
	ret = swCore_netifCreate(0, &np);
80002384:	0c000eef 	jal	80003bbc <swCore_netifCreate>
80002388:	00002021 	move	a0,zero
	if (ret != 0) {
8000238c:	10400007 	beqz	v0,800023ac <eth_startup+0x100>
80002390:	27a50038 	addiu	a1,sp,56
		printf( "Creating intif fails:%d\n", ret );
80002394:	3c048001 	lui	a0,0x8001
80002398:	2484440c 	addiu	a0,a0,17420
8000239c:	0c002325 	jal	80008c94 <dprintf>
800023a0:	00402821 	move	a1,v0
		return;
800023a4:	080008ff 	j	800023fc <eth_startup+0x150>
800023a8:	8fbf006c 	lw	ra,108(sp)
	}

	/* Create vlan */
	bzero((void *) &vp, sizeof(rtl_vlan_param_t));
800023ac:	aca00008 	sw	zero,8(a1)
	vp.egressUntag = ALL_PORT_MASK;
800023b0:	2402003f 	li	v0,63
800023b4:	afa2003c 	sw	v0,60(sp)
	vp.memberPort = ALL_PORT_MASK;
800023b8:	afa20038 	sw	v0,56(sp)
	ret = swCore_vlanCreate(8, &vp);
800023bc:	0c000eb2 	jal	80003ac8 <vlanTable_create>
800023c0:	24040008 	li	a0,8
	if (ret != 0) {       
800023c4:	10400007 	beqz	v0,800023e4 <eth_startup+0x138>
800023c8:	24040019 	li	a0,25
		printf( "Creating vlan fails:%d\n", ret );
800023cc:	3c048001 	lui	a0,0x8001
800023d0:	24844428 	addiu	a0,a0,17448
800023d4:	0c002325 	jal	80008c94 <dprintf>
800023d8:	00402821 	move	a1,v0
       return;
800023dc:	080008ff 	j	800023fc <eth_startup+0x150>
800023e0:	8fbf006c 	lw	ra,108(sp)
    /* Set interrupt routing register */

#if !defined(CONFIG_RTL8198C)
	REG32(IRR1_REG) |= (3<<28); 
#endif	
 	request_IRQ(ETH0_IRQ, &irq_eth15,&(ETH[0]));
800023e4:	3c058001 	lui	a1,0x8001
800023e8:	24a57598 	addiu	a1,a1,30104
800023ec:	3c068002 	lui	a2,0x8002
800023f0:	0c000274 	jal	800009d0 <request_IRQ>
800023f4:	24c63c6c 	addiu	a2,a2,15468
}
800023f8:	8fbf006c 	lw	ra,108(sp)
800023fc:	03e00008 	jr	ra
80002400:	27bd0070 	addiu	sp,sp,112

80002404 <eth_interrupt>:
static struct eth_private ETH[2];
static struct irqaction irq_eth15 = {eth_interrupt, 0, 15,"eth0", NULL, NULL};  
//--------------------------------------------------------------------------------------------

void eth_interrupt(int irq, void *dev_id, struct pt_regs *regs)
{
80002404:	27bdffe0 	addiu	sp,sp,-32
80002408:	afbf001c 	sw	ra,28(sp)
8000240c:	afb10018 	sw	s1,24(sp)
80002410:	afb00014 	sw	s0,20(sp)
#ifdef CONFIG_NIC_LOOPBACK
	int i=0;
#endif
	int status=*(volatile Int32*)(0xb801002c);
80002414:	3c02b801 	lui	v0,0xb801
80002418:	3442002c 	ori	v0,v0,0x2c
8000241c:	8c430000 	lw	v1,0(v0)
	*(volatile Int32*)(0xb801002c)=status;
80002420:	ac430000 	sw	v1,0(v0)
  	if (swNic_receive((void **)&nic.packet, &nic.packetlen)== 0) 
 		kick_tftpd();  	
*/
//		printf("rx intterupt...\n");

	nic.packetlen=0;
80002424:	3c028002 	lui	v0,0x8002
80002428:	ac402e50 	sw	zero,11856(v0)
	while(swNic_receive((void **)&nic.packet, &nic.packetlen)== 0) 
8000242c:	3c108002 	lui	s0,0x8002
80002430:	26102e4c 	addiu	s0,s0,11852
80002434:	08000914 	j	80002450 <eth_interrupt+0x4c>
80002438:	24512e50 	addiu	s1,v0,11856
				swNic_txDone();
		}
		else 
#endif		
		{
			swNic_txDone();
8000243c:	0c000b6a 	jal	80002da8 <swNic_txDone>
80002440:	00000000 	nop
			kick_tftpd();  	
80002444:	0c0003c1 	jal	80000f04 <kick_tftpd>
80002448:	00000000 	nop
			nic.packetlen=0;
8000244c:	ae000004 	sw	zero,4(s0)
 		kick_tftpd();  	
*/
//		printf("rx intterupt...\n");

	nic.packetlen=0;
	while(swNic_receive((void **)&nic.packet, &nic.packetlen)== 0) 
80002450:	02002021 	move	a0,s0
80002454:	0c000d8b 	jal	8000362c <swNic_receive>
80002458:	02202821 	move	a1,s1
8000245c:	1040fff7 	beqz	v0,8000243c <eth_interrupt+0x38>
80002460:	00000000 	nop
			kick_tftpd();  	
			nic.packetlen=0;
		}
	}

	swNic_txDone();
80002464:	0c000b6a 	jal	80002da8 <swNic_txDone>
80002468:	00000000 	nop
}
8000246c:	8fbf001c 	lw	ra,28(sp)
80002470:	8fb10018 	lw	s1,24(sp)
80002474:	8fb00014 	lw	s0,20(sp)
80002478:	03e00008 	jr	ra
8000247c:	27bd0020 	addiu	sp,sp,32

80002480 <rtl8651_filterDbIndex>:
	#endif

	return SUCCESS;
}

uint32 rtl8651_filterDbIndex(ether_addr_t * macAddr,uint16 fid) {
80002480:	30a5ffff 	andi	a1,a1,0xffff
80002484:	90830001 	lbu	v1,1(a0)
80002488:	90820000 	lbu	v0,0(a0)
8000248c:	00621026 	xor	v0,v1,v0
80002490:	90830002 	lbu	v1,2(a0)
80002494:	00431026 	xor	v0,v0,v1
80002498:	90830003 	lbu	v1,3(a0)
8000249c:	00431026 	xor	v0,v0,v1
800024a0:	90830004 	lbu	v1,4(a0)
800024a4:	00431026 	xor	v0,v0,v1
800024a8:	90830005 	lbu	v1,5(a0)
800024ac:	3c048001 	lui	a0,0x8001
800024b0:	248400a0 	addiu	a0,a0,160
800024b4:	00a42821 	addu	a1,a1,a0
800024b8:	00431026 	xor	v0,v0,v1
800024bc:	90a30000 	lbu	v1,0(a1)
800024c0:	00431026 	xor	v0,v0,v1
    return ( macAddr->octet[0] ^ macAddr->octet[1] ^
                    macAddr->octet[2] ^ macAddr->octet[3] ^
                    macAddr->octet[4] ^ macAddr->octet[5] ^fidHashTable[fid]) & 0xFF;
}
800024c4:	03e00008 	jr	ra
800024c8:	304200ff 	andi	v0,v0,0xff

800024cc <rtl8651_getAsicEthernetPHYReg>:

int32 rtl8651_getAsicEthernetPHYReg(uint32 phyId, uint32 regId, uint32 *rData)
{
	uint32 status;
	
	WRITE_MEM32( MDCIOCR, COMMAND_READ | ( phyId << PHYADD_OFFSET ) | ( regId << REGADD_OFFSET ) );
800024cc:	00052c00 	sll	a1,a1,0x10
800024d0:	00042600 	sll	a0,a0,0x18
800024d4:	00a42825 	or	a1,a1,a0
800024d8:	3c02bb80 	lui	v0,0xbb80
800024dc:	34424004 	ori	v0,v0,0x4004
800024e0:	ac450000 	sw	a1,0(v0)
#else
#if defined(CONFIG_RTL8198) && !defined(CONFIG_RTL8198C)
	REG32(GIMR_REG) = REG32(GIMR_REG) | (0x1<<8);    //add by jiawenjian
	delay_ms(10);   //wei add, for 8196C_test chip patch. mdio data read will delay 1 mdc clock.
#endif
	do { status = READ_MEM32( MDCIOSR ); } while ( ( status & STATUS ) != 0 );
800024e4:	3c03bb80 	lui	v1,0xbb80
800024e8:	34634008 	ori	v1,v1,0x4008
800024ec:	8c620000 	lw	v0,0(v1)
800024f0:	0440fffe 	bltz	v0,800024ec <rtl8651_getAsicEthernetPHYReg+0x20>
800024f4:	3042ffff 	andi	v0,v0,0xffff
#endif

	status &= 0xffff;
	*rData = status;
800024f8:	acc20000 	sw	v0,0(a2)

	return SUCCESS;
}
800024fc:	03e00008 	jr	ra
80002500:	00001021 	move	v0,zero

80002504 <rtl8651_setAsicEthernetPHYReg>:
    //dprintf("\nSet enable_10M_power_saving01!\n");
    rtl8651_getAsicEthernetPHYReg( phyid, regnum, &tmp );*/

int32 rtl8651_setAsicEthernetPHYReg(uint32 phyId, uint32 regId, uint32 wData)
{
	WRITE_MEM32( MDCIOCR, COMMAND_WRITE | ( phyId << PHYADD_OFFSET ) | ( regId << REGADD_OFFSET ) | wData );
80002504:	00042600 	sll	a0,a0,0x18
80002508:	3c028000 	lui	v0,0x8000
8000250c:	00822025 	or	a0,a0,v0
80002510:	00052c00 	sll	a1,a1,0x10
80002514:	00852025 	or	a0,a0,a1
80002518:	00862025 	or	a0,a0,a2
8000251c:	3c02bb80 	lui	v0,0xbb80
80002520:	34424004 	ori	v0,v0,0x4004
80002524:	ac440000 	sw	a0,0(v0)

#ifdef RTL865X_TEST
#else
	while( ( READ_MEM32( MDCIOSR ) & STATUS ) != 0 );		/* wait until command complete */
80002528:	3c03bb80 	lui	v1,0xbb80
8000252c:	34634008 	ori	v1,v1,0x4008
80002530:	8c620000 	lw	v0,0(v1)
80002534:	0440fffe 	bltz	v0,80002530 <rtl8651_setAsicEthernetPHYReg+0x2c>
80002538:	00001021 	move	v0,zero
#endif

	return SUCCESS;
}
8000253c:	03e00008 	jr	ra
80002540:	00000000 	nop

80002544 <rtl8651_restartAsicEthernetPHYNway>:

int32 rtl8651_restartAsicEthernetPHYNway(uint32 port, uint32 phyid)
{
80002544:	27bdffe0 	addiu	sp,sp,-32
80002548:	afbf001c 	sw	ra,28(sp)
8000254c:	afb00018 	sw	s0,24(sp)
80002550:	00a08021 	move	s0,a1
	uint32 statCtrlReg0;

	/* read current PHY reg 0 */
	rtl8651_getAsicEthernetPHYReg( phyid, 0, &statCtrlReg0 );
80002554:	00a02021 	move	a0,a1
80002558:	00002821 	move	a1,zero
8000255c:	0c000933 	jal	800024cc <rtl8651_getAsicEthernetPHYReg>
80002560:	27a60010 	addiu	a2,sp,16

	/* enable 'restart Nway' bit */
	statCtrlReg0 |= RESTART_AUTONEGO;
80002564:	8fa60010 	lw	a2,16(sp)
80002568:	34c60200 	ori	a2,a2,0x200
8000256c:	afa60010 	sw	a2,16(sp)

	/* write PHY reg 0 */
	rtl8651_setAsicEthernetPHYReg( phyid, 0, statCtrlReg0 );
80002570:	02002021 	move	a0,s0
80002574:	0c000941 	jal	80002504 <rtl8651_setAsicEthernetPHYReg>
80002578:	00002821 	move	a1,zero

	return SUCCESS;
}
8000257c:	00001021 	move	v0,zero
80002580:	8fbf001c 	lw	ra,28(sp)
80002584:	8fb00018 	lw	s0,24(sp)
80002588:	03e00008 	jr	ra
8000258c:	27bd0020 	addiu	sp,sp,32

80002590 <rtl8651_setAsicFlowControlRegister>:
	return SUCCESS;
}
#endif

int32 rtl8651_setAsicFlowControlRegister(uint32 port, uint32 enable, uint32 phyid)
{
80002590:	27bdffd8 	addiu	sp,sp,-40
80002594:	afbf0024 	sw	ra,36(sp)
80002598:	afb20020 	sw	s2,32(sp)
8000259c:	afb1001c 	sw	s1,28(sp)
800025a0:	afb00018 	sw	s0,24(sp)
800025a4:	00808021 	move	s0,a0
800025a8:	00a09021 	move	s2,a1
800025ac:	00c08821 	move	s1,a2
	uint32 statCtrlReg4;

	/* Read */
	rtl8651_getAsicEthernetPHYReg( phyid, 4, &statCtrlReg4 );
800025b0:	00c02021 	move	a0,a2
800025b4:	24050004 	li	a1,4
800025b8:	0c000933 	jal	800024cc <rtl8651_getAsicEthernetPHYReg>
800025bc:	27a60010 	addiu	a2,sp,16

	if ( enable && ( statCtrlReg4 & CAPABLE_PAUSE ) == 0 )
800025c0:	12400006 	beqz	s2,800025dc <rtl8651_setAsicFlowControlRegister+0x4c>
800025c4:	8fa20010 	lw	v0,16(sp)
800025c8:	30430400 	andi	v1,v0,0x400
800025cc:	1460000f 	bnez	v1,8000260c <rtl8651_setAsicFlowControlRegister+0x7c>
800025d0:	34420400 	ori	v0,v0,0x400
800025d4:	0800097c 	j	800025f0 <rtl8651_setAsicFlowControlRegister+0x60>
800025d8:	afa20010 	sw	v0,16(sp)
	{
		statCtrlReg4 |= CAPABLE_PAUSE;		
	}
	else if ( enable == 0 && ( statCtrlReg4 & CAPABLE_PAUSE ) )
800025dc:	30430400 	andi	v1,v0,0x400
800025e0:	1060000a 	beqz	v1,8000260c <rtl8651_setAsicFlowControlRegister+0x7c>
800025e4:	2403fbff 	li	v1,-1025
	{
		statCtrlReg4 &= ~CAPABLE_PAUSE;
800025e8:	00431024 	and	v0,v0,v1
800025ec:	afa20010 	sw	v0,16(sp)
	}
	else
		return SUCCESS;	/* The configuration does not change. Do nothing. */

	rtl8651_setAsicEthernetPHYReg( phyid, 4, statCtrlReg4 );
800025f0:	02202021 	move	a0,s1
800025f4:	24050004 	li	a1,4
800025f8:	0c000941 	jal	80002504 <rtl8651_setAsicEthernetPHYReg>
800025fc:	8fa60010 	lw	a2,16(sp)
	
	/* restart N-way. */
	rtl8651_restartAsicEthernetPHYNway(port, phyid);
80002600:	02002021 	move	a0,s0
80002604:	0c000951 	jal	80002544 <rtl8651_restartAsicEthernetPHYNway>
80002608:	02202821 	move	a1,s1

	return SUCCESS;
}
8000260c:	00001021 	move	v0,zero
80002610:	8fbf0024 	lw	ra,36(sp)
80002614:	8fb20020 	lw	s2,32(sp)
80002618:	8fb1001c 	lw	s1,28(sp)
8000261c:	8fb00018 	lw	s0,24(sp)
80002620:	03e00008 	jr	ra
80002624:	27bd0028 	addiu	sp,sp,40

80002628 <Set_GPHYWB>:

//====================================================================

#if defined(CONFIG_RTL8196D) || defined(CONFIG_RTL8196E) || defined(CONFIG_RTL8198C)
void Set_GPHYWB(unsigned int phyid, unsigned int page, unsigned int reg, unsigned int mask, unsigned int val)
{
80002628:	27bdffc8 	addiu	sp,sp,-56
8000262c:	afbf0034 	sw	ra,52(sp)
80002630:	afb60030 	sw	s6,48(sp)
80002634:	afb5002c 	sw	s5,44(sp)
80002638:	afb40028 	sw	s4,40(sp)
8000263c:	afb30024 	sw	s3,36(sp)
80002640:	afb20020 	sw	s2,32(sp)
80002644:	afb1001c 	sw	s1,28(sp)
80002648:	afb00018 	sw	s0,24(sp)
8000264c:	00a0a021 	move	s4,a1
80002650:	00c09021 	move	s2,a2
80002654:	00e08821 	move	s1,a3
80002658:	8fb50048 	lw	s5,72(sp)

	unsigned int data=0;
	unsigned int wphyid=0;	//start
	unsigned int wphyid_end=1;   //end
	if(phyid==999)
8000265c:	240203e7 	li	v0,999
80002660:	14820004 	bne	a0,v0,80002674 <Set_GPHYWB+0x4c>
80002664:	afa00010 	sw	zero,16(sp)
80002668:	24130005 	li	s3,5
8000266c:	080009a1 	j	80002684 <Set_GPHYWB+0x5c>
80002670:	00008021 	move	s0,zero
	{	wphyid=0;
		wphyid_end=5;    //total phyid=0~4
	}
	else
	{	wphyid=phyid;
		wphyid_end=phyid+1;
80002674:	24930001 	addiu	s3,a0,1
	}

	for(; wphyid<wphyid_end; wphyid++)
80002678:	0093102b 	sltu	v0,a0,s3
8000267c:	10400017 	beqz	v0,800026dc <Set_GPHYWB+0xb4>
80002680:	00808021 	move	s0,a0
		//change page 
			rtl8651_setAsicEthernetPHYReg( wphyid, 31, page  );
		
		if(mask!=0)
		{
			rtl8651_getAsicEthernetPHYReg( wphyid, reg, &data);
80002684:	27b60010 	addiu	s6,sp,16
	}

	for(; wphyid<wphyid_end; wphyid++)
	{
		//change page 
			rtl8651_setAsicEthernetPHYReg( wphyid, 31, page  );
80002688:	02002021 	move	a0,s0
8000268c:	2405001f 	li	a1,31
80002690:	0c000941 	jal	80002504 <rtl8651_setAsicEthernetPHYReg>
80002694:	02803021 	move	a2,s4
		
		if(mask!=0)
80002698:	12200008 	beqz	s1,800026bc <Set_GPHYWB+0x94>
8000269c:	02002021 	move	a0,s0
		{
			rtl8651_getAsicEthernetPHYReg( wphyid, reg, &data);
800026a0:	02402821 	move	a1,s2
800026a4:	0c000933 	jal	800024cc <rtl8651_getAsicEthernetPHYReg>
800026a8:	02c03021 	move	a2,s6
			data=data&mask;
800026ac:	8fa20010 	lw	v0,16(sp)
800026b0:	00511024 	and	v0,v0,s1
800026b4:	afa20010 	sw	v0,16(sp)
		}
		rtl8651_setAsicEthernetPHYReg( wphyid, reg, data|val  );
800026b8:	02002021 	move	a0,s0
800026bc:	02402821 	move	a1,s2
800026c0:	8fa60010 	lw	a2,16(sp)
800026c4:	0c000941 	jal	80002504 <rtl8651_setAsicEthernetPHYReg>
800026c8:	02a63025 	or	a2,s5,a2
	else
	{	wphyid=phyid;
		wphyid_end=phyid+1;
	}

	for(; wphyid<wphyid_end; wphyid++)
800026cc:	26100001 	addiu	s0,s0,1
800026d0:	0213102b 	sltu	v0,s0,s3
800026d4:	1440ffed 	bnez	v0,8000268c <Set_GPHYWB+0x64>
800026d8:	02002021 	move	a0,s0
			rtl8651_setAsicEthernetPHYReg( wphyid, 31, 0  );
		}
		*/
#endif		
	}
}
800026dc:	8fbf0034 	lw	ra,52(sp)
800026e0:	8fb60030 	lw	s6,48(sp)
800026e4:	8fb5002c 	lw	s5,44(sp)
800026e8:	8fb40028 	lw	s4,40(sp)
800026ec:	8fb30024 	lw	s3,36(sp)
800026f0:	8fb20020 	lw	s2,32(sp)
800026f4:	8fb1001c 	lw	s1,28(sp)
800026f8:	8fb00018 	lw	s0,24(sp)
800026fc:	03e00008 	jr	ra
80002700:	27bd0038 	addiu	sp,sp,56

80002704 <Get_P0_RxDelay>:
	#define RANG3  7
	#define RANG4 0xf	
	
	#define SYS_HW_STRAP   (0xb8000000 +0x08)
	
	unsigned int v=REG32(SYS_HW_STRAP);
80002704:	3c02b800 	lui	v0,0xb800
80002708:	34420008 	ori	v0,v0,0x8
8000270c:	8c420000 	lw	v0,0(v0)
	unsigned int val=GET_BITVAL(v, 26, RANG3);
	return val;

}
80002710:	03e00008 	jr	ra
80002714:	7c421680 	ext	v0,v0,0x1a,0x3

80002718 <Get_P0_TxDelay>:
	#define RANG3  7
	#define RANG4 0xf	
	
	#define SYS_HW_STRAP   (0xb8000000 +0x08)
	
	unsigned int v=REG32(SYS_HW_STRAP);
80002718:	3c02b800 	lui	v0,0xb800
8000271c:	34420008 	ori	v0,v0,0x8
80002720:	8c420000 	lw	v0,0(v0)
	unsigned int val=GET_BITVAL(v, 29, RANG1);
	return val;

}
80002724:	03e00008 	jr	ra
80002728:	7c420740 	ext	v0,v0,0x1d,0x1

8000272c <set_phy_pwr_save>:



#define BIT(x)     (1 << (x))
void set_phy_pwr_save(int val)
{
8000272c:	27bdffc8 	addiu	sp,sp,-56
80002730:	afbf0034 	sw	ra,52(sp)
80002734:	afb60030 	sw	s6,48(sp)
80002738:	afb5002c 	sw	s5,44(sp)
8000273c:	afb40028 	sw	s4,40(sp)
80002740:	afb30024 	sw	s3,36(sp)
80002744:	afb20020 	sw	s2,32(sp)
80002748:	afb1001c 	sw	s1,28(sp)
8000274c:	afb00018 	sw	s0,24(sp)
80002750:	00809021 	move	s2,a0
80002754:	00008021 	move	s0,zero
	int i;
	uint32 reg_val;
	
	for(i=0; i<5; i++)
	{
		rtl8651_getAsicEthernetPHYReg( i, 24, &reg_val);
80002758:	27b50010 	addiu	s5,sp,16

		if (val == 1)
8000275c:	24130001 	li	s3,1
			rtl8651_setAsicEthernetPHYReg( i, 24, (reg_val | BIT(15)) );
		else 
			rtl8651_setAsicEthernetPHYReg( i, 24, (reg_val & (~BIT(15))) );
80002760:	3c16ffff 	lui	s6,0xffff
80002764:	36d67fff 	ori	s6,s6,0x7fff
void set_phy_pwr_save(int val)
{
	int i;
	uint32 reg_val;
	
	for(i=0; i<5; i++)
80002768:	24140005 	li	s4,5
	{
		rtl8651_getAsicEthernetPHYReg( i, 24, &reg_val);
8000276c:	02002021 	move	a0,s0
80002770:	24050018 	li	a1,24
80002774:	0c000933 	jal	800024cc <rtl8651_getAsicEthernetPHYReg>
80002778:	02a03021 	move	a2,s5

		if (val == 1)
8000277c:	16530007 	bne	s2,s3,8000279c <set_phy_pwr_save+0x70>
80002780:	02002021 	move	a0,s0
			rtl8651_setAsicEthernetPHYReg( i, 24, (reg_val | BIT(15)) );
80002784:	24050018 	li	a1,24
80002788:	8fa60010 	lw	a2,16(sp)
8000278c:	0c000941 	jal	80002504 <rtl8651_setAsicEthernetPHYReg>
80002790:	34c68000 	ori	a2,a2,0x8000
void set_phy_pwr_save(int val)
{
	int i;
	uint32 reg_val;
	
	for(i=0; i<5; i++)
80002794:	080009ec 	j	800027b0 <set_phy_pwr_save+0x84>
80002798:	26100001 	addiu	s0,s0,1
		rtl8651_getAsicEthernetPHYReg( i, 24, &reg_val);

		if (val == 1)
			rtl8651_setAsicEthernetPHYReg( i, 24, (reg_val | BIT(15)) );
		else 
			rtl8651_setAsicEthernetPHYReg( i, 24, (reg_val & (~BIT(15))) );
8000279c:	24050018 	li	a1,24
800027a0:	8fa60010 	lw	a2,16(sp)
800027a4:	0c000941 	jal	80002504 <rtl8651_setAsicEthernetPHYReg>
800027a8:	00d63024 	and	a2,a2,s6
void set_phy_pwr_save(int val)
{
	int i;
	uint32 reg_val;
	
	for(i=0; i<5; i++)
800027ac:	26100001 	addiu	s0,s0,1
800027b0:	1614ffef 	bne	s0,s4,80002770 <set_phy_pwr_save+0x44>
800027b4:	02002021 	move	a0,s0
		else 
			rtl8651_setAsicEthernetPHYReg( i, 24, (reg_val & (~BIT(15))) );
		
//		rtl8651_restartAsicEthernetPHYNway(i+1, i);							
			}
}
800027b8:	8fbf0034 	lw	ra,52(sp)
800027bc:	8fb60030 	lw	s6,48(sp)
800027c0:	8fb5002c 	lw	s5,44(sp)
800027c4:	8fb40028 	lw	s4,40(sp)
800027c8:	8fb30024 	lw	s3,36(sp)
800027cc:	8fb20020 	lw	s2,32(sp)
800027d0:	8fb1001c 	lw	s1,28(sp)
800027d4:	8fb00018 	lw	s0,24(sp)
800027d8:	03e00008 	jr	ra
800027dc:	27bd0038 	addiu	sp,sp,56

800027e0 <_rtl8651_clearSpecifiedAsicTable>:
#endif
#endif

//------------------------------------------------------------------------
static void _rtl8651_clearSpecifiedAsicTable(uint32 type, uint32 count) 
{
800027e0:	27bdffb8 	addiu	sp,sp,-72
800027e4:	afbf0044 	sw	ra,68(sp)
800027e8:	afb30040 	sw	s3,64(sp)
800027ec:	afb2003c 	sw	s2,60(sp)
800027f0:	afb10038 	sw	s1,56(sp)
800027f4:	afb00034 	sw	s0,52(sp)
800027f8:	00809821 	move	s3,a0
800027fc:	00a09021 	move	s2,a1
	struct { uint32 _content[8]; } entry;
	uint32 idx;
	
	bzero(&entry, sizeof(entry));
80002800:	afa00010 	sw	zero,16(sp)
80002804:	afa00014 	sw	zero,20(sp)
80002808:	afa00018 	sw	zero,24(sp)
8000280c:	afa0001c 	sw	zero,28(sp)
80002810:	afa00020 	sw	zero,32(sp)
80002814:	afa00024 	sw	zero,36(sp)
80002818:	afa00028 	sw	zero,40(sp)
	for (idx=0; idx<count; idx++)// Write into hardware
8000281c:	10a0000b 	beqz	a1,8000284c <_rtl8651_clearSpecifiedAsicTable+0x6c>
80002820:	afa0002c 	sw	zero,44(sp)
80002824:	00008021 	move	s0,zero
		swTable_addEntry(type, idx, &entry);
80002828:	27b10010 	addiu	s1,sp,16
8000282c:	02602021 	move	a0,s3
80002830:	02002821 	move	a1,s0
80002834:	0c000e4a 	jal	80003928 <swTable_addEntry>
80002838:	02203021 	move	a2,s1
{
	struct { uint32 _content[8]; } entry;
	uint32 idx;
	
	bzero(&entry, sizeof(entry));
	for (idx=0; idx<count; idx++)// Write into hardware
8000283c:	26100001 	addiu	s0,s0,1
80002840:	0212102b 	sltu	v0,s0,s2
80002844:	1440fffa 	bnez	v0,80002830 <_rtl8651_clearSpecifiedAsicTable+0x50>
80002848:	02602021 	move	a0,s3
		swTable_addEntry(type, idx, &entry);
}
8000284c:	8fbf0044 	lw	ra,68(sp)
80002850:	8fb30040 	lw	s3,64(sp)
80002854:	8fb2003c 	lw	s2,60(sp)
80002858:	8fb10038 	lw	s1,56(sp)
8000285c:	8fb00034 	lw	s0,52(sp)
80002860:	03e00008 	jr	ra
80002864:	27bd0048 	addiu	sp,sp,72

80002868 <rtl8651_setAsicL2Table>:
                    macAddr->octet[2] ^ macAddr->octet[3] ^
                    macAddr->octet[4] ^ macAddr->octet[5] ^fidHashTable[fid]) & 0xFF;
}

static int32 rtl8651_setAsicL2Table(ether_addr_t	*mac, uint32 column)
{
80002868:	27bdffc0 	addiu	sp,sp,-64
8000286c:	afbf003c 	sw	ra,60(sp)
80002870:	afb20038 	sw	s2,56(sp)
80002874:	afb10034 	sw	s1,52(sp)
80002878:	afb00030 	sw	s0,48(sp)
8000287c:	00809021 	move	s2,a0
80002880:	00a08821 	move	s1,a1
	rtl865xc_tblAsic_l2Table_t entry;
	uint32	row;

	row = rtl8651_filterDbIndex(mac, 0);
80002884:	0c000920 	jal	80002480 <rtl8651_filterDbIndex>
80002888:	00002821 	move	a1,zero
8000288c:	00408021 	move	s0,v0
	if((row >= RTL8651_L2TBL_ROW) || (column >= RTL8651_L2TBL_COLUMN))
80002890:	2c420100 	sltiu	v0,v0,256
80002894:	1040005c 	beqz	v0,80002a08 <rtl8651_setAsicL2Table+0x1a0>
80002898:	2402ffff 	li	v0,-1
8000289c:	2e220004 	sltiu	v0,s1,4
800028a0:	10400059 	beqz	v0,80002a08 <rtl8651_setAsicL2Table+0x1a0>
800028a4:	2402ffff 	li	v0,-1
		return FAILED;
	if(mac->octet[5] != ((row^(fidHashTable[0])^ mac->octet[0] ^ mac->octet[1] ^ mac->octet[2] ^ mac->octet[3] ^ mac->octet[4] ) & 0xff))
800028a8:	92430005 	lbu	v1,5(s2)
800028ac:	92440001 	lbu	a0,1(s2)
800028b0:	92420000 	lbu	v0,0(s2)
800028b4:	00822026 	xor	a0,a0,v0
800028b8:	92420002 	lbu	v0,2(s2)
800028bc:	00822026 	xor	a0,a0,v0
800028c0:	92420003 	lbu	v0,3(s2)
800028c4:	00822026 	xor	a0,a0,v0
800028c8:	92420004 	lbu	v0,4(s2)
800028cc:	00821026 	xor	v0,a0,v0
800028d0:	00501026 	xor	v0,v0,s0
800028d4:	304200ff 	andi	v0,v0,0xff
800028d8:	1462004b 	bne	v1,v0,80002a08 <rtl8651_setAsicL2Table+0x1a0>
800028dc:	2402ffff 	li	v0,-1
		return FAILED;

	memset(&entry, 0,sizeof(entry));
800028e0:	27a40010 	addiu	a0,sp,16
800028e4:	00002821 	move	a1,zero
800028e8:	0c00203d 	jal	800080f4 <memset>
800028ec:	24060020 	li	a2,32
	entry.mac47_40 = mac->octet[0];
800028f0:	92420000 	lbu	v0,0(s2)
800028f4:	a3a20017 	sb	v0,23(sp)
	entry.mac39_24 = (mac->octet[1] << 8) | mac->octet[2];
800028f8:	92420001 	lbu	v0,1(s2)
800028fc:	92430002 	lbu	v1,2(s2)
80002900:	00021200 	sll	v0,v0,0x8
80002904:	00431025 	or	v0,v0,v1
80002908:	a7a20010 	sh	v0,16(sp)
	entry.mac23_8 = (mac->octet[3] << 8) | mac->octet[4];
8000290c:	92460003 	lbu	a2,3(s2)
80002910:	92450004 	lbu	a1,4(s2)
static int32 _rtl8651_forceAddAsicEntry(uint32 tableType, uint32 eidx, void *entryContent_P) {

	#ifdef RTL865XC_ASIC_WRITE_PROTECTION
	if (RTL865X_TLU_BUG_FIXED)	/* No need to stop HW table lookup process */
	{	/* No need to stop HW table lookup process */
		WRITE_MEM32(SWTCR0,EN_STOP_TLU|READ_MEM32(SWTCR0));
80002914:	3c02bb80 	lui	v0,0xbb80
80002918:	34424418 	ori	v0,v0,0x4418
8000291c:	8c440000 	lw	a0,0(v0)
80002920:	3c030004 	lui	v1,0x4
80002924:	00831825 	or	v1,a0,v1
80002928:	ac430000 	sw	v1,0(v0)
		while ( (READ_MEM32(SWTCR0) & STOP_TLU_READY)==0);
8000292c:	00402021 	move	a0,v0
80002930:	3c030008 	lui	v1,0x8
80002934:	8c820000 	lw	v0,0(a0)
80002938:	00431024 	and	v0,v0,v1
8000293c:	1040fffd 	beqz	v0,80002934 <rtl8651_setAsicL2Table+0xcc>
80002940:	00000000 	nop

static void _rtl8651_asicTableAccessForward(uint32 tableType, uint32 eidx, void *entryContent_P) {
	ASSERT_CSP(entryContent_P);


	while ( (READ_MEM32(SWTACR) & ACTION_MASK) != ACTION_DONE );//Wait for command done
80002944:	3c03bb80 	lui	v1,0xbb80
80002948:	34634d00 	ori	v1,v1,0x4d00
8000294c:	8c620000 	lw	v0,0(v1)
80002950:	30420001 	andi	v0,v0,0x1
80002954:	1440fffd 	bnez	v0,8000294c <rtl8651_setAsicL2Table+0xe4>
80002958:	00061200 	sll	v0,a2,0x8
		return FAILED;

	memset(&entry, 0,sizeof(entry));
	entry.mac47_40 = mac->octet[0];
	entry.mac39_24 = (mac->octet[1] << 8) | mac->octet[2];
	entry.mac23_8 = (mac->octet[3] << 8) | mac->octet[4];
8000295c:	00a21025 	or	v0,a1,v0
80002960:	a7a20012 	sh	v0,18(sp)

//	entry.extMemberPort = 0;   
	entry.memberPort = 7;
80002964:	8fa30014 	lw	v1,20(sp)
80002968:	24020007 	li	v0,7
8000296c:	7c436a04 	ins	v1,v0,0x8,0x6
	entry.toCPU = 1;
80002970:	24020001 	li	v0,1
80002974:	7c438c44 	ins	v1,v0,0x11,0x1
	entry.isStatic = 1;
80002978:	7c439484 	ins	v1,v0,0x12,0x1
//	entry.nxtHostFlag = 1;

	/* RTL865xC: modification of age from ( 2 -> 3 -> 1 -> 0 ) to ( 3 -> 2 -> 1 -> 0 ). modification of granularity 100 sec to 150 sec. */
	entry.agingTime = 0x03;
8000297c:	24040003 	li	a0,3
80002980:	7c83a4c4 	ins	v1,a0,0x13,0x2
	
//	entry.srcBlock = 0;
	entry.fid=0;
80002984:	7c03c5c4 	ins	v1,zero,0x17,0x2
	entry.auth=1;
80002988:	7c43ce44 	ins	v1,v0,0x19,0x1
8000298c:	afa30014 	sw	v1,20(sp)
	{
		register uint32 index;

		for( index = 0; index < _rtl8651_asicTableSize[tableType]; index++ )
		{
			WRITE_MEM32(TCR0+(index<<2), *((uint32 *)entryContent_P + index));
80002990:	27a30010 	addiu	v1,sp,16
80002994:	8c650000 	lw	a1,0(v1)
80002998:	3c02bb80 	lui	v0,0xbb80
8000299c:	34444d20 	ori	a0,v0,0x4d20
800029a0:	ac850000 	sw	a1,0(a0)
800029a4:	8c640004 	lw	a0,4(v1)
800029a8:	34434d24 	ori	v1,v0,0x4d24
800029ac:	ac640000 	sw	a0,0(v1)
	WRITE_MEM32(TCR4, *((uint32 *)entryContent_P + 4));
	WRITE_MEM32(TCR5, *((uint32 *)entryContent_P + 5));
	WRITE_MEM32(TCR6, *((uint32 *)entryContent_P + 6));
	WRITE_MEM32(TCR7, *((uint32 *)entryContent_P + 7));
#endif	
	WRITE_MEM32(SWTAA, ((uint32) rtl8651_asicTableAccessAddrBase(tableType) + eidx * RTL8651_ASICTABLE_ENTRY_LENGTH));//Fill address
800029b0:	00102080 	sll	a0,s0,0x2
800029b4:	00912025 	or	a0,a0,s1
800029b8:	00042140 	sll	a0,a0,0x5
800029bc:	3c03bb00 	lui	v1,0xbb00
800029c0:	00832021 	addu	a0,a0,v1
800029c4:	34434d08 	ori	v1,v0,0x4d08
800029c8:	ac640000 	sw	a0,0(v1)
	}
	#endif

	_rtl8651_asicTableAccessForward(tableType, eidx, entryContent_P);

 	WRITE_MEM32(SWTACR, ACTION_START | CMD_FORCE);//Activate add command
800029cc:	34424d00 	ori	v0,v0,0x4d00
800029d0:	24030009 	li	v1,9
800029d4:	ac430000 	sw	v1,0(v0)
	while ( (READ_MEM32(SWTACR) & ACTION_MASK) != ACTION_DONE );//Wait for command done
800029d8:	00401821 	move	v1,v0
800029dc:	8c620000 	lw	v0,0(v1)
800029e0:	30420001 	andi	v0,v0,0x1
800029e4:	1440fffd 	bnez	v0,800029dc <rtl8651_setAsicL2Table+0x174>
800029e8:	3c02bb80 	lui	v0,0xbb80

	#ifdef RTL865XC_ASIC_WRITE_PROTECTION
	if (RTL865X_TLU_BUG_FIXED)	/* No need to stop HW table lookup process */
	{
		WRITE_MEM32(SWTCR0,~EN_STOP_TLU&READ_MEM32(SWTCR0));
800029ec:	34424418 	ori	v0,v0,0x4418
800029f0:	8c440000 	lw	a0,0(v0)
800029f4:	3c03fffb 	lui	v1,0xfffb
800029f8:	3463ffff 	ori	v1,v1,0xffff
800029fc:	00831824 	and	v1,a0,v1
80002a00:	ac430000 	sw	v1,0(v0)
80002a04:	00001021 	move	v0,zero
//	entry.srcBlock = 0;
	entry.fid=0;
	entry.auth=1;

	return _rtl8651_forceAddAsicEntry(TYPE_L2_SWITCH_TABLE, row<<2 | column, &entry);
}
80002a08:	8fbf003c 	lw	ra,60(sp)
80002a0c:	8fb20038 	lw	s2,56(sp)
80002a10:	8fb10034 	lw	s1,52(sp)
80002a14:	8fb00030 	lw	s0,48(sp)
80002a18:	03e00008 	jr	ra
80002a1c:	27bd0040 	addiu	sp,sp,64

80002a20 <Get_P0_MiiMode>:
#define MACTYPE_MII_PHY 1
#define MACTYPE_RGMII 2
#define MACTYPE_GMII 3

unsigned int Get_P0_MiiMode()
{
80002a20:	27bdffd8 	addiu	sp,sp,-40
80002a24:	afbf0024 	sw	ra,36(sp)
80002a28:	afb00020 	sw	s0,32(sp)
		const unsigned char *miimodename[]={ "MII-MAC", "MII-PHY", "RGMII", "GMII-MAC" };
80002a2c:	3c028001 	lui	v0,0x8001
80002a30:	244245c4 	addiu	v0,v0,17860
80002a34:	afa20010 	sw	v0,16(sp)
80002a38:	3c028001 	lui	v0,0x8001
80002a3c:	244245cc 	addiu	v0,v0,17868
80002a40:	afa20014 	sw	v0,20(sp)
80002a44:	3c028001 	lui	v0,0x8001
80002a48:	244245d4 	addiu	v0,v0,17876
80002a4c:	afa20018 	sw	v0,24(sp)
80002a50:	3c028001 	lui	v0,0x8001
80002a54:	244245dc 	addiu	v0,v0,17884
80002a58:	afa2001c 	sw	v0,28(sp)
	#define RANG3  7
	#define RANG4 0xf	
	
	#define SYS_HW_STRAP   (0xb8000000 +0x08)
	
	unsigned int v=REG32(SYS_HW_STRAP);
80002a5c:	3c02b800 	lui	v0,0xb800
80002a60:	34420008 	ori	v0,v0,0x8
80002a64:	8c500000 	lw	s0,0(v0)
	unsigned int mode=GET_BITVAL(v, 30, RANG2);
80002a68:	00108782 	srl	s0,s0,0x1e

	printf("P0miimode=%02x, %s\n", mode, miimodename[mode] );
80002a6c:	00101080 	sll	v0,s0,0x2
80002a70:	03a21021 	addu	v0,sp,v0
80002a74:	3c048001 	lui	a0,0x8001
80002a78:	248445e8 	addiu	a0,a0,17896
80002a7c:	02002821 	move	a1,s0
80002a80:	0c002325 	jal	80008c94 <dprintf>
80002a84:	8c460010 	lw	a2,16(v0)


	if(mode==0)		return MACTYPE_MII_MAC;
80002a88:	12000008 	beqz	s0,80002aac <Get_P0_MiiMode+0x8c>
80002a8c:	00001021 	move	v0,zero
	else if(mode==1)	return MACTYPE_MII_PHY;
80002a90:	24030001 	li	v1,1
80002a94:	12030005 	beq	s0,v1,80002aac <Get_P0_MiiMode+0x8c>
80002a98:	24020001 	li	v0,1
	else if(mode==2) return MACTYPE_RGMII;
80002a9c:	3a100002 	xori	s0,s0,0x2
80002aa0:	24030003 	li	v1,3
80002aa4:	24020002 	li	v0,2
80002aa8:	0070100b 	movn	v0,v1,s0
	else				return MACTYPE_GMII;

	
}
80002aac:	8fbf0024 	lw	ra,36(sp)
80002ab0:	8fb00020 	lw	s0,32(sp)
80002ab4:	03e00008 	jr	ra
80002ab8:	27bd0028 	addiu	sp,sp,40

80002abc <Get_P0_PhyMode>:
//====================================================================
#if defined(CONFIG_RTL8196D) || defined(CONFIG_RTL8196E)||defined(CONFIG_RTL8881A)
#define PHYTYPE_EMB 0
#define PHYTYPE_EXT 1
unsigned int Get_P0_PhyMode()
{
80002abc:	27bdffe8 	addiu	sp,sp,-24
80002ac0:	afbf0014 	sw	ra,20(sp)
80002ac4:	afb00010 	sw	s0,16(sp)
	#define RANG3  7
	#define RANG4 0xf	
	
	#define SYS_HW_STRAP   (0xb8000000 +0x08)
	
	unsigned int v=REG32(SYS_HW_STRAP);
80002ac8:	3c02b800 	lui	v0,0xb800
80002acc:	34420008 	ori	v0,v0,0x8
80002ad0:	8c420000 	lw	v0,0(v0)
	unsigned int mode=GET_BITVAL(v, 6, RANG1) *2 + GET_BITVAL(v, 7, RANG1);
80002ad4:	7c500180 	ext	s0,v0,0x6,0x1
80002ad8:	00108040 	sll	s0,s0,0x1
80002adc:	7c4201c0 	ext	v0,v0,0x7,0x1
80002ae0:	02028021 	addu	s0,s0,v0
	
	printf("P0phymode=%02x, %s phy\n", mode,   (mode==2) ? "external" : "embedded"  );
80002ae4:	24020002 	li	v0,2
80002ae8:	12020003 	beq	s0,v0,80002af8 <Get_P0_PhyMode+0x3c>
80002aec:	3c068001 	lui	a2,0x8001
80002af0:	08000ac0 	j	80002b00 <Get_P0_PhyMode+0x44>
80002af4:	24c645fc 	addiu	a2,a2,17916
80002af8:	3c068001 	lui	a2,0x8001
80002afc:	24c64608 	addiu	a2,a2,17928
80002b00:	3c048001 	lui	a0,0x8001
80002b04:	24844614 	addiu	a0,a0,17940
80002b08:	0c002325 	jal	80008c94 <dprintf>
80002b0c:	02002821 	move	a1,s0
80002b10:	3a020002 	xori	v0,s0,0x2
	
	if(mode==2)	return PHYTYPE_EXT;
	else 		return PHYTYPE_EMB;

	
}
80002b14:	2c420001 	sltiu	v0,v0,1
80002b18:	8fbf0014 	lw	ra,20(sp)
80002b1c:	8fb00010 	lw	s0,16(sp)
80002b20:	03e00008 	jr	ra
80002b24:	27bd0018 	addiu	sp,sp,24

80002b28 <FullAndSemiReset>:
	for (idx=0; idx<count; idx++)// Write into hardware
		swTable_addEntry(type, idx, &entry);
}

void FullAndSemiReset( void )
{
80002b28:	27bdffe8 	addiu	sp,sp,-24
80002b2c:	afbf0014 	sw	ra,20(sp)
80002b30:	afb00010 	sw	s0,16(sp)

	/* FIXME: Currently workable for FPGA, may need further modification for real chip */
// CONFIG_RTL8198C
//	REG32(0xb8000010)|=(1<<27);  //protect bit=1
	
	REG32(0xb8000010)&= ~(1<<11);  //active_swcore=0
80002b34:	3c10b800 	lui	s0,0xb800
80002b38:	36100010 	ori	s0,s0,0x10
80002b3c:	8e030000 	lw	v1,0(s0)
80002b40:	2402f7ff 	li	v0,-2049
80002b44:	00621024 	and	v0,v1,v0
80002b48:	ae020000 	sw	v0,0(s0)

	__delay(5000);
80002b4c:	0c0038e0 	jal	8000e380 <__delay>
80002b50:	24041388 	li	a0,5000
	
	REG32(0xb8000010)|= (1<<11);  //active_swcore=1
80002b54:	8e020000 	lw	v0,0(s0)
80002b58:	34420800 	ori	v0,v0,0x800
80002b5c:	ae020000 	sw	v0,0(s0)
#endif




}
80002b60:	8fbf0014 	lw	ra,20(sp)
80002b64:	8fb00010 	lw	s0,16(sp)
80002b68:	03e00008 	jr	ra
80002b6c:	27bd0018 	addiu	sp,sp,24

80002b70 <swCore_init>:
		REG32(PCRP0+i*4) &= ~(EnForceMode);
}
#endif

int32 swCore_init()
{
80002b70:	27bdffe0 	addiu	sp,sp,-32
80002b74:	afbf001c 	sw	ra,28(sp)
80002b78:	afb10018 	sw	s1,24(sp)
80002b7c:	afb00014 	sw	s0,20(sp)
		#define REG32_ANDOR(x,y,z)   (REG32(x)=(REG32(x)& (y))|(z))

	int port;

	/* Full reset and semreset */
	FullAndSemiReset();
80002b80:	0c000aca 	jal	80002b28 <FullAndSemiReset>
80002b84:	3c10bb80 	lui	s0,0xbb80
	}
#endif		

	/* rtl8651_clearAsicAllTable */
#if defined(CONFIG_RTL8196D) || defined(CONFIG_RTL8196E) ||defined(CONFIG_RTL8881A)
	REG32(MEMCR) = 0;
80002b88:	36024234 	ori	v0,s0,0x4234
80002b8c:	ac400000 	sw	zero,0(v0)
	REG32(MEMCR) = 0x7f;
80002b90:	2403007f 	li	v1,127
80002b94:	ac430000 	sw	v1,0(v0)
	_rtl8651_clearSpecifiedAsicTable(TYPE_MULTICAST_TABLE, RTL8651_IPMULTICASTTBL_SIZE);
80002b98:	24040003 	li	a0,3
80002b9c:	0c0009f8 	jal	800027e0 <_rtl8651_clearSpecifiedAsicTable>
80002ba0:	24050040 	li	a1,64
	_rtl8651_clearSpecifiedAsicTable(TYPE_NETINTERFACE_TABLE, RTL865XC_NETINTERFACE_NUMBER);
80002ba4:	24040004 	li	a0,4
80002ba8:	0c0009f8 	jal	800027e0 <_rtl8651_clearSpecifiedAsicTable>
80002bac:	24050008 	li	a1,8

#else  //8198, not NFBI
		//anson add
		//REG32(0xbb804300)= 0x00055500;

		REG32(PCRP0) &= (0xFFFFFFFF-(0x00000000|MacSwReset));
80002bb0:	36034104 	ori	v1,s0,0x4104
80002bb4:	8c640000 	lw	a0,0(v1)
80002bb8:	2402fff7 	li	v0,-9
80002bbc:	00822024 	and	a0,a0,v0
80002bc0:	ac640000 	sw	a0,0(v1)
                REG32(PCRP1) &= (0xFFFFFFFF-(0x00000000|MacSwReset));
80002bc4:	36074108 	ori	a3,s0,0x4108
80002bc8:	8ce40000 	lw	a0,0(a3)
80002bcc:	00822024 	and	a0,a0,v0
80002bd0:	ace40000 	sw	a0,0(a3)
                REG32(PCRP2) &= (0xFFFFFFFF-(0x00000000|MacSwReset));
80002bd4:	3606410c 	ori	a2,s0,0x410c
80002bd8:	8cc40000 	lw	a0,0(a2)
80002bdc:	00822024 	and	a0,a0,v0
80002be0:	acc40000 	sw	a0,0(a2)
                REG32(PCRP3) &= (0xFFFFFFFF-(0x00000000|MacSwReset));
80002be4:	36054110 	ori	a1,s0,0x4110
80002be8:	8ca40000 	lw	a0,0(a1)
80002bec:	00822024 	and	a0,a0,v0
80002bf0:	aca40000 	sw	a0,0(a1)
                REG32(PCRP4) &= (0xFFFFFFFF-(0x00000000|MacSwReset));
80002bf4:	36044114 	ori	a0,s0,0x4114
80002bf8:	8c880000 	lw	t0,0(a0)
80002bfc:	01021024 	and	v0,t0,v0
80002c00:	ac820000 	sw	v0,0(a0)

//		REG32(PCRP0) = REG32(PCRP0) | (0 << ExtPHYID_OFFSET) | AcptMaxLen_16K | EnablePHYIf | MacSwReset;   //move to below

		REG32(PCRP1) = REG32(PCRP1) | (1 << ExtPHYID_OFFSET) |  EnablePHYIf | MacSwReset;
80002c04:	8ce80000 	lw	t0,0(a3)
80002c08:	3c020400 	lui	v0,0x400
80002c0c:	34420009 	ori	v0,v0,0x9
80002c10:	01021025 	or	v0,t0,v0
80002c14:	ace20000 	sw	v0,0(a3)
		REG32(PCRP2) = REG32(PCRP2) | (2 << ExtPHYID_OFFSET) |  EnablePHYIf | MacSwReset;
80002c18:	8cc70000 	lw	a3,0(a2)
80002c1c:	3c020800 	lui	v0,0x800
80002c20:	34420009 	ori	v0,v0,0x9
80002c24:	00e21025 	or	v0,a3,v0
80002c28:	acc20000 	sw	v0,0(a2)
		REG32(PCRP3) = REG32(PCRP3) | (3 << ExtPHYID_OFFSET) |  EnablePHYIf | MacSwReset;
80002c2c:	8ca60000 	lw	a2,0(a1)
80002c30:	3c020c00 	lui	v0,0xc00
80002c34:	34420009 	ori	v0,v0,0x9
80002c38:	00c21025 	or	v0,a2,v0
80002c3c:	aca20000 	sw	v0,0(a1)
		REG32(PCRP4) = REG32(PCRP4) | (4 << ExtPHYID_OFFSET) |  EnablePHYIf | MacSwReset;
80002c40:	8c850000 	lw	a1,0(a0)
80002c44:	3c021000 	lui	v0,0x1000
80002c48:	34420009 	ori	v0,v0,0x9
80002c4c:	00a21025 	or	v0,a1,v0
80002c50:	ac820000 	sw	v0,0(a0)
			PHYID= 0x10	: 0x011	:	0x01
		*/
		REG32_ANDOR(0xbb804050, ~(0x1f<<0), 0x11<<0); 
		REG32(PCRP0) |=  (0<< ExtPHYID_OFFSET) |  EnablePHYIf | MacSwReset;	//emabedded
#else
		REG32(PCRP0) |=  (0 << ExtPHYID_OFFSET) | EnablePHYIf | MacSwReset;	//emabedded
80002c54:	8c620000 	lw	v0,0(v1)
80002c58:	34420009 	ori	v0,v0,0x9
80002c5c:	ac620000 	sw	v0,0(v1)
	
#endif


	/* Set PVID of all ports to 8 */
	REG32(PVCR0) = (0x8 << 16) | 0x8;
80002c60:	36034a08 	ori	v1,s0,0x4a08
80002c64:	3c020008 	lui	v0,0x8
80002c68:	34420008 	ori	v0,v0,0x8
80002c6c:	ac620000 	sw	v0,0(v1)
	REG32(PVCR1) = (0x8 << 16) | 0x8;
80002c70:	36034a0c 	ori	v1,s0,0x4a0c
80002c74:	ac620000 	sw	v0,0(v1)
	REG32(PVCR2) = (0x8 << 16) | 0x8;
80002c78:	36034a10 	ori	v1,s0,0x4a10
80002c7c:	ac620000 	sw	v0,0(v1)
	REG32(PVCR3) = (0x8 << 16) | 0x8;
80002c80:	36034a14 	ori	v1,s0,0x4a14
80002c84:	ac620000 	sw	v0,0(v1)

	
	/* Enable L2 lookup engine and spanning tree functionality */
	// REG32(MSCR) = EN_L2 | EN_L3 | EN_L4 | EN_IN_ACL;
	REG32(MSCR) = EN_L2;
80002c88:	36024410 	ori	v0,s0,0x4410
80002c8c:	24030001 	li	v1,1
80002c90:	ac430000 	sw	v1,0(v0)
	REG32(QNUMCR) = P0QNum_1 | P1QNum_1 | P2QNum_1 | P3QNum_1 | P4QNum_1;
80002c94:	36024754 	ori	v0,s0,0x4754
80002c98:	24031249 	li	v1,4681
80002c9c:	ac430000 	sw	v1,0(v0)

	/* Start normal TX and RX */
	REG32(SIRR) |= TRXRDY;
80002ca0:	36024204 	ori	v0,s0,0x4204
80002ca4:	8c430000 	lw	v1,0(v0)
80002ca8:	34630001 	ori	v1,v1,0x1
80002cac:	ac430000 	sw	v1,0(v0)

#define PINMUX   0xb8000040
#define PINMUX2 0xb8000044

#if defined(CONFIG_RTL8198C)
	REG32(PINMUX) &= ~((3<<8) | (3<<10) | (3<<3) | (1<<15) );  //let P0 to mii mode
80002cb0:	3c02b800 	lui	v0,0xb800
80002cb4:	34430040 	ori	v1,v0,0x40
80002cb8:	8c650000 	lw	a1,0(v1)
80002cbc:	3c04ffff 	lui	a0,0xffff
80002cc0:	348470e7 	ori	a0,a0,0x70e7
80002cc4:	00a42024 	and	a0,a1,a0
80002cc8:	ac640000 	sw	a0,0(v1)
	REG32(PINMUX2) &= ~((3<<0) | (3<<3) | (3<<6) | (3<<9) | (3<<12) | (7<<15) );  //S0-S3, P0-P1
80002ccc:	34430044 	ori	v1,v0,0x44
80002cd0:	8c650000 	lw	a1,0(v1)
80002cd4:	3c04fffc 	lui	a0,0xfffc
80002cd8:	34844924 	ori	a0,a0,0x4924
80002cdc:	00a42024 	and	a0,a1,a0
80002ce0:	ac640000 	sw	a0,0(v1)

	#ifdef CONFIG_USING_JTAG
	REG32(PIN_MUX_SEL3) = (REG32(PIN_MUX_SEL3) & ~ (0x7FFF));  //LED0~LED4
	#else
	REG32(PIN_MUX_SEL3) = (REG32(PIN_MUX_SEL3) & ~ (0x7FFF)) | ((1<<0) | (1<<3) | (1<<6) | (1<<9) | (1<<12));  //LED0~LED4
80002ce4:	34420108 	ori	v0,v0,0x108
80002ce8:	8c440000 	lw	a0,0(v0)
80002cec:	24038000 	li	v1,-32768
80002cf0:	00831824 	and	v1,a0,v1
80002cf4:	34631249 	ori	v1,v1,0x1249
80002cf8:	ac430000 	sw	v1,0(v0)
	#endif

	REG32(LEDCR0) = (REG32(LEDCR0) & ~ LEDTOPOLOGY_MASK) |LEDMODE_DIRECT;
80002cfc:	36024300 	ori	v0,s0,0x4300
80002d00:	8c440000 	lw	a0,0(v0)
80002d04:	3c03ffcf 	lui	v1,0xffcf
80002d08:	3463ffff 	ori	v1,v1,0xffff
80002d0c:	00831824 	and	v1,a0,v1
80002d10:	3c040020 	lui	a0,0x20
80002d14:	00641825 	or	v1,v1,a0
80002d18:	ac430000 	sw	v1,0(v0)
	REG32(DIRECTLCR) = (REG32(DIRECTLCR) & ~ LEDONSCALEP0_MASK) |(7<<LEDONSCALEP0_OFFSET);
80002d1c:	36104314 	ori	s0,s0,0x4314
80002d20:	8e030000 	lw	v1,0(s0)
80002d24:	3c020007 	lui	v0,0x7
80002d28:	00621025 	or	v0,v1,v0
80002d2c:	ae020000 	sw	v0,0(s0)
80002d30:	00008021 	move	s0,zero
	REG32(LEDCR)  = (2<<20) | (0<<18) | (0<<16) | (0<<14) | (0<<12) | (0<<10) | (0<<8);  //P0-P5
#endif

	
	/*PHY FlowControl. Default enable*/
	for(port=0;port<MAX_PORT_NUMBER;port++)
80002d34:	24110006 	li	s1,6
		if(port ==0)
					rtl8651_restartAsicEthernetPHYNway(port+1, 0x11);
		else
			
#endif
		rtl8651_restartAsicEthernetPHYNway(port+1, port);
80002d38:	26100001 	addiu	s0,s0,1
80002d3c:	02002021 	move	a0,s0
80002d40:	0c000951 	jal	80002544 <rtl8651_restartAsicEthernetPHYNway>
80002d44:	2605ffff 	addiu	a1,s0,-1
	REG32(LEDCR)  = (2<<20) | (0<<18) | (0<<16) | (0<<14) | (0<<12) | (0<<10) | (0<<8);  //P0-P5
#endif

	
	/*PHY FlowControl. Default enable*/
	for(port=0;port<MAX_PORT_NUMBER;port++)
80002d48:	1611fffc 	bne	s0,s1,80002d3c <swCore_init+0x1cc>
80002d4c:	26100001 	addiu	s0,s0,1
#if ! (defined( CONFIG_NFBI) || defined(CONFIG_NONE_FLASH))

	{		
		extern char eth0_mac[6];
		extern char eth0_mac_httpd[6];
		rtl8651_setAsicL2Table((ether_addr_t*)(&eth0_mac), 0);
80002d50:	3c048001 	lui	a0,0x8001
80002d54:	24847590 	addiu	a0,a0,30096
80002d58:	0c000a1a 	jal	80002868 <rtl8651_setAsicL2Table>
80002d5c:	00002821 	move	a1,zero
		rtl8651_setAsicL2Table((ether_addr_t*)(&eth0_mac_httpd), 1);
80002d60:	3c048002 	lui	a0,0x8002
80002d64:	24842fe0 	addiu	a0,a0,12256
80002d68:	0c000a1a 	jal	80002868 <rtl8651_setAsicL2Table>
80002d6c:	24050001 	li	a1,1
	}
#endif

	REG32(FFCR) = EN_UNUNICAST_TOCPU | EN_UNMCAST_TOCPU; // rx broadcast and unicast packet
80002d70:	24030003 	li	v1,3
80002d74:	3c02bb80 	lui	v0,0xbb80
80002d78:	34424428 	ori	v0,v0,0x4428
80002d7c:	ac430000 	sw	v1,0(v0)
	return 0;
}
80002d80:	00001021 	move	v0,zero
80002d84:	8fbf001c 	lw	ra,28(sp)
80002d88:	8fb10018 	lw	s1,24(sp)
80002d8c:	8fb00014 	lw	s0,20(sp)
80002d90:	03e00008 	jr	ra
80002d94:	27bd0020 	addiu	sp,sp,32
	...

80002da0 <swNic_intHandler>:
*       intPending      Pending interrupt sources.
*                                                                         
*   OUTPUTS                                                               
*       None
*************************************************************************/
void swNic_intHandler(uint32 intPending) {return;}
80002da0:	03e00008 	jr	ra
80002da4:	00000000 	nop

80002da8 <swNic_txDone>:

void swNic_txDone(void)
{
	struct pktHdr * pPkthdr;
	
	while (txPktDoneDescIndex != currTxPkthdrDescIndex) {		
80002da8:	3c028002 	lui	v0,0x8002
80002dac:	8c463d60 	lw	a2,15712(v0)
	    if ( (*(volatile uint32 *)&txPkthdrRing[0][txPktDoneDescIndex] 
80002db0:	3c028002 	lui	v0,0x8002
80002db4:	8c483d34 	lw	t0,15668(v0)
                    & DESC_OWNED_BIT) == DESC_RISC_OWNED ) {										
	    
		    pPkthdr = (struct pktHdr *) ((int32) txPkthdrRing[0][txPktDoneDescIndex] 
                                                & ~(DESC_OWNED_BIT | DESC_WRAP));

			if (++txPktDoneDescIndex == txPkthdrRingCnt[0])
80002db8:	3c028002 	lui	v0,0x8002
80002dbc:	8c473d44 	lw	a3,15684(v0)
80002dc0:	3c028002 	lui	v0,0x8002
80002dc4:	8c423d64 	lw	v0,15716(v0)

void swNic_txDone(void)
{
	struct pktHdr * pPkthdr;
	
	while (txPktDoneDescIndex != currTxPkthdrDescIndex) {		
80002dc8:	08000b7e 	j	80002df8 <swNic_txDone+0x50>
80002dcc:	00004821 	move	t1,zero
	    if ( (*(volatile uint32 *)&txPkthdrRing[0][txPktDoneDescIndex] 
80002dd0:	8c640000 	lw	a0,0(v1)
80002dd4:	30840001 	andi	a0,a0,0x1
80002dd8:	10800004 	beqz	a0,80002dec <swNic_txDone+0x44>
80002ddc:	24420001 	addiu	v0,v0,1
80002de0:	3c028002 	lui	v0,0x8002
80002de4:	03e00008 	jr	ra
80002de8:	ac453d64 	sw	a1,15716(v0)
                    & DESC_OWNED_BIT) == DESC_RISC_OWNED ) {										
	    
		    pPkthdr = (struct pktHdr *) ((int32) txPkthdrRing[0][txPktDoneDescIndex] 
                                                & ~(DESC_OWNED_BIT | DESC_WRAP));

			if (++txPktDoneDescIndex == txPkthdrRingCnt[0])
80002dec:	14e20004 	bne	a3,v0,80002e00 <swNic_txDone+0x58>
80002df0:	24630004 	addiu	v1,v1,4
80002df4:	01201021 	move	v0,t1
80002df8:	00021880 	sll	v1,v0,0x2
80002dfc:	01031821 	addu	v1,t0,v1

void swNic_txDone(void)
{
	struct pktHdr * pPkthdr;
	
	while (txPktDoneDescIndex != currTxPkthdrDescIndex) {		
80002e00:	14c2fff3 	bne	a2,v0,80002dd0 <swNic_txDone+0x28>
80002e04:	00402821 	move	a1,v0
80002e08:	3c028002 	lui	v0,0x8002
80002e0c:	03e00008 	jr	ra
80002e10:	ac453d64 	sw	a1,15716(v0)

80002e14 <swNic_init>:

int32 swNic_init(uint32 userNeedRxPkthdrRingCnt[RTL865X_SWNIC_RXRING_MAX_PKTDESC],
                 uint32 userNeedRxMbufRingCnt,
                 uint32 userNeedTxPkthdrRingCnt[RTL865X_SWNIC_TXRING_MAX_PKTDESC],
                 uint32 clusterSize)
{
80002e14:	27bdffc0 	addiu	sp,sp,-64
80002e18:	afbf003c 	sw	ra,60(sp)
80002e1c:	afbe0038 	sw	s8,56(sp)
80002e20:	afb70034 	sw	s7,52(sp)
80002e24:	afb60030 	sw	s6,48(sp)
80002e28:	afb5002c 	sw	s5,44(sp)
80002e2c:	afb40028 	sw	s4,40(sp)
80002e30:	afb30024 	sw	s3,36(sp)
80002e34:	afb20020 	sw	s2,32(sp)
80002e38:	afb1001c 	sw	s1,28(sp)
80002e3c:	afb00018 	sw	s0,24(sp)
80002e40:	00809021 	move	s2,a0
80002e44:	00a0b821 	move	s7,a1
80002e48:	00c0b021 	move	s6,a2
    uint8 * pClusterList;
    struct pktHdr * pPkthdr;
    struct mBuf * pMbuf;

    /* Cluster size is always 2048 */
    size_of_cluster = 2048;
80002e4c:	24030800 	li	v1,2048
80002e50:	3c028002 	lui	v0,0x8002
80002e54:	ac433d54 	sw	v1,15700(v0)
80002e58:	3c158002 	lui	s5,0x8002
80002e5c:	26b53d1c 	addiu	s5,s5,15644
80002e60:	02a08821 	move	s1,s5
80002e64:	00008021 	move	s0,zero
80002e68:	0000a021 	move	s4,zero
    for (i = 0; i < RTL865X_SWNIC_RXRING_MAX_PKTDESC; i++) {
		rxPkthdrRingCnt[i] = userNeedRxPkthdrRingCnt[i];
		if (rxPkthdrRingCnt[i] == 0)
			continue;

		rxPkthdrRing[i] = (uint32 *) UNCACHED_MALLOC(rxPkthdrRingCnt[i] * sizeof(uint32));
80002e6c:	3c1ea000 	lui	s8,0xa000
80002e70:	3c028002 	lui	v0,0x8002
80002e74:	24423d04 	addiu	v0,v0,15620
80002e78:	afa20010 	sw	v0,16(sp)
		ASSERT_CSP( (uint32) rxPkthdrRing[i] & 0x0fffffff );
80002e7c:	3c020fff 	lui	v0,0xfff
80002e80:	3442ffff 	ori	v0,v0,0xffff
80002e84:	afa20014 	sw	v0,20(sp)

    /* Cluster size is always 2048 */
    size_of_cluster = 2048;

    /* Allocate Rx descriptors of rings */
    for (i = 0; i < RTL865X_SWNIC_RXRING_MAX_PKTDESC; i++) {
80002e88:	24130018 	li	s3,24
		rxPkthdrRingCnt[i] = userNeedRxPkthdrRingCnt[i];
80002e8c:	02501021 	addu	v0,s2,s0
80002e90:	8c440000 	lw	a0,0(v0)
		if (rxPkthdrRingCnt[i] == 0)
80002e94:	10800015 	beqz	a0,80002eec <swNic_init+0xd8>
80002e98:	ae240000 	sw	a0,0(s1)
			continue;

		rxPkthdrRing[i] = (uint32 *) UNCACHED_MALLOC(rxPkthdrRingCnt[i] * sizeof(uint32));
80002e9c:	0c001f55 	jal	80007d54 <malloc>
80002ea0:	00042080 	sll	a0,a0,0x2
80002ea4:	005e2025 	or	a0,v0,s8
80002ea8:	8fa30010 	lw	v1,16(sp)
80002eac:	00701021 	addu	v0,v1,s0
80002eb0:	ac440000 	sw	a0,0(v0)
		ASSERT_CSP( (uint32) rxPkthdrRing[i] & 0x0fffffff );
80002eb4:	8fa30014 	lw	v1,20(sp)
80002eb8:	00831024 	and	v0,a0,v1
80002ebc:	14400006 	bnez	v0,80002ed8 <swNic_init+0xc4>
80002ec0:	00002821 	move	a1,zero
80002ec4:	3c048001 	lui	a0,0x8001
80002ec8:	0c002325 	jal	80008c94 <dprintf>
80002ecc:	2484462c 	addiu	a0,a0,17964
80002ed0:	08000bb4 	j	80002ed0 <swNic_init+0xbc>
80002ed4:	00000000 	nop
		memset(rxPkthdrRing[i],0,rxPkthdrRingCnt[i] * sizeof(uint32));
80002ed8:	8e260000 	lw	a2,0(s1)
80002edc:	0c00203d 	jal	800080f4 <memset>
80002ee0:	00063080 	sll	a2,a2,0x2
		totalRxPkthdrRingCnt += rxPkthdrRingCnt[i];
80002ee4:	8e220000 	lw	v0,0(s1)
80002ee8:	0282a021 	addu	s4,s4,v0
80002eec:	26100004 	addiu	s0,s0,4

    /* Cluster size is always 2048 */
    size_of_cluster = 2048;

    /* Allocate Rx descriptors of rings */
    for (i = 0; i < RTL865X_SWNIC_RXRING_MAX_PKTDESC; i++) {
80002ef0:	1613ffe6 	bne	s0,s3,80002e8c <swNic_init+0x78>
80002ef4:	26310004 	addiu	s1,s1,4
		ASSERT_CSP( (uint32) rxPkthdrRing[i] & 0x0fffffff );
		memset(rxPkthdrRing[i],0,rxPkthdrRingCnt[i] * sizeof(uint32));
		totalRxPkthdrRingCnt += rxPkthdrRingCnt[i];
    }
	
	if (totalRxPkthdrRingCnt == 0)
80002ef8:	12800160 	beqz	s4,8000347c <swNic_init+0x668>
80002efc:	3c138002 	lui	s3,0x8002
80002f00:	26733d44 	addiu	s3,s3,15684
80002f04:	02608021 	move	s0,s3
80002f08:	00008821 	move	s1,zero
80002f0c:	00009021 	move	s2,zero
		txPkthdrRingCnt[i] = userNeedTxPkthdrRingCnt[i];

		if (txPkthdrRingCnt[i] == 0)
			continue;

		txPkthdrRing[i] = (uint32 *) UNCACHED_MALLOC(txPkthdrRingCnt[i] * sizeof(uint32));
80002f10:	3c028002 	lui	v0,0x8002
80002f14:	24423d34 	addiu	v0,v0,15668
80002f18:	afa20010 	sw	v0,16(sp)
		
		ASSERT_CSP( (uint32) txPkthdrRing[i] & 0x0fffffff );
80002f1c:	3c020fff 	lui	v0,0xfff
80002f20:	3442ffff 	ori	v0,v0,0xffff
80002f24:	afa20014 	sw	v0,20(sp)
	
	if (totalRxPkthdrRingCnt == 0)
		return EINVAL;

    /* Allocate Tx descriptors of rings */
    for (i = 0; i < RTL865X_SWNIC_TXRING_MAX_PKTDESC; i++) {
80002f28:	241e0010 	li	s8,16
		txPkthdrRingCnt[i] = userNeedTxPkthdrRingCnt[i];
80002f2c:	02d11021 	addu	v0,s6,s1
80002f30:	8c440000 	lw	a0,0(v0)

		if (txPkthdrRingCnt[i] == 0)
80002f34:	10800016 	beqz	a0,80002f90 <swNic_init+0x17c>
80002f38:	ae040000 	sw	a0,0(s0)
			continue;

		txPkthdrRing[i] = (uint32 *) UNCACHED_MALLOC(txPkthdrRingCnt[i] * sizeof(uint32));
80002f3c:	0c001f55 	jal	80007d54 <malloc>
80002f40:	00042080 	sll	a0,a0,0x2
80002f44:	3c03a000 	lui	v1,0xa000
80002f48:	00432025 	or	a0,v0,v1
80002f4c:	8fa30010 	lw	v1,16(sp)
80002f50:	00711021 	addu	v0,v1,s1
80002f54:	ac440000 	sw	a0,0(v0)
		
		ASSERT_CSP( (uint32) txPkthdrRing[i] & 0x0fffffff );
80002f58:	8fa30014 	lw	v1,20(sp)
80002f5c:	00831024 	and	v0,a0,v1
80002f60:	14400006 	bnez	v0,80002f7c <swNic_init+0x168>
80002f64:	00002821 	move	a1,zero
80002f68:	3c048001 	lui	a0,0x8001
80002f6c:	0c002325 	jal	80008c94 <dprintf>
80002f70:	2484462c 	addiu	a0,a0,17964
80002f74:	08000bdd 	j	80002f74 <swNic_init+0x160>
80002f78:	00000000 	nop
		memset(txPkthdrRing[i],0,(txPkthdrRingCnt[i] * sizeof(uint32)));
80002f7c:	8e060000 	lw	a2,0(s0)
80002f80:	0c00203d 	jal	800080f4 <memset>
80002f84:	00063080 	sll	a2,a2,0x2
		totalTxPkthdrRingCnt += txPkthdrRingCnt[i];
80002f88:	8e020000 	lw	v0,0(s0)
80002f8c:	02429021 	addu	s2,s2,v0
80002f90:	26310004 	addiu	s1,s1,4
	
	if (totalRxPkthdrRingCnt == 0)
		return EINVAL;

    /* Allocate Tx descriptors of rings */
    for (i = 0; i < RTL865X_SWNIC_TXRING_MAX_PKTDESC; i++) {
80002f94:	163effe5 	bne	s1,s8,80002f2c <swNic_init+0x118>
80002f98:	26100004 	addiu	s0,s0,4
		ASSERT_CSP( (uint32) txPkthdrRing[i] & 0x0fffffff );
		memset(txPkthdrRing[i],0,(txPkthdrRingCnt[i] * sizeof(uint32)));
		totalTxPkthdrRingCnt += txPkthdrRingCnt[i];
    }

	if (totalTxPkthdrRingCnt == 0)
80002f9c:	12400137 	beqz	s2,8000347c <swNic_init+0x668>
80002fa0:	3c028002 	lui	v0,0x8002
		return EINVAL;

    /* Allocate MBuf descriptors of rings */
	rxMbufRingCnt = userNeedRxMbufRingCnt;

	if (userNeedRxMbufRingCnt == 0)
80002fa4:	12e00135 	beqz	s7,8000347c <swNic_init+0x668>
80002fa8:	ac572e6c 	sw	s7,11884(v0)
		return EINVAL;

	rxMbufRing = (uint32 *) UNCACHED_MALLOC(userNeedRxMbufRingCnt * sizeof(uint32));
80002fac:	0017b880 	sll	s7,s7,0x2
80002fb0:	0c001f55 	jal	80007d54 <malloc>
80002fb4:	02e02021 	move	a0,s7
80002fb8:	3c03a000 	lui	v1,0xa000
80002fbc:	00432025 	or	a0,v0,v1
80002fc0:	3c028002 	lui	v0,0x8002
80002fc4:	ac443d00 	sw	a0,15616(v0)
    ASSERT_CSP( (uint32) rxMbufRing & 0x0fffffff );
80002fc8:	3c020fff 	lui	v0,0xfff
80002fcc:	3442ffff 	ori	v0,v0,0xffff
80002fd0:	00821024 	and	v0,a0,v0
80002fd4:	14400006 	bnez	v0,80002ff0 <swNic_init+0x1dc>
80002fd8:	00002821 	move	a1,zero
80002fdc:	3c048001 	lui	a0,0x8001
80002fe0:	0c002325 	jal	80008c94 <dprintf>
80002fe4:	2484462c 	addiu	a0,a0,17964
80002fe8:	08000bfa 	j	80002fe8 <swNic_init+0x1d4>
80002fec:	00000000 	nop
	memset(rxMbufRing,0,userNeedRxMbufRingCnt * sizeof(uint32));
80002ff0:	0c00203d 	jal	800080f4 <memset>
80002ff4:	02e03021 	move	a2,s7
    /* Allocate pkthdr */
    pPkthdrList = (struct pktHdr *) UNCACHED_MALLOC(
80002ff8:	0254a021 	addu	s4,s2,s4
80002ffc:	001410c0 	sll	v0,s4,0x3
80003000:	0014a140 	sll	s4,s4,0x5
80003004:	02828823 	subu	s1,s4,v0
80003008:	0c001f55 	jal	80007d54 <malloc>
8000300c:	02202021 	move	a0,s1
80003010:	3c10a000 	lui	s0,0xa000
80003014:	00508025 	or	s0,v0,s0
                    (totalRxPkthdrRingCnt + totalTxPkthdrRingCnt) * sizeof(struct pktHdr));
    ASSERT_CSP( (uint32) pPkthdrList & 0x0fffffff );
80003018:	3c020fff 	lui	v0,0xfff
8000301c:	3442ffff 	ori	v0,v0,0xffff
80003020:	02021024 	and	v0,s0,v0
80003024:	14400006 	bnez	v0,80003040 <swNic_init+0x22c>
80003028:	00002821 	move	a1,zero
8000302c:	3c048001 	lui	a0,0x8001
80003030:	0c002325 	jal	80008c94 <dprintf>
80003034:	2484462c 	addiu	a0,a0,17964
80003038:	08000c0e 	j	80003038 <swNic_init+0x224>
8000303c:	00000000 	nop
   memset(pPkthdrList,0, (totalRxPkthdrRingCnt + totalTxPkthdrRingCnt) * sizeof(struct pktHdr));                 
80003040:	02002021 	move	a0,s0
80003044:	0c00203d 	jal	800080f4 <memset>
80003048:	02203021 	move	a2,s1
    /* Allocate mbufs */
    pMbufList = (struct mBuf *) UNCACHED_MALLOC(
8000304c:	3c028002 	lui	v0,0x8002
80003050:	8c422e6c 	lw	v0,11884(v0)
80003054:	02421021 	addu	v0,s2,v0
80003058:	000218c0 	sll	v1,v0,0x3
8000305c:	00021140 	sll	v0,v0,0x5
80003060:	0c001f55 	jal	80007d54 <malloc>
80003064:	00432023 	subu	a0,v0,v1
80003068:	3c11a000 	lui	s1,0xa000
8000306c:	00518825 	or	s1,v0,s1
                    (rxMbufRingCnt + totalTxPkthdrRingCnt) * sizeof(struct mBuf));
    ASSERT_CSP( (uint32) pMbufList & 0x0fffffff );
80003070:	3c020fff 	lui	v0,0xfff
80003074:	3442ffff 	ori	v0,v0,0xffff
80003078:	02221024 	and	v0,s1,v0
8000307c:	14400006 	bnez	v0,80003098 <swNic_init+0x284>
80003080:	3c148002 	lui	s4,0x8002
80003084:	3c048001 	lui	a0,0x8001
80003088:	0c002325 	jal	80008c94 <dprintf>
8000308c:	2484462c 	addiu	a0,a0,17964
80003090:	08000c24 	j	80003090 <swNic_init+0x27c>
80003094:	00000000 	nop
    memset(pMbufList,0,((rxMbufRingCnt + totalTxPkthdrRingCnt) * sizeof(struct mBuf)));                
80003098:	8e862e6c 	lw	a2,11884(s4)
8000309c:	02463021 	addu	a2,s2,a2
800030a0:	000610c0 	sll	v0,a2,0x3
800030a4:	00063140 	sll	a2,a2,0x5
800030a8:	02202021 	move	a0,s1
800030ac:	00002821 	move	a1,zero
800030b0:	0c00203d 	jal	800080f4 <memset>
800030b4:	00c23023 	subu	a2,a2,v0
    /* Allocate clusters */
    pClusterList = (uint8 *) UNCACHED_MALLOC(rxMbufRingCnt * size_of_cluster + 8 - 1+2*rxMbufRingCnt);
800030b8:	3c028002 	lui	v0,0x8002
800030bc:	8c443d54 	lw	a0,15700(v0)
800030c0:	24840002 	addiu	a0,a0,2
800030c4:	8e822e6c 	lw	v0,11884(s4)
800030c8:	70822002 	mul	a0,a0,v0
800030cc:	0c001f55 	jal	80007d54 <malloc>
800030d0:	24840007 	addiu	a0,a0,7
800030d4:	3c12a000 	lui	s2,0xa000
800030d8:	00529025 	or	s2,v0,s2
    ASSERT_CSP( (uint32) pClusterList & 0x0fffffff );
800030dc:	3c020fff 	lui	v0,0xfff
800030e0:	3442ffff 	ori	v0,v0,0xffff
800030e4:	02421024 	and	v0,s2,v0
800030e8:	14400006 	bnez	v0,80003104 <swNic_init+0x2f0>
800030ec:	3c028002 	lui	v0,0x8002
800030f0:	3c048001 	lui	a0,0x8001
800030f4:	0c002325 	jal	80008c94 <dprintf>
800030f8:	2484462c 	addiu	a0,a0,17964
800030fc:	08000c3f 	j	800030fc <swNic_init+0x2e8>
80003100:	00000000 	nop
    memset(pClusterList,0,(rxMbufRingCnt * size_of_cluster + 8 - 1+2*rxMbufRingCnt));
80003104:	8c463d54 	lw	a2,15700(v0)
80003108:	24c60002 	addiu	a2,a2,2
8000310c:	3c028002 	lui	v0,0x8002
80003110:	8c422e6c 	lw	v0,11884(v0)
80003114:	70c23002 	mul	a2,a2,v0
80003118:	02402021 	move	a0,s2
8000311c:	00002821 	move	a1,zero
80003120:	0c00203d 	jal	800080f4 <memset>
80003124:	24c60007 	addiu	a2,a2,7
    pClusterList = (uint8*)(((uint32) pClusterList + 8 - 1) & ~(8 - 1));

    /* Initialize interrupt statistics counter */
    rxPktCounter = txPktCounter = 0;
80003128:	3c028002 	lui	v0,0x8002
8000312c:	ac403d6c 	sw	zero,15724(v0)
80003130:	3c028002 	lui	v0,0x8002
80003134:	ac403d68 	sw	zero,15720(v0)

    /* Initialize index of Tx pkthdr descriptor */
    currTxPkthdrDescIndex = 0;
80003138:	3c028002 	lui	v0,0x8002
8000313c:	ac403d60 	sw	zero,15712(v0)
    txPktDoneDescIndex=0;
80003140:	3c028002 	lui	v0,0x8002
80003144:	ac403d64 	sw	zero,15716(v0)
80003148:	3c048002 	lui	a0,0x8002
8000314c:	24843d34 	addiu	a0,a0,15668
*                                                                         
*   OUTPUTS                                                               
*       Status.
*************************************************************************/

int32 swNic_init(uint32 userNeedRxPkthdrRingCnt[RTL865X_SWNIC_RXRING_MAX_PKTDESC],
80003150:	3c0a8002 	lui	t2,0x8002
80003154:	254a3d44 	addiu	t2,t2,15684
    /* Initialize index of Tx pkthdr descriptor */
    currTxPkthdrDescIndex = 0;
    txPktDoneDescIndex=0;

    /* Initialize Tx packet header descriptors */
    for (i = 0; i < RTL865X_SWNIC_TXRING_MAX_PKTDESC; i++)
80003158:	00004821 	move	t1,zero
         bzero((void *) pPkthdr, sizeof(struct pktHdr));
         bzero((void *) pMbuf, sizeof(struct mBuf));

			pPkthdr->ph_mbuf = pMbuf;
			pPkthdr->ph_len = 0;
			pPkthdr->ph_flags = PKTHDR_USED | PKT_OUTGOING;
8000315c:	24088800 	li	t0,-30720
			pPkthdr->ph_type = PKTHDR_ETHERNET;
			pPkthdr->ph_portlist = 0;

			pMbuf->m_next = NULL;
			pMbuf->m_pkthdr = pPkthdr;
			pMbuf->m_flags = MBUF_USED | MBUF_EXT | MBUF_PKTHDR | MBUF_EOR;
80003160:	08000c8a 	j	80003228 <swNic_init+0x414>
80003164:	2407009c 	li	a3,156
	{
		for (j = 0; j < txPkthdrRingCnt[i]; j++)
		{
			/* Dequeue pkthdr and mbuf */
			pPkthdr = pPkthdrList++;
			pMbuf = pMbufList++;
80003168:	26230018 	addiu	v1,s1,24

         bzero((void *) pPkthdr, sizeof(struct pktHdr));
8000316c:	ae000000 	sw	zero,0(s0)
80003170:	ae000004 	sw	zero,4(s0)
80003174:	ae000008 	sw	zero,8(s0)
80003178:	ae00000c 	sw	zero,12(s0)
8000317c:	ae000010 	sw	zero,16(s0)
80003180:	ae000014 	sw	zero,20(s0)
         bzero((void *) pMbuf, sizeof(struct mBuf));
80003184:	ae200000 	sw	zero,0(s1)
80003188:	ae200004 	sw	zero,4(s1)
8000318c:	ae200008 	sw	zero,8(s1)
80003190:	ae20000c 	sw	zero,12(s1)
80003194:	ae200010 	sw	zero,16(s1)
80003198:	ae200014 	sw	zero,20(s1)

			pPkthdr->ph_mbuf = pMbuf;
8000319c:	ac510000 	sw	s1,0(v0)
			pPkthdr->ph_len = 0;
800031a0:	a4400004 	sh	zero,4(v0)
			pPkthdr->ph_flags = PKTHDR_USED | PKT_OUTGOING;
800031a4:	a448000c 	sh	t0,12(v0)
			pPkthdr->ph_type = PKTHDR_ETHERNET;
800031a8:	8e060008 	lw	a2,8(s0)
800031ac:	7c06ff44 	ins	a2,zero,0x1d,0x3
800031b0:	ae060008 	sw	a2,8(s0)
			pPkthdr->ph_portlist = 0;
800031b4:	a040000f 	sb	zero,15(v0)

			pMbuf->m_next = NULL;
800031b8:	ac60ffe8 	sw	zero,-24(v1)
			pMbuf->m_pkthdr = pPkthdr;
800031bc:	ac70ffec 	sw	s0,-20(v1)
			pMbuf->m_flags = MBUF_USED | MBUF_EXT | MBUF_PKTHDR | MBUF_EOR;
800031c0:	a467fff2 	sh	a3,-14(v1)
			pMbuf->m_data = NULL;
800031c4:	ac60fff4 	sw	zero,-12(v1)
			pMbuf->m_extbuf = NULL;
800031c8:	ac60fff8 	sw	zero,-8(v1)
			pMbuf->m_extsize = 0;
800031cc:	a460fffc 	sh	zero,-4(v1)

			txPkthdrRing[i][j] = (int32) pPkthdr | DESC_RISC_OWNED;
800031d0:	8c8b0000 	lw	t3,0(a0)
800031d4:	00053080 	sll	a2,a1,0x2
800031d8:	01663021 	addu	a2,t3,a2
800031dc:	acc20000 	sw	v0,0(a2)
    txPktDoneDescIndex=0;

    /* Initialize Tx packet header descriptors */
    for (i = 0; i < RTL865X_SWNIC_TXRING_MAX_PKTDESC; i++)
	{
		for (j = 0; j < txPkthdrRingCnt[i]; j++)
800031e0:	24a50001 	addiu	a1,a1,1
800031e4:	24420018 	addiu	v0,v0,24
800031e8:	00608821 	move	s1,v1
800031ec:	8e630000 	lw	v1,0(s3)
800031f0:	00a3302b 	sltu	a2,a1,v1
800031f4:	14c0ffdc 	bnez	a2,80003168 <swNic_init+0x354>
800031f8:	00408021 	move	s0,v0
			txPkthdrRing[i][j] = (int32) pPkthdr | DESC_RISC_OWNED;

		}

		/* Set wrap bit of the last descriptor */
        if (txPkthdrRingCnt[i] != 0)
800031fc:	10600007 	beqz	v1,8000321c <swNic_init+0x408>
80003200:	2463ffff 	addiu	v1,v1,-1
{
            txPkthdrRing[i][txPkthdrRingCnt[i] - 1] |= DESC_WRAP;
80003204:	00031880 	sll	v1,v1,0x2
80003208:	8c820000 	lw	v0,0(a0)
8000320c:	00431021 	addu	v0,v0,v1
80003210:	8c430000 	lw	v1,0(v0)
80003214:	34630002 	ori	v1,v1,0x2
80003218:	ac430000 	sw	v1,0(v0)
8000321c:	24840004 	addiu	a0,a0,4
    /* Initialize index of Tx pkthdr descriptor */
    currTxPkthdrDescIndex = 0;
    txPktDoneDescIndex=0;

    /* Initialize Tx packet header descriptors */
    for (i = 0; i < RTL865X_SWNIC_TXRING_MAX_PKTDESC; i++)
80003220:	108a0004 	beq	a0,t2,80003234 <swNic_init+0x420>
80003224:	26730004 	addiu	s3,s3,4
80003228:	02001021 	move	v0,s0
8000322c:	08000c7b 	j	800031ec <swNic_init+0x3d8>
80003230:	01202821 	move	a1,t1
    memset(pMbufList,0,((rxMbufRingCnt + totalTxPkthdrRingCnt) * sizeof(struct mBuf)));                
    /* Allocate clusters */
    pClusterList = (uint8 *) UNCACHED_MALLOC(rxMbufRingCnt * size_of_cluster + 8 - 1+2*rxMbufRingCnt);
    ASSERT_CSP( (uint32) pClusterList & 0x0fffffff );
    memset(pClusterList,0,(rxMbufRingCnt * size_of_cluster + 8 - 1+2*rxMbufRingCnt));
    pClusterList = (uint8*)(((uint32) pClusterList + 8 - 1) & ~(8 - 1));
80003234:	26520007 	addiu	s2,s2,7
80003238:	2402fff8 	li	v0,-8
8000323c:	02429024 	and	s2,s2,v0
}

	}

    /* Fill Tx packet header FDP */
    REG32(CPUTPDCR0) = (uint32) txPkthdrRing[0];
80003240:	3c038002 	lui	v1,0x8002
80003244:	8c653d34 	lw	a1,15668(v1)
80003248:	3c02b801 	lui	v0,0xb801
8000324c:	34440020 	ori	a0,v0,0x20
80003250:	ac850000 	sw	a1,0(a0)
    REG32(CPUTPDCR1) = (uint32) txPkthdrRing[1];
80003254:	24633d34 	addiu	v1,v1,15668
80003258:	8c650004 	lw	a1,4(v1)
8000325c:	34440024 	ori	a0,v0,0x24
80003260:	ac850000 	sw	a1,0(a0)
#if defined(CONFIG_RTL8196D) || defined(CONFIG_RTL8196E)||defined(CONFIG_RTL8881A)
    REG32(CPUTPDCR2) = (uint32) txPkthdrRing[2];
80003264:	8c650008 	lw	a1,8(v1)
80003268:	34440060 	ori	a0,v0,0x60
8000326c:	ac850000 	sw	a1,0(a0)
    REG32(CPUTPDCR3) = (uint32) txPkthdrRing[3];
80003270:	8c63000c 	lw	v1,12(v1)
80003274:	34420064 	ori	v0,v0,0x64
80003278:	ac430000 	sw	v1,0(v0)
#endif

    /* Initialize index of current Rx pkthdr descriptor */
    currRxPkthdrDescIndex = 0;
8000327c:	3c028002 	lui	v0,0x8002
80003280:	ac403d58 	sw	zero,15704(v0)

    /* Initialize index of current Rx Mbuf descriptor */
    currRxMbufDescIndex = 0;
80003284:	3c028002 	lui	v0,0x8002
80003288:	ac403d5c 	sw	zero,15708(v0)
8000328c:	3c048002 	lui	a0,0x8002
80003290:	24843d04 	addiu	a0,a0,15620
*                                                                         
*   OUTPUTS                                                               
*       Status.
*************************************************************************/

int32 swNic_init(uint32 userNeedRxPkthdrRingCnt[RTL865X_SWNIC_RXRING_MAX_PKTDESC],
80003294:	3c0e8002 	lui	t6,0x8002
80003298:	25ce3d1c 	addiu	t6,t6,15644
8000329c:	00003021 	move	a2,zero
    currRxMbufDescIndex = 0;

    /* Initialize Rx packet header descriptors */
	k = 0;

    for (i = 0; i < RTL865X_SWNIC_RXRING_MAX_PKTDESC; i++)
800032a0:	00006821 	move	t5,zero
         bzero((void *) pMbuf, sizeof(struct mBuf));

			/* Setup pkthdr and mbuf */
			pPkthdr->ph_mbuf = pMbuf;
			pPkthdr->ph_len = 0;
			pPkthdr->ph_flags = PKTHDR_USED | PKT_INCOMING;
800032a4:	240c9000 	li	t4,-28672
			pPkthdr->ph_type = PKTHDR_ETHERNET;
			pPkthdr->ph_portlist = 0;
			pMbuf->m_next = NULL;
			pMbuf->m_pkthdr = pPkthdr;
			pMbuf->m_len = 0;
			pMbuf->m_flags = MBUF_USED | MBUF_EXT | MBUF_PKTHDR | MBUF_EOR;
800032a8:	240b009c 	li	t3,156
			pMbuf->m_data = NULL;
			pMbuf->m_extsize = size_of_cluster;
800032ac:	3c098002 	lui	t1,0x8002
			pMbuf->m_data = pMbuf->m_extbuf = (pClusterList+2);
			pClusterList += size_of_cluster;
			
			/* Setup descriptors */
			rxPkthdrRing[i][j] = (int32) pPkthdr | DESC_SWCORE_OWNED;
			rxMbufRing[k++] = (int32) pMbuf | DESC_SWCORE_OWNED;
800032b0:	08000cec 	j	800033b0 <swNic_init+0x59c>
800032b4:	3c0a8002 	lui	t2,0x8002
		{
			/* Dequeue pkthdr and mbuf */
			pPkthdr = pPkthdrList++;
			pMbuf = pMbufList++;

         bzero((void *) pPkthdr, sizeof(struct pktHdr));
800032b8:	ae000000 	sw	zero,0(s0)
800032bc:	ae000004 	sw	zero,4(s0)
800032c0:	ae000008 	sw	zero,8(s0)
800032c4:	ae00000c 	sw	zero,12(s0)
800032c8:	ae000010 	sw	zero,16(s0)
800032cc:	ae000014 	sw	zero,20(s0)
         bzero((void *) pMbuf, sizeof(struct mBuf));
800032d0:	ae200000 	sw	zero,0(s1)
800032d4:	ae200004 	sw	zero,4(s1)
800032d8:	ae200008 	sw	zero,8(s1)
800032dc:	ae20000c 	sw	zero,12(s1)
800032e0:	ae200010 	sw	zero,16(s1)
800032e4:	ae200014 	sw	zero,20(s1)

			/* Setup pkthdr and mbuf */
			pPkthdr->ph_mbuf = pMbuf;
800032e8:	ac710000 	sw	s1,0(v1)
			pPkthdr->ph_len = 0;
800032ec:	a4600004 	sh	zero,4(v1)
			pPkthdr->ph_flags = PKTHDR_USED | PKT_INCOMING;
800032f0:	a46c000c 	sh	t4,12(v1)
			pPkthdr->ph_type = PKTHDR_ETHERNET;
800032f4:	8e080008 	lw	t0,8(s0)
800032f8:	7c08ff44 	ins	t0,zero,0x1d,0x3
800032fc:	ae080008 	sw	t0,8(s0)
			pPkthdr->ph_portlist = 0;
80003300:	a060000f 	sb	zero,15(v1)
			pMbuf->m_next = NULL;
80003304:	ac400000 	sw	zero,0(v0)
			pMbuf->m_pkthdr = pPkthdr;
80003308:	ac500004 	sw	s0,4(v0)
			pMbuf->m_len = 0;
8000330c:	a4400008 	sh	zero,8(v0)
			pMbuf->m_flags = MBUF_USED | MBUF_EXT | MBUF_PKTHDR | MBUF_EOR;
80003310:	a44b000a 	sh	t3,10(v0)
			pMbuf->m_data = NULL;
80003314:	ac40000c 	sw	zero,12(v0)
			pMbuf->m_extsize = size_of_cluster;
80003318:	8d283d54 	lw	t0,15700(t1)
8000331c:	a4480014 	sh	t0,20(v0)
			/*offset 2 bytes for 4 bytes align of ip packet*/
			pMbuf->m_data = pMbuf->m_extbuf = (pClusterList+2);
80003320:	26480002 	addiu	t0,s2,2
80003324:	ac480010 	sw	t0,16(v0)
80003328:	ac48000c 	sw	t0,12(v0)
			pClusterList += size_of_cluster;
8000332c:	8d283d54 	lw	t0,15700(t1)
80003330:	02489021 	addu	s2,s2,t0
			
			/* Setup descriptors */
			rxPkthdrRing[i][j] = (int32) pPkthdr | DESC_SWCORE_OWNED;
80003334:	8c8f0000 	lw	t7,0(a0)
80003338:	00054080 	sll	t0,a1,0x2
8000333c:	01e84021 	addu	t0,t7,t0
80003340:	346f0001 	ori	t7,v1,0x1
80003344:	ad0f0000 	sw	t7,0(t0)
			rxMbufRing[k++] = (int32) pMbuf | DESC_SWCORE_OWNED;
80003348:	8d483d00 	lw	t0,15616(t2)
8000334c:	01074021 	addu	t0,t0,a3
80003350:	344f0001 	ori	t7,v0,0x1
80003354:	ad0f0000 	sw	t7,0(t0)
    /* Initialize Rx packet header descriptors */
	k = 0;

    for (i = 0; i < RTL865X_SWNIC_RXRING_MAX_PKTDESC; i++)
	{
		for (j = 0; j < rxPkthdrRingCnt[i]; j++)
80003358:	24a50001 	addiu	a1,a1,1
8000335c:	24630018 	addiu	v1,v1,24
80003360:	24420018 	addiu	v0,v0,24
80003364:	24e70004 	addiu	a3,a3,4
80003368:	00408821 	move	s1,v0
8000336c:	00608021 	move	s0,v1
80003370:	8ea80000 	lw	t0,0(s5)
80003374:	00a8c02b 	sltu	t8,a1,t0
80003378:	1700ffcf 	bnez	t8,800032b8 <swNic_init+0x4a4>
8000337c:	00a67821 	addu	t7,a1,a2
			rxPkthdrRing[i][j] = (int32) pPkthdr | DESC_SWCORE_OWNED;
			rxMbufRing[k++] = (int32) pMbuf | DESC_SWCORE_OWNED;
		}

		/* Set wrap bit of the last descriptor */
        if (rxPkthdrRingCnt[i] != 0)
80003380:	11000007 	beqz	t0,800033a0 <swNic_init+0x58c>
80003384:	2508ffff 	addiu	t0,t0,-1
		    rxPkthdrRing[i][rxPkthdrRingCnt[i] - 1] |= DESC_WRAP;
80003388:	00084080 	sll	t0,t0,0x2
8000338c:	8c820000 	lw	v0,0(a0)
80003390:	00481021 	addu	v0,v0,t0
80003394:	8c430000 	lw	v1,0(v0)
80003398:	34630002 	ori	v1,v1,0x2
8000339c:	ac430000 	sw	v1,0(v0)
800033a0:	24840004 	addiu	a0,a0,4
    currRxMbufDescIndex = 0;

    /* Initialize Rx packet header descriptors */
	k = 0;

    for (i = 0; i < RTL865X_SWNIC_RXRING_MAX_PKTDESC; i++)
800033a4:	108e0007 	beq	a0,t6,800033c4 <swNic_init+0x5b0>
800033a8:	26b50004 	addiu	s5,s5,4
800033ac:	01e03021 	move	a2,t7
800033b0:	02001821 	move	v1,s0
800033b4:	02201021 	move	v0,s1
800033b8:	00063880 	sll	a3,a2,0x2
800033bc:	08000cda 	j	80003368 <swNic_init+0x554>
800033c0:	01a02821 	move	a1,t5
		/* Set wrap bit of the last descriptor */
        if (rxPkthdrRingCnt[i] != 0)
		    rxPkthdrRing[i][rxPkthdrRingCnt[i] - 1] |= DESC_WRAP;
	}

	rxMbufRing[rxMbufRingCnt - 1] |= DESC_WRAP;
800033c4:	3c048002 	lui	a0,0x8002
800033c8:	3c028002 	lui	v0,0x8002
800033cc:	8c422e6c 	lw	v0,11884(v0)
800033d0:	2442ffff 	addiu	v0,v0,-1
800033d4:	00021080 	sll	v0,v0,0x2
800033d8:	8c833d00 	lw	v1,15616(a0)
800033dc:	00621021 	addu	v0,v1,v0
800033e0:	8c430000 	lw	v1,0(v0)
800033e4:	34630002 	ori	v1,v1,0x2
800033e8:	ac430000 	sw	v1,0(v0)

    /* Fill Rx packet header FDP */
    REG32(CPURPDCR0) = (uint32) rxPkthdrRing[0];
800033ec:	3c038002 	lui	v1,0x8002
800033f0:	8c663d04 	lw	a2,15620(v1)
800033f4:	3c02b801 	lui	v0,0xb801
800033f8:	34450004 	ori	a1,v0,0x4
800033fc:	aca60000 	sw	a2,0(a1)
    REG32(CPURPDCR1) = (uint32) rxPkthdrRing[1];
80003400:	24633d04 	addiu	v1,v1,15620
80003404:	8c660004 	lw	a2,4(v1)
80003408:	34450008 	ori	a1,v0,0x8
8000340c:	aca60000 	sw	a2,0(a1)
    REG32(CPURPDCR2) = (uint32) rxPkthdrRing[2];
80003410:	8c660008 	lw	a2,8(v1)
80003414:	3445000c 	ori	a1,v0,0xc
80003418:	aca60000 	sw	a2,0(a1)
    REG32(CPURPDCR3) = (uint32) rxPkthdrRing[3];
8000341c:	8c66000c 	lw	a2,12(v1)
80003420:	34450010 	ori	a1,v0,0x10
80003424:	aca60000 	sw	a2,0(a1)
    REG32(CPURPDCR4) = (uint32) rxPkthdrRing[4];
80003428:	8c660010 	lw	a2,16(v1)
8000342c:	34450014 	ori	a1,v0,0x14
80003430:	aca60000 	sw	a2,0(a1)
    REG32(CPURPDCR5) = (uint32) rxPkthdrRing[5];
80003434:	8c650014 	lw	a1,20(v1)
80003438:	34430018 	ori	v1,v0,0x18
8000343c:	ac650000 	sw	a1,0(v1)

    REG32(CPURMDCR0) = (uint32) rxMbufRing;
80003440:	8c843d00 	lw	a0,15616(a0)
80003444:	3443001c 	ori	v1,v0,0x1c
80003448:	ac640000 	sw	a0,0(v1)
	//dprintf("eth0 CPUIIMR status=%x\r\n", *(volatile unsigned int*)(0xb8010028));   //ISR	
	
    /* Enable Rx & Tx. Config bus burst size and mbuf size. */
    //REG32(CPUICR) = TXCMD | RXCMD | BUSBURST_256WORDS | icr_mbufsize;
    //REG32(CPUICR) = TXCMD | RXCMD | BUSBURST_32WORDS | MBUF_2048BYTES;	//8651c
	REG32(CPUICR) = TXCMD | RXCMD | BUSBURST_32WORDS | MBUF_2048BYTES; //wei test irq
8000344c:	3c03c400 	lui	v1,0xc400
80003450:	ac430000 	sw	v1,0(v0)

	REG32(CPUIIMR) = RX_DONE_IE_ALL | TX_DONE_IE_ALL; 
80003454:	34420028 	ori	v0,v0,0x28
80003458:	240307f8 	li	v1,2040
8000345c:	ac430000 	sw	v1,0(v0)


	REG32(MDCIOCR)=0x96181441;      // enable Giga port 8211B LED
80003460:	3c039618 	lui	v1,0x9618
80003464:	34631441 	ori	v1,v1,0x1441
80003468:	3c02bb80 	lui	v0,0xbb80
8000346c:	34424004 	ori	v0,v0,0x4004
80003470:	ac430000 	sw	v1,0(v0)
	//dprintf("eth0 CPUIIMR status=%x\r\n", *(volatile unsigned int*)(0xb8010028));   //ISR
	
    return SUCCESS;
80003474:	08000d20 	j	80003480 <swNic_init+0x66c>
80003478:	00001021 	move	v0,zero
8000347c:	24020016 	li	v0,22
}
80003480:	8fbf003c 	lw	ra,60(sp)
80003484:	8fbe0038 	lw	s8,56(sp)
80003488:	8fb70034 	lw	s7,52(sp)
8000348c:	8fb60030 	lw	s6,48(sp)
80003490:	8fb5002c 	lw	s5,44(sp)
80003494:	8fb40028 	lw	s4,40(sp)
80003498:	8fb30024 	lw	s3,36(sp)
8000349c:	8fb20020 	lw	s2,32(sp)
800034a0:	8fb1001c 	lw	s1,28(sp)
800034a4:	8fb00018 	lw	s0,24(sp)
800034a8:	03e00008 	jr	ra
800034ac:	27bd0040 	addiu	sp,sp,64

800034b0 <swNic_send>:
*                                                                         
*   OUTPUTS                                                               
*       None
*************************************************************************/
int32 swNic_send(void * output, uint32 len)
{
800034b0:	27bdffe0 	addiu	sp,sp,-32
800034b4:	afbf001c 	sw	ra,28(sp)
800034b8:	afb20018 	sw	s2,24(sp)
800034bc:	afb10014 	sw	s1,20(sp)
800034c0:	afb00010 	sw	s0,16(sp)
800034c4:	00801021 	move	v0,a0
    struct pktHdr * pPkthdr;
    //uint8 pktbuf[2048];
    uint8* pktbuf_alligned;

	int next_index;
	if ((currTxPkthdrDescIndex+1) == txPkthdrRingCnt[0])
800034c8:	3c038002 	lui	v1,0x8002
800034cc:	8c703d60 	lw	s0,15712(v1)
800034d0:	26100001 	addiu	s0,s0,1
800034d4:	3c038002 	lui	v1,0x8002
800034d8:	8c633d44 	lw	v1,15684(v1)
800034dc:	02031826 	xor	v1,s0,v1
800034e0:	0003800a 	movz	s0,zero,v1
		next_index = 0;
	else
		next_index = currTxPkthdrDescIndex+1;
	if (next_index == txPktDoneDescIndex) {
800034e4:	3c038002 	lui	v1,0x8002
800034e8:	8c633d64 	lw	v1,15716(v1)
800034ec:	16030006 	bne	s0,v1,80003508 <swNic_send+0x58>
800034f0:	00a08821 	move	s1,a1
		dprintf("Tx Desc full!\n");
800034f4:	3c048001 	lui	a0,0x8001
800034f8:	0c002325 	jal	80008c94 <dprintf>
800034fc:	24844644 	addiu	a0,a0,17988
		return -1;
80003500:	08000d85 	j	80003614 <swNic_send+0x164>
80003504:	2402ffff 	li	v0,-1
	}		

#ifdef _FAST_TX
	pktbuf_alligned = (uint8 *)output;
#else
	pktbuf_alligned = (uint8 *) (( (uint32) pktbuf & 0xfffffffc) | 0xa0000000);
80003508:	3c035fff 	lui	v1,0x5fff
8000350c:	3463fffc 	ori	v1,v1,0xfffc
80003510:	3c128002 	lui	s2,0x8002
80003514:	26524704 	addiu	s2,s2,18180
80003518:	02439024 	and	s2,s2,v1
8000351c:	3c03a000 	lui	v1,0xa000
80003520:	02439025 	or	s2,s2,v1
    /* Copy Packet Content */
    memcpy(pktbuf_alligned, output, len);
80003524:	02402021 	move	a0,s2
80003528:	00402821 	move	a1,v0
8000352c:	0c002046 	jal	80008118 <memcpy>
80003530:	02203021 	move	a2,s1
			ddump(output, 32);
//		else
//			ddump(output, len);
	}
#endif
    ASSERT_CSP( ((int32) txPkthdrRing[0][currTxPkthdrDescIndex] & DESC_OWNED_BIT) == DESC_RISC_OWNED );
80003534:	3c028002 	lui	v0,0x8002
80003538:	8c433d60 	lw	v1,15712(v0)
8000353c:	00031880 	sll	v1,v1,0x2
80003540:	3c028002 	lui	v0,0x8002
80003544:	8c423d34 	lw	v0,15668(v0)
80003548:	00431021 	addu	v0,v0,v1
8000354c:	8c420000 	lw	v0,0(v0)
80003550:	30440001 	andi	a0,v0,0x1
80003554:	10800005 	beqz	a0,8000356c <swNic_send+0xbc>
80003558:	3c048001 	lui	a0,0x8001
8000355c:	0c002325 	jal	80008c94 <dprintf>
80003560:	2484462c 	addiu	a0,a0,17964
80003564:	08000d59 	j	80003564 <swNic_send+0xb4>
80003568:	00000000 	nop

    /* Fetch packet header from Tx ring */
    pPkthdr = (struct pktHdr *) ((int32) txPkthdrRing[0][currTxPkthdrDescIndex] 
8000356c:	2404fffc 	li	a0,-4
80003570:	00441024 	and	v0,v0,a0
                                                & ~(DESC_OWNED_BIT | DESC_WRAP));

    /* Pad small packets and add CRC */
    if ( len < 60 )
80003574:	2e24003c 	sltiu	a0,s1,60
80003578:	10800004 	beqz	a0,8000358c <swNic_send+0xdc>
8000357c:	26310004 	addiu	s1,s1,4
        pPkthdr->ph_len = 64;
80003580:	24040040 	li	a0,64
80003584:	08000d64 	j	80003590 <swNic_send+0xe0>
80003588:	a4440004 	sh	a0,4(v0)
    else
        pPkthdr->ph_len = len + 4;
8000358c:	a4510004 	sh	s1,4(v0)
    pPkthdr->ph_mbuf->m_len       = pPkthdr->ph_len;
80003590:	8c440000 	lw	a0,0(v0)
80003594:	94450004 	lhu	a1,4(v0)
80003598:	a4850008 	sh	a1,8(a0)
    pPkthdr->ph_mbuf->m_extsize = pPkthdr->ph_len;
8000359c:	8c440000 	lw	a0,0(v0)
800035a0:	94450004 	lhu	a1,4(v0)
800035a4:	a4850014 	sh	a1,20(a0)

    /* Set cluster pointer to buffer */
    pPkthdr->ph_mbuf->m_data    = pktbuf_alligned;
800035a8:	8c440000 	lw	a0,0(v0)
800035ac:	ac92000c 	sw	s2,12(a0)
    pPkthdr->ph_mbuf->m_extbuf = pktbuf_alligned;
800035b0:	8c440000 	lw	a0,0(v0)
800035b4:	ac920010 	sw	s2,16(a0)
#if defined(CONFIG_RTL8196D) || defined(CONFIG_RTL8196E)||defined(CONFIG_RTL8881A)
    pPkthdr->ph_ptpPkt = 0;
800035b8:	8c440014 	lw	a0,20(v0)
800035bc:	7c04c604 	ins	a0,zero,0x18,0x1
800035c0:	ac440014 	sw	a0,20(v0)
#endif

    /* Set destination port */
#if defined(CONFIG_RTL8198)
    pPkthdr->ph_portlist = ALL_PORT_MASK;
800035c4:	2404003f 	li	a0,63
800035c8:	a044000f 	sb	a0,15(v0)
        {
                pPkthdr->ph_portlist = AP_MODE_PORT_MASK;//Port 4 Only for AP Mode
        }
#endif		
    /* Give descriptor to switch core */
    txPkthdrRing[0][currTxPkthdrDescIndex] |= DESC_SWCORE_OWNED;
800035cc:	3c028002 	lui	v0,0x8002
800035d0:	8c423d34 	lw	v0,15668(v0)
800035d4:	00431021 	addu	v0,v0,v1
800035d8:	8c430000 	lw	v1,0(v0)
800035dc:	34630001 	ori	v1,v1,0x1
800035e0:	ac430000 	sw	v1,0(v0)

    /* Set TXFD bit to start send */
    REG32(CPUICR) |= TXFD;
800035e4:	3c02b801 	lui	v0,0xb801
800035e8:	8c440000 	lw	a0,0(v0)
800035ec:	3c030080 	lui	v1,0x80
800035f0:	00831825 	or	v1,a0,v1
800035f4:	ac430000 	sw	v1,0(v0)
    txPktCounter++;
800035f8:	3c028002 	lui	v0,0x8002
800035fc:	8c433d6c 	lw	v1,15724(v0)
80003600:	24630001 	addiu	v1,v1,1
80003604:	ac433d6c 	sw	v1,15724(v0)

	currTxPkthdrDescIndex = next_index;
80003608:	3c028002 	lui	v0,0x8002
8000360c:	ac503d60 	sw	s0,15712(v0)
80003610:	00001021 	move	v0,zero
    return 0;
}
80003614:	8fbf001c 	lw	ra,28(sp)
80003618:	8fb20018 	lw	s2,24(sp)
8000361c:	8fb10014 	lw	s1,20(sp)
80003620:	8fb00010 	lw	s0,16(sp)
80003624:	03e00008 	jr	ra
80003628:	27bd0020 	addiu	sp,sp,32

8000362c <swNic_receive>:
*                                                                         
*   OUTPUTS                                                               
*       None
*************************************************************************/
int32 swNic_receive(void** input, uint32* pLen)
{
8000362c:	27bdffd8 	addiu	sp,sp,-40
80003630:	afbf0024 	sw	ra,36(sp)
80003634:	afb30020 	sw	s3,32(sp)
80003638:	afb2001c 	sw	s2,28(sp)
8000363c:	afb10018 	sw	s1,24(sp)
80003640:	afb00014 	sw	s0,20(sp)
80003644:	00808021 	move	s0,a0
80003648:	00a08821 	move	s1,a1
    static int32 firstTime = 1;
    char	*data;
    int	ret=-1;

    /* Check OWN bit of descriptors */
    if ( (rxPkthdrRing[0][currRxPkthdrDescIndex] & DESC_OWNED_BIT) == DESC_RISC_OWNED )
8000364c:	3c028002 	lui	v0,0x8002
80003650:	8c423d58 	lw	v0,15704(v0)
80003654:	3c038002 	lui	v1,0x8002
80003658:	8c633d04 	lw	v1,15620(v1)
8000365c:	00021080 	sll	v0,v0,0x2
80003660:	00621021 	addu	v0,v1,v0
80003664:	8c420000 	lw	v0,0(v0)
80003668:	30440001 	andi	a0,v0,0x1
8000366c:	14800069 	bnez	a0,80003814 <swNic_receive+0x1e8>
80003670:	2403ffff 	li	v1,-1
    {
        //ASSERT_ISR(currRxPkthdrDescIndex < rxPkthdrRingCnt[0]);
        
        /* Fetch pkthdr */
        pPkthdr = (struct pktHdr *) (rxPkthdrRing[0][currRxPkthdrDescIndex] & 
80003674:	2413fffc 	li	s3,-4
80003678:	00539824 	and	s3,v0,s3
        //ASSERT_ISR(pPkthdr->ph_len); /* Not allow zero packet length */
        //ASSERT_ISR(pPkthdr->ph_len >= 64);
        //ASSERT_ISR(pPkthdr->ph_len <= 1522);

        /* Increment counter */
        rxPktCounter++;
8000367c:	3c028002 	lui	v0,0x8002
80003680:	8c433d68 	lw	v1,15720(v0)
80003684:	24630001 	addiu	v1,v1,1
80003688:	ac433d68 	sw	v1,15720(v0)

	data = pPkthdr->ph_mbuf->m_data;
8000368c:	8e620000 	lw	v0,0(s3)
80003690:	8c52000c 	lw	s2,12(v0)
 		extern char eth0_mac[6]; 
	if ( (data[0]&0x1)||!memcmp(data, eth0_mac, 6) )

#else
		extern char eth0_mac[6];
		if ( (data[0]&0x1)||!memcmp(data, eth0_mac, 6) )
80003694:	92420000 	lbu	v0,0(s2)
80003698:	30420001 	andi	v0,v0,0x1
8000369c:	14400007 	bnez	v0,800036bc <swNic_receive+0x90>
800036a0:	02402021 	move	a0,s2
800036a4:	3c058001 	lui	a1,0x8001
800036a8:	24a57590 	addiu	a1,a1,30096
800036ac:	0c002051 	jal	80008144 <memcmp>
800036b0:	24060006 	li	a2,6
800036b4:	1440000e 	bnez	v0,800036f0 <swNic_receive+0xc4>
800036b8:	2403ffff 	li	v1,-1
#endif
		{

		
        /* Output packet */
		        *input = data;
800036bc:	ae120000 	sw	s2,0(s0)
        *pLen = pPkthdr->ph_len - 4;
800036c0:	96660004 	lhu	a2,4(s3)
800036c4:	24c6fffc 	addiu	a2,a2,-4
800036c8:	ae260000 	sw	a2,0(s1)
			ret = 0;


#if 1 //joey patch for inic
	   // for iNic & 8306 board, the received packet will has VLAN tag
	   if (*(unsigned short *)&(data[12]) == 0x8100)
800036cc:	9644000c 	lhu	a0,12(s2)
800036d0:	34028100 	li	v0,0x8100
800036d4:	14820006 	bne	a0,v0,800036f0 <swNic_receive+0xc4>
800036d8:	00001821 	move	v1,zero
	   {
		    memcpy(&(data[12]), &(data[16]), *pLen - 16);
800036dc:	2644000c 	addiu	a0,s2,12
800036e0:	26450010 	addiu	a1,s2,16
800036e4:	0c002046 	jal	80008118 <memcpy>
800036e8:	24c6fff0 	addiu	a2,a2,-16
800036ec:	00001821 	move	v1,zero
			ddump(*input, 64);
//		else
//			ddump(*input, *pLen);
	}
#endif
        if ( !firstTime )
800036f0:	3c028001 	lui	v0,0x8001
800036f4:	8c4275b0 	lw	v0,30128(v0)
800036f8:	14400024 	bnez	v0,8000378c <swNic_receive+0x160>
800036fc:	3c028001 	lui	v0,0x8001
        {
            /* Calculate previous pkthdr and mbuf index */
            pkthdr_index = currRxPkthdrDescIndex;
80003700:	3c028002 	lui	v0,0x8002
80003704:	8c443d58 	lw	a0,15704(v0)
            if ( --pkthdr_index < 0 )
80003708:	2484ffff 	addiu	a0,a0,-1
8000370c:	04810005 	bgez	a0,80003724 <swNic_receive+0xf8>
80003710:	00042080 	sll	a0,a0,0x2
                pkthdr_index = rxPkthdrRingCnt[0] - 1;
80003714:	3c028002 	lui	v0,0x8002
80003718:	8c443d1c 	lw	a0,15644(v0)
8000371c:	2484ffff 	addiu	a0,a0,-1
#if defined(CONFIG_RTL8196D) || defined(CONFIG_RTL8196E)||defined(CONFIG_RTL8881A)
            // for rx descriptor runout
            pPkthdr = (struct pktHdr *) (rxPkthdrRing[0][pkthdr_index] & ~(DESC_OWNED_BIT | DESC_WRAP));
80003720:	00042080 	sll	a0,a0,0x2
80003724:	3c028002 	lui	v0,0x8002
80003728:	8c423d04 	lw	v0,15620(v0)
8000372c:	00442021 	addu	a0,v0,a0
80003730:	8c850000 	lw	a1,0(a0)
            mbuf_index = ((uint32)(pPkthdr->ph_mbuf) - (rxMbufRing[0] & ~(DESC_OWNED_BIT | DESC_WRAP))) /
80003734:	2406fffc 	li	a2,-4
80003738:	00a63824 	and	a3,a1,a2
8000373c:	3c028002 	lui	v0,0x8002
80003740:	8c483d00 	lw	t0,15616(v0)
80003744:	8d080000 	lw	t0,0(t0)
80003748:	01063024 	and	a2,t0,a2
8000374c:	8ce70000 	lw	a3,0(a3)
80003750:	00e63023 	subu	a2,a3,a2
80003754:	3c07aaaa 	lui	a3,0xaaaa
80003758:	34e7aaab 	ori	a3,a3,0xaaab
8000375c:	00c70019 	multu	a2,a3
80003760:	00003010 	mfhi	a2
80003764:	00063102 	srl	a2,a2,0x4
            if ( --mbuf_index < 0 )
                mbuf_index = rxPkthdrRingCnt[0] - 1;
#endif
        
            /* Reset OWN bit */
            rxPkthdrRing[0][pkthdr_index] |= DESC_SWCORE_OWNED;
80003768:	34a50001 	ori	a1,a1,0x1
8000376c:	ac850000 	sw	a1,0(a0)
            rxMbufRing[mbuf_index] |= DESC_SWCORE_OWNED;
80003770:	00063080 	sll	a2,a2,0x2
80003774:	8c423d00 	lw	v0,15616(v0)
80003778:	00463021 	addu	a2,v0,a2
8000377c:	8cc20000 	lw	v0,0(a2)
80003780:	34420001 	ori	v0,v0,0x1
80003784:	08000de4 	j	80003790 <swNic_receive+0x164>
80003788:	acc20000 	sw	v0,0(a2)
        }
        else
            firstTime = 0;
8000378c:	ac4075b0 	sw	zero,30128(v0)
        
        /* Increment index */
        if ( ++currRxPkthdrDescIndex == rxPkthdrRingCnt[0] )
80003790:	3c048002 	lui	a0,0x8002
80003794:	8c823d58 	lw	v0,15704(a0)
80003798:	24420001 	addiu	v0,v0,1
8000379c:	ac823d58 	sw	v0,15704(a0)
800037a0:	3c048002 	lui	a0,0x8002
800037a4:	8c843d1c 	lw	a0,15644(a0)
800037a8:	14440003 	bne	v0,a0,800037b8 <swNic_receive+0x18c>
800037ac:	3c048002 	lui	a0,0x8002
            currRxPkthdrDescIndex = 0;
800037b0:	3c028002 	lui	v0,0x8002
800037b4:	ac403d58 	sw	zero,15704(v0)
        if ( ++currRxMbufDescIndex == rxMbufRingCnt )
800037b8:	8c823d5c 	lw	v0,15708(a0)
800037bc:	24420001 	addiu	v0,v0,1
800037c0:	ac823d5c 	sw	v0,15708(a0)
800037c4:	3c048002 	lui	a0,0x8002
800037c8:	8c842e6c 	lw	a0,11884(a0)
800037cc:	14440004 	bne	v0,a0,800037e0 <swNic_receive+0x1b4>
800037d0:	3c02b801 	lui	v0,0xb801
            currRxMbufDescIndex = 0;
800037d4:	3c028002 	lui	v0,0x8002
800037d8:	ac403d5c 	sw	zero,15708(v0)

        if ( REG32(CPUIISR) & PKTHDR_DESC_RUNOUT_IP_ALL )
800037dc:	3c02b801 	lui	v0,0xb801
800037e0:	3442002c 	ori	v0,v0,0x2c
800037e4:	8c440000 	lw	a0,0(v0)
800037e8:	3c02007e 	lui	v0,0x7e
800037ec:	00821024 	and	v0,a0,v0
800037f0:	10400008 	beqz	v0,80003814 <swNic_receive+0x1e8>
800037f4:	3c04b801 	lui	a0,0xb801
        {
            /* Enable and clear interrupt for continue reception */
            REG32(CPUIIMR) |= PKTHDR_DESC_RUNOUT_IE_ALL;
800037f8:	34850028 	ori	a1,a0,0x28
800037fc:	8ca60000 	lw	a2,0(a1)
80003800:	3c02007e 	lui	v0,0x7e
80003804:	00c23025 	or	a2,a2,v0
80003808:	aca60000 	sw	a2,0(a1)
            REG32(CPUIISR) = PKTHDR_DESC_RUNOUT_IP_ALL;
8000380c:	3484002c 	ori	a0,a0,0x2c
80003810:	ac820000 	sw	v0,0(a0)
        }
        return ret;
    }
    else
        return -1;
}
80003814:	00601021 	move	v0,v1
80003818:	8fbf0024 	lw	ra,36(sp)
8000381c:	8fb30020 	lw	s3,32(sp)
80003820:	8fb2001c 	lw	s2,28(sp)
80003824:	8fb10018 	lw	s1,24(sp)
80003828:	8fb00014 	lw	s0,20(sp)
8000382c:	03e00008 	jr	ra
80003830:	27bd0028 	addiu	sp,sp,40
	...

80003840 <swTable_readEntry>:



#ifdef CONFIG_RTL865XC
int32 swTable_readEntry(uint32 tableType, uint32 eidx, void *entryContent_P)
{
80003840:	27bdffe8 	addiu	sp,sp,-24
80003844:	afbf0014 	sw	ra,20(sp)
    uint32 *    entryAddr;

    REG32(SWTCR0) = REG32(SWTCR0) | EN_STOP_TLU;
80003848:	3c02bb80 	lui	v0,0xbb80
8000384c:	34424418 	ori	v0,v0,0x4418
80003850:	8c470000 	lw	a3,0(v0)
80003854:	3c030004 	lui	v1,0x4
80003858:	00e31825 	or	v1,a3,v1
8000385c:	ac430000 	sw	v1,0(v0)
    while ((REG32(SWTCR0) & STOP_TLU_READY) == 0);
80003860:	00403821 	move	a3,v0
80003864:	3c030008 	lui	v1,0x8
80003868:	8ce20000 	lw	v0,0(a3)
8000386c:	00431024 	and	v0,v0,v1
80003870:	1040fffd 	beqz	v0,80003868 <swTable_readEntry+0x28>
80003874:	00000000 	nop

    ASSERT_CSP(entryContent_P);
80003878:	14c00006 	bnez	a2,80003894 <swTable_readEntry+0x54>
8000387c:	3402bb00 	li	v0,0xbb00
80003880:	3c048001 	lui	a0,0x8001
80003884:	0c002325 	jal	80008c94 <dprintf>
80003888:	2484462c 	addiu	a0,a0,17964
8000388c:	08000e23 	j	8000388c <swTable_readEntry+0x4c>
80003890:	00000000 	nop
    
    entryAddr = (uint32 *) (table_access_addr_base(tableType) + eidx * TABLE_ENTRY_DISTANCE);
80003894:	00822021 	addu	a0,a0,v0
80003898:	000422c0 	sll	a0,a0,0xb
8000389c:	00852821 	addu	a1,a0,a1
800038a0:	00052940 	sll	a1,a1,0x5
    
    /* Wait for command ready */
    while ( (REG32(SWTACR) & ACTION_MASK) != ACTION_DONE );
800038a4:	3c03bb80 	lui	v1,0xbb80
800038a8:	34634d00 	ori	v1,v1,0x4d00
800038ac:	8c620000 	lw	v0,0(v1)
800038b0:	30420001 	andi	v0,v0,0x1
800038b4:	1440fffd 	bnez	v0,800038ac <swTable_readEntry+0x6c>
800038b8:	00000000 	nop
    
    /* Read registers according to entry width of each table */
    *((uint32 *)entryContent_P + 7) = *(entryAddr + 7);
800038bc:	8ca2001c 	lw	v0,28(a1)
800038c0:	acc2001c 	sw	v0,28(a2)
    *((uint32 *)entryContent_P + 6) = *(entryAddr + 6);
800038c4:	8ca20018 	lw	v0,24(a1)
800038c8:	acc20018 	sw	v0,24(a2)
    *((uint32 *)entryContent_P + 5) = *(entryAddr + 5);
800038cc:	8ca20014 	lw	v0,20(a1)
800038d0:	acc20014 	sw	v0,20(a2)
    *((uint32 *)entryContent_P + 4) = *(entryAddr + 4);
800038d4:	8ca20010 	lw	v0,16(a1)
800038d8:	acc20010 	sw	v0,16(a2)
    *((uint32 *)entryContent_P + 3) = *(entryAddr + 3);
800038dc:	8ca2000c 	lw	v0,12(a1)
800038e0:	acc2000c 	sw	v0,12(a2)
    *((uint32 *)entryContent_P + 2) = *(entryAddr + 2);
800038e4:	8ca20008 	lw	v0,8(a1)
800038e8:	acc20008 	sw	v0,8(a2)
    *((uint32 *)entryContent_P + 1) = *(entryAddr + 1);
800038ec:	8ca20004 	lw	v0,4(a1)
800038f0:	acc20004 	sw	v0,4(a2)
    *((uint32 *)entryContent_P + 0) = *(entryAddr + 0);
800038f4:	8ca20000 	lw	v0,0(a1)
800038f8:	acc20000 	sw	v0,0(a2)

    REG32(SWTCR0) = REG32(SWTCR0) & ~EN_STOP_TLU;
800038fc:	3c02bb80 	lui	v0,0xbb80
80003900:	34424418 	ori	v0,v0,0x4418
80003904:	8c440000 	lw	a0,0(v0)
80003908:	3c03fffb 	lui	v1,0xfffb
8000390c:	3463ffff 	ori	v1,v1,0xffff
80003910:	00831824 	and	v1,a0,v1
80003914:	ac430000 	sw	v1,0(v0)

    return 0;
}
80003918:	00001021 	move	v0,zero
8000391c:	8fbf0014 	lw	ra,20(sp)
80003920:	03e00008 	jr	ra
80003924:	27bd0018 	addiu	sp,sp,24

80003928 <swTable_addEntry>:
 */
RTL_STATIC_INLINE void tableAccessForeword(uint32, uint32, void *);

#ifdef CONFIG_RTL865XC
int32 swTable_addEntry(uint32 tableType, uint32 eidx, void *entryContent_P)
{
80003928:	27bdffe8 	addiu	sp,sp,-24
8000392c:	afbf0014 	sw	ra,20(sp)
    REG32(SWTCR0) = REG32(SWTCR0) | EN_STOP_TLU;
80003930:	3c02bb80 	lui	v0,0xbb80
80003934:	34424418 	ori	v0,v0,0x4418
80003938:	8c470000 	lw	a3,0(v0)
8000393c:	3c030004 	lui	v1,0x4
80003940:	00e31825 	or	v1,a3,v1
80003944:	ac430000 	sw	v1,0(v0)
    while ((REG32(SWTCR0) & STOP_TLU_READY) == 0);
80003948:	00403821 	move	a3,v0
8000394c:	3c030008 	lui	v1,0x8
80003950:	8ce20000 	lw	v0,0(a3)
80003954:	00431024 	and	v0,v0,v1
80003958:	1040fffd 	beqz	v0,80003950 <swTable_addEntry+0x28>
8000395c:	00000000 	nop


//RTL_STATIC_INLINE void tableAccessForeword(uint32 tableType, uint32 eidx,     void *entryContent_P)
void tableAccessForeword(uint32 tableType, uint32 eidx,     void *entryContent_P)
{
    ASSERT_CSP(entryContent_P);
80003960:	14c00006 	bnez	a2,8000397c <swTable_addEntry+0x54>
80003964:	3c03bb80 	lui	v1,0xbb80
80003968:	3c048001 	lui	a0,0x8001
8000396c:	0c002325 	jal	80008c94 <dprintf>
80003970:	2484462c 	addiu	a0,a0,17964
80003974:	08000e5d 	j	80003974 <swTable_addEntry+0x4c>
80003978:	00000000 	nop

    /* Wait for command done */
    while ( (REG32(SWTACR) & ACTION_MASK) != ACTION_DONE );
8000397c:	34634d00 	ori	v1,v1,0x4d00
80003980:	8c620000 	lw	v0,0(v1)
80003984:	30420001 	andi	v0,v0,0x1
80003988:	1440fffd 	bnez	v0,80003980 <swTable_addEntry+0x58>
8000398c:	3c02bb80 	lui	v0,0xbb80
    
    /* Write registers according to entry width of each table */
    REG32(TCR7) = *((uint32 *)entryContent_P + 7);
80003990:	8cc7001c 	lw	a3,28(a2)
80003994:	34434d3c 	ori	v1,v0,0x4d3c
80003998:	ac670000 	sw	a3,0(v1)
    REG32(TCR6) = *((uint32 *)entryContent_P + 6);
8000399c:	8cc70018 	lw	a3,24(a2)
800039a0:	34434d38 	ori	v1,v0,0x4d38
800039a4:	ac670000 	sw	a3,0(v1)
    REG32(TCR5) = *((uint32 *)entryContent_P + 5);
800039a8:	8cc70014 	lw	a3,20(a2)
800039ac:	34434d34 	ori	v1,v0,0x4d34
800039b0:	ac670000 	sw	a3,0(v1)
    REG32(TCR4) = *((uint32 *)entryContent_P + 4);
800039b4:	8cc70010 	lw	a3,16(a2)
800039b8:	34434d30 	ori	v1,v0,0x4d30
800039bc:	ac670000 	sw	a3,0(v1)
    REG32(TCR3) = *((uint32 *)entryContent_P + 3);
800039c0:	8cc7000c 	lw	a3,12(a2)
800039c4:	34434d2c 	ori	v1,v0,0x4d2c
800039c8:	ac670000 	sw	a3,0(v1)
    REG32(TCR2) = *((uint32 *)entryContent_P + 2);
800039cc:	8cc70008 	lw	a3,8(a2)
800039d0:	34434d28 	ori	v1,v0,0x4d28
800039d4:	ac670000 	sw	a3,0(v1)
    REG32(TCR1) = *((uint32 *)entryContent_P + 1);
800039d8:	8cc70004 	lw	a3,4(a2)
800039dc:	34434d24 	ori	v1,v0,0x4d24
800039e0:	ac670000 	sw	a3,0(v1)
    REG32(TCR0) = *(uint32 *)entryContent_P;
800039e4:	8cc60000 	lw	a2,0(a2)
800039e8:	34434d20 	ori	v1,v0,0x4d20
800039ec:	ac660000 	sw	a2,0(v1)
    
    /* Fill address */
    REG32(SWTAA) = table_access_addr_base(tableType) + eidx * TABLE_ENTRY_DISTANCE;
800039f0:	3403bb00 	li	v1,0xbb00
800039f4:	00832021 	addu	a0,a0,v1
800039f8:	000422c0 	sll	a0,a0,0xb
800039fc:	00852821 	addu	a1,a0,a1
80003a00:	00052940 	sll	a1,a1,0x5
80003a04:	34434d08 	ori	v1,v0,0x4d08
80003a08:	ac650000 	sw	a1,0(v1)
    while ((REG32(SWTCR0) & STOP_TLU_READY) == 0);

    tableAccessForeword(tableType, eidx, entryContent_P);
        
    /* Activate add command */
    REG32(SWTACR) = ACTION_START | CMD_ADD;
80003a0c:	34424d00 	ori	v0,v0,0x4d00
80003a10:	24030003 	li	v1,3
80003a14:	ac430000 	sw	v1,0(v0)
    
    /* Wait for command done */
    while ( (REG32(SWTACR) & ACTION_MASK) != ACTION_DONE );
80003a18:	00401821 	move	v1,v0
80003a1c:	8c620000 	lw	v0,0(v1)
80003a20:	30420001 	andi	v0,v0,0x1
80003a24:	1440fffd 	bnez	v0,80003a1c <swTable_addEntry+0xf4>
80003a28:	3c02bb80 	lui	v0,0xbb80

    REG32(SWTCR0) = REG32(SWTCR0) & ~EN_STOP_TLU;
80003a2c:	34434418 	ori	v1,v0,0x4418
80003a30:	8c650000 	lw	a1,0(v1)
80003a34:	3c04fffb 	lui	a0,0xfffb
80003a38:	3484ffff 	ori	a0,a0,0xffff
80003a3c:	00a42024 	and	a0,a1,a0
80003a40:	ac640000 	sw	a0,0(v1)

    /* Check status */
    if ( (REG32(SWTASR) & TABSTS_MASK) != TABSTS_SUCCESS )
80003a44:	34424d04 	ori	v0,v0,0x4d04
80003a48:	8c430000 	lw	v1,0(v0)
80003a4c:	30630001 	andi	v1,v1,0x1
        return ECOLLISION;
    else
        return 0;
}
80003a50:	24020058 	li	v0,88
80003a54:	0003100a 	movz	v0,zero,v1
80003a58:	8fbf0014 	lw	ra,20(sp)
80003a5c:	03e00008 	jr	ra
80003a60:	27bd0018 	addiu	sp,sp,24
	...

80003a70 <lx4180_ReadStatus>:
extern int32 swTable_readEntry(uint32 tableType, uint32 eidx, void *entryContent_P);

#include <asm/mipsregs.h>
//wei add
int lx4180_ReadStatus()
{
80003a70:	27bdfff8 	addiu	sp,sp,-8
   volatile unsigned int reg;
	reg= read_32bit_cp0_register(CP0_STATUS);
80003a74:	40026000 	mfc0	v0,c0_status
80003a78:	afa20000 	sw	v0,0(sp)
	...
	__asm__ volatile("nop");	// david
   	__asm__ volatile("nop");   
	return reg;
80003a84:	8fa20000 	lw	v0,0(sp)

}
80003a88:	03e00008 	jr	ra
80003a8c:	27bd0008 	addiu	sp,sp,8

80003a90 <lx4180_WriteStatus>:
void lx4180_WriteStatus(int s)
{
80003a90:	27bdfff8 	addiu	sp,sp,-8
   volatile unsigned int reg=s;
80003a94:	afa40000 	sw	a0,0(sp)
	write_32bit_cp0_register(CP0_STATUS, reg);
80003a98:	8fa20000 	lw	v0,0(sp)
80003a9c:	40826000 	mtc0	v0,c0_status
80003aa0:	00000040 	ssnop
80003aa4:	00000040 	ssnop
80003aa8:	00000040 	ssnop
80003aac:	00000040 	ssnop
	...
	__asm__ volatile("nop");	// david
   	__asm__ volatile("nop");   
	return ;

}
80003ab8:	03e00008 	jr	ra
80003abc:	27bd0008 	addiu	sp,sp,8

80003ac0 <vlanTable_setStpStatusOfAllPorts>:


int32 vlanTable_setStpStatusOfAllPorts(uint32 vid, uint32 STPStatus)
{

}
80003ac0:	03e00008 	jr	ra
80003ac4:	00000000 	nop

80003ac8 <vlanTable_create>:




int32 vlanTable_create(uint32 vid, rtl_vlan_param_t * param)
{
80003ac8:	27bdffc0 	addiu	sp,sp,-64
80003acc:	afbf003c 	sw	ra,60(sp)
80003ad0:	afb20038 	sw	s2,56(sp)
80003ad4:	afb10034 	sw	s1,52(sp)
80003ad8:	afb00030 	sw	s0,48(sp)
80003adc:	00809021 	move	s2,a0
    vlan_table_t    entryContent;
    uint32	temp,temp2;
    
    ASSERT_CSP(param);
80003ae0:	14a00006 	bnez	a1,80003afc <vlanTable_create+0x34>
80003ae4:	00a08021 	move	s0,a1
80003ae8:	3c048001 	lui	a0,0x8001
80003aec:	0c002325 	jal	80008c94 <dprintf>
80003af0:	2484462c 	addiu	a0,a0,17964
80003af4:	08000ebd 	j	80003af4 <vlanTable_create+0x2c>
80003af8:	00000000 	nop
    
    // disable interrupt
    // I don't know the reason but if you want to use "-O" flag, must disalbe interrupt before swTable_readEntry();
    temp = lx4180_ReadStatus();
80003afc:	0c000e9c 	jal	80003a70 <lx4180_ReadStatus>
80003b00:	00000000 	nop
    if (0!=temp&0x1) {
80003b04:	1040000c 	beqz	v0,80003b38 <vlanTable_create+0x70>
80003b08:	00408821 	move	s1,v0
	    temp2 = temp&0xfffffffe;
	    lx4180_WriteStatus(temp2);
80003b0c:	2402fffe 	li	v0,-2
80003b10:	0c000ea4 	jal	80003a90 <lx4180_WriteStatus>
80003b14:	02222024 	and	a0,s1,v0
    }
    
    swTable_readEntry(TYPE_VLAN_TABLE, vid, &entryContent);
80003b18:	24040006 	li	a0,6
80003b1c:	02402821 	move	a1,s2
80003b20:	0c000e10 	jal	80003840 <swTable_readEntry>
80003b24:	27a60010 	addiu	a2,sp,16
    
    // restore status register
    if (0!=temp&0x1) {
	    lx4180_WriteStatus(temp);
80003b28:	0c000ea4 	jal	80003a90 <lx4180_WriteStatus>
80003b2c:	02202021 	move	a0,s1
    }

    bzero( (void *) &entryContent, sizeof(entryContent) );
80003b30:	08000ed3 	j	80003b4c <vlanTable_create+0x84>
80003b34:	27b10010 	addiu	s1,sp,16
    if (0!=temp&0x1) {
	    temp2 = temp&0xfffffffe;
	    lx4180_WriteStatus(temp2);
    }
    
    swTable_readEntry(TYPE_VLAN_TABLE, vid, &entryContent);
80003b38:	24040006 	li	a0,6
80003b3c:	02402821 	move	a1,s2
80003b40:	0c000e10 	jal	80003840 <swTable_readEntry>
80003b44:	27a60010 	addiu	a2,sp,16
    // restore status register
    if (0!=temp&0x1) {
	    lx4180_WriteStatus(temp);
    }

    bzero( (void *) &entryContent, sizeof(entryContent) );
80003b48:	27b10010 	addiu	s1,sp,16
80003b4c:	02202021 	move	a0,s1
80003b50:	00002821 	move	a1,zero
80003b54:	0c00203d 	jal	800080f4 <memset>
80003b58:	24060020 	li	a2,32
    entryContent.memberPort = param->memberPort & ALL_PORT_MASK;
80003b5c:	92020003 	lbu	v0,3(s0)
    entryContent.egressUntag = param->egressUntag;
80003b60:	8e030004 	lw	v1,4(s0)
80003b64:	3042003f 	andi	v0,v0,0x3f
80003b68:	7c627244 	ins	v0,v1,0x9,0x6
    entryContent.fid = param->fid;
80003b6c:	8e030008 	lw	v1,8(s0)
80003b70:	7c630f80 	ext	v1,v1,0x1e,0x2
80003b74:	7c629c84 	ins	v0,v1,0x12,0x2
80003b78:	afa20010 	sw	v0,16(sp)
#if (defined(CONFIG_RTL8196D) || defined(CONFIG_RTL8196E)||defined(CONFIG_RTL8881A)) && !defined(CONFIG_RTL8198C)
    entryContent.vid = vid;
#endif

    /* Write into hardware */
    if ( swTable_addEntry(TYPE_VLAN_TABLE, vid, &entryContent) == 0 )
80003b7c:	24040006 	li	a0,6
80003b80:	02402821 	move	a1,s2
80003b84:	0c000e4a 	jal	80003928 <swTable_addEntry>
80003b88:	02203021 	move	a2,s1
80003b8c:	14400006 	bnez	v0,80003ba8 <vlanTable_create+0xe0>
80003b90:	8fbf003c 	lw	ra,60(sp)
        return 0;
    else
        /* There might be something wrong */
        ASSERT_CSP( 0 );
}
80003b94:	8fb20038 	lw	s2,56(sp)
80003b98:	8fb10034 	lw	s1,52(sp)
80003b9c:	8fb00030 	lw	s0,48(sp)
80003ba0:	03e00008 	jr	ra
80003ba4:	27bd0040 	addiu	sp,sp,64
    /* Write into hardware */
    if ( swTable_addEntry(TYPE_VLAN_TABLE, vid, &entryContent) == 0 )
        return 0;
    else
        /* There might be something wrong */
        ASSERT_CSP( 0 );
80003ba8:	3c048001 	lui	a0,0x8001
80003bac:	0c002325 	jal	80008c94 <dprintf>
80003bb0:	2484462c 	addiu	a0,a0,17964
80003bb4:	08000eed 	j	80003bb4 <vlanTable_create+0xec>
80003bb8:	00000000 	nop

80003bbc <swCore_netifCreate>:
        ASSERT_CSP( 0 );
}
#endif

int32 swCore_netifCreate(uint32 idx, rtl_netif_param_t * param)
{
80003bbc:	27bdffc0 	addiu	sp,sp,-64
80003bc0:	afbf003c 	sw	ra,60(sp)
80003bc4:	afb20038 	sw	s2,56(sp)
80003bc8:	afb10034 	sw	s1,52(sp)
80003bcc:	afb00030 	sw	s0,48(sp)
80003bd0:	00809021 	move	s2,a0
    netif_table_t    entryContent;
    uint32	temp,temp2;
    
    ASSERT_CSP(param);
80003bd4:	14a00006 	bnez	a1,80003bf0 <swCore_netifCreate+0x34>
80003bd8:	00a08021 	move	s0,a1
80003bdc:	3c048001 	lui	a0,0x8001
80003be0:	0c002325 	jal	80008c94 <dprintf>
80003be4:	2484462c 	addiu	a0,a0,17964
80003be8:	08000efa 	j	80003be8 <swCore_netifCreate+0x2c>
80003bec:	00000000 	nop
    
    // disable interrupt
    // I don't know the reason but if you want to use "-O" flag, must disalbe interrupt before swTable_readEntry();
    temp = lx4180_ReadStatus();
80003bf0:	0c000e9c 	jal	80003a70 <lx4180_ReadStatus>
80003bf4:	00000000 	nop
    if (0!=temp&0x1) {
80003bf8:	1040000c 	beqz	v0,80003c2c <swCore_netifCreate+0x70>
80003bfc:	00408821 	move	s1,v0
	    temp2 = temp&0xfffffffe;
	    lx4180_WriteStatus(temp2);
80003c00:	2402fffe 	li	v0,-2
80003c04:	0c000ea4 	jal	80003a90 <lx4180_WriteStatus>
80003c08:	02222024 	and	a0,s1,v0
    }

    swTable_readEntry(TYPE_NETINTERFACE_TABLE, idx, &entryContent);
80003c0c:	24040004 	li	a0,4
80003c10:	02402821 	move	a1,s2
80003c14:	0c000e10 	jal	80003840 <swTable_readEntry>
80003c18:	27a60010 	addiu	a2,sp,16

    // restore status register
    if (0!=temp&0x1) {
	    lx4180_WriteStatus(temp);
80003c1c:	0c000ea4 	jal	80003a90 <lx4180_WriteStatus>
80003c20:	02202021 	move	a0,s1
    }
    
    if ( entryContent.valid )
80003c24:	08000f10 	j	80003c40 <swCore_netifCreate+0x84>
80003c28:	8fa20010 	lw	v0,16(sp)
    if (0!=temp&0x1) {
	    temp2 = temp&0xfffffffe;
	    lx4180_WriteStatus(temp2);
    }

    swTable_readEntry(TYPE_NETINTERFACE_TABLE, idx, &entryContent);
80003c2c:	24040004 	li	a0,4
80003c30:	02402821 	move	a1,s2
80003c34:	0c000e10 	jal	80003840 <swTable_readEntry>
80003c38:	27a60010 	addiu	a2,sp,16
    // restore status register
    if (0!=temp&0x1) {
	    lx4180_WriteStatus(temp);
    }
    
    if ( entryContent.valid )
80003c3c:	8fa20010 	lw	v0,16(sp)
80003c40:	30420001 	andi	v0,v0,0x1
80003c44:	14400066 	bnez	v0,80003de0 <swCore_netifCreate+0x224>
80003c48:	24030011 	li	v1,17
    {
       return EEXIST;
    }

    bzero( (void *) &entryContent, sizeof(entryContent) );
80003c4c:	27a40010 	addiu	a0,sp,16
80003c50:	00002821 	move	a1,zero
80003c54:	0c00203d 	jal	800080f4 <memset>
80003c58:	24060020 	li	a2,32
    entryContent.valid = param->valid;
80003c5c:	8e030020 	lw	v1,32(s0)
80003c60:	7c620780 	ext	v0,v1,0x1e,0x1
80003c64:	8fa40010 	lw	a0,16(sp)
80003c68:	7c440004 	ins	a0,v0,0x0,0x1
    entryContent.vid = param->vid;
80003c6c:	9602000a 	lhu	v0,10(s0)
80003c70:	7c446044 	ins	a0,v0,0x1,0xc

    entryContent.mac47_19 = ((param->gMac.mac47_32 << 13) | (param->gMac.mac31_16 >> 3)) & 0x1FFFFFFF;
80003c74:	96050002 	lhu	a1,2(s0)
80003c78:	000530c2 	srl	a2,a1,0x3
80003c7c:	96020000 	lhu	v0,0(s0)
80003c80:	00021340 	sll	v0,v0,0xd
80003c84:	00c23025 	or	a2,a2,v0
80003c88:	8fa20014 	lw	v0,20(sp)
80003c8c:	7cc2e004 	ins	v0,a2,0x0,0x1d
    entryContent.mac18_0 = ((param->gMac.mac31_16 << 16) | param->gMac.mac15_0) & 0x7FFFF;
80003c90:	00052c00 	sll	a1,a1,0x10
80003c94:	96060004 	lhu	a2,4(s0)
80003c98:	00a62825 	or	a1,a1,a2
80003c9c:	3c060007 	lui	a2,0x7
80003ca0:	34c6ffff 	ori	a2,a2,0xffff
80003ca4:	00a62824 	and	a1,a1,a2
80003ca8:	7ca4fb44 	ins	a0,a1,0xd,0x13
80003cac:	afa40010 	sw	a0,16(sp)

#if defined(CONFIG_RTL8198C)
	entryContent.inACLStartH = (param->inAclStart >>1)&0x7f;
80003cb0:	8e05000c 	lw	a1,12(s0)
80003cb4:	7ca63040 	ext	a2,a1,0x1,0x7
80003cb8:	8fa40018 	lw	a0,24(sp)
80003cbc:	7cc43004 	ins	a0,a2,0x0,0x7
	entryContent.inACLStartL = param->inAclStart&0x1;
80003cc0:	7ca2ffc4 	ins	v0,a1,0x1f,0x1
	entryContent.inACLEnd    = param->inAclEnd;
80003cc4:	8e050010 	lw	a1,16(s0)
80003cc8:	7ca471c4 	ins	a0,a1,0x7,0x8
	entryContent.outACLStart = param->outAclStart;
80003ccc:	8e050014 	lw	a1,20(s0)
80003cd0:	7ca4b3c4 	ins	a0,a1,0xf,0x8
	entryContent.outACLEnd   = param->outAclEnd;
80003cd4:	8e050018 	lw	a1,24(s0)
80003cd8:	7ca4f5c4 	ins	a0,a1,0x17,0x8
80003cdc:	afa40018 	sw	a0,24(sp)
	entryContent.enHWRouteV6 = 0;
80003ce0:	7c02f784 	ins	v0,zero,0x1e,0x1
	entryContent.enHWRoute   = param->enableRoute;
80003ce4:	7c6307c0 	ext	v1,v1,0x1f,0x1
80003ce8:	7c62ef44 	ins	v0,v1,0x1d,0x1
80003cec:	afa20014 	sw	v0,20(sp)
	switch(param->macAddrNumber) {
80003cf0:	96020008 	lhu	v0,8(s0)
80003cf4:	2c420009 	sltiu	v0,v0,9
80003cf8:	10400039 	beqz	v0,80003de0 <swCore_netifCreate+0x224>
80003cfc:	24030011 	li	v1,17
80003d00:	96030008 	lhu	v1,8(s0)
80003d04:	00031880 	sll	v1,v1,0x2
80003d08:	3c028001 	lui	v0,0x8001
80003d0c:	244200b0 	addiu	v0,v0,176
80003d10:	00431021 	addu	v0,v0,v1
80003d14:	8c420000 	lw	v0,0(v0)
80003d18:	00400008 	jr	v0
80003d1c:	00000000 	nop
		case 0:
		case 1:
		    entryContent.macMaskL = 1;
80003d20:	8fa20018 	lw	v0,24(sp)
80003d24:	24030001 	li	v1,1
80003d28:	7c62ffc4 	ins	v0,v1,0x1f,0x1
80003d2c:	afa20018 	sw	v0,24(sp)
		    entryContent.macMaskH = 3;
80003d30:	8fa2001c 	lw	v0,28(sp)
80003d34:	24030003 	li	v1,3
80003d38:	7c620804 	ins	v0,v1,0x0,0x2
		break;
80003d3c:	08000f67 	j	80003d9c <swCore_netifCreate+0x1e0>
80003d40:	afa2001c 	sw	v0,28(sp)
		case 2:
		    entryContent.macMaskL = 0;
80003d44:	8fa20018 	lw	v0,24(sp)
80003d48:	7c02ffc4 	ins	v0,zero,0x1f,0x1
80003d4c:	afa20018 	sw	v0,24(sp)
		    entryContent.macMaskH = 3;
80003d50:	8fa2001c 	lw	v0,28(sp)
80003d54:	24030003 	li	v1,3
80003d58:	7c620804 	ins	v0,v1,0x0,0x2
		break;
80003d5c:	08000f67 	j	80003d9c <swCore_netifCreate+0x1e0>
80003d60:	afa2001c 	sw	v0,28(sp)
		case 4:
		    entryContent.macMaskL = 0;
80003d64:	8fa20018 	lw	v0,24(sp)
80003d68:	7c02ffc4 	ins	v0,zero,0x1f,0x1
80003d6c:	afa20018 	sw	v0,24(sp)
		    entryContent.macMaskH = 2;
80003d70:	8fa2001c 	lw	v0,28(sp)
80003d74:	24030002 	li	v1,2
80003d78:	7c620804 	ins	v0,v1,0x0,0x2
		break;
80003d7c:	08000f67 	j	80003d9c <swCore_netifCreate+0x1e0>
80003d80:	afa2001c 	sw	v0,28(sp)
		case 8:
		    entryContent.macMaskL = 0;
80003d84:	8fa20018 	lw	v0,24(sp)
80003d88:	7c02ffc4 	ins	v0,zero,0x1f,0x1
80003d8c:	afa20018 	sw	v0,24(sp)
		    entryContent.macMaskH = 0;
80003d90:	8fa2001c 	lw	v0,28(sp)
80003d94:	7c020804 	ins	v0,zero,0x0,0x2
80003d98:	afa2001c 	sw	v0,28(sp)
			break;
		default:
		    return EEXIST;//Not permitted macNumber value
	}

	entryContent.mtu   = param->mtu;
80003d9c:	8e03001c 	lw	v1,28(s0)
80003da0:	8fa2001c 	lw	v0,28(sp)
80003da4:	7c628084 	ins	v0,v1,0x2,0xf
	entryContent.mtuv6 = param->mtu;
80003da8:	7c62fc44 	ins	v0,v1,0x11,0xf
80003dac:	afa2001c 	sw	v0,28(sp)
    entryContent.mtuH = param->mtu >> 3;
    entryContent.mtuL = param->mtu & 0x7;
#endif

    /* Write into hardware */
    if ( swTable_addEntry(TYPE_NETINTERFACE_TABLE, idx, &entryContent) == 0 )
80003db0:	24040004 	li	a0,4
80003db4:	02402821 	move	a1,s2
80003db8:	0c000e4a 	jal	80003928 <swTable_addEntry>
80003dbc:	27a60010 	addiu	a2,sp,16
80003dc0:	10400007 	beqz	v0,80003de0 <swCore_netifCreate+0x224>
80003dc4:	00001821 	move	v1,zero
        return 0;
    else
        /* There might be something wrong */
        ASSERT_CSP( 0 );
80003dc8:	3c048001 	lui	a0,0x8001
80003dcc:	0c002325 	jal	80008c94 <dprintf>
80003dd0:	2484462c 	addiu	a0,a0,17964
80003dd4:	08000f75 	j	80003dd4 <swCore_netifCreate+0x218>
80003dd8:	00000000 	nop
80003ddc:	24030011 	li	v1,17
}
80003de0:	00601021 	move	v0,v1
80003de4:	8fbf003c 	lw	ra,60(sp)
80003de8:	8fb20038 	lw	s2,56(sp)
80003dec:	8fb10034 	lw	s1,52(sp)
80003df0:	8fb00030 	lw	s0,48(sp)
80003df4:	03e00008 	jr	ra
80003df8:	27bd0040 	addiu	sp,sp,64
80003dfc:	00000000 	nop

80003e00 <check_ready_nand>:
void 
check_ready_nand (void ) 
{
  while (1)
    {
      if ((rtk_readl (NACR) & 0x80000000) == 0x80000000)
80003e00:	3c04b801 	lui	a0,0xb801
80003e04:	3482a004 	ori	v0,a0,0xa004
80003e08:	8c430000 	lw	v1,0(v0)
80003e0c:	0461fffe 	bgez	v1,80003e08 <check_ready_nand+0x8>
80003e10:	00000000 	nop
        break;
    }
}
80003e14:	03e00008 	jr	ra
80003e18:	00000000 	nop

80003e1c <rtk_nand_read_id>:

int 
rtk_nand_read_id () 
{
80003e1c:	27bdffe0 	addiu	sp,sp,-32
80003e20:	afbf001c 	sw	ra,28(sp)
80003e24:	afb20018 	sw	s2,24(sp)
80003e28:	afb10014 	sw	s1,20(sp)
80003e2c:	afb00010 	sw	s0,16(sp)
  int i;
  int id_chain;
  
    //unsigned char id[5];
    check_ready_nand ();
80003e30:	0c000f80 	jal	80003e00 <check_ready_nand>
80003e34:	3c10b801 	lui	s0,0xb801
  
    //rtk_writel( (rtk_readl(NACR) |ECC_enable|RBO|WBO), NACR);
    rtk_writel ((rtk_readl (NACR) | ECC_enable), NACR);
80003e38:	3603a004 	ori	v1,s0,0xa004
80003e3c:	8c640000 	lw	a0,0(v1)
80003e40:	3c024000 	lui	v0,0x4000
80003e44:	00822025 	or	a0,a0,v0
80003e48:	ac640000 	sw	a0,0(v1)
  rtk_writel (0x0, NACMR);
80003e4c:	3611a008 	ori	s1,s0,0xa008
80003e50:	ae200000 	sw	zero,0(s1)
  rtk_writel ((CECS0 | CMD_READ_ID), NACMR);   //read ID command
80003e54:	34420090 	ori	v0,v0,0x90
80003e58:	ae220000 	sw	v0,0(s1)
  check_ready_nand ();
80003e5c:	0c000f80 	jal	80003e00 <check_ready_nand>
80003e60:	3612a00c 	ori	s2,s0,0xa00c
  rtk_writel (0x0, NAADR);
80003e64:	ae400000 	sw	zero,0(s2)
  rtk_writel ((0x0 | AD2EN | AD1EN | AD0EN), NAADR);   //dummy address cycle
80003e68:	3c020700 	lui	v0,0x700
80003e6c:	ae420000 	sw	v0,0(s2)
  check_ready_nand ();
80003e70:	0c000f80 	jal	80003e00 <check_ready_nand>
80003e74:	3610a014 	ori	s0,s0,0xa014
  id_chain = rtk_readl (NADR);
80003e78:	8e020000 	lw	v0,0(s0)
  id[2] = (id_chain >> 16) & 0xff;
  id[3] = (id_chain >> 24) & 0xff;
  id[4] = id_chain & 0xff;
  
#else   /*  */
    rtk_writel (0x0, NACMR);
80003e7c:	ae200000 	sw	zero,0(s1)
  rtk_writel (0x0, NAADR);
80003e80:	ae400000 	sw	zero,0(s2)
  return id_chain;
  
#endif  /*  */
}
80003e84:	8fbf001c 	lw	ra,28(sp)
80003e88:	8fb20018 	lw	s2,24(sp)
80003e8c:	8fb10014 	lw	s1,20(sp)
80003e90:	8fb00010 	lw	s0,16(sp)
80003e94:	03e00008 	jr	ra
80003e98:	27bd0020 	addiu	sp,sp,32

80003e9c <shift_value>:
unsigned int shift_value(unsigned int x)
{
	int r = 1;

        if (!x)
80003e9c:	10800018 	beqz	a0,80003f00 <shift_value+0x64>
80003ea0:	00001021 	move	v0,zero
                return 0;
        if (!(x & 0xffff)) {
80003ea4:	3083ffff 	andi	v1,a0,0xffff
80003ea8:	14600003 	bnez	v1,80003eb8 <shift_value+0x1c>
80003eac:	24020001 	li	v0,1
                x >>= 16;
80003eb0:	00042402 	srl	a0,a0,0x10
80003eb4:	24020011 	li	v0,17
                r += 16;
        }
        if (!(x & 0xff)) {
80003eb8:	308300ff 	andi	v1,a0,0xff
80003ebc:	14600004 	bnez	v1,80003ed0 <shift_value+0x34>
80003ec0:	3083000f 	andi	v1,a0,0xf
                x >>= 8;
80003ec4:	00042202 	srl	a0,a0,0x8
                r += 8;
80003ec8:	24420008 	addiu	v0,v0,8
        }
        if (!(x & 0xf)) {
80003ecc:	3083000f 	andi	v1,a0,0xf
80003ed0:	14600004 	bnez	v1,80003ee4 <shift_value+0x48>
80003ed4:	30830003 	andi	v1,a0,0x3
                x >>= 4;
80003ed8:	00042102 	srl	a0,a0,0x4
                r += 4;
80003edc:	24420004 	addiu	v0,v0,4
        }
        if (!(x & 3)) {
80003ee0:	30830003 	andi	v1,a0,0x3
80003ee4:	14600003 	bnez	v1,80003ef4 <shift_value+0x58>
80003ee8:	00000000 	nop
                x >>= 2;
80003eec:	00042082 	srl	a0,a0,0x2
                r += 2;
80003ef0:	24420002 	addiu	v0,v0,2
        }
        if (!(x & 1)) {
80003ef4:	30840001 	andi	a0,a0,0x1
                x >>= 1;
                r += 1;
80003ef8:	2c840001 	sltiu	a0,a0,1
        }
        return r;
80003efc:	00441021 	addu	v0,v0,a0
}
80003f00:	03e00008 	jr	ra
80003f04:	00000000 	nop

80003f08 <rtk_nand_strapin_setting>:

  /*Enable NAND Flash IP clock */
#define REG32(reg)  (*(volatile unsigned int *)(reg))
  //REG32(clk_manage_REG) |= 1 << 28;

REG32(clk_manage_REG) |= ((1 << 28)| (3<<12)| (7<<18));
80003f08:	3c02b800 	lui	v0,0xb800
80003f0c:	34430010 	ori	v1,v0,0x10
80003f10:	8c650000 	lw	a1,0(v1)
80003f14:	3c04101c 	lui	a0,0x101c
80003f18:	34843000 	ori	a0,a0,0x3000
80003f1c:	00a42025 	or	a0,a1,a0
80003f20:	ac640000 	sw	a0,0(v1)

#define PINMUX_SEL_1 0xb8000100
#define PINMUX_SEL_2 0xb8000104
#define PINMUX_SEL_3 0xb8000108

  REG32 (PINMUX_SEL_1) |=((1<<26)  | (1<<24)  );  //set MFCS1# to NAND CS0#
80003f24:	34430100 	ori	v1,v0,0x100
80003f28:	8c650000 	lw	a1,0(v1)
80003f2c:	3c040500 	lui	a0,0x500
80003f30:	00a42025 	or	a0,a1,a0
80003f34:	ac640000 	sw	a0,0(v1)
  //REG32 (PINMUX_SEL_2) |=((1<<23) | (1<<25) );  //set UART0_CTS # to NAND MD[7] ,  UART0_RTS to NF_CE1#
  REG32 (PINMUX_SEL_2) |=((1<<23)  );  //set UART0_CTS # to NAND MD[7]
80003f38:	34430104 	ori	v1,v0,0x104
80003f3c:	8c650000 	lw	a1,0(v1)
80003f40:	3c040080 	lui	a0,0x80
80003f44:	00a42025 	or	a0,a1,a0
80003f48:	ac640000 	sw	a0,0(v1)
  REG32 (PINMUX_SEL_3) |=((1<<15) | (1<<18) | (1<<21) | (1<<24) | (1<<27)  | (1<<30) );  //set Port0 RGMII I/F to NAND
80003f4c:	34430108 	ori	v1,v0,0x108
80003f50:	8c650000 	lw	a1,0(v1)
80003f54:	3c044924 	lui	a0,0x4924
80003f58:	34848000 	ori	a0,a0,0x8000
80003f5c:	00a42025 	or	a0,a1,a0
80003f60:	ac640000 	sw	a0,0(v1)
#define AC_4cycles  (1<<26)
#define AC_3cycles (0<<26)

#define ECC_12T (1<<31)

REG32 (HW_Strap_REG) &= ~(0xf <<26);
80003f64:	34420008 	ori	v0,v0,0x8
80003f68:	8c440000 	lw	a0,0(v0)
80003f6c:	3c03c3ff 	lui	v1,0xc3ff
80003f70:	3463ffff 	ori	v1,v1,0xffff
80003f74:	00831824 	and	v1,a0,v1
80003f78:	ac430000 	sw	v1,0(v0)
#ifdef CONFIG_NAND_Flash_Large_Page_256MBto1GB_5cycles 
REG32 (HW_Strap_REG) |=( RC_Pages2KB |AC_5cycles ); 
#endif

#ifdef CONFIG_NAND_Flash_Large_Page_128MB_4cycles 
REG32 (HW_Strap_REG) |=( RC_Pages2KB |AC_4cycles ); 
80003f7c:	8c440000 	lw	a0,0(v0)
80003f80:	3c031400 	lui	v1,0x1400
80003f84:	00831825 	or	v1,a0,v1
80003f88:	ac430000 	sw	v1,0(v0)
 // printf("\nTurn on Bus TimeOut Arbiter\n");

  //REG32(LX_control_REG) |= (1 << 15);
  //dprintf("\nPINMUX_REG_8196D_97D(%x)=0x%x \n",PINMUX_REG_8196D_97D,REG32(PINMUX_REG_8196D_97D));
#endif /*  */
}
80003f8c:	03e00008 	jr	ra
80003f90:	00000000 	nop

80003f94 <isBadBlock>:
                  initial_bad_block_table[bbt_loop],
                  initial_bad_block_table[bbt_loop] * ppb * (page_size +
                                                              oob_size));
  prom_printf ("\n###################################\n");
  free (nand_verify_buf);
}
80003f94:	03e00008 	jr	ra
80003f98:	2402ffff 	li	v0,-1

80003f9c <rtk_PIO_write_word>:
#endif   


//debug cl
int rtk_PIO_write_word(unsigned long flash_address, unsigned char *image_addr, unsigned int image_size)
{
80003f9c:	27bdffb8 	addiu	sp,sp,-72
80003fa0:	afbf0044 	sw	ra,68(sp)
80003fa4:	afb60040 	sw	s6,64(sp)
80003fa8:	afb5003c 	sw	s5,60(sp)
80003fac:	afb40038 	sw	s4,56(sp)
80003fb0:	afb30034 	sw	s3,52(sp)
80003fb4:	afb20030 	sw	s2,48(sp)
80003fb8:	afb1002c 	sw	s1,44(sp)
80003fbc:	afb00028 	sw	s0,40(sp)
80003fc0:	00808021 	move	s0,a0
80003fc4:	00a09021 	move	s2,a1
  //debug cl
  //dprintf("[%s]:%d for boot safe debug return directly\n",__func__,__LINE__);
  //return FAIL;
  flush_cache();
80003fc8:	0c001eae 	jal	80007ab8 <flush_cache>
80003fcc:	00c0b021 	move	s6,a2
 

  if ((flash_address % (page_size + oob_size)) != 0) {
80003fd0:	3c028001 	lui	v0,0x8001
80003fd4:	8c4575e4 	lw	a1,30180(v0)
80003fd8:	3c028001 	lui	v0,0x8001
80003fdc:	8c4675e8 	lw	a2,30184(v0)
80003fe0:	00c5a821 	addu	s5,a2,a1
80003fe4:	0215001b 	divu	zero,s0,s5
80003fe8:	02a001f4 	teq	s5,zero,0x7
80003fec:	00001010 	mfhi	v0
80003ff0:	10400006 	beqz	v0,8000400c <rtk_PIO_write_word+0x70>
80003ff4:	3c11b801 	lui	s1,0xb801
    dprintf("\n\rflash_address must be page(0x%x+0x%x Bytes) aligned!\n",
80003ff8:	3c048001 	lui	a0,0x8001
80003ffc:	0c002325 	jal	80008c94 <dprintf>
80004000:	24844654 	addiu	a0,a0,18004
            page_size, oob_size);
    return;
80004004:	0800103f 	j	800040fc <rtk_PIO_write_word+0x160>
80004008:	8fbf0044 	lw	ra,68(sp)

  //pre-allocat
  //int* ptr_PIO_WRITE_NADR= malloc (0x4);
  int *ptr_PIO_WRITE_NADR = image_addr;

  int page_PIO_num = flash_address / (page_size + oob_size);
8000400c:	0215001b 	divu	zero,s0,s5
80004010:	02a001f4 	teq	s5,zero,0x7
80004014:	0000a812 	mflo	s5
  int i, j;


  /*PIO write step-0. */
#if 1
  rtk_writel(0x0, NACMR);       //Clear NACMR, set CECS0=0, CE_CMD = 0x00
80004018:	3630a008 	ori	s0,s1,0xa008
8000401c:	ae000000 	sw	zero,0(s0)
  rtk_writel(0x0, NAADR);
80004020:	3634a00c 	ori	s4,s1,0xa00c
80004024:	ae800000 	sw	zero,0(s4)
  rtk_writel((CECS0 | CMD_RESET), NACMR);       //Reset for break PIO successively read 4Byte data from NADR      
80004028:	3c134000 	lui	s3,0x4000
8000402c:	366200ff 	ori	v0,s3,0xff
80004030:	ae020000 	sw	v0,0(s0)
#endif



  /*PIO write step-1. */
  check_ready_nand();
80004034:	0c000f80 	jal	80003e00 <check_ready_nand>
80004038:	3631a004 	ori	s1,s1,0xa004

  //rtk_writel ((rtk_readl (NACR) & ~(ECC_enable)), NACR); //disable ECC function
  rtk_writel((rtk_readl(NACR) | (ECC_enable)), NACR);   //enable ECC function
8000403c:	8e220000 	lw	v0,0(s1)
80004040:	00531025 	or	v0,v0,s3
80004044:	ae220000 	sw	v0,0(s1)


  check_ready_nand();
80004048:	0c000f80 	jal	80003e00 <check_ready_nand>
8000404c:	00000000 	nop

  /*PIO write step-2. */
  rtk_writel(0x0, NACMR);
80004050:	ae000000 	sw	zero,0(s0)
  rtk_writel((CECS0 | CMD_PG_WRITE_C1), NACMR); //JSW:0x80 is sequential data input command for 1st cycle.
80004054:	36730080 	ori	s3,s3,0x80
80004058:	ae130000 	sw	s3,0(s0)
  rtk_writel(NAADR_REG_value, NAADR);
  check_ready_nand();
  //dprintf (" c1-NAADR_REG_value=0x%x\n", NAADR_REG_value);
#endif
#ifdef CONFIG_NAND_Flash_Large_Page_128MB_4cycles
  addr_cycle[0] = addr_cycle[1] = 0;    //Basic PIO read is "Page"
8000405c:	afa00014 	sw	zero,20(sp)
80004060:	afa00010 	sw	zero,16(sp)

  for (page_shift = 0; page_shift < 2; page_shift++) {
    addr_cycle[page_shift + 2] = (page_PIO_num >> (8 * page_shift)) & 0xff;
80004064:	32a200ff 	andi	v0,s5,0xff
80004068:	afa20018 	sw	v0,24(sp)
8000406c:	7eb03a00 	ext	s0,s5,0x8,0x8
80004070:	afb0001c 	sw	s0,28(sp)
  }

  NAADR_REG_value =
      enNextAD | AD2EN | AD1EN | AD0EN | (addr_cycle[2] << CE_ADDR2);
  rtk_writel(NAADR_REG_value, NAADR);
80004074:	00021400 	sll	v0,v0,0x10
80004078:	3c030f00 	lui	v1,0xf00
8000407c:	00431025 	or	v0,v0,v1
80004080:	ae820000 	sw	v0,0(s4)
  check_ready_nand();
80004084:	0c000f80 	jal	80003e00 <check_ready_nand>
80004088:	00000000 	nop
  // dprintf ("c0-NAADR_REG_value=0x%x\n", NAADR_REG_value);

  NAADR_REG_value = (~enNextAD) & AD0EN | (addr_cycle[3] << CE_ADDR0);
  rtk_writel(NAADR_REG_value, NAADR);
8000408c:	3c020100 	lui	v0,0x100
80004090:	02028025 	or	s0,s0,v0
80004094:	ae900000 	sw	s0,0(s4)
  check_ready_nand();
80004098:	0c000f80 	jal	80003e00 <check_ready_nand>
8000409c:	00168882 	srl	s1,s6,0x2


  /*PIO write step-4. */
#if 1
  /*before setting CES0 to 1 (step.6) , user can successively read NADR for the continue next 4 bytes */
  for (i = 0; i < ((image_size) / 4); i++) {
800040a0:	1220000d 	beqz	s1,800040d8 <rtk_PIO_write_word+0x13c>
800040a4:	00001021 	move	v0,zero
800040a8:	00008021 	move	s0,zero
      dprintf("\nNADTSAR(0x%x): 0x%X\n ", NADTSAR, rtk_readl(NADTSAR));
    }
#endif //show NECN message

#endif //end of show NECN message
    rtk_readl(NADR) = *(ptr_PIO_WRITE_NADR + i);
800040ac:	3c13b801 	lui	s3,0xb801
800040b0:	3673a014 	ori	s3,s3,0xa014
800040b4:	00021080 	sll	v0,v0,0x2
800040b8:	02421021 	addu	v0,s2,v0
800040bc:	8c420000 	lw	v0,0(v0)
800040c0:	ae620000 	sw	v0,0(s3)

    check_ready_nand();
800040c4:	0c000f80 	jal	80003e00 <check_ready_nand>
800040c8:	26100001 	addiu	s0,s0,1


  /*PIO write step-4. */
#if 1
  /*before setting CES0 to 1 (step.6) , user can successively read NADR for the continue next 4 bytes */
  for (i = 0; i < ((image_size) / 4); i++) {
800040cc:	0211182b 	sltu	v1,s0,s1
800040d0:	1460fff8 	bnez	v1,800040b4 <rtk_PIO_write_word+0x118>
800040d4:	02001021 	move	v0,s0

  }
#endif

  /*PIO write step-5. */
  rtk_writel((CECS0 | CMD_PG_WRITE_C2), NACMR); //JSW:0x10 is page program command for 2 cycle.
800040d8:	3c10b801 	lui	s0,0xb801
800040dc:	3610a008 	ori	s0,s0,0xa008
800040e0:	3c024000 	lui	v0,0x4000
800040e4:	34420010 	ori	v0,v0,0x10
800040e8:	ae020000 	sw	v0,0(s0)
  check_ready_nand();
800040ec:	0c000f80 	jal	80003e00 <check_ready_nand>
800040f0:	00000000 	nop
  //dprintf("ptr_PIO_WRITE_NADR=0x%x\n", ptr_PIO_WRITE_NADR);

  // free(ptr_PIO_WRITE_NADR);

  /*PIO write step-6. */
  rtk_writel(0x0, NACMR);       //Not select NAND CS0
800040f4:	ae000000 	sw	zero,0(s0)


}
800040f8:	8fbf0044 	lw	ra,68(sp)
800040fc:	8fb60040 	lw	s6,64(sp)
80004100:	8fb5003c 	lw	s5,60(sp)
80004104:	8fb40038 	lw	s4,56(sp)
80004108:	8fb30034 	lw	s3,52(sp)
8000410c:	8fb20030 	lw	s2,48(sp)
80004110:	8fb1002c 	lw	s1,44(sp)
80004114:	8fb00028 	lw	s0,40(sp)
80004118:	03e00008 	jr	ra
8000411c:	27bd0048 	addiu	sp,sp,72

80004120 <rtk_erase_block_a>:




int  rtk_erase_block_a (int page)
{
80004120:	27bdffc0 	addiu	sp,sp,-64
80004124:	afbf003c 	sw	ra,60(sp)
80004128:	afb40038 	sw	s4,56(sp)
8000412c:	afb30034 	sw	s3,52(sp)
80004130:	afb20030 	sw	s2,48(sp)
80004134:	afb1002c 	sw	s1,44(sp)
80004138:	afb00028 	sw	s0,40(sp)
    //debug cl for safe not write in 0,1 block that is for boot.
    //printf("[%s:] %d \n",__func__,__LINE__);
	if(page < 128||page > chip_size/page_size - 1)
8000413c:	28820080 	slti	v0,a0,128
80004140:	1440000c 	bnez	v0,80004174 <rtk_erase_block_a+0x54>
80004144:	00808021 	move	s0,a0
80004148:	3c028002 	lui	v0,0x8002
8000414c:	8c433d80 	lw	v1,15744(v0)
80004150:	3c028001 	lui	v0,0x8001
80004154:	8c4275e4 	lw	v0,30180(v0)
80004158:	0062001b 	divu	zero,v1,v0
8000415c:	004001f4 	teq	v0,zero,0x7
80004160:	00001812 	mflo	v1
80004164:	2462ffff 	addiu	v0,v1,-1
80004168:	0044102b 	sltu	v0,v0,a0
8000416c:	10400009 	beqz	v0,80004194 <rtk_erase_block_a+0x74>
80004170:	00809021 	move	s2,a0
	{
		dprintf("[%s]:%d panic:fatal error *************,try to write in 0,1 block for boot,protect for debug\n",__func__,__LINE__);
80004174:	3c048001 	lui	a0,0x8001
80004178:	2484468c 	addiu	a0,a0,18060
8000417c:	3c058001 	lui	a1,0x8001
80004180:	24a503c4 	addiu	a1,a1,964
80004184:	0c002325 	jal	80008c94 <dprintf>
80004188:	240609f1 	li	a2,2545
		return FAIL;
8000418c:	080010b0 	j	800042c0 <rtk_erase_block_a+0x1a0>
80004190:	2402ffff 	li	v0,-1
	}
	int addr_cycle[5], page_shift;

	//printf("!!!!! rtk_erase_block !!!!!, block = %d\n\r",page/ppb);

	if ( page & (ppb-1) ){
80004194:	3c028001 	lui	v0,0x8001
80004198:	8c4275ec 	lw	v0,30188(v0)
8000419c:	2442ffff 	addiu	v0,v0,-1
800041a0:	00821024 	and	v0,a0,v0
800041a4:	10400007 	beqz	v0,800041c4 <rtk_erase_block_a+0xa4>
800041a8:	3c048001 	lui	a0,0x8001
		printf("page %d is not block alignment !!\n", page);
800041ac:	3c048001 	lui	a0,0x8001
800041b0:	248446ec 	addiu	a0,a0,18156
800041b4:	0c002325 	jal	80008c94 <dprintf>
800041b8:	02002821 	move	a1,s0
		return 0;
800041bc:	080010b0 	j	800042c0 <rtk_erase_block_a+0x1a0>
800041c0:	00001021 	move	v0,zero
	}
	printf(".");
800041c4:	0c002325 	jal	80008c94 <dprintf>
800041c8:	24846e08 	addiu	a0,a0,28168
	check_ready_nand();
800041cc:	0c000f80 	jal	80003e00 <check_ready_nand>
800041d0:	00000000 	nop

	rtk_writel( (rtk_readl(NACR) |ECC_enable|RBO), NACR);
800041d4:	3c02b801 	lui	v0,0xb801
800041d8:	3443a004 	ori	v1,v0,0xa004
800041dc:	8c650000 	lw	a1,0(v1)
800041e0:	3c046000 	lui	a0,0x6000
800041e4:	00a42025 	or	a0,a1,a0
800041e8:	ac640000 	sw	a0,0(v1)
	rtk_writel((NWER|NRER|NDRS|NDWS), NASR);
800041ec:	3443a028 	ori	v1,v0,0xa028
800041f0:	2404000f 	li	a0,15
800041f4:	ac640000 	sw	a0,0(v1)
	rtk_writel(0x0, NACMR);
800041f8:	3442a008 	ori	v0,v0,0xa008
800041fc:	ac400000 	sw	zero,0(v0)

	rtk_writel((CECS0|CMD_BLK_ERASE_C1),NACMR);
80004200:	3c034000 	lui	v1,0x4000
80004204:	34630060 	ori	v1,v1,0x60
80004208:	ac430000 	sw	v1,0(v0)
	check_ready_nand();
8000420c:	0c000f80 	jal	80003e00 <check_ready_nand>
80004210:	00000000 	nop


	if(!NAND_ADDR_CYCLE){
		addr_cycle[0] = addr_cycle[1] =0;
80004214:	afa00014 	sw	zero,20(sp)
80004218:	afa00010 	sw	zero,16(sp)
8000421c:	27a30018 	addiu	v1,sp,24
80004220:	00001021 	move	v0,zero
		for(page_shift=0; page_shift<3; page_shift++){
80004224:	24050018 	li	a1,24
			addr_cycle[page_shift+2] = (page>>(8*page_shift)) & 0xff;
80004228:	00502007 	srav	a0,s0,v0
8000422c:	308400ff 	andi	a0,a0,0xff
80004230:	ac640000 	sw	a0,0(v1)
80004234:	24420008 	addiu	v0,v0,8
	check_ready_nand();


	if(!NAND_ADDR_CYCLE){
		addr_cycle[0] = addr_cycle[1] =0;
		for(page_shift=0; page_shift<3; page_shift++){
80004238:	1445fffb 	bne	v0,a1,80004228 <rtk_erase_block_a+0x108>
8000423c:	24630004 	addiu	v1,v1,4
			addr_cycle[page_shift+2] = (page>>(8*page_shift)) & 0xff;
		}

		rtk_writel( ((~enNextAD) & AD2EN|AD1EN|AD0EN|
80004240:	3c020700 	lui	v0,0x700
80004244:	8fa30018 	lw	v1,24(sp)
80004248:	00621825 	or	v1,v1,v0
8000424c:	8fa2001c 	lw	v0,28(sp)
80004250:	00021200 	sll	v0,v0,0x8
80004254:	00621825 	or	v1,v1,v0
80004258:	8fa20020 	lw	v0,32(sp)
8000425c:	00021400 	sll	v0,v0,0x10
80004260:	00621825 	or	v1,v1,v0
80004264:	3c11b801 	lui	s1,0xb801
80004268:	3622a00c 	ori	v0,s1,0xa00c
8000426c:	ac430000 	sw	v1,0(v0)
				(addr_cycle[1]<<CE_ADDR0) |(addr_cycle[2]<<CE_ADDR1)|(addr_cycle[3]<<CE_ADDR2)),NAADR);
	}



	rtk_writel((CECS0|CMD_BLK_ERASE_C2),NACMR);
80004270:	3634a008 	ori	s4,s1,0xa008
80004274:	3c134000 	lui	s3,0x4000
80004278:	366200d0 	ori	v0,s3,0xd0
8000427c:	ae820000 	sw	v0,0(s4)
	check_ready_nand();
80004280:	0c000f80 	jal	80003e00 <check_ready_nand>
80004284:	36730070 	ori	s3,s3,0x70

	rtk_writel((CECS0|CMD_BLK_ERASE_C3),NACMR);
80004288:	ae930000 	sw	s3,0(s4)
	check_ready_nand();
8000428c:	0c000f80 	jal	80003e00 <check_ready_nand>
80004290:	3631a014 	ori	s1,s1,0xa014

	if(rtk_readl(NADR) & 0x01){
80004294:	8e220000 	lw	v0,0(s1)
80004298:	30420001 	andi	v0,v0,0x1
8000429c:	10400008 	beqz	v0,800042c0 <rtk_erase_block_a+0x1a0>
800042a0:	00001021 	move	v0,zero
		if( page>=0 && page < ppb)
800042a4:	06000005 	bltz	s0,800042bc <rtk_erase_block_a+0x19c>
800042a8:	3c028001 	lui	v0,0x8001
800042ac:	8c4275ec 	lw	v0,30188(v0)
800042b0:	0242902b 	sltu	s2,s2,v0
800042b4:	16400002 	bnez	s2,800042c0 <rtk_erase_block_a+0x1a0>
800042b8:	00001021 	move	v0,zero
800042bc:	2402ffff 	li	v0,-1
			return FAIL;
	}
		
	return SUCCESS;

}
800042c0:	8fbf003c 	lw	ra,60(sp)
800042c4:	8fb40038 	lw	s4,56(sp)
800042c8:	8fb30034 	lw	s3,52(sp)
800042cc:	8fb20030 	lw	s2,48(sp)
800042d0:	8fb1002c 	lw	s1,44(sp)
800042d4:	8fb00028 	lw	s0,40(sp)
800042d8:	03e00008 	jr	ra
800042dc:	27bd0040 	addiu	sp,sp,64

800042e0 <check_BBT>:
}
#endif

#ifdef CONFIG_RTK_NAND_BBT
int check_BBT(unsigned int blk)
{	
800042e0:	27bdffe8 	addiu	sp,sp,-24
800042e4:	afbf0014 	sw	ra,20(sp)
800042e8:	afb00010 	sw	s0,16(sp)
800042ec:	00808021 	move	s0,a0
	int i;	
	printf("[%s] blk:%d\n", __FUNCTION__, blk);	
800042f0:	3c048001 	lui	a0,0x8001
800042f4:	24844710 	addiu	a0,a0,18192
800042f8:	3c058001 	lui	a1,0x8001
800042fc:	24a503d8 	addiu	a1,a1,984
80004300:	0c002325 	jal	80008c94 <dprintf>
80004304:	02003021 	move	a2,s0

	for ( i=0; i<RBA; i++)	
80004308:	3c028002 	lui	v0,0x8002
8000430c:	8c452e74 	lw	a1,11892(v0)
80004310:	10a00015 	beqz	a1,80004368 <check_BBT+0x88>
80004314:	3c028002 	lui	v0,0x8002
	{		
	    if ( bbt[i].bad_block == blk )
80004318:	8c432e78 	lw	v1,11896(v0)
8000431c:	94620002 	lhu	v0,2(v1)
80004320:	1450000c 	bne	v0,s0,80004354 <check_BBT+0x74>
80004324:	3c048001 	lui	a0,0x8001
        {			
            printf("blk 0x%x already exist\n",blk);			
80004328:	080010d1 	j	80004344 <check_BBT+0x64>
8000432c:	24844720 	addiu	a0,a0,18208
	int i;	
	printf("[%s] blk:%d\n", __FUNCTION__, blk);	

	for ( i=0; i<RBA; i++)	
	{		
	    if ( bbt[i].bad_block == blk )
80004330:	9464000a 	lhu	a0,10(v1)
80004334:	14900008 	bne	a0,s0,80004358 <check_BBT+0x78>
80004338:	24630008 	addiu	v1,v1,8
        {			
            printf("blk 0x%x already exist\n",blk);			
8000433c:	3c048001 	lui	a0,0x8001
80004340:	24844720 	addiu	a0,a0,18208
80004344:	0c002325 	jal	80008c94 <dprintf>
80004348:	02002821 	move	a1,s0
		    return -1;			
8000434c:	080010db 	j	8000436c <check_BBT+0x8c>
80004350:	2402ffff 	li	v0,-1
80004354:	00001021 	move	v0,zero
int check_BBT(unsigned int blk)
{	
	int i;	
	printf("[%s] blk:%d\n", __FUNCTION__, blk);	

	for ( i=0; i<RBA; i++)	
80004358:	24420001 	addiu	v0,v0,1
8000435c:	0045202b 	sltu	a0,v0,a1
80004360:	1480fff3 	bnez	a0,80004330 <check_BBT+0x50>
80004364:	00000000 	nop
80004368:	00001021 	move	v0,zero
            printf("blk 0x%x already exist\n",blk);			
		    return -1;			
	    }	
	}	
	return 0;
}
8000436c:	8fbf0014 	lw	ra,20(sp)
80004370:	8fb00010 	lw	s0,16(sp)
80004374:	03e00008 	jr	ra
80004378:	27bd0018 	addiu	sp,sp,24

8000437c <rtk_PIO_read_basic>:

	return 0;

}
int rtk_PIO_read_basic(int page, int offset)
{
8000437c:	27bdffd0 	addiu	sp,sp,-48
80004380:	afbf002c 	sw	ra,44(sp)
80004384:	afb30028 	sw	s3,40(sp)
80004388:	afb20024 	sw	s2,36(sp)
8000438c:	afb10020 	sw	s1,32(sp)
80004390:	afb0001c 	sw	s0,28(sp)
80004394:	00809021 	move	s2,a0
80004398:	00a09821 	move	s3,a1
	int rlen, real_page;
	unsigned int cmd;

	real_page = page;

	rlen = page_size + oob_size;
8000439c:	3c028001 	lui	v0,0x8001
800043a0:	8c5175e8 	lw	s1,30184(v0)
800043a4:	3c028001 	lui	v0,0x8001
800043a8:	8c4275e4 	lw	v0,30180(v0)
800043ac:	02228821 	addu	s1,s1,v0
	cmd = CMD_PG_READ_A;

	rtk_writel(0xc00fffff, NACR);
800043b0:	3c10b801 	lui	s0,0xb801
800043b4:	3602a004 	ori	v0,s0,0xa004
800043b8:	3c03c00f 	lui	v1,0xc00f
800043bc:	3463ffff 	ori	v1,v1,0xffff
800043c0:	ac430000 	sw	v1,0(v0)

	/* Command cycle 1*/
	rtk_writel((CECS0|cmd), NACMR);
800043c4:	3602a008 	ori	v0,s0,0xa008
800043c8:	3c034000 	lui	v1,0x4000
800043cc:	ac430000 	sw	v1,0(v0)

	check_ready_nand();//check_ready();
800043d0:	0c000f80 	jal	80003e00 <check_ready_nand>
800043d4:	3610a00c 	ori	s0,s0,0xa00c

	flash_addr1 |= ((real_page & 0xffffff) << 8) ;

	/* Give address */
	rtk_writel( (AD2EN|AD1EN|AD0EN|flash_addr1), NAADR);
800043d8:	00121a00 	sll	v1,s2,0x8
800043dc:	3c020700 	lui	v0,0x700
800043e0:	00621025 	or	v0,v1,v0
800043e4:	ae020000 	sw	v0,0(s0)

	check_ready_nand();//check_ready();
800043e8:	0c000f80 	jal	80003e00 <check_ready_nand>
800043ec:	00000000 	nop

	for(i=0; i<(rlen/4); i++){
800043f0:	26220003 	addiu	v0,s1,3
800043f4:	2a230000 	slti	v1,s1,0
800043f8:	0223100a 	movz	v0,s1,v1
800043fc:	00021883 	sra	v1,v0,0x2
80004400:	18600022 	blez	v1,8000448c <rtk_PIO_read_basic+0x110>
80004404:	3c02b801 	lui	v0,0xb801
		data_out = rtk_readl(NADR);
80004408:	3442a014 	ori	v0,v0,0xa014
8000440c:	8c460000 	lw	a2,0(v0)
		//printf("[%3d] 0x%08X \n",i, data_out);
		if(data_out!=0xffffffff){
80004410:	2402ffff 	li	v0,-1
80004414:	10c20016 	beq	a2,v0,80004470 <rtk_PIO_read_basic+0xf4>
80004418:	00008021 	move	s0,zero
			printf("[%3d] 0x%08X \n",i, data_out);
8000441c:	0800110e 	j	80004438 <rtk_PIO_read_basic+0xbc>
80004420:	3c048001 	lui	a0,0x8001
	rtk_writel( (AD2EN|AD1EN|AD0EN|flash_addr1), NAADR);

	check_ready_nand();//check_ready();

	for(i=0; i<(rlen/4); i++){
		data_out = rtk_readl(NADR);
80004424:	8ca60000 	lw	a2,0(a1)
		//printf("[%3d] 0x%08X \n",i, data_out);
		if(data_out!=0xffffffff){
80004428:	10c40015 	beq	a2,a0,80004480 <rtk_PIO_read_basic+0x104>
8000442c:	26100001 	addiu	s0,s0,1
80004430:	2610ffff 	addiu	s0,s0,-1
			printf("[%3d] 0x%08X \n",i, data_out);
80004434:	3c048001 	lui	a0,0x8001
80004438:	24844738 	addiu	a0,a0,18232
8000443c:	0c002325 	jal	80008c94 <dprintf>
80004440:	02002821 	move	a1,s0
			printf("%s: page %d offset %d i %d rlen %d\n",__FUNCTION__, page, offset, i, rlen);
80004444:	afb00010 	sw	s0,16(sp)
80004448:	afb10014 	sw	s1,20(sp)
8000444c:	3c048001 	lui	a0,0x8001
80004450:	24844748 	addiu	a0,a0,18248
80004454:	3c058001 	lui	a1,0x8001
80004458:	24a50408 	addiu	a1,a1,1032
8000445c:	02403021 	move	a2,s2
80004460:	0c002325 	jal	80008c94 <dprintf>
80004464:	02603821 	move	a3,s3
			return -1;
80004468:	08001131 	j	800044c4 <rtk_PIO_read_basic+0x148>
8000446c:	2402ffff 	li	v0,-1
	rtk_writel( (AD2EN|AD1EN|AD0EN|flash_addr1), NAADR);

	check_ready_nand();//check_ready();

	for(i=0; i<(rlen/4); i++){
		data_out = rtk_readl(NADR);
80004470:	3c05b801 	lui	a1,0xb801
80004474:	34a5a014 	ori	a1,a1,0xa014
		//printf("[%3d] 0x%08X \n",i, data_out);
		if(data_out!=0xffffffff){
80004478:	2404ffff 	li	a0,-1
	/* Give address */
	rtk_writel( (AD2EN|AD1EN|AD0EN|flash_addr1), NAADR);

	check_ready_nand();//check_ready();

	for(i=0; i<(rlen/4); i++){
8000447c:	26100001 	addiu	s0,s0,1
80004480:	0203102a 	slt	v0,s0,v1
80004484:	1440ffe7 	bnez	v0,80004424 <rtk_PIO_read_basic+0xa8>
80004488:	00000000 	nop
			printf("%s: page %d offset %d i %d rlen %d\n",__FUNCTION__, page, offset, i, rlen);
			return -1;
		}
	}

	rtk_writel(0, NACMR);
8000448c:	3c11b801 	lui	s1,0xb801
80004490:	3630a008 	ori	s0,s1,0xa008
80004494:	ae000000 	sw	zero,0(s0)
	check_ready_nand(); //check_ready();
80004498:	0c000f80 	jal	80003e00 <check_ready_nand>
8000449c:	00000000 	nop
	rtk_writel (0x0, NACMR);    
800044a0:	ae000000 	sw	zero,0(s0)
	rtk_writel (0x0, NAADR);    
800044a4:	3631a00c 	ori	s1,s1,0xa00c
800044a8:	ae200000 	sw	zero,0(s1)
	rtk_writel ((CECS0 | CMD_RESET), NACMR);         //reset                 //rtk_nand_read_id () ;    
800044ac:	3c024000 	lui	v0,0x4000
800044b0:	344200ff 	ori	v0,v0,0xff
800044b4:	ae020000 	sw	v0,0(s0)
	check_ready_nand ();
800044b8:	0c000f80 	jal	80003e00 <check_ready_nand>
800044bc:	00000000 	nop
800044c0:	00001021 	move	v0,zero
	
	return 0;
	
}
800044c4:	8fbf002c 	lw	ra,44(sp)
800044c8:	8fb30028 	lw	s3,40(sp)
800044cc:	8fb20024 	lw	s2,36(sp)
800044d0:	8fb10020 	lw	s1,32(sp)
800044d4:	8fb0001c 	lw	s0,28(sp)
800044d8:	03e00008 	jr	ra
800044dc:	27bd0030 	addiu	sp,sp,48

800044e0 <rtk_check_allone_512>:

int rtk_check_allone_512(int page)
{
800044e0:	27bdffe8 	addiu	sp,sp,-24
800044e4:	afbf0014 	sw	ra,20(sp)
	int rc=0;

	rc = rtk_PIO_read_basic(page,0);
800044e8:	0c0010df 	jal	8000437c <rtk_PIO_read_basic>
800044ec:	00002821 	move	a1,zero
	if(rc < 0)
		goto read_finish;

read_finish:
	return rc;
}
800044f0:	8fbf0014 	lw	ra,20(sp)
800044f4:	03e00008 	jr	ra
800044f8:	27bd0018 	addiu	sp,sp,24

800044fc <rtk_check_allone>:
}


#endif  /*  */
int rtk_check_allone(int page, int offset)
{
800044fc:	27bdffd0 	addiu	sp,sp,-48
80004500:	afbf002c 	sw	ra,44(sp)
80004504:	afb40028 	sw	s4,40(sp)
80004508:	afb30024 	sw	s3,36(sp)
8000450c:	afb20020 	sw	s2,32(sp)
80004510:	afb1001c 	sw	s1,28(sp)
80004514:	afb00018 	sw	s0,24(sp)
80004518:	00808821 	move	s1,a0
8000451c:	00a0a021 	move	s4,a1
	real_page = page;

	/* rlen is equal to (512 + 16) */
	rlen = 528; 
	
	rtk_writel(0xc00fffff, NACR);
80004520:	3c10b801 	lui	s0,0xb801
80004524:	3602a004 	ori	v0,s0,0xa004
80004528:	3c03c00f 	lui	v1,0xc00f
8000452c:	3463ffff 	ori	v1,v1,0xffff
80004530:	ac430000 	sw	v1,0(v0)

	/* Command cycle 1*/
	rtk_writel((CECS0|CMD_PG_READ_C1), NACMR);
80004534:	3613a008 	ori	s3,s0,0xa008
80004538:	3c124000 	lui	s2,0x4000
8000453c:	ae720000 	sw	s2,0(s3)

	check_ready_nand();//check_ready();
80004540:	0c000f80 	jal	80003e00 <check_ready_nand>
80004544:	00000000 	nop

	flash_addr1 =  ((real_page & 0xff) << 16) | offset;
	flash_addr2 = (real_page >> 8) & 0xffffff;

	/* Give address */
	rtk_writel( (enNextAD|AD2EN|AD1EN|AD0EN|flash_addr1), NAADR);
80004548:	322300ff 	andi	v1,s1,0xff
8000454c:	00031c00 	sll	v1,v1,0x10
80004550:	00741825 	or	v1,v1,s4
80004554:	3c020f00 	lui	v0,0xf00
80004558:	00621825 	or	v1,v1,v0
8000455c:	3602a00c 	ori	v0,s0,0xa00c
80004560:	ac430000 	sw	v1,0(v0)
	rtk_writel( (AD1EN|AD0EN|flash_addr2), NAADR);
80004564:	00112202 	srl	a0,s1,0x8
80004568:	3c030300 	lui	v1,0x300
8000456c:	00831825 	or	v1,a0,v1
80004570:	ac430000 	sw	v1,0(v0)

	/* Command cycle 2*/
	rtk_writel((CECS0|CMD_PG_READ_C2), NACMR);
80004574:	36520030 	ori	s2,s2,0x30
80004578:	ae720000 	sw	s2,0(s3)

	check_ready_nand();//check_ready();
8000457c:	0c000f80 	jal	80003e00 <check_ready_nand>
80004580:	3610a014 	ori	s0,s0,0xa014

	for(i=0; i<(rlen/4); i++){
		data_out = rtk_readl(NADR);	
80004584:	8e030000 	lw	v1,0(s0)
		if( data_out != 0xffffffff){
80004588:	2404ffff 	li	a0,-1
8000458c:	10640003 	beq	v1,a0,8000459c <rtk_check_allone+0xa0>
80004590:	24020001 	li	v0,1
80004594:	0800116f 	j	800045bc <rtk_check_allone+0xc0>
80004598:	00001021 	move	v0,zero
	rtk_writel((CECS0|CMD_PG_READ_C2), NACMR);

	check_ready_nand();//check_ready();

	for(i=0; i<(rlen/4); i++){
		data_out = rtk_readl(NADR);	
8000459c:	3c05b801 	lui	a1,0xb801
800045a0:	34a5a014 	ori	a1,a1,0xa014
		if( data_out != 0xffffffff){
800045a4:	2404ffff 	li	a0,-1
	/* Command cycle 2*/
	rtk_writel((CECS0|CMD_PG_READ_C2), NACMR);

	check_ready_nand();//check_ready();

	for(i=0; i<(rlen/4); i++){
800045a8:	24060084 	li	a2,132
		data_out = rtk_readl(NADR);	
800045ac:	8ca30000 	lw	v1,0(a1)
		if( data_out != 0xffffffff){
800045b0:	1064000d 	beq	v1,a0,800045e8 <rtk_check_allone+0xec>
800045b4:	24420001 	addiu	v0,v0,1
800045b8:	2442ffff 	addiu	v0,v0,-1
			
			printf("%s, page %d offset %x i %x da:%x\n",__FUNCTION__, page, offset, i,data_out);
800045bc:	afa20010 	sw	v0,16(sp)
800045c0:	afa30014 	sw	v1,20(sp)
800045c4:	3c048001 	lui	a0,0x8001
800045c8:	2484476c 	addiu	a0,a0,18284
800045cc:	3c058001 	lui	a1,0x8001
800045d0:	24a5041c 	addiu	a1,a1,1052
800045d4:	02203021 	move	a2,s1
800045d8:	0c002325 	jal	80008c94 <dprintf>
800045dc:	02803821 	move	a3,s4
			return -1;
800045e0:	08001182 	j	80004608 <rtk_check_allone+0x10c>
800045e4:	2402ffff 	li	v0,-1
	/* Command cycle 2*/
	rtk_writel((CECS0|CMD_PG_READ_C2), NACMR);

	check_ready_nand();//check_ready();

	for(i=0; i<(rlen/4); i++){
800045e8:	1446fff0 	bne	v0,a2,800045ac <rtk_check_allone+0xb0>
800045ec:	00000000 	nop
			printf("%s, page %d offset %x i %x da:%x\n",__FUNCTION__, page, offset, i,data_out);
			return -1;
		}
	}

	check_ready_nand();//check_ready();
800045f0:	0c000f80 	jal	80003e00 <check_ready_nand>
800045f4:	00000000 	nop
	rtk_writel(0, NACMR);
800045f8:	3c02b801 	lui	v0,0xb801
800045fc:	3442a008 	ori	v0,v0,0xa008
80004600:	ac400000 	sw	zero,0(v0)
80004604:	00001021 	move	v0,zero

	return 0;

}
80004608:	8fbf002c 	lw	ra,44(sp)
8000460c:	8fb40028 	lw	s4,40(sp)
80004610:	8fb30024 	lw	s3,36(sp)
80004614:	8fb20020 	lw	s2,32(sp)
80004618:	8fb1001c 	lw	s1,28(sp)
8000461c:	8fb00018 	lw	s0,24(sp)
80004620:	03e00008 	jr	ra
80004624:	27bd0030 	addiu	sp,sp,48

80004628 <rtk_check_pageData>:

read_finish:
	return rc;
}
int rtk_check_pageData(int page, int offset)
{
80004628:	27bdffd8 	addiu	sp,sp,-40
8000462c:	afbf0024 	sw	ra,36(sp)
80004630:	afb20020 	sw	s2,32(sp)
80004634:	afb1001c 	sw	s1,28(sp)
80004638:	afb00018 	sw	s0,24(sp)
8000463c:	00808021 	move	s0,a0
	int rc = 0;
	int error_count,status;

	status = rtk_readl(NASR);
80004640:	3c02b801 	lui	v0,0xb801
80004644:	3442a028 	ori	v0,v0,0xa028
80004648:	8c510000 	lw	s1,0(v0)

	if( (status & NDRS)== NDRS){		
8000464c:	32220002 	andi	v0,s1,0x2
80004650:	1040002c 	beqz	v0,80004704 <rtk_check_pageData+0xdc>
80004654:	02209021 	move	s2,s1

		 if( status & NRER) {
80004658:	32220008 	andi	v0,s1,0x8
8000465c:	10400039 	beqz	v0,80004744 <rtk_check_pageData+0x11c>
80004660:	3c02b801 	lui	v0,0xb801
			error_count = (status & 0xf0) >> 4;
80004664:	7e311900 	ext	s1,s1,0x4,0x4
			
			if(error_count <=4 && error_count > 0 ) {
80004668:	2622ffff 	addiu	v0,s1,-1
8000466c:	2c420004 	sltiu	v0,v0,4
80004670:	1040000d 	beqz	v0,800046a8 <rtk_check_pageData+0x80>
80004674:	02003021 	move	a2,s0
				printf("[%s] boot: Correctable HW ECC Error at page=%x, status=0x%08X\n\r", __FUNCTION__, page,status);
80004678:	3c048001 	lui	a0,0x8001
8000467c:	24844790 	addiu	a0,a0,18320
80004680:	3c058001 	lui	a1,0x8001
80004684:	24a503f4 	addiu	a1,a1,1012
80004688:	0c002325 	jal	80008c94 <dprintf>
8000468c:	02403821 	move	a3,s2
				status &= 0x0f; //clear NECN
				rtk_writel(status, NASR);
80004690:	3252000f 	andi	s2,s2,0xf
80004694:	3c02b801 	lui	v0,0xb801
80004698:	3442a028 	ori	v0,v0,0xa028
8000469c:	ac520000 	sw	s2,0(v0)
				return 0;
800046a0:	080011d4 	j	80004750 <rtk_check_pageData+0x128>
800046a4:	00001021 	move	v0,zero
				}
}
else
//#else
{
				if( rtk_check_allone(page,offset) == 0 ){
800046a8:	0c00113f 	jal	800044fc <rtk_check_allone>
800046ac:	00000000 	nop
800046b0:	14400007 	bnez	v0,800046d0 <rtk_check_pageData+0xa8>
800046b4:	3c048001 	lui	a0,0x8001
					status &= 0x0f; //clear NECN
					rtk_writel(status, NASR);
800046b8:	3252000f 	andi	s2,s2,0xf
800046bc:	3c02b801 	lui	v0,0xb801
800046c0:	3442a028 	ori	v0,v0,0xa028
800046c4:	ac520000 	sw	s2,0(v0)
				    	//printf("[%s] Page %d is all one page, bypass it !!\n\r",__func__,page);
				    	return 0;
800046c8:	080011d4 	j	80004750 <rtk_check_pageData+0x128>
800046cc:	00001021 	move	v0,zero
				}
}
//#endif			
				printf("[%s] boot: Un-Correctable HW ECC Error at page=%x, status=0x%08X error_count %d\n\r", __FUNCTION__, page,status, error_count);
800046d0:	afb10010 	sw	s1,16(sp)
800046d4:	248447d0 	addiu	a0,a0,18384
800046d8:	3c058001 	lui	a1,0x8001
800046dc:	24a503f4 	addiu	a1,a1,1012
800046e0:	02003021 	move	a2,s0
800046e4:	0c002325 	jal	80008c94 <dprintf>
800046e8:	02403821 	move	a3,s2
				status &= 0x0f; //clear NECN
				rtk_writel(status, NASR);
800046ec:	3252000f 	andi	s2,s2,0xf
800046f0:	3c02b801 	lui	v0,0xb801
800046f4:	3442a028 	ori	v0,v0,0xa028
800046f8:	ac520000 	sw	s2,0(v0)
				return -1;				
800046fc:	080011d4 	j	80004750 <rtk_check_pageData+0x128>
80004700:	2402ffff 	li	v0,-1
			}
		}
		
	}
	else if( (status & NDWS)== NDWS){
		 if( status & NWER) {
80004704:	32230005 	andi	v1,s1,0x5
80004708:	24020005 	li	v0,5
8000470c:	1462000c 	bne	v1,v0,80004740 <rtk_check_pageData+0x118>
80004710:	3c048001 	lui	a0,0x8001
			printf("[%s] boot: NAND Flash write failed at page=%x, status=0x%08X\n\r", __FUNCTION__, page,status);
80004714:	24844824 	addiu	a0,a0,18468
80004718:	3c058001 	lui	a1,0x8001
8000471c:	24a503f4 	addiu	a1,a1,1012
80004720:	02003021 	move	a2,s0
80004724:	0c002325 	jal	80008c94 <dprintf>
80004728:	02203821 	move	a3,s1
			rtk_writel(status, NASR);
8000472c:	3c02b801 	lui	v0,0xb801
80004730:	3442a028 	ori	v0,v0,0xa028
80004734:	ac510000 	sw	s1,0(v0)
			return -1;
80004738:	080011d4 	j	80004750 <rtk_check_pageData+0x128>
8000473c:	2402ffff 	li	v0,-1
		}
	}

	rtk_writel(status, NASR);
80004740:	3c02b801 	lui	v0,0xb801
80004744:	3442a028 	ori	v0,v0,0xa028
80004748:	ac510000 	sw	s1,0(v0)
8000474c:	00001021 	move	v0,zero

	return rc;
}
80004750:	8fbf0024 	lw	ra,36(sp)
80004754:	8fb20020 	lw	s2,32(sp)
80004758:	8fb1001c 	lw	s1,28(sp)
8000475c:	8fb00018 	lw	s0,24(sp)
80004760:	03e00008 	jr	ra
80004764:	27bd0028 	addiu	sp,sp,40

80004768 <rtk_write_ecc_page_a>:
// Output:
//		BOOL: 0=>OK, -1=>FAIL
//####################################################################
int  rtk_write_ecc_page_a (unsigned int flash_page, unsigned char *image_addr, unsigned char *oob_addr,
		unsigned int image_size)
{
80004768:	27bdffa8 	addiu	sp,sp,-88
8000476c:	afbf0054 	sw	ra,84(sp)
80004770:	afbe0050 	sw	s8,80(sp)
80004774:	afb7004c 	sw	s7,76(sp)
80004778:	afb60048 	sw	s6,72(sp)
8000477c:	afb50044 	sw	s5,68(sp)
80004780:	afb40040 	sw	s4,64(sp)
80004784:	afb3003c 	sw	s3,60(sp)
80004788:	afb20038 	sw	s2,56(sp)
8000478c:	afb10034 	sw	s1,52(sp)
80004790:	afb00030 	sw	s0,48(sp)
80004794:	afa40058 	sw	a0,88(sp)
80004798:	afa5005c 	sw	a1,92(sp)
    //debug cl for safe not write in 0,1 block that is for boot.
	//printf("[%s:] %d\n",__func__,__LINE__);
	if(flash_page < 128||flash_page > chip_size/page_size - 1)
8000479c:	2c820080 	sltiu	v0,a0,128
800047a0:	1440000d 	bnez	v0,800047d8 <rtk_write_ecc_page_a+0x70>
800047a4:	afa60060 	sw	a2,96(sp)
800047a8:	3c028001 	lui	v0,0x8001
800047ac:	8c4275e4 	lw	v0,30180(v0)
800047b0:	3c038002 	lui	v1,0x8002
800047b4:	8c633d80 	lw	v1,15744(v1)
800047b8:	0062001b 	divu	zero,v1,v0
800047bc:	004001f4 	teq	v0,zero,0x7
800047c0:	00002012 	mflo	a0
800047c4:	2483ffff 	addiu	v1,a0,-1
800047c8:	8fa50058 	lw	a1,88(sp)
800047cc:	0065182b 	sltu	v1,v1,a1
800047d0:	10600009 	beqz	v1,800047f8 <rtk_write_ecc_page_a+0x90>
800047d4:	3c04c00f 	lui	a0,0xc00f
	{
		dprintf("[%s]:%d panic:fatal error *************,try to write in 0,1 block for boot,protect for debug\n",__func__,__LINE__);
800047d8:	3c048001 	lui	a0,0x8001
800047dc:	2484468c 	addiu	a0,a0,18060
800047e0:	3c058001 	lui	a1,0x8001
800047e4:	24a503ac 	addiu	a1,a1,940
800047e8:	0c002325 	jal	80008c94 <dprintf>
800047ec:	24060a3f 	li	a2,2623
		return FAIL;
800047f0:	08001296 	j	80004a58 <rtk_write_ecc_page_a+0x2f0>
800047f4:	2402ffff 	li	v0,-1
	unsigned char switch_bbi = 0;
	#endif
	//unsigned char *oob_buf;

	//debug cl
	rtk_writel(0xc00fffff, NACR);
800047f8:	3484ffff 	ori	a0,a0,0xffff
800047fc:	3c03b801 	lui	v1,0xb801
80004800:	3463a004 	ori	v1,v1,0xa004
80004804:	ac640000 	sw	a0,0(v1)
		return FAIL;
	}*/

	//Page size alignment
	dma_size = image_size;
	if( image_size%page_size ){
80004808:	00e2001b 	divu	zero,a3,v0
8000480c:	004001f4 	teq	v0,zero,0x7
80004810:	00009010 	mfhi	s2
		dma_size +=(image_size%page_size);
	}
	
	//Translate nand flash address
	page_start = flash_page;   
80004814:	8fb10058 	lw	s1,88(sp)
	#ifdef SWAP_2K_DATA
	block = flash_page/ppb;
	
	if(block>=BOOT_BLOCK)
80004818:	3c028001 	lui	v0,0x8001
8000481c:	8c4275ec 	lw	v0,30188(v0)
80004820:	0222001b 	divu	zero,s1,v0
80004824:	004001f4 	teq	v0,zero,0x7
80004828:	00001812 	mflo	v1
8000482c:	28620002 	slti	v0,v1,2
80004830:	1440000a 	bnez	v0,8000485c <rtk_write_ecc_page_a+0xf4>
80004834:	00f29021 	addu	s2,a3,s2

		if(!NAND_ADDR_CYCLE)
		{
			unsigned char temp_val;
			if(switch_bbi){
				temp_val = image_addr[BBI_DMA_OFFSET];
80004838:	8fa4005c 	lw	a0,92(sp)
8000483c:	248307d0 	addiu	v1,a0,2000
80004840:	90640000 	lbu	a0,0(v1)
				image_addr[BBI_DMA_OFFSET] = oob_addr[BBI_SWAP_OFFSET];
80004844:	8fa50060 	lw	a1,96(sp)
80004848:	24a20035 	addiu	v0,a1,53
8000484c:	90450000 	lbu	a1,0(v0)
80004850:	a0650000 	sb	a1,0(v1)
		if(image_size>=BBI_DMA_OFFSET)
		oob_addr[BBI_SWAP_OFFSET]=image_addr[BBI_DMA_OFFSET];
		image_addr[BBI_DMA_OFFSET]=0xFF;
		#endif
		
		flush_cache ();
80004854:	0c001eae 	jal	80007ab8 <flush_cache>
80004858:	a0440000 	sb	a0,0(v0)
8000485c:	00001021 	move	v0,zero
80004860:	00008021 	move	s0,zero
		//printf("W  oob_buf [%d] is %x \n",BBI_SWAP_OFFSET, oob_addr[BBI_SWAP_OFFSET]); 
		
	}
	#endif
	
	for(page_shift=0;page_shift<3; page_shift++) {
80004864:	24050018 	li	a1,24
		 page_num[page_shift] = ((page_start>>(8*page_shift)) & 0xff);
		 if(!NAND_ADDR_CYCLE){
		 	 flash_addr_t |= (page_num[page_shift] << (12+8*page_shift));
80004868:	00511807 	srav	v1,s1,v0
8000486c:	306300ff 	andi	v1,v1,0xff
80004870:	2444000c 	addiu	a0,v0,12
80004874:	00831804 	sllv	v1,v1,a0
80004878:	24420008 	addiu	v0,v0,8
		//printf("W  oob_buf [%d] is %x \n",BBI_SWAP_OFFSET, oob_addr[BBI_SWAP_OFFSET]); 
		
	}
	#endif
	
	for(page_shift=0;page_shift<3; page_shift++) {
8000487c:	1445fffa 	bne	v0,a1,80004868 <rtk_write_ecc_page_a+0x100>
80004880:	02038025 	or	s0,s0,v1
    	}

	//Setting default value of flash_addr_t1
	flash_addr_t1 = flash_addr_t;

	while( dma_size>0 ){
80004884:	1a40005f 	blez	s2,80004a04 <rtk_write_ecc_page_a+0x29c>
80004888:	0000a821 	move	s5,zero
8000488c:	8fa20058 	lw	v0,88(sp)
80004890:	afa20010 	sw	v0,16(sp)
80004894:	afa00024 	sw	zero,36(sp)

		if( (dma_size%(ppb*page_size)) == 0)
			printf(".");
80004898:	3c028001 	lui	v0,0x8001
8000489c:	24426e08 	addiu	v0,v0,28168
800048a0:	afa20028 	sw	v0,40(sp)

		while(dma_counter >0) {  //Move 1 page
		//printf("-->dma_counter:%x r\n",dma_counter);
#if 1
			check_ready_nand();
			rtk_writel( (rtk_readl(NACR) |ECC_enable & (~RBO) & (~WBO)), NACR);
800048a4:	3c02b801 	lui	v0,0xb801
800048a8:	3456a004 	ori	s6,v0,0xa004

			//set DMA RAM start address
			dram_sa = ((unsigned int)image_addr+buf_pos*512) & (~M_mask);
			rtk_writel( dram_sa, NADRSAR);
800048ac:	3443a020 	ori	v1,v0,0xa020
800048b0:	afa30014 	sw	v1,20(sp)
			//printf("NADRSAR : 0x%08X ",rtk_readl(NADRSAR));

			//set DMA OOB start address
			oob_sa = ((unsigned int) oob_addr+buf_pos*16) & (~M_mask);
			rtk_writel( oob_sa, NADTSAR);
800048b4:	3457a024 	ori	s7,v0,0xa024

			//set DMA flash start address
			   //flash_addr_t &= 0x1fffffff;
			rtk_writel( flash_addr_t, NADFSAR);
800048b8:	3444a018 	ori	a0,v0,0xa018
800048bc:	afa40018 	sw	a0,24(sp)
		
			//set OOB address
				rtk_writel(oob_sa, NADTSAR);
	 flush_cache ();		
			//DMA write
			rtk_writel( (~TAG_DIS) & (DESC0|DMAWE|LBC_128),NADCRR);	
800048c0:	3442a010 	ori	v0,v0,0xa010
800048c4:	afa2001c 	sw	v0,28(sp)
			check_ready_nand();
			rtk_writel( (rtk_readl(NACR) |ECC_enable & (~RBO) & (~WBO)), NACR);

			//set DMA RAM start address
			dram_sa = ((unsigned int)image_addr+buf_pos*512) & (~M_mask);
			rtk_writel( dram_sa, NADRSAR);
800048c8:	3c1e1fff 	lui	s8,0x1fff
800048cc:	37deffff 	ori	s8,s8,0xffff
	//Setting default value of flash_addr_t1
	flash_addr_t1 = flash_addr_t;

	while( dma_size>0 ){

		if( (dma_size%(ppb*page_size)) == 0)
800048d0:	afb20020 	sw	s2,32(sp)
800048d4:	3c058001 	lui	a1,0x8001
800048d8:	8ca375e4 	lw	v1,30180(a1)
800048dc:	3c048001 	lui	a0,0x8001
800048e0:	8c8275ec 	lw	v0,30188(a0)
800048e4:	70621002 	mul	v0,v1,v0
800048e8:	0242001b 	divu	zero,s2,v0
800048ec:	004001f4 	teq	v0,zero,0x7
800048f0:	00001010 	mfhi	v0
800048f4:	14400004 	bnez	v0,80004908 <rtk_write_ecc_page_a+0x1a0>
800048f8:	3c028001 	lui	v0,0x8001
			printf(".");
800048fc:	0c002325 	jal	80008c94 <dprintf>
80004900:	8fa40028 	lw	a0,40(sp)

		dma_counter = page_size >> 9;
80004904:	3c028001 	lui	v0,0x8001
80004908:	8c5175e4 	lw	s1,30180(v0)
		//printf("dma_counter:%x image:%x\r\n",dma_counter,page_size);
		

		flush_cache ();
8000490c:	0c001eae 	jal	80007ab8 <flush_cache>
80004910:	00118a42 	srl	s1,s1,0x9
		if(oob_addr){
80004914:	8fa30060 	lw	v1,96(sp)
80004918:	10600003 	beqz	v1,80004928 <rtk_write_ecc_page_a+0x1c0>
8000491c:	00000000 	nop
			flush_cache ();
80004920:	0c001eae 	jal	80007ab8 <flush_cache>
80004924:	00000000 	nop
		}

		while(dma_counter >0) {  //Move 1 page
80004928:	1a20002a 	blez	s1,800049d4 <rtk_write_ecc_page_a+0x26c>
8000492c:	00151240 	sll	v0,s5,0x9
80004930:	8fa4005c 	lw	a0,92(sp)
80004934:	00829021 	addu	s2,a0,v0
80004938:	0015a100 	sll	s4,s5,0x4
8000493c:	8fa50060 	lw	a1,96(sp)
80004940:	00b49821 	addu	s3,a1,s4
80004944:	0282a021 	addu	s4,s4,v0
		//printf("-->dma_counter:%x r\n",dma_counter);
#if 1
			check_ready_nand();
80004948:	0c000f80 	jal	80003e00 <check_ready_nand>
8000494c:	00000000 	nop
			rtk_writel( (rtk_readl(NACR) |ECC_enable & (~RBO) & (~WBO)), NACR);
80004950:	8ec20000 	lw	v0,0(s6)
80004954:	3c034000 	lui	v1,0x4000
80004958:	00431025 	or	v0,v0,v1
8000495c:	aec20000 	sw	v0,0(s6)

			//set DMA RAM start address
			dram_sa = ((unsigned int)image_addr+buf_pos*512) & (~M_mask);
			rtk_writel( dram_sa, NADRSAR);
80004960:	025e1024 	and	v0,s2,s8
80004964:	8fa40014 	lw	a0,20(sp)
80004968:	ac820000 	sw	v0,0(a0)
			//printf("NADRSAR : 0x%08X ",rtk_readl(NADRSAR));

			//set DMA OOB start address
			oob_sa = ((unsigned int) oob_addr+buf_pos*16) & (~M_mask);
			rtk_writel( oob_sa, NADTSAR);
8000496c:	027e1024 	and	v0,s3,s8
80004970:	aee20000 	sw	v0,0(s7)

			//set DMA flash start address
			   //flash_addr_t &= 0x1fffffff;
			rtk_writel( flash_addr_t, NADFSAR);
80004974:	8fa50018 	lw	a1,24(sp)
80004978:	acb00000 	sw	s0,0(a1)
			//printf("flash_addr_t:0x%08X NADFSAR : 0x%08X  c:%x\n\r",flash_addr_t,rtk_readl(NADFSAR),dma_counter);
			flash_addr_t +=528;
8000497c:	26100210 	addiu	s0,s0,528
		
			//set OOB address
				rtk_writel(oob_sa, NADTSAR);
80004980:	aee20000 	sw	v0,0(s7)
	 flush_cache ();		
80004984:	0c001eae 	jal	80007ab8 <flush_cache>
80004988:	00000000 	nop
			//DMA write
			rtk_writel( (~TAG_DIS) & (DESC0|DMAWE|LBC_128),NADCRR);	
8000498c:	24030017 	li	v1,23
80004990:	8fa2001c 	lw	v0,28(sp)
80004994:	ac430000 	sw	v1,0(v0)
			check_ready_nand();
80004998:	0c000f80 	jal	80003e00 <check_ready_nand>
8000499c:	00000000 	nop
            //DMA write
            rtk_writel ((~TAG_DIS) &
                        ((0 << TAG_SEL) | DESC0 | DMAWE | LBC_128), NADCRR);
          check_ready_nand ();
#endif
			if(FAIL== rtk_check_pageData((page_start+page_counter), buf_pos*(512+16)))
800049a0:	8fa40010 	lw	a0,16(sp)
800049a4:	0c00118a 	jal	80004628 <rtk_check_pageData>
800049a8:	02802821 	move	a1,s4
800049ac:	2404ffff 	li	a0,-1
800049b0:	14440003 	bne	v0,a0,800049c0 <rtk_write_ecc_page_a+0x258>
800049b4:	2631ffff 	addiu	s1,s1,-1
800049b8:	08001296 	j	80004a58 <rtk_write_ecc_page_a+0x2f0>
800049bc:	2402ffff 	li	v0,-1
				return FAIL;
			
			dma_counter--;
			buf_pos++;
800049c0:	26b50001 	addiu	s5,s5,1
800049c4:	26520200 	addiu	s2,s2,512
800049c8:	26730010 	addiu	s3,s3,16
		flush_cache ();
		if(oob_addr){
			flush_cache ();
		}

		while(dma_counter >0) {  //Move 1 page
800049cc:	1e20ffde 	bgtz	s1,80004948 <rtk_write_ecc_page_a+0x1e0>
800049d0:	26940210 	addiu	s4,s4,528
		else
			flash_addr_t1 =page_counter*0x200;
		
		
		flash_addr_t = flash_addr_t1;
		dma_size -= page_size;
800049d4:	3c058001 	lui	a1,0x8001
800049d8:	8cb275e4 	lw	s2,30180(a1)
800049dc:	8fa20020 	lw	v0,32(sp)
800049e0:	00529023 	subu	s2,v0,s2
800049e4:	8fa30024 	lw	v1,36(sp)
800049e8:	24701000 	addiu	s0,v1,4096
800049ec:	8fa40010 	lw	a0,16(sp)
800049f0:	24840001 	addiu	a0,a0,1
    	}

	//Setting default value of flash_addr_t1
	flash_addr_t1 = flash_addr_t;

	while( dma_size>0 ){
800049f4:	1a400003 	blez	s2,80004a04 <rtk_write_ecc_page_a+0x29c>
800049f8:	afa40010 	sw	a0,16(sp)
800049fc:	08001234 	j	800048d0 <rtk_write_ecc_page_a+0x168>
80004a00:	afb00024 	sw	s0,36(sp)
		flash_addr_t = flash_addr_t1;
		dma_size -= page_size;
		//printf("flash_addr_t:%x dma_size %x\r\n",flash_addr_t,dma_size);

	}
	 flush_cache ();
80004a04:	0c001eae 	jal	80007ab8 <flush_cache>
80004a08:	00000000 	nop
	#ifdef SWAP_2K_DATA
	block = flash_page/ppb;
	//unsigned int write_bbi;
	//unsigned char switch_bbi = 0;
	
	if(block>=BOOT_BLOCK)
80004a0c:	3c028001 	lui	v0,0x8001
80004a10:	8c4275ec 	lw	v0,30188(v0)
80004a14:	8fa40058 	lw	a0,88(sp)
80004a18:	0082001b 	divu	zero,a0,v0
80004a1c:	004001f4 	teq	v0,zero,0x7
80004a20:	00001812 	mflo	v1
80004a24:	28630002 	slti	v1,v1,2
80004a28:	1460000b 	bnez	v1,80004a58 <rtk_write_ecc_page_a+0x2f0>
80004a2c:	00001021 	move	v0,zero

		if(!NAND_ADDR_CYCLE)
		{
			unsigned char temp_val;
			if(switch_bbi){
				temp_val = image_addr[BBI_DMA_OFFSET];
80004a30:	8fa5005c 	lw	a1,92(sp)
80004a34:	24a307d0 	addiu	v1,a1,2000
80004a38:	90640000 	lbu	a0,0(v1)
				image_addr[BBI_DMA_OFFSET] = oob_addr[BBI_SWAP_OFFSET];
80004a3c:	8fa50060 	lw	a1,96(sp)
80004a40:	24a20035 	addiu	v0,a1,53
80004a44:	90450000 	lbu	a1,0(v0)
80004a48:	a0650000 	sb	a1,0(v1)
		if(image_size>=BBI_DMA_OFFSET)
			oob_addr[BBI_SWAP_OFFSET]=image_addr[BBI_DMA_OFFSET];
		image_addr[BBI_DMA_OFFSET]=0xFF;
		#endif
		
		flush_cache ();
80004a4c:	0c001eae 	jal	80007ab8 <flush_cache>
80004a50:	a0440000 	sb	a0,0(v0)
80004a54:	00001021 	move	v0,zero
	}
	#endif

	//free(oob_buf);
	return SUCCESS;
}
80004a58:	8fbf0054 	lw	ra,84(sp)
80004a5c:	8fbe0050 	lw	s8,80(sp)
80004a60:	8fb7004c 	lw	s7,76(sp)
80004a64:	8fb60048 	lw	s6,72(sp)
80004a68:	8fb50044 	lw	s5,68(sp)
80004a6c:	8fb40040 	lw	s4,64(sp)
80004a70:	8fb3003c 	lw	s3,60(sp)
80004a74:	8fb20038 	lw	s2,56(sp)
80004a78:	8fb10034 	lw	s1,52(sp)
80004a7c:	8fb00030 	lw	s0,48(sp)
80004a80:	03e00008 	jr	ra
80004a84:	27bd0058 	addiu	sp,sp,88

80004a88 <rtk_read_ecc_page_a>:
//		image_size	: the length of image
// Output:
//		BOOL: 0=>OK, -1=>FAIL
//####################################################################
int  rtk_read_ecc_page_a (unsigned int flash_page, unsigned char *image_addr, unsigned char *oob_addr, unsigned int image_size)
{
80004a88:	27bdffa8 	addiu	sp,sp,-88
80004a8c:	afbf0054 	sw	ra,84(sp)
80004a90:	afbe0050 	sw	s8,80(sp)
80004a94:	afb7004c 	sw	s7,76(sp)
80004a98:	afb60048 	sw	s6,72(sp)
80004a9c:	afb50044 	sw	s5,68(sp)
80004aa0:	afb40040 	sw	s4,64(sp)
80004aa4:	afb3003c 	sw	s3,60(sp)
80004aa8:	afb20038 	sw	s2,56(sp)
80004aac:	afb10034 	sw	s1,52(sp)
80004ab0:	afb00030 	sw	s0,48(sp)
80004ab4:	afa40058 	sw	a0,88(sp)
80004ab8:	afa5005c 	sw	a1,92(sp)
    //debug cl for safe not write in 0,1 block that is for boot.
	if((flash_page < 128||flash_page > chip_size/page_size - 1)
80004abc:	2c820080 	sltiu	v0,a0,128
80004ac0:	1440000c 	bnez	v0,80004af4 <rtk_read_ecc_page_a+0x6c>
80004ac4:	afa60060 	sw	a2,96(sp)
80004ac8:	3c028002 	lui	v0,0x8002
80004acc:	8c433d80 	lw	v1,15744(v0)
80004ad0:	3c028001 	lui	v0,0x8001
80004ad4:	8c4275e4 	lw	v0,30180(v0)
80004ad8:	0062001b 	divu	zero,v1,v0
80004adc:	004001f4 	teq	v0,zero,0x7
80004ae0:	00001812 	mflo	v1
80004ae4:	2462ffff 	addiu	v0,v1,-1
80004ae8:	0044102b 	sltu	v0,v0,a0
80004aec:	10400004 	beqz	v0,80004b00 <rtk_read_ecc_page_a+0x78>
80004af0:	3c028001 	lui	v0,0x8001
80004af4:	3c028002 	lui	v0,0x8002
80004af8:	ac403d84 	sw	zero,15748(v0)
	int page_counter=0;
	int page_num[3], page_shift=0, page_start;
	unsigned char * oob_buf;
	unsigned long flash_addr_t=0, flash_addr_t1;
	#ifdef SWAP_2K_DATA
	int block= flash_page/ppb;
80004afc:	3c028001 	lui	v0,0x8001
80004b00:	8c4275ec 	lw	v0,30188(v0)
80004b04:	afa2002c 	sw	v0,44(sp)
	#endif
	
	//Page size alignment
	dma_size = image_size;
	if( image_size%page_size ){
80004b08:	3c028001 	lui	v0,0x8001
80004b0c:	8c4275e4 	lw	v0,30180(v0)
80004b10:	00e2001b 	divu	zero,a3,v0
80004b14:	004001f4 	teq	v0,zero,0x7
80004b18:	00001010 	mfhi	v0
	#ifdef SWAP_2K_DATA
	int block= flash_page/ppb;
	#endif
	
	//Page size alignment
	dma_size = image_size;
80004b1c:	00e23821 	addu	a3,a3,v0
80004b20:	afa70020 	sw	a3,32(sp)
	if( image_size%page_size ){
		dma_size +=(image_size%page_size);
	}

	//Translate nand flash address
	page_start = flash_page;
80004b24:	8fa60058 	lw	a2,88(sp)
80004b28:	00001021 	move	v0,zero
80004b2c:	00008021 	move	s0,zero
	
	for(page_shift=0;page_shift<3; page_shift++) {
80004b30:	24050018 	li	a1,24
             	page_num[page_shift] = ((page_start>>(8*page_shift)) & 0xff);
		if(!NAND_ADDR_CYCLE)
             		flash_addr_t |= (page_num[page_shift] << (12+8*page_shift));
80004b34:	00461807 	srav	v1,a2,v0
80004b38:	306300ff 	andi	v1,v1,0xff
80004b3c:	2444000c 	addiu	a0,v0,12
80004b40:	00831804 	sllv	v1,v1,a0
80004b44:	24420008 	addiu	v0,v0,8
	}

	//Translate nand flash address
	page_start = flash_page;
	
	for(page_shift=0;page_shift<3; page_shift++) {
80004b48:	1445fffa 	bne	v0,a1,80004b34 <rtk_read_ecc_page_a+0xac>
80004b4c:	02038025 	or	s0,s0,v1
    	}

	//Setting default value of flash_addr_t1
	flash_addr_t1 = flash_addr_t;
	
	while( dma_size>0 ){
80004b50:	8fa20020 	lw	v0,32(sp)
80004b54:	18400053 	blez	v0,80004ca4 <rtk_read_ecc_page_a+0x21c>
80004b58:	8fbe0058 	lw	s8,88(sp)
80004b5c:	afb00028 	sw	s0,40(sp)
80004b60:	afa00024 	sw	zero,36(sp)
80004b64:	0000a821 	move	s5,zero
		}

		while(dma_counter >0) {  //Move 1 page
			flush_cache ();
			check_ready_nand();//check_ready();
			rtk_writel( (rtk_readl(NACR) |ECC_enable & (~RBO) & (~WBO)), NACR);
80004b68:	3c02b801 	lui	v0,0xb801
80004b6c:	3456a004 	ori	s6,v0,0xa004

			//set DMA RAM start address
			dram_sa = ((unsigned int)image_addr+buf_pos*512) & (~M_mask);
			rtk_writel( dram_sa, NADRSAR);
80004b70:	3443a020 	ori	v1,v0,0xa020
80004b74:	afa30010 	sw	v1,16(sp)
			//printf("SDRAM address: 0x%08X ",dram_sa);

			//set DMA oob start address
			//oob_sa = ((unsigned int)oob_buf+buf_pos*16) & (~M_mask);
			oob_sa = ((unsigned int)oob_addr+buf_pos*16) & (~M_mask);
			rtk_writel( oob_sa, NADTSAR);
80004b78:	3444a024 	ori	a0,v0,0xa024
80004b7c:	afa40014 	sw	a0,20(sp)

			//set DMA flash start address
			rtk_writel( flash_addr_t, NADFSAR);
80004b80:	3445a018 	ori	a1,v0,0xa018
80004b84:	afa50018 	sw	a1,24(sp)
			//printf("Flash address: 0x%08X \n\r",flash_addr_t);
			flash_addr_t +=528;
			
			//DMA read
			rtk_writel((~TAG_DIS) & (DESC0|DMARE|LBC_128),NADCRR);	
80004b88:	3442a010 	ori	v0,v0,0xa010
80004b8c:	afa2001c 	sw	v0,28(sp)
			check_ready_nand();//check_ready();
			rtk_writel( (rtk_readl(NACR) |ECC_enable & (~RBO) & (~WBO)), NACR);

			//set DMA RAM start address
			dram_sa = ((unsigned int)image_addr+buf_pos*512) & (~M_mask);
			rtk_writel( dram_sa, NADRSAR);
80004b90:	3c171fff 	lui	s7,0x1fff
80004b94:	36f7ffff 	ori	s7,s7,0xffff
	flash_addr_t1 = flash_addr_t;
	
	while( dma_size>0 ){

		//printf("[%s:] %d\n",__func__,__LINE__);
		dma_counter = page_size >> 9;
80004b98:	3c028001 	lui	v0,0x8001
80004b9c:	8c5175e4 	lw	s1,30180(v0)

		if(oob_addr){
80004ba0:	8fa30060 	lw	v1,96(sp)
80004ba4:	10600003 	beqz	v1,80004bb4 <rtk_read_ecc_page_a+0x12c>
80004ba8:	00118a42 	srl	s1,s1,0x9
			flush_cache ();
80004bac:	0c001eae 	jal	80007ab8 <flush_cache>
80004bb0:	00000000 	nop
				//dma_cache_writeb();
		}

		while(dma_counter >0) {  //Move 1 page
80004bb4:	1a20002c 	blez	s1,80004c68 <rtk_read_ecc_page_a+0x1e0>
80004bb8:	00151240 	sll	v0,s5,0x9
80004bbc:	8fa4005c 	lw	a0,92(sp)
80004bc0:	00829021 	addu	s2,a0,v0
80004bc4:	0015a100 	sll	s4,s5,0x4
80004bc8:	8fa50060 	lw	a1,96(sp)
80004bcc:	00b49821 	addu	s3,a1,s4
80004bd0:	0282a021 	addu	s4,s4,v0
			flush_cache ();
80004bd4:	0c001eae 	jal	80007ab8 <flush_cache>
80004bd8:	00000000 	nop
			check_ready_nand();//check_ready();
80004bdc:	0c000f80 	jal	80003e00 <check_ready_nand>
80004be0:	00000000 	nop
			rtk_writel( (rtk_readl(NACR) |ECC_enable & (~RBO) & (~WBO)), NACR);
80004be4:	8ec20000 	lw	v0,0(s6)
80004be8:	3c034000 	lui	v1,0x4000
80004bec:	00431025 	or	v0,v0,v1
80004bf0:	aec20000 	sw	v0,0(s6)

			//set DMA RAM start address
			dram_sa = ((unsigned int)image_addr+buf_pos*512) & (~M_mask);
			rtk_writel( dram_sa, NADRSAR);
80004bf4:	02571024 	and	v0,s2,s7
80004bf8:	8fa40010 	lw	a0,16(sp)
80004bfc:	ac820000 	sw	v0,0(a0)
			//printf("SDRAM address: 0x%08X ",dram_sa);

			//set DMA oob start address
			//oob_sa = ((unsigned int)oob_buf+buf_pos*16) & (~M_mask);
			oob_sa = ((unsigned int)oob_addr+buf_pos*16) & (~M_mask);
			rtk_writel( oob_sa, NADTSAR);
80004c00:	02771024 	and	v0,s3,s7
80004c04:	8fa50014 	lw	a1,20(sp)
80004c08:	aca20000 	sw	v0,0(a1)

			//set DMA flash start address
			rtk_writel( flash_addr_t, NADFSAR);
80004c0c:	8fa20018 	lw	v0,24(sp)
80004c10:	ac500000 	sw	s0,0(v0)
			//printf("Flash address: 0x%08X \n\r",flash_addr_t);
			flash_addr_t +=528;
80004c14:	26100210 	addiu	s0,s0,528
			
			//DMA read
			rtk_writel((~TAG_DIS) & (DESC0|DMARE|LBC_128),NADCRR);	
80004c18:	2404001b 	li	a0,27
80004c1c:	8fa3001c 	lw	v1,28(sp)
80004c20:	ac640000 	sw	a0,0(v1)
			check_ready_nand(); //check_ready();
80004c24:	0c000f80 	jal	80003e00 <check_ready_nand>
80004c28:	00000000 	nop

			if(FAIL== rtk_check_pageData((page_start+page_counter), buf_pos*(512+16))) {
80004c2c:	03c02021 	move	a0,s8
80004c30:	0c00118a 	jal	80004628 <rtk_check_pageData>
80004c34:	02802821 	move	a1,s4
80004c38:	2405ffff 	li	a1,-1
80004c3c:	14450005 	bne	v0,a1,80004c54 <rtk_read_ecc_page_a+0x1cc>
80004c40:	2631ffff 	addiu	s1,s1,-1
				flush_cache ();//dma_cache_writeb();
80004c44:	0c001eae 	jal	80007ab8 <flush_cache>
80004c48:	00000000 	nop
				return FAIL;
80004c4c:	0800133d 	j	80004cf4 <rtk_read_ecc_page_a+0x26c>
80004c50:	2402ffff 	li	v0,-1
			}
			
			dma_counter--;
			buf_pos++;
80004c54:	26b50001 	addiu	s5,s5,1
80004c58:	26520200 	addiu	s2,s2,512
80004c5c:	26730010 	addiu	s3,s3,16
		if(oob_addr){
			flush_cache ();
				//dma_cache_writeb();
		}

		while(dma_counter >0) {  //Move 1 page
80004c60:	1e20ffdc 	bgtz	s1,80004bd4 <rtk_read_ecc_page_a+0x14c>
80004c64:	26940210 	addiu	s4,s4,528
		}else{
			flash_addr_t1 +=page_counter*0x200;
		}
		
		flash_addr_t = flash_addr_t1;
		dma_size -= page_size;
80004c68:	3c038001 	lui	v1,0x8001
80004c6c:	8c6275e4 	lw	v0,30180(v1)
80004c70:	8fa40020 	lw	a0,32(sp)
80004c74:	00822023 	subu	a0,a0,v0
80004c78:	afa40020 	sw	a0,32(sp)
80004c7c:	8fa50024 	lw	a1,36(sp)
80004c80:	24a51000 	addiu	a1,a1,4096
80004c84:	afa50024 	sw	a1,36(sp)
    	}

	//Setting default value of flash_addr_t1
	flash_addr_t1 = flash_addr_t;
	
	while( dma_size>0 ){
80004c88:	18800006 	blez	a0,80004ca4 <rtk_read_ecc_page_a+0x21c>
80004c8c:	27de0001 	addiu	s8,s8,1
		}

		page_counter +=1;

		if(!NAND_ADDR_CYCLE){
			flash_addr_t1 +=page_counter*0x1000;
80004c90:	8fa20028 	lw	v0,40(sp)
80004c94:	00451021 	addu	v0,v0,a1
80004c98:	afa20028 	sw	v0,40(sp)
80004c9c:	080012e6 	j	80004b98 <rtk_read_ecc_page_a+0x110>
80004ca0:	00408021 	move	s0,v0
		flash_addr_t = flash_addr_t1;
		dma_size -= page_size;
		
	}

	flush_cache ();
80004ca4:	0c001eae 	jal	80007ab8 <flush_cache>
80004ca8:	00000000 	nop
	#ifdef SWAP_2K_DATA
	if(block>=BOOT_BLOCK){
80004cac:	8fa40058 	lw	a0,88(sp)
80004cb0:	8fa5002c 	lw	a1,44(sp)
80004cb4:	0085001b 	divu	zero,a0,a1
80004cb8:	00a001f4 	teq	a1,zero,0x7
80004cbc:	00001812 	mflo	v1
80004cc0:	28630002 	slti	v1,v1,2
80004cc4:	1460000b 	bnez	v1,80004cf4 <rtk_read_ecc_page_a+0x26c>
80004cc8:	00001021 	move	v0,zero
		if(!NAND_ADDR_CYCLE)
		{
			/*switch bad block info*/
			unsigned char temp_val=0;
			if(switch_bbi){
				temp_val = image_addr[DATA_BBI_OFF];
80004ccc:	8fa2005c 	lw	v0,92(sp)
80004cd0:	244307d0 	addiu	v1,v0,2000
80004cd4:	90640000 	lbu	a0,0(v1)
				image_addr[DATA_BBI_OFF] = oob_addr[BBI_SWAP_OFFSET]; 
80004cd8:	8fa50060 	lw	a1,96(sp)
80004cdc:	24a20035 	addiu	v0,a1,53
80004ce0:	90450000 	lbu	a1,0(v0)
80004ce4:	a0650000 	sb	a1,0(v1)
		if(image_size>=BBI_DMA_OFFSET)
		image_addr[BBI_DMA_OFFSET]=oob_addr[BBI_SWAP_OFFSET];
		oob_addr[BBI_SWAP_OFFSET]=0xFF;
		#endif
		
		flush_cache ();
80004ce8:	0c001eae 	jal	80007ab8 <flush_cache>
80004cec:	a0440000 	sb	a0,0(v0)
80004cf0:	00001021 	move	v0,zero
		
	}
	#endif
	//free(oob_buf);
	return SUCCESS;
}
80004cf4:	8fbf0054 	lw	ra,84(sp)
80004cf8:	8fbe0050 	lw	s8,80(sp)
80004cfc:	8fb7004c 	lw	s7,76(sp)
80004d00:	8fb60048 	lw	s6,72(sp)
80004d04:	8fb50044 	lw	s5,68(sp)
80004d08:	8fb40040 	lw	s4,64(sp)
80004d0c:	8fb3003c 	lw	s3,60(sp)
80004d10:	8fb20038 	lw	s2,56(sp)
80004d14:	8fb10034 	lw	s1,52(sp)
80004d18:	8fb00030 	lw	s0,48(sp)
80004d1c:	03e00008 	jr	ra
80004d20:	27bd0058 	addiu	sp,sp,88

80004d24 <rtk_block_isbad>:
//		BOOL: 0=>OK, 
//			 -1=>This block is bad, 
//			   1=>Read oob area fail,
//####################################################################
int rtk_block_isbad(unsigned int ofs)
{
80004d24:	27bdffe0 	addiu	sp,sp,-32
80004d28:	afbf001c 	sw	ra,28(sp)
80004d2c:	afb10018 	sw	s1,24(sp)
80004d30:	afb00014 	sw	s0,20(sp)
	int i;

	unsigned char * oob_buf = mybuf;
	unsigned char * data_buf = mydatabuf;

	page = ((int) ofs) >> page_shift;
80004d34:	3c028002 	lui	v0,0x8002
80004d38:	8c503d78 	lw	s0,15736(v0)
80004d3c:	02048007 	srav	s0,a0,s0
	page_offset = page & (ppb-1);
	block = page/ppb;
80004d40:	3c028001 	lui	v0,0x8001
80004d44:	8c4275ec 	lw	v0,30188(v0)
80004d48:	0202001b 	divu	zero,s0,v0
80004d4c:	004001f4 	teq	v0,zero,0x7

	if ( isLastPage ){
80004d50:	3c038002 	lui	v1,0x8002
80004d54:	8c633d7c 	lw	v1,15740(v1)
80004d58:	10600018 	beqz	v1,80004dbc <rtk_block_isbad+0x98>
80004d5c:	00008812 	mflo	s1
		page = block*ppb + (ppb-1);	
80004d60:	26300001 	addiu	s0,s1,1
80004d64:	72028002 	mul	s0,s0,v0
80004d68:	2610ffff 	addiu	s0,s0,-1
		if(rtk_read_ecc_page_a(page, data_buf, oob_buf, page_size)){
80004d6c:	02002021 	move	a0,s0
80004d70:	3c058002 	lui	a1,0x8002
80004d74:	24a557a8 	addiu	a1,a1,22440
80004d78:	3c068002 	lui	a2,0x8002
80004d7c:	24c65704 	addiu	a2,a2,22276
80004d80:	3c028001 	lui	v0,0x8001
80004d84:	0c0012a2 	jal	80004a88 <rtk_read_ecc_page_a>
80004d88:	8c4775e4 	lw	a3,30180(v0)
80004d8c:	10400008 	beqz	v0,80004db0 <rtk_block_isbad+0x8c>
80004d90:	3c048001 	lui	a0,0x8001
			printf("%s: read_oob page=%d failed\n", __FUNCTION__, page);
80004d94:	24844864 	addiu	a0,a0,18532
80004d98:	3c058001 	lui	a1,0x8001
80004d9c:	24a503e4 	addiu	a1,a1,996
80004da0:	0c002325 	jal	80008c94 <dprintf>
80004da4:	02003021 	move	a2,s0
			return 1;
80004da8:	0800138d 	j	80004e34 <rtk_block_isbad+0x110>
80004dac:	24020001 	li	v0,1
		}
		//ccwei 111116
        if(!NAND_ADDR_CYCLE)
		#ifdef SWAP_2K_DATA
			block_status_p1 = oob_buf[BBI_SWAP_OFFSET];
80004db0:	3c028002 	lui	v0,0x8002
80004db4:	08001382 	j	80004e08 <rtk_block_isbad+0xe4>
80004db8:	90465739 	lbu	a2,22329(v0)
		#endif
		else
			block_status_p1 = oob_buf[5];
		
	}else{	
		if ( rtk_read_ecc_page_a(page, data_buf, oob_buf, page_size) ){
80004dbc:	02002021 	move	a0,s0
80004dc0:	3c058002 	lui	a1,0x8002
80004dc4:	24a557a8 	addiu	a1,a1,22440
80004dc8:	3c068002 	lui	a2,0x8002
80004dcc:	24c65704 	addiu	a2,a2,22276
80004dd0:	3c028001 	lui	v0,0x8001
80004dd4:	0c0012a2 	jal	80004a88 <rtk_read_ecc_page_a>
80004dd8:	8c4775e4 	lw	a3,30180(v0)
80004ddc:	10400008 	beqz	v0,80004e00 <rtk_block_isbad+0xdc>
80004de0:	3c048001 	lui	a0,0x8001
			printf ("%s: read_oob page=%d failed\n", __FUNCTION__, page);
80004de4:	24844864 	addiu	a0,a0,18532
80004de8:	3c058001 	lui	a1,0x8001
80004dec:	24a503e4 	addiu	a1,a1,996
80004df0:	0c002325 	jal	80008c94 <dprintf>
80004df4:	02003021 	move	a2,s0
			return 1;
80004df8:	0800138d 	j	80004e34 <rtk_block_isbad+0x110>
80004dfc:	24020001 	li	v0,1
		}

	    //ccwei 111116
	    if(!NAND_ADDR_CYCLE)
	    #ifdef SWAP_2K_DATA
			block_status_p1 = oob_buf[BBI_SWAP_OFFSET];
80004e00:	3c028002 	lui	v0,0x8002
80004e04:	90465739 	lbu	a2,22329(v0)
		#endif
	    else
		    block_status_p1 = oob_buf[5];
	}

	if( block_status_p1 == BBT_TAG){
80004e08:	240200bb 	li	v0,187
80004e0c:	10c20008 	beq	a2,v0,80004e30 <rtk_block_isbad+0x10c>
80004e10:	240200ff 	li	v0,255
		//printf("Reserved area for BBT: block=%d, block_status_p1=0x%x\n\r",block,block_status_p1);
		//printf("[%s:] %d block=%d is BBT_TAG already init ok\n",__func__,__LINE__,block);
		return 0;
	}else 
	if ( block_status_p1 != 0xff){		
80004e14:	10c20006 	beq	a2,v0,80004e30 <rtk_block_isbad+0x10c>
80004e18:	3c048001 	lui	a0,0x8001
		printf ("WARNING: Die 0: block=%d is bad, block_status_p1=0x%x\n\r", block, block_status_p1);
80004e1c:	24844884 	addiu	a0,a0,18564
80004e20:	0c002325 	jal	80008c94 <dprintf>
80004e24:	02202821 	move	a1,s1
		return -1;
80004e28:	0800138d 	j	80004e34 <rtk_block_isbad+0x110>
80004e2c:	2402ffff 	li	v0,-1
80004e30:	00001021 	move	v0,zero
	}
	//printf("[%s:] %d block is normal good ok\n",__func__,__LINE__);
	return 0;

}
80004e34:	8fbf001c 	lw	ra,28(sp)
80004e38:	8fb10018 	lw	s1,24(sp)
80004e3c:	8fb00014 	lw	s0,20(sp)
80004e40:	03e00008 	jr	ra
80004e44:	27bd0020 	addiu	sp,sp,32

80004e48 <dump_BBT>:
//		NON
// Output:
//		NON
//####################################################################
static void dump_BBT(void)
{
80004e48:	27bdffc8 	addiu	sp,sp,-56
80004e4c:	afbf0034 	sw	ra,52(sp)
80004e50:	afb50030 	sw	s5,48(sp)
80004e54:	afb4002c 	sw	s4,44(sp)
80004e58:	afb30028 	sw	s3,40(sp)
80004e5c:	afb20024 	sw	s2,36(sp)
80004e60:	afb10020 	sw	s1,32(sp)
80004e64:	afb0001c 	sw	s0,28(sp)
	int i;
	int BBs=0;

	printf("[%s] Nand BBT Content\n\r", __FUNCTION__);
80004e68:	3c048001 	lui	a0,0x8001
80004e6c:	248448bc 	addiu	a0,a0,18620
80004e70:	3c058001 	lui	a1,0x8001
80004e74:	0c002325 	jal	80008c94 <dprintf>
80004e78:	24a50444 	addiu	a1,a1,1092

	for ( i=0; i<RBA; i++){
80004e7c:	3c028002 	lui	v0,0x8002
80004e80:	8c422e74 	lw	v0,11892(v0)
80004e84:	10400029 	beqz	v0,80004f2c <dump_BBT+0xe4>
80004e88:	00008021 	move	s0,zero
80004e8c:	00001821 	move	v1,zero
		if ( i==0 && bbt[i].BB_die == BB_DIE_INIT && bbt[i].bad_block == BB_INIT ){
			printf("Congratulation!! No BBs in this Nand.\n\r");
			break;
		}
		if ( bbt[i].bad_block != BB_INIT ){
			printf("[%d] (%d, %x, %x, %x)\n\r", i, bbt[i].BB_die,bbt[i].bad_block, 
80004e90:	3c148001 	lui	s4,0x8001
80004e94:	269448fc 	addiu	s4,s4,18684
	for ( i=0; i<RBA; i++){
		if ( i==0 && bbt[i].BB_die == BB_DIE_INIT && bbt[i].bad_block == BB_INIT ){
			printf("Congratulation!! No BBs in this Nand.\n\r");
			break;
		}
		if ( bbt[i].bad_block != BB_INIT ){
80004e98:	3c118002 	lui	s1,0x8002
80004e9c:	3413fffe 	li	s3,0xfffe
	int BBs=0;

	printf("[%s] Nand BBT Content\n\r", __FUNCTION__);

	for ( i=0; i<RBA; i++){
		if ( i==0 && bbt[i].BB_die == BB_DIE_INIT && bbt[i].bad_block == BB_INIT ){
80004ea0:	3415eeee 	li	s5,0xeeee
	int i;
	int BBs=0;

	printf("[%s] Nand BBT Content\n\r", __FUNCTION__);

	for ( i=0; i<RBA; i++){
80004ea4:	3c128002 	lui	s2,0x8002
		if ( i==0 && bbt[i].BB_die == BB_DIE_INIT && bbt[i].bad_block == BB_INIT ){
80004ea8:	1600000d 	bnez	s0,80004ee0 <dump_BBT+0x98>
80004eac:	000310c0 	sll	v0,v1,0x3
80004eb0:	8e242e78 	lw	a0,11896(s1)
80004eb4:	00821021 	addu	v0,a0,v0
80004eb8:	94440000 	lhu	a0,0(v0)
80004ebc:	14950008 	bne	a0,s5,80004ee0 <dump_BBT+0x98>
80004ec0:	00000000 	nop
80004ec4:	94470002 	lhu	a3,2(v0)
80004ec8:	14f3000b 	bne	a3,s3,80004ef8 <dump_BBT+0xb0>
80004ecc:	3c048001 	lui	a0,0x8001
			printf("Congratulation!! No BBs in this Nand.\n\r");
80004ed0:	0c002325 	jal	80008c94 <dprintf>
80004ed4:	248448d4 	addiu	a0,a0,18644
			break;
80004ed8:	080013cc 	j	80004f30 <dump_BBT+0xe8>
80004edc:	8fbf0034 	lw	ra,52(sp)
		}
		if ( bbt[i].bad_block != BB_INIT ){
80004ee0:	000318c0 	sll	v1,v1,0x3
80004ee4:	8e222e78 	lw	v0,11896(s1)
80004ee8:	00431021 	addu	v0,v0,v1
80004eec:	94470002 	lhu	a3,2(v0)
80004ef0:	10f30009 	beq	a3,s3,80004f18 <dump_BBT+0xd0>
80004ef4:	00000000 	nop
			printf("[%d] (%d, %x, %x, %x)\n\r", i, bbt[i].BB_die,bbt[i].bad_block, 
80004ef8:	94460000 	lhu	a2,0(v0)
80004efc:	94430004 	lhu	v1,4(v0)
80004f00:	afa30010 	sw	v1,16(sp)
80004f04:	94420006 	lhu	v0,6(v0)
80004f08:	afa20014 	sw	v0,20(sp)
80004f0c:	02802021 	move	a0,s4
80004f10:	0c002325 	jal	80008c94 <dprintf>
80004f14:	02002821 	move	a1,s0
	int i;
	int BBs=0;

	printf("[%s] Nand BBT Content\n\r", __FUNCTION__);

	for ( i=0; i<RBA; i++){
80004f18:	26100001 	addiu	s0,s0,1
80004f1c:	8e422e74 	lw	v0,11892(s2)
80004f20:	0202102b 	sltu	v0,s0,v0
80004f24:	1440ffe0 	bnez	v0,80004ea8 <dump_BBT+0x60>
80004f28:	02001821 	move	v1,s0
			BBs++;
		}
	}
	//this->BBs = BBs;
	return;
}
80004f2c:	8fbf0034 	lw	ra,52(sp)
80004f30:	8fb50030 	lw	s5,48(sp)
80004f34:	8fb4002c 	lw	s4,44(sp)
80004f38:	8fb30028 	lw	s3,40(sp)
80004f3c:	8fb20024 	lw	s2,36(sp)
80004f40:	8fb10020 	lw	s1,32(sp)
80004f44:	8fb0001c 	lw	s0,28(sp)
80004f48:	03e00008 	jr	ra
80004f4c:	27bd0038 	addiu	sp,sp,56

80004f50 <rtk_read_ecc_page>:
#endif
#if 1
void 
rtk_read_ecc_page (unsigned long flash_address, unsigned char *image_addr,
                   unsigned int image_size, char ecc_enable ) 
{
80004f50:	27bdffb8 	addiu	sp,sp,-72
80004f54:	afbf0044 	sw	ra,68(sp)
80004f58:	afbe0040 	sw	s8,64(sp)
80004f5c:	afb7003c 	sw	s7,60(sp)
80004f60:	afb60038 	sw	s6,56(sp)
80004f64:	afb50034 	sw	s5,52(sp)
80004f68:	afb40030 	sw	s4,48(sp)
80004f6c:	afb3002c 	sw	s3,44(sp)
80004f70:	afb20028 	sw	s2,40(sp)
80004f74:	afb10024 	sw	s1,36(sp)
80004f78:	afb00020 	sw	s0,32(sp)
80004f7c:	00808021 	move	s0,a0
80004f80:	afa5004c 	sw	a1,76(sp)
80004f84:	00c09021 	move	s2,a2
  //debug cl
  //dprintf("[%s]:%d for boot safe debug return directly\n",__func__,__LINE__);
  //return FAIL;
  flush_cache ();
80004f88:	0c001eae 	jal	80007ab8 <flush_cache>
80004f8c:	7c078c20 	seb	s1,a3
	//	dprintf("[%s]:%d panic:fatal error *************,try to write in 0,1 block for boot,protect for debug\n",__func__,__LINE__);
	//	return FAIL;
	//}
  
    //default enable
    rtk_writel ((rtk_readl (NACR) | ECC_enable), NACR); //Enable ECC function
80004f90:	3c02b801 	lui	v0,0xb801
80004f94:	3442a004 	ori	v0,v0,0xa004
80004f98:	8c440000 	lw	a0,0(v0)
80004f9c:	3c034000 	lui	v1,0x4000
80004fa0:	00831825 	or	v1,a0,v1
80004fa4:	ac430000 	sw	v1,0(v0)
  if (ecc_enable == 0)
80004fa8:	16200008 	bnez	s1,80004fcc <rtk_read_ecc_page+0x7c>
80004fac:	3c02b801 	lui	v0,0xb801
    
      //disable ECC function
      rtk_writel ((rtk_readl (NACR) & ~(ECC_enable)), NACR);
80004fb0:	3442a004 	ori	v0,v0,0xa004
80004fb4:	8c440000 	lw	a0,0(v0)
80004fb8:	3c03bfff 	lui	v1,0xbfff
80004fbc:	3463ffff 	ori	v1,v1,0xffff
80004fc0:	00831824 	and	v1,a0,v1
80004fc4:	ac430000 	sw	v1,0(v0)
    //dprintf("\n\recc_enable=%d\n",ecc_enable);
    
    /* Clear NAND Flash Status Register (NASR , 0xb801a020)
     *   NECN write "0" to clear bit [7:4] and NRER write "1" to clear bit[3].
     */ 
    rtk_writel ((rtk_readl (NASR) & 0xFFFFFF0F), NASR);
80004fc8:	3c02b801 	lui	v0,0xb801
80004fcc:	3442a028 	ori	v0,v0,0xa028
80004fd0:	8c440000 	lw	a0,0(v0)
80004fd4:	2403ff0f 	li	v1,-241
80004fd8:	00831824 	and	v1,a0,v1
80004fdc:	ac430000 	sw	v1,0(v0)
  check_ready_nand ();
80004fe0:	0c000f80 	jal	80003e00 <check_ready_nand>
80004fe4:	00000000 	nop
    {
      dma_size += (image_size % 2048);
    }
  
#else   /*  */
   if ((flash_address % (page_size + oob_size)) != 0)
80004fe8:	3c028001 	lui	v0,0x8001
80004fec:	8c4575e4 	lw	a1,30180(v0)
80004ff0:	3c028001 	lui	v0,0x8001
80004ff4:	8c4675e8 	lw	a2,30184(v0)
80004ff8:	00c51021 	addu	v0,a2,a1
80004ffc:	0202001b 	divu	zero,s0,v0
80005000:	004001f4 	teq	v0,zero,0x7
80005004:	00001810 	mfhi	v1
80005008:	10600006 	beqz	v1,80005024 <rtk_read_ecc_page+0xd4>
8000500c:	00001821 	move	v1,zero
    {
     dprintf ("\n\rflash_address must be page(0x%x+0x%x Bytes) aligned!\n",
80005010:	3c048001 	lui	a0,0x8001
80005014:	0c002325 	jal	80008c94 <dprintf>
80005018:	24844654 	addiu	a0,a0,18004
               page_size, oob_size);
        
     return;
8000501c:	0800144a 	j	80005128 <rtk_read_ecc_page+0x1d8>
80005020:	8fbf0044 	lw	ra,68(sp)
    /*Translate nand flash address formula */ 
#if 0                           //def NAND_Flash_Small_Page_32MB_3cycles
    flash_addr_t = flash_address;
  
#else   /*  */
    page_start = flash_address / (page_size + oob_size);
80005024:	0202001b 	divu	zero,s0,v0
80005028:	004001f4 	teq	v0,zero,0x7
8000502c:	00003012 	mflo	a2
80005030:	00008021 	move	s0,zero
  for (page_shift = 0; page_shift < 3; page_shift++)
80005034:	24020018 	li	v0,24
    {
      page_num[page_shift] = ((page_start >> (8 * page_shift)) & 0xff);
      flash_addr_t |= (page_num[page_shift] << (12 + 8 * page_shift));
80005038:	00662007 	srav	a0,a2,v1
8000503c:	308400ff 	andi	a0,a0,0xff
80005040:	2465000c 	addiu	a1,v1,12
80005044:	00a42004 	sllv	a0,a0,a1
80005048:	24630008 	addiu	v1,v1,8
#if 0                           //def NAND_Flash_Small_Page_32MB_3cycles
    flash_addr_t = flash_address;
  
#else   /*  */
    page_start = flash_address / (page_size + oob_size);
  for (page_shift = 0; page_shift < 3; page_shift++)
8000504c:	1462fffa 	bne	v1,v0,80005038 <rtk_read_ecc_page+0xe8>
80005050:	02048025 	or	s0,s0,a0
  
#endif  /*  */
    
    //DMA read
    //dprintf("\n\n(DMA Read)\r");
    while (dma_size > 0)
80005054:	1a400031 	blez	s2,8000511c <rtk_read_ecc_page+0x1cc>
80005058:	afb20010 	sw	s2,16(sp)
8000505c:	24c60001 	addiu	a2,a2,1
80005060:	00063300 	sll	a2,a2,0xc
80005064:	afa60014 	sw	a2,20(sp)
80005068:	afa00018 	sw	zero,24(sp)
            }
          check_ready_nand ();
          
            //set DMA RAM start address
            dram_sa = ((unsigned int) image_addr + buf_pos * 512) & (~M_mask);
          rtk_writel (dram_sa, NADRSAR);
8000506c:	3c131fff 	lui	s3,0x1fff
80005070:	3673ffff 	ori	s3,s3,0xffff
80005074:	3c16b801 	lui	s6,0xb801
80005078:	36d4a020 	ori	s4,s6,0xa020
          
             //dprintf("\nDMA-R:SDRAM address: 0x%X\n ",(dram_sa));
            
            //set DMA flash start address
            rtk_writel (flash_addr_t, NADFSAR);
8000507c:	36d5a018 	ori	s5,s6,0xa018
             //dprintf("\nFlash Laddress: 0x%X\n\n\r",(flash_addr_t));
            
            //DMA read
            //rtk_writel((~TAG_DIS) & (DESC0|DMARE|LBC_128),NADCRR);       //enable tag access
            //disable tag access
            rtk_writel ((TAG_DIS | DESC0 | DMARE | LBC_128), NADCRR);
80005080:	36d6a010 	ori	s6,s6,0xa010
80005084:	2417005b 	li	s7,91
    
    //DMA read
    //dprintf("\n\n(DMA Read)\r");
    while (dma_size > 0)
    {
      dma_counter = page_size >> 9;
80005088:	3c028001 	lui	v0,0x8001
8000508c:	8c5e75e4 	lw	s8,30180(v0)
80005090:	001ef242 	srl	s8,s8,0x9
      while (dma_counter > 0) //Move 1 page
80005094:	1bc0001b 	blez	s8,80005104 <rtk_read_ecc_page+0x1b4>
80005098:	8fa20018 	lw	v0,24(sp)
8000509c:	00028a40 	sll	s1,v0,0x9
800050a0:	8fa2004c 	lw	v0,76(sp)
800050a4:	00518821 	addu	s1,v0,s1
800050a8:	03c09021 	move	s2,s8
            {
              dma_total_Rcounter++;
              
                //dprintf("\nNAND_dma_Rcounter_512Bytes=0x%x\n",dma_total_Rcounter);
            }
          check_ready_nand ();
800050ac:	0c000f80 	jal	80003e00 <check_ready_nand>
800050b0:	00000000 	nop
          
            //set DMA RAM start address
            dram_sa = ((unsigned int) image_addr + buf_pos * 512) & (~M_mask);
          rtk_writel (dram_sa, NADRSAR);
800050b4:	02331024 	and	v0,s1,s3
800050b8:	ae820000 	sw	v0,0(s4)
          
             //dprintf("\nDMA-R:SDRAM address: 0x%X\n ",(dram_sa));
            
            //set DMA flash start address
            rtk_writel (flash_addr_t, NADFSAR);
800050bc:	aeb00000 	sw	s0,0(s5)
             //dprintf("\nFlash Laddress: 0x%X\n\n\r",(flash_addr_t));
            
            //DMA read
            //rtk_writel((~TAG_DIS) & (DESC0|DMARE|LBC_128),NADCRR);       //enable tag access
            //disable tag access
            rtk_writel ((TAG_DIS | DESC0 | DMARE | LBC_128), NADCRR);
800050c0:	aed70000 	sw	s7,0(s6)
            check_ready_nand ();
800050c4:	0c000f80 	jal	80003e00 <check_ready_nand>
800050c8:	26100210 	addiu	s0,s0,528
          
#endif  /*  */
            dma_counter--;
          buf_pos++;
          dma_size -= 512;
          flush_cache ();
800050cc:	0c001eae 	jal	80007ab8 <flush_cache>
800050d0:	2652ffff 	addiu	s2,s2,-1
    //DMA read
    //dprintf("\n\n(DMA Read)\r");
    while (dma_size > 0)
    {
      dma_counter = page_size >> 9;
      while (dma_counter > 0) //Move 1 page
800050d4:	1e40fff5 	bgtz	s2,800050ac <rtk_read_ecc_page+0x15c>
800050d8:	26310200 	addiu	s1,s1,512
800050dc:	8fa20018 	lw	v0,24(sp)
800050e0:	005e1021 	addu	v0,v0,s8
800050e4:	afa20018 	sw	v0,24(sp)
800050e8:	24020001 	li	v0,1
800050ec:	005ef023 	subu	s8,v0,s8
800050f0:	001ef240 	sll	s8,s8,0x9
800050f4:	27defe00 	addiu	s8,s8,-512
800050f8:	8fa20010 	lw	v0,16(sp)
800050fc:	005e1021 	addu	v0,v0,s8
80005100:	afa20010 	sw	v0,16(sp)
  
#endif  /*  */
    
    //DMA read
    //dprintf("\n\n(DMA Read)\r");
    while (dma_size > 0)
80005104:	8fa20010 	lw	v0,16(sp)
80005108:	18400004 	blez	v0,8000511c <rtk_read_ecc_page+0x1cc>
8000510c:	8fb00014 	lw	s0,20(sp)
80005110:	26021000 	addiu	v0,s0,4096
80005114:	08001422 	j	80005088 <rtk_read_ecc_page+0x138>
80005118:	afa20014 	sw	v0,20(sp)
        flash_addr_t1 = (page_counter * 0x1000) + (page_start * 0x1000);
           
#endif  /*  */
	 flash_addr_t = flash_addr_t1;
    }
  flush_cache ();
8000511c:	0c001eae 	jal	80007ab8 <flush_cache>
80005120:	00000000 	nop
}
80005124:	8fbf0044 	lw	ra,68(sp)
80005128:	8fbe0040 	lw	s8,64(sp)
8000512c:	8fb7003c 	lw	s7,60(sp)
80005130:	8fb60038 	lw	s6,56(sp)
80005134:	8fb50034 	lw	s5,52(sp)
80005138:	8fb40030 	lw	s4,48(sp)
8000513c:	8fb3002c 	lw	s3,44(sp)
80005140:	8fb20028 	lw	s2,40(sp)
80005144:	8fb10024 	lw	s1,36(sp)
80005148:	8fb00020 	lw	s0,32(sp)
8000514c:	03e00008 	jr	ra
80005150:	27bd0048 	addiu	sp,sp,72

80005154 <rtk_erase_block>:
}

#define REG32(reg)	(*(volatile unsigned int *)(reg))
#if 1
int rtk_erase_block (int page ) 
{
80005154:	27bdffc0 	addiu	sp,sp,-64
80005158:	afbf003c 	sw	ra,60(sp)
8000515c:	afb30038 	sw	s3,56(sp)
80005160:	afb20034 	sw	s2,52(sp)
80005164:	afb10030 	sw	s1,48(sp)
80005168:	afb0002c 	sw	s0,44(sp)
  //dprintf("[%s]:%d for boot safe debug return directly\n",__func__,__LINE__);
  //return FAIL;

    //debug cl for safe not write in 0,1 block that is for boot.
	//if(page < 128||page > chip_size/page_size - 1)
	if(page > chip_size/page_size - 1)
8000516c:	3c028002 	lui	v0,0x8002
80005170:	8c433d80 	lw	v1,15744(v0)
80005174:	3c028001 	lui	v0,0x8001
80005178:	8c4275e4 	lw	v0,30180(v0)
8000517c:	0062001b 	divu	zero,v1,v0
80005180:	004001f4 	teq	v0,zero,0x7
80005184:	00001812 	mflo	v1
80005188:	2462ffff 	addiu	v0,v1,-1
8000518c:	0044102b 	sltu	v0,v0,a0
80005190:	10400009 	beqz	v0,800051b8 <rtk_erase_block+0x64>
80005194:	00808021 	move	s0,a0
	{
		dprintf("[%s]:%d panic:fatal error *************,try to write in 0,1 block for boot,protect for debug\n",__func__,__LINE__);
80005198:	3c048001 	lui	a0,0x8001
8000519c:	2484468c 	addiu	a0,a0,18060
800051a0:	3c058001 	lui	a1,0x8001
800051a4:	24a50488 	addiu	a1,a1,1160
800051a8:	0c002325 	jal	80008c94 <dprintf>
800051ac:	2406010e 	li	a2,270
    rtk_writel ((CECS0 | CMD_BLK_ERASE_C2), NACMR);
  check_ready_nand ();
  rtk_writel ((CECS0 | CMD_BLK_ERASE_C3), NACMR);
  check_ready_nand ();
  return;
}
800051b0:	0800149d 	j	80005274 <rtk_erase_block+0x120>
800051b4:	2402ffff 	li	v0,-1
  dprintf ("Erase NAND Flash Size=0x%x ~ 0x%x\n\n\r", (528) * page, 
            ((528) * (page + 32)) - 1);
  
#endif  /*  */
#endif  /*  */
    check_ready_nand ();
800051b8:	0c000f80 	jal	80003e00 <check_ready_nand>
800051bc:	00000000 	nop
      return;
    }
  
#endif  /*  */
#ifdef CONFIG_NAND_Flash_Large_Page_128MB_4cycles
    if (page & (ppb - 1))
800051c0:	3c028001 	lui	v0,0x8001
800051c4:	8c4275ec 	lw	v0,30188(v0)
800051c8:	2442ffff 	addiu	v0,v0,-1
800051cc:	02028824 	and	s1,s0,v0
800051d0:	12200006 	beqz	s1,800051ec <rtk_erase_block+0x98>
800051d4:	3c048001 	lui	a0,0x8001
    {
      dprintf ("page %d is not block alignment (1 block=64=0x40 pages)!!\n",
800051d8:	24844914 	addiu	a0,a0,18708
800051dc:	0c002325 	jal	80008c94 <dprintf>
800051e0:	02002821 	move	a1,s0
                page);
      return;
800051e4:	0800149e 	j	80005278 <rtk_erase_block+0x124>
800051e8:	8fbf003c 	lw	ra,60(sp)
                page);
      return;
    }
  
#endif  /*  */
    check_ready_nand ();
800051ec:	0c000f80 	jal	80003e00 <check_ready_nand>
800051f0:	3c11b801 	lui	s1,0xb801
  
    //rtk_writel( (rtk_readl(NACR) |ECC_enable|RBO), NACR);
    //JSW RBO=0 ,WBO=0
    rtk_writel ((rtk_readl (NACR) | ECC_enable & ~(3 << 28)), NACR);
800051f4:	3622a004 	ori	v0,s1,0xa004
800051f8:	8c430000 	lw	v1,0(v0)
800051fc:	3c124000 	lui	s2,0x4000
80005200:	00721825 	or	v1,v1,s2
80005204:	ac430000 	sw	v1,0(v0)
  rtk_writel ((NWER | NRER | NDRS | NDWS), NASR);
80005208:	3622a028 	ori	v0,s1,0xa028
8000520c:	2403000f 	li	v1,15
80005210:	ac430000 	sw	v1,0(v0)
  rtk_writel (0x0, NACMR);
80005214:	3633a008 	ori	s3,s1,0xa008
80005218:	ae600000 	sw	zero,0(s3)
  rtk_writel ((CECS0 | CMD_BLK_ERASE_C1), NACMR);
8000521c:	36420060 	ori	v0,s2,0x60
80005220:	ae620000 	sw	v0,0(s3)
  check_ready_nand ();
80005224:	0c000f80 	jal	80003e00 <check_ready_nand>
80005228:	3631a00c 	ori	s1,s1,0xa00c
    (((~enNextAD) & AD2EN | AD1EN | AD0EN | (addr_cycle[2] << CE_ADDR0) | 
      (addr_cycle[3] << CE_ADDR1) | (addr_cycle[4] << CE_ADDR2) ), NAADR);
  
#endif  /*  */
#ifdef CONFIG_NAND_Flash_Large_Page_128MB_4cycles
    addr_cycle[0] = addr_cycle[1] = 0;
8000522c:	afa00014 	sw	zero,20(sp)
80005230:	afa00010 	sw	zero,16(sp)
  for (page_shift = 0; page_shift < 2; page_shift++)
    {
      addr_cycle[page_shift + 2] = (page >> (8 * page_shift)) & 0xff;
80005234:	320200ff 	andi	v0,s0,0xff
80005238:	afa20018 	sw	v0,24(sp)
8000523c:	7e103a00 	ext	s0,s0,0x8,0x8
80005240:	afb0001c 	sw	s0,28(sp)
    }
  
    //rtk_writel( (enNextAD|AD2EN|AD1EN|AD0EN|(addr_cycle[2]<<CE_ADDR2)),NAADR);
    rtk_writel 
80005244:	3c030300 	lui	v1,0x300
80005248:	00431025 	or	v0,v0,v1
8000524c:	00108200 	sll	s0,s0,0x8
80005250:	00508025 	or	s0,v0,s0
80005254:	ae300000 	sw	s0,0(s1)
   //dprintf ("page=0x%x\n",page);
   //dprintf ("NAADR_data=0x%x\n",NAADR_data);
   //dprintf ("NAADR=0x%x\n",REG32(NAADR));
  
#endif  /*  */
    rtk_writel ((CECS0 | CMD_BLK_ERASE_C2), NACMR);
80005258:	364200d0 	ori	v0,s2,0xd0
8000525c:	ae620000 	sw	v0,0(s3)
  check_ready_nand ();
80005260:	0c000f80 	jal	80003e00 <check_ready_nand>
80005264:	36520070 	ori	s2,s2,0x70
  rtk_writel ((CECS0 | CMD_BLK_ERASE_C3), NACMR);
80005268:	ae720000 	sw	s2,0(s3)
  check_ready_nand ();
8000526c:	0c000f80 	jal	80003e00 <check_ready_nand>
80005270:	00000000 	nop
  return;
}
80005274:	8fbf003c 	lw	ra,60(sp)
80005278:	8fb30038 	lw	s3,56(sp)
8000527c:	8fb20034 	lw	s2,52(sp)
80005280:	8fb10030 	lw	s1,48(sp)
80005284:	8fb0002c 	lw	s0,44(sp)
80005288:	03e00008 	jr	ra
8000528c:	27bd0040 	addiu	sp,sp,64

80005290 <rtk_write_ecc_page>:
#if 1

void 
rtk_write_ecc_page (unsigned long flash_address, unsigned char *image_addr,
                    unsigned int image_size ) 
{
80005290:	27bdffb8 	addiu	sp,sp,-72
80005294:	afbf0044 	sw	ra,68(sp)
80005298:	afbe0040 	sw	s8,64(sp)
8000529c:	afb7003c 	sw	s7,60(sp)
800052a0:	afb60038 	sw	s6,56(sp)
800052a4:	afb50034 	sw	s5,52(sp)
800052a8:	afb40030 	sw	s4,48(sp)
800052ac:	afb3002c 	sw	s3,44(sp)
800052b0:	afb20028 	sw	s2,40(sp)
800052b4:	afb10024 	sw	s1,36(sp)
800052b8:	afb00020 	sw	s0,32(sp)
800052bc:	00808821 	move	s1,a0
800052c0:	afa5004c 	sw	a1,76(sp)
  //debug cl
  //dprintf("[%s]:%d for boot safe debug return directly\n",__func__,__LINE__);
  //return FAIL;
  //end debug cl
  flush_cache ();
800052c4:	0c001eae 	jal	80007ab8 <flush_cache>
800052c8:	00c09821 	move	s3,a2


    int page = flash_address / (page_size + oob_size);
800052cc:	3c028001 	lui	v0,0x8001
800052d0:	8c4575e4 	lw	a1,30180(v0)
800052d4:	3c028001 	lui	v0,0x8001
800052d8:	8c4675e8 	lw	a2,30184(v0)
800052dc:	00c51021 	addu	v0,a2,a1
	//if(page < 128||page > chip_size/page_size - 1)
	if(page > chip_size/page_size - 1)
800052e0:	0222001b 	divu	zero,s1,v0
800052e4:	004001f4 	teq	v0,zero,0x7
800052e8:	00001812 	mflo	v1
800052ec:	3c048002 	lui	a0,0x8002
800052f0:	8c843d80 	lw	a0,15744(a0)
800052f4:	0085001b 	divu	zero,a0,a1
800052f8:	00a001f4 	teq	a1,zero,0x7
800052fc:	00003812 	mflo	a3
80005300:	24e4ffff 	addiu	a0,a3,-1
80005304:	0083182b 	sltu	v1,a0,v1
80005308:	10600008 	beqz	v1,8000532c <rtk_write_ecc_page+0x9c>
8000530c:	3c048001 	lui	a0,0x8001
	{
		dprintf("[%s]:%d panic:fatal error *************,try to write in 0,1 block for boot,protect for debug\n",__func__,__LINE__);
80005310:	2484468c 	addiu	a0,a0,18060
80005314:	3c058001 	lui	a1,0x8001
80005318:	24a50464 	addiu	a1,a1,1124
8000531c:	0c002325 	jal	80008c94 <dprintf>
80005320:	24060309 	li	a2,777
		return FAIL;
80005324:	08001542 	j	80005508 <rtk_write_ecc_page+0x278>
80005328:	8fbf0044 	lw	ra,68(sp)
  int page_num[3], page_shift = 0, page_start;
  unsigned long flash_addr_t = 0, flash_addr_t1;
  char *oob_buf;
  int dma_total_Wcounter = 0;
  
  if ((flash_address % (page_size + oob_size)) != 0)
8000532c:	0222001b 	divu	zero,s1,v0
80005330:	004001f4 	teq	v0,zero,0x7
80005334:	00001010 	mfhi	v0
80005338:	10400005 	beqz	v0,80005350 <rtk_write_ecc_page+0xc0>
8000533c:	3c048001 	lui	a0,0x8001
    {
      dprintf ("\n\rflash_address must be page(0x%x+0x%x Bytes) aligned!\n",
80005340:	0c002325 	jal	80008c94 <dprintf>
80005344:	24844654 	addiu	a0,a0,18004
                page_size, oob_size);
      return;
80005348:	08001542 	j	80005508 <rtk_write_ecc_page+0x278>
8000534c:	8fbf0044 	lw	ra,68(sp)
    }
  
  oob_buf = malloc (oob_size);
80005350:	0c001f55 	jal	80007d54 <malloc>
80005354:	00c02021 	move	a0,a2
  if (!oob_buf)
80005358:	14400006 	bnez	v0,80005374 <rtk_write_ecc_page+0xe4>
8000535c:	3c028001 	lui	v0,0x8001
    {
      dprintf ("allocate fail!!\n\r");
80005360:	3c048001 	lui	a0,0x8001
80005364:	0c002325 	jal	80008c94 <dprintf>
80005368:	24844950 	addiu	a0,a0,18768
      return;
8000536c:	08001542 	j	80005508 <rtk_write_ecc_page+0x278>
80005370:	8fbf0044 	lw	ra,68(sp)
      dma_size += (image_size % 2048);
    }
  
#endif  /*  */
#ifdef CONFIG_NAND_Flash_Large_Page_128MB_4cycles
    if (image_size % page_size)
80005374:	8c4275e4 	lw	v0,30180(v0)
80005378:	0262001b 	divu	zero,s3,v0
8000537c:	004001f4 	teq	v0,zero,0x7
80005380:	00001810 	mfhi	v1
80005384:	10600004 	beqz	v1,80005398 <rtk_write_ecc_page+0x108>
80005388:	afb30014 	sw	s3,20(sp)
    {
      dma_size += (image_size % 2048);
8000538c:	326307ff 	andi	v1,s3,0x7ff
80005390:	00731821 	addu	v1,v1,s3
80005394:	afa30014 	sw	v1,20(sp)
    /*Translate nand flash address formula */ 
#if 0                           //def NAND_Flash_Small_Page_32MB_3cycles
    flash_addr_t = flash_address;
  
#else   /*  */
    page_start = flash_address / (page_size + oob_size);
80005398:	3c038001 	lui	v1,0x8001
8000539c:	8c7475e8 	lw	s4,30184(v1)
800053a0:	00541021 	addu	v0,v0,s4
800053a4:	0222001b 	divu	zero,s1,v0
800053a8:	004001f4 	teq	v0,zero,0x7
800053ac:	0000a012 	mflo	s4
800053b0:	00001021 	move	v0,zero
800053b4:	00008021 	move	s0,zero
  for (page_shift = 0; page_shift < 3; page_shift++)
800053b8:	24050018 	li	a1,24
    {
      page_num[page_shift] = ((page_start >> (8 * page_shift)) & 0xff);
      flash_addr_t |= (page_num[page_shift] << (12 + 8 * page_shift));
800053bc:	00541807 	srav	v1,s4,v0
800053c0:	306300ff 	andi	v1,v1,0xff
800053c4:	2444000c 	addiu	a0,v0,12
800053c8:	00831804 	sllv	v1,v1,a0
800053cc:	24420008 	addiu	v0,v0,8
#if 0                           //def NAND_Flash_Small_Page_32MB_3cycles
    flash_addr_t = flash_address;
  
#else   /*  */
    page_start = flash_address / (page_size + oob_size);
  for (page_shift = 0; page_shift < 3; page_shift++)
800053d0:	1445fffa 	bne	v0,a1,800053bc <rtk_write_ecc_page+0x12c>
800053d4:	02038025 	or	s0,s0,v1
#endif  /*  */
#ifdef CONFIG_NAND_Flash_Large_Page_128MB_4cycles
    
    //Erase NAND
  unsigned int NAND_Blk_ecnt;
  unsigned int NAND_Blk_ecnt_start = flash_address / (2112 * 64);
800053d8:	3c023e0f 	lui	v0,0x3e0f
800053dc:	344283e1 	ori	v0,v0,0x83e1
800053e0:	02220019 	multu	s1,v0
800053e4:	00008810 	mfhi	s1
800053e8:	001193c2 	srl	s2,s1,0xf
  for (NAND_Blk_ecnt = NAND_Blk_ecnt_start;
        NAND_Blk_ecnt <= (NAND_Blk_ecnt_start + (image_size / (2048 * 64)));
800053ec:	00139c42 	srl	s3,s3,0x11
800053f0:	02729821 	addu	s3,s3,s2
#ifdef CONFIG_NAND_Flash_Large_Page_128MB_4cycles
    
    //Erase NAND
  unsigned int NAND_Blk_ecnt;
  unsigned int NAND_Blk_ecnt_start = flash_address / (2112 * 64);
  for (NAND_Blk_ecnt = NAND_Blk_ecnt_start;
800053f4:	0272102b 	sltu	v0,s3,s2
800053f8:	14400009 	bnez	v0,80005420 <rtk_write_ecc_page+0x190>
800053fc:	8fa20014 	lw	v0,20(sp)
80005400:	00128980 	sll	s1,s2,0x6
        NAND_Blk_ecnt <= (NAND_Blk_ecnt_start + (image_size / (2048 * 64)));
        NAND_Blk_ecnt++)
    {
      rtk_erase_block (NAND_Blk_ecnt * 64);     //JSW:Large page's block=64=0x40 pages , it needs input page count
80005404:	0c001455 	jal	80005154 <rtk_erase_block>
80005408:	02202021 	move	a0,s1
    //Erase NAND
  unsigned int NAND_Blk_ecnt;
  unsigned int NAND_Blk_ecnt_start = flash_address / (2112 * 64);
  for (NAND_Blk_ecnt = NAND_Blk_ecnt_start;
        NAND_Blk_ecnt <= (NAND_Blk_ecnt_start + (image_size / (2048 * 64)));
        NAND_Blk_ecnt++)
8000540c:	26520001 	addiu	s2,s2,1
#ifdef CONFIG_NAND_Flash_Large_Page_128MB_4cycles
    
    //Erase NAND
  unsigned int NAND_Blk_ecnt;
  unsigned int NAND_Blk_ecnt_start = flash_address / (2112 * 64);
  for (NAND_Blk_ecnt = NAND_Blk_ecnt_start;
80005410:	0272102b 	sltu	v0,s3,s2
80005414:	1040fffb 	beqz	v0,80005404 <rtk_write_ecc_page+0x174>
80005418:	26310040 	addiu	s1,s1,64
    }
  
#endif  /*  */


    while (dma_size > 0)
8000541c:	8fa20014 	lw	v0,20(sp)
80005420:	18400036 	blez	v0,800054fc <rtk_write_ecc_page+0x26c>
80005424:	26940001 	addiu	s4,s4,1
80005428:	0014a300 	sll	s4,s4,0xc
8000542c:	afb40018 	sw	s4,24(sp)
80005430:	afa0001c 	sw	zero,28(sp)
      while (dma_counter > 0) //Move 1 page
        {
          
            //prom_printf("\n DMA(512 Bytes) Start, DMA total count=%d\n\n\r",buf_pos);
            check_ready_nand ();
          rtk_writel ((rtk_readl (NACR) | ECC_enable), NACR);
80005434:	3c1eb801 	lui	s8,0xb801
80005438:	37d3a004 	ori	s3,s8,0xa004
8000543c:	3c144000 	lui	s4,0x4000
          
            //set DMA RAM start address
            dram_sa = ((unsigned int) image_addr + buf_pos * 512) & (~M_mask);
          rtk_writel (dram_sa, NADRSAR);
80005440:	3c151fff 	lui	s5,0x1fff
80005444:	36b5ffff 	ori	s5,s5,0xffff
80005448:	37d6a020 	ori	s6,s8,0xa020
          
           //dprintf("\nDMA-W:SDRAM address: 0x%X\n ",(dram_sa));
            //set DMA flash start address
            //flash_addr_t &= 0x1fffffff;
          rtk_writel (flash_addr_t, NADFSAR);
8000544c:	37d7a018 	ori	s7,s8,0xa018
          
            //dprintf("\nFlash Laddress: 0x%X\n\n\r",(flash_addr_t));
            //set OOB address
            //rtk_writel(oob_sa, NADTSAR);
            //DMA write
            rtk_writel ((~TAG_DIS) &
80005450:	37dea010 	ori	s8,s8,0xa010
#endif  /*  */


    while (dma_size > 0)
    {
      dma_counter = page_size >> 9;
80005454:	3c038001 	lui	v1,0x8001
80005458:	8c6275e4 	lw	v0,30180(v1)
8000545c:	00021242 	srl	v0,v0,0x9
      while (dma_counter > 0) //Move 1 page
80005460:	18400020 	blez	v0,800054e4 <rtk_write_ecc_page+0x254>
80005464:	afa20010 	sw	v0,16(sp)
80005468:	8fa4001c 	lw	a0,28(sp)
8000546c:	00048a40 	sll	s1,a0,0x9
80005470:	8fa7004c 	lw	a3,76(sp)
80005474:	00f18821 	addu	s1,a3,s1
80005478:	00409021 	move	s2,v0
        {
          
            //prom_printf("\n DMA(512 Bytes) Start, DMA total count=%d\n\n\r",buf_pos);
            check_ready_nand ();
8000547c:	0c000f80 	jal	80003e00 <check_ready_nand>
80005480:	00000000 	nop
          rtk_writel ((rtk_readl (NACR) | ECC_enable), NACR);
80005484:	8e620000 	lw	v0,0(s3)
80005488:	00541025 	or	v0,v0,s4
8000548c:	ae620000 	sw	v0,0(s3)
          
            //set DMA RAM start address
            dram_sa = ((unsigned int) image_addr + buf_pos * 512) & (~M_mask);
          rtk_writel (dram_sa, NADRSAR);
80005490:	02351024 	and	v0,s1,s5
80005494:	aec20000 	sw	v0,0(s6)
          
           //dprintf("\nDMA-W:SDRAM address: 0x%X\n ",(dram_sa));
            //set DMA flash start address
            //flash_addr_t &= 0x1fffffff;
          rtk_writel (flash_addr_t, NADFSAR);
80005498:	aef00000 	sw	s0,0(s7)
          
            //dprintf("\nFlash Laddress: 0x%X\n\n\r",(flash_addr_t));
            //set OOB address
            //rtk_writel(oob_sa, NADTSAR);
            //DMA write
            rtk_writel ((~TAG_DIS) &
8000549c:	24020017 	li	v0,23
800054a0:	afc20000 	sw	v0,0(s8)
                        ((0 << TAG_SEL) | DESC0 | DMAWE | LBC_128), NADCRR);
          check_ready_nand ();
800054a4:	0c000f80 	jal	80003e00 <check_ready_nand>
800054a8:	26100210 	addiu	s0,s0,528
          
#else   /*  */
            flash_addr_t += 528;
          
#endif  /*  */
            dma_counter--;
800054ac:	2652ffff 	addiu	s2,s2,-1


    while (dma_size > 0)
    {
      dma_counter = page_size >> 9;
      while (dma_counter > 0) //Move 1 page
800054b0:	1e40fff2 	bgtz	s2,8000547c <rtk_write_ecc_page+0x1ec>
800054b4:	26310200 	addiu	s1,s1,512
800054b8:	8fa3001c 	lw	v1,28(sp)
800054bc:	8fa40010 	lw	a0,16(sp)
800054c0:	00641821 	addu	v1,v1,a0
800054c4:	afa3001c 	sw	v1,28(sp)
800054c8:	24070001 	li	a3,1
800054cc:	00e41023 	subu	v0,a3,a0
800054d0:	00021240 	sll	v0,v0,0x9
800054d4:	2442fe00 	addiu	v0,v0,-512
800054d8:	8fa30014 	lw	v1,20(sp)
800054dc:	00621821 	addu	v1,v1,v0
800054e0:	afa30014 	sw	v1,20(sp)
    }
  
#endif  /*  */


    while (dma_size > 0)
800054e4:	8fa40014 	lw	a0,20(sp)
800054e8:	18800004 	blez	a0,800054fc <rtk_write_ecc_page+0x26c>
800054ec:	8fb00018 	lw	s0,24(sp)
800054f0:	26071000 	addiu	a3,s0,4096
800054f4:	08001515 	j	80005454 <rtk_write_ecc_page+0x1c4>
800054f8:	afa70018 	sw	a3,24(sp)
        flash_addr_t1 = (page_counter * 0x1000) + (page_start * 0x1000);
           
#endif  /*  */
	 flash_addr_t = flash_addr_t1;
    }
  flush_cache ();
800054fc:	0c001eae 	jal	80007ab8 <flush_cache>
80005500:	00000000 	nop

 
}
80005504:	8fbf0044 	lw	ra,68(sp)
80005508:	8fbe0040 	lw	s8,64(sp)
8000550c:	8fb7003c 	lw	s7,60(sp)
80005510:	8fb60038 	lw	s6,56(sp)
80005514:	8fb50034 	lw	s5,52(sp)
80005518:	8fb40030 	lw	s4,48(sp)
8000551c:	8fb3002c 	lw	s3,44(sp)
80005520:	8fb20028 	lw	s2,40(sp)
80005524:	8fb10024 	lw	s1,36(sp)
80005528:	8fb00020 	lw	s0,32(sp)
8000552c:	03e00008 	jr	ra
80005530:	27bd0048 	addiu	sp,sp,72

80005534 <rtk_update_bbt>:
	}		
	return rc;

}
int rtk_update_bbt (struct BB_t *bbt)
{
80005534:	27bdffa8 	addiu	sp,sp,-88
80005538:	afbf0054 	sw	ra,84(sp)
8000553c:	afbe0050 	sw	s8,80(sp)
80005540:	afb7004c 	sw	s7,76(sp)
80005544:	afb60048 	sw	s6,72(sp)
80005548:	afb50044 	sw	s5,68(sp)
8000554c:	afb40040 	sw	s4,64(sp)
80005550:	afb3003c 	sw	s3,60(sp)
80005554:	afb20038 	sw	s2,56(sp)
80005558:	afb10034 	sw	s1,52(sp)
8000555c:	afb00030 	sw	s0,48(sp)
80005560:	00808821 	move	s1,a0
	unsigned char mem_page_num=0, page_counter=0;
	unsigned char mem_page_num_tmp=0, page_counter_tmp=0;

	//czyao, reserve 1M bytes area for bootloader, and the last 2 blocks of 1M area is for bad block table
	//bbt_page = ((BOOT_SIZE/block_size)-BACKUP_BBT)*ppb;
	bbt_page = ((REMAP_BBT_POS/block_size)+BACKUP_BBT)*ppb;
80005564:	3c140010 	lui	s4,0x10
80005568:	3c028001 	lui	v0,0x8001
8000556c:	8c4275c4 	lw	v0,30148(v0)
80005570:	0282001a 	div	zero,s4,v0
80005574:	004001f4 	teq	v0,zero,0x7
80005578:	0000a012 	mflo	s4
8000557c:	26940003 	addiu	s4,s4,3
80005580:	3c028001 	lui	v0,0x8001
80005584:	8c4375ec 	lw	v1,30188(v0)
80005588:	7283a002 	mul	s4,s4,v1
	
	//dprintf("[%s]:%d (BOOT_SIZE/block_size) = %d\n",__func__,__LINE__,BOOT_SIZE/block_size); //should be 8
	mem_page_num = (sizeof(struct BB_t)*RBA + page_size-1 )/page_size;
8000558c:	3c028001 	lui	v0,0x8001
80005590:	8c4475e4 	lw	a0,30180(v0)
80005594:	2483ffff 	addiu	v1,a0,-1
80005598:	3c028002 	lui	v0,0x8002
8000559c:	8c422e74 	lw	v0,11892(v0)
800055a0:	000210c0 	sll	v0,v0,0x3
800055a4:	00621021 	addu	v0,v1,v0
800055a8:	0044001b 	divu	zero,v0,a0
800055ac:	008001f4 	teq	a0,zero,0x7
800055b0:	00001012 	mflo	v0
800055b4:	304200ff 	andi	v0,v0,0xff
800055b8:	afa20018 	sw	v0,24(sp)
	//printf("[%s] mem_page_num %d\n\r", __FUNCTION__, mem_page_num);
	
	temp_BBT = (unsigned char *)malloc(mem_page_num*page_size);
800055bc:	00408021 	move	s0,v0
800055c0:	0c001f55 	jal	80007d54 <malloc>
800055c4:	70442002 	mul	a0,v0,a0
	if ( !(temp_BBT) ){
800055c8:	14400008 	bnez	v0,800055ec <rtk_update_bbt+0xb8>
800055cc:	0040b021 	move	s6,v0
		printf("%s: Error, no enough memory for temp_BBT\n",__FUNCTION__);
800055d0:	3c048001 	lui	a0,0x8001
800055d4:	24844964 	addiu	a0,a0,18788
800055d8:	3c058001 	lui	a1,0x8001
800055dc:	0c002325 	jal	80008c94 <dprintf>
800055e0:	24a502fc 	addiu	a1,a1,764
		return FAIL;
800055e4:	080015dc 	j	80005770 <rtk_update_bbt+0x23c>
800055e8:	2402ffff 	li	v0,-1
	}	
	memset(temp_BBT, 0xff, mem_page_num*page_size);
800055ec:	3c028001 	lui	v0,0x8001
800055f0:	8c4675e4 	lw	a2,30180(v0)
800055f4:	02c02021 	move	a0,s6
800055f8:	240500ff 	li	a1,255
800055fc:	0c00203d 	jal	800080f4 <memset>
80005600:	72063002 	mul	a2,s0,a2
	memcpy(temp_BBT, bbt, sizeof(struct BB_t)*RBA );
80005604:	3c028002 	lui	v0,0x8002
80005608:	8c462e74 	lw	a2,11892(v0)
8000560c:	02c02021 	move	a0,s6
80005610:	02202821 	move	a1,s1
80005614:	0c002046 	jal	80008118 <memcpy>
80005618:	000630c0 	sll	a2,a2,0x3
8000561c:	afa00014 	sw	zero,20(sp)
80005620:	afa00010 	sw	zero,16(sp)
    for(i=0;i<BACKUP_BBT;i++){
		mem_page_num_tmp = mem_page_num;
		page_counter=0;
		if(!NAND_ADDR_CYCLE)
		#ifdef SWAP_2K_DATA
			NfSpareBuf[BBI_SWAP_OFFSET] = BBT_TAG;
80005624:	3c178002 	lui	s7,0x8002
80005628:	26f75768 	addiu	s7,s7,22376
		#else
			NfSpareBuf[0] = BBT_TAG;
		#endif
		else
			NfSpareBuf[5] = BBT_TAG;
		if(rtk_erase_block_a(bbt_page+(ppb*i))){
8000562c:	3c128001 	lui	s2,0x8001
			printf("[%s]error: erase BBT%d page %d failure\n\r", __FUNCTION__,i, bbt_page+(ppb*i));
			/*erase fail: mean this block is bad, so do not write data!!!*/
			mem_page_num_tmp = 0; 
			error_count++;
		}
		while( mem_page_num_tmp>0 ){
80005630:	8fa20018 	lw	v0,24(sp)
80005634:	afa20020 	sw	v0,32(sp)
			//if ( this->write_ecc_page(mtd, 0, page+page_counter, temp_BBT+page_counter*page_size, 
			//	this->g_oobbuf, 1) )
			if(rtk_write_ecc_page_a(bbt_page+(ppb*i)+page_counter,temp_BBT+page_counter*page_size, &NfSpareBuf, page_size))	{
80005638:	3c138001 	lui	s3,0x8001
					printf("[%s] write BBT%d page %d failure!!\n\r", __FUNCTION__,i, bbt_page+(ppb*i)+page_counter);
8000563c:	3c028001 	lui	v0,0x8001
80005640:	244249bc 	addiu	v0,v0,18876
80005644:	afa20024 	sw	v0,36(sp)
80005648:	3c028001 	lui	v0,0x8001
8000564c:	244202fc 	addiu	v0,v0,764
80005650:	afa2001c 	sw	v0,28(sp)
			NfSpareBuf[0] = BBT_TAG;
		#endif
		else
			NfSpareBuf[5] = BBT_TAG;
		if(rtk_erase_block_a(bbt_page+(ppb*i))){
			printf("[%s]error: erase BBT%d page %d failure\n\r", __FUNCTION__,i, bbt_page+(ppb*i));
80005654:	3c028001 	lui	v0,0x8001
80005658:	24424990 	addiu	v0,v0,18832
8000565c:	afa20028 	sw	v0,40(sp)
    for(i=0;i<BACKUP_BBT;i++){
		mem_page_num_tmp = mem_page_num;
		page_counter=0;
		if(!NAND_ADDR_CYCLE)
		#ifdef SWAP_2K_DATA
			NfSpareBuf[BBI_SWAP_OFFSET] = BBT_TAG;
80005660:	2403ffbb 	li	v1,-69
80005664:	a2e30035 	sb	v1,53(s7)
80005668:	8fb50010 	lw	s5,16(sp)
		#else
			NfSpareBuf[0] = BBT_TAG;
		#endif
		else
			NfSpareBuf[5] = BBT_TAG;
		if(rtk_erase_block_a(bbt_page+(ppb*i))){
8000566c:	8e4475ec 	lw	a0,30188(s2)
80005670:	72a41002 	mul	v0,s5,a0
80005674:	0c001048 	jal	80004120 <rtk_erase_block_a>
80005678:	00542021 	addu	a0,v0,s4
8000567c:	1040000c 	beqz	v0,800056b0 <rtk_update_bbt+0x17c>
80005680:	8fa20018 	lw	v0,24(sp)
			printf("[%s]error: erase BBT%d page %d failure\n\r", __FUNCTION__,i, bbt_page+(ppb*i));
80005684:	8e4775ec 	lw	a3,30188(s2)
80005688:	8fa40028 	lw	a0,40(sp)
8000568c:	8fa5001c 	lw	a1,28(sp)
80005690:	8fa60010 	lw	a2,16(sp)
80005694:	72a71002 	mul	v0,s5,a3
80005698:	0c002325 	jal	80008c94 <dprintf>
8000569c:	00543821 	addu	a3,v0,s4
			/*erase fail: mean this block is bad, so do not write data!!!*/
			mem_page_num_tmp = 0; 
			error_count++;
800056a0:	8fa30014 	lw	v1,20(sp)
800056a4:	24630001 	addiu	v1,v1,1
800056a8:	080015cc 	j	80005730 <rtk_update_bbt+0x1fc>
800056ac:	afa30014 	sw	v1,20(sp)
		}
		while( mem_page_num_tmp>0 ){
800056b0:	1040001f 	beqz	v0,80005730 <rtk_update_bbt+0x1fc>
800056b4:	8fb10020 	lw	s1,32(sp)
800056b8:	00008021 	move	s0,zero
			//if ( this->write_ecc_page(mtd, 0, page+page_counter, temp_BBT+page_counter*page_size, 
			//	this->g_oobbuf, 1) )
			if(rtk_write_ecc_page_a(bbt_page+(ppb*i)+page_counter,temp_BBT+page_counter*page_size, &NfSpareBuf, page_size))	{
800056bc:	8e6775e4 	lw	a3,30180(s3)
800056c0:	8e4475ec 	lw	a0,30188(s2)
800056c4:	72a41002 	mul	v0,s5,a0
800056c8:	00542021 	addu	a0,v0,s4
800056cc:	00902021 	addu	a0,a0,s0
800056d0:	72071002 	mul	v0,s0,a3
800056d4:	00562821 	addu	a1,v0,s6
800056d8:	0c0011da 	jal	80004768 <rtk_write_ecc_page_a>
800056dc:	02e03021 	move	a2,s7
800056e0:	1040000e 	beqz	v0,8000571c <rtk_update_bbt+0x1e8>
800056e4:	2631ffff 	addiu	s1,s1,-1
800056e8:	26310001 	addiu	s1,s1,1
					printf("[%s] write BBT%d page %d failure!!\n\r", __FUNCTION__,i, bbt_page+(ppb*i)+page_counter);
800056ec:	8e4275ec 	lw	v0,30188(s2)
800056f0:	72a21802 	mul	v1,s5,v0
800056f4:	0074a821 	addu	s5,v1,s4
800056f8:	8fa40024 	lw	a0,36(sp)
800056fc:	8fa5001c 	lw	a1,28(sp)
80005700:	8fa60010 	lw	a2,16(sp)
80005704:	0c002325 	jal	80008c94 <dprintf>
80005708:	02b03821 	addu	a3,s5,s0
					//rc =  -1;
					//goto EXIT;
					error_count++;
8000570c:	8fa20014 	lw	v0,20(sp)
80005710:	24420001 	addiu	v0,v0,1
					break;
80005714:	080015cc 	j	80005730 <rtk_update_bbt+0x1fc>
80005718:	afa20014 	sw	v0,20(sp)
			}
		//printf("[%s, line %d] mem_page_num = %d page_counter %d\n\r",__FUNCTION__,__LINE__,mem_page_num, page_counter);
			page_counter++;
			mem_page_num_tmp--; 	
8000571c:	323100ff 	andi	s1,s1,0xff
			printf("[%s]error: erase BBT%d page %d failure\n\r", __FUNCTION__,i, bbt_page+(ppb*i));
			/*erase fail: mean this block is bad, so do not write data!!!*/
			mem_page_num_tmp = 0; 
			error_count++;
		}
		while( mem_page_num_tmp>0 ){
80005720:	12200003 	beqz	s1,80005730 <rtk_update_bbt+0x1fc>
80005724:	26100001 	addiu	s0,s0,1
					//goto EXIT;
					error_count++;
					break;
			}
		//printf("[%s, line %d] mem_page_num = %d page_counter %d\n\r",__FUNCTION__,__LINE__,mem_page_num, page_counter);
			page_counter++;
80005728:	080015af 	j	800056bc <rtk_update_bbt+0x188>
8000572c:	321000ff 	andi	s0,s0,0xff
	    NfSpareBuf[0] = BBT_TAG;
	else
	    NfSpareBuf[5] = BBT_TAG;
*/	    
//test new method
    for(i=0;i<BACKUP_BBT;i++){
80005730:	8fa30010 	lw	v1,16(sp)
80005734:	24630001 	addiu	v1,v1,1
80005738:	24020003 	li	v0,3
8000573c:	1462ffc8 	bne	v1,v0,80005660 <rtk_update_bbt+0x12c>
80005740:	afa30010 	sw	v1,16(sp)
		}		
	}
#endif
EXIT:
	if (temp_BBT)
		free(temp_BBT);
80005744:	0c001f86 	jal	80007e18 <free>
80005748:	02c02021 	move	a0,s6
    if(error_count >= BACKUP_BBT){
8000574c:	8fa20014 	lw	v0,20(sp)
80005750:	28430003 	slti	v1,v0,3
80005754:	14600006 	bnez	v1,80005770 <rtk_update_bbt+0x23c>
80005758:	00001021 	move	v0,zero
		rc = -1;
		printf("%d table are all bad!(T______T)\n\r", BACKUP_BBT);
8000575c:	3c048001 	lui	a0,0x8001
80005760:	248449e4 	addiu	a0,a0,18916
80005764:	0c002325 	jal	80008c94 <dprintf>
80005768:	24050003 	li	a1,3
8000576c:	2402ffff 	li	v0,-1
	}
	return rc;
}
80005770:	8fbf0054 	lw	ra,84(sp)
80005774:	8fbe0050 	lw	s8,80(sp)
80005778:	8fb7004c 	lw	s7,76(sp)
8000577c:	8fb60048 	lw	s6,72(sp)
80005780:	8fb50044 	lw	s5,68(sp)
80005784:	8fb40040 	lw	s4,64(sp)
80005788:	8fb3003c 	lw	s3,60(sp)
8000578c:	8fb20038 	lw	s2,56(sp)
80005790:	8fb10034 	lw	s1,52(sp)
80005794:	8fb00030 	lw	s0,48(sp)
80005798:	03e00008 	jr	ra
8000579c:	27bd0058 	addiu	sp,sp,88

800057a0 <rtk_nand_scan_bbt>:
//		NON
// Output:
//		BOOL: 0=>OK, -1=>FAIL
//####################################################################
int rtk_nand_scan_bbt(void)
{
800057a0:	27bdff88 	addiu	sp,sp,-120
800057a4:	afbf0074 	sw	ra,116(sp)
800057a8:	afbe0070 	sw	s8,112(sp)
800057ac:	afb7006c 	sw	s7,108(sp)
800057b0:	afb60068 	sw	s6,104(sp)
800057b4:	afb50064 	sw	s5,100(sp)
800057b8:	afb40060 	sw	s4,96(sp)
800057bc:	afb3005c 	sw	s3,92(sp)
800057c0:	afb20058 	sw	s2,88(sp)
800057c4:	afb10054 	sw	s1,84(sp)
800057c8:	afb00050 	sw	s0,80(sp)
	extern int block_size;
		{
    /*czyao, reserve RESERVED_AREA bytes area for bootloader, 
      and the last 'BACKUP_BBT' blocks of RESERVED_AREA area is for bad block table*/
	//bbt_page = ((BOOT_SIZE/block_size)-BACKUP_BBT)*ppb;
	bbt_page = ((REMAP_BBT_POS/block_size)+BACKUP_BBT)*ppb;
800057cc:	3c028001 	lui	v0,0x8001
800057d0:	8c4275c4 	lw	v0,30148(v0)
800057d4:	3c030010 	lui	v1,0x10
800057d8:	0062001a 	div	zero,v1,v0
800057dc:	004001f4 	teq	v0,zero,0x7
800057e0:	0000f012 	mflo	s8
800057e4:	27de0003 	addiu	s8,s8,3
800057e8:	3c038001 	lui	v1,0x8001
800057ec:	8c6475ec 	lw	a0,30188(v1)
800057f0:	73c4f002 	mul	s8,s8,a0
		}
	
	//printf("[%s, line %d] bbt_page = %d \n\r",__FUNCTION__,__LINE__,bbt_page);
	//printf("[%s, line %d] bbt_block = %d \n\r",__FUNCTION__,__LINE__,bbt_page/ppb);

	RBA = ((unsigned int)chip_size/block_size)*RBA_PERCENT / 100;
800057f4:	3c038002 	lui	v1,0x8002
800057f8:	8c633d80 	lw	v1,15744(v1)
800057fc:	0062001b 	divu	zero,v1,v0
80005800:	004001f4 	teq	v0,zero,0x7
80005804:	00001012 	mflo	v0
80005808:	3c038001 	lui	v1,0x8001
8000580c:	8c6475c8 	lw	a0,30152(v1)
80005810:	70441002 	mul	v0,v0,a0
80005814:	3c0451eb 	lui	a0,0x51eb
80005818:	3484851f 	ori	a0,a0,0x851f
8000581c:	00440019 	multu	v0,a0
80005820:	00001010 	mfhi	v0
80005824:	00021142 	srl	v0,v0,0x5
80005828:	3c038002 	lui	v1,0x8002
8000582c:	ac622e74 	sw	v0,11892(v1)

	//printf("[%s, line %d] RBA = %d \n\r",__FUNCTION__,__LINE__,RBA);

	//czyao 
	bbt = (unsigned char *) malloc(sizeof(struct BB_t)*RBA);
80005830:	0c001f55 	jal	80007d54 <malloc>
80005834:	000220c0 	sll	a0,v0,0x3
80005838:	3c038002 	lui	v1,0x8002
	if(!bbt){
8000583c:	14400009 	bnez	v0,80005864 <rtk_nand_scan_bbt+0xc4>
80005840:	ac622e78 	sw	v0,11896(v1)
		printf("%s-%d: Error, no enough memory for bbt\n",__FUNCTION__,__LINE__);
80005844:	3c048001 	lui	a0,0x8001
80005848:	24844a08 	addiu	a0,a0,18952
8000584c:	3c058001 	lui	a1,0x8001
80005850:	24a5030c 	addiu	a1,a1,780
80005854:	0c002325 	jal	80008c94 <dprintf>
80005858:	24060d94 	li	a2,3476
		return FAIL;
8000585c:	080017b3 	j	80005ecc <rtk_nand_scan_bbt+0x72c>
80005860:	2402ffff 	li	v0,-1
	}

	mem_page_num = (sizeof(struct BB_t)*RBA + page_size-1 )/page_size;
80005864:	3c028001 	lui	v0,0x8001
80005868:	8c4475e4 	lw	a0,30180(v0)
8000586c:	2483ffff 	addiu	v1,a0,-1
80005870:	3c028002 	lui	v0,0x8002
80005874:	8c422e74 	lw	v0,11892(v0)
80005878:	000210c0 	sll	v0,v0,0x3
8000587c:	00621021 	addu	v0,v1,v0
80005880:	0044001b 	divu	zero,v0,a0
80005884:	008001f4 	teq	a0,zero,0x7
80005888:	00001012 	mflo	v0
8000588c:	304200ff 	andi	v0,v0,0xff
80005890:	afa20024 	sw	v0,36(sp)
	//printf("[%s, line %d] mem_page_num = %d\n\r",__FUNCTION__,__LINE__,mem_page_num);

	temp_BBT =(unsigned char *)malloc( mem_page_num*page_size );
80005894:	00408021 	move	s0,v0
80005898:	0c001f55 	jal	80007d54 <malloc>
8000589c:	70442002 	mul	a0,v0,a0
	if(!temp_BBT){
800058a0:	14400008 	bnez	v0,800058c4 <rtk_nand_scan_bbt+0x124>
800058a4:	00409821 	move	s3,v0
		printf("%s: Error, no enough memory for temp_BBT\n",__FUNCTION__);
800058a8:	3c048001 	lui	a0,0x8001
800058ac:	24844964 	addiu	a0,a0,18788
800058b0:	3c058001 	lui	a1,0x8001
800058b4:	0c002325 	jal	80008c94 <dprintf>
800058b8:	24a5030c 	addiu	a1,a1,780
		return FAIL;
800058bc:	080017b3 	j	80005ecc <rtk_nand_scan_bbt+0x72c>
800058c0:	2402ffff 	li	v0,-1
	}

	memset( temp_BBT, 0xff, mem_page_num*page_size);
800058c4:	3c028001 	lui	v0,0x8001
800058c8:	8c4675e4 	lw	a2,30180(v0)
800058cc:	02602021 	move	a0,s3
800058d0:	240500ff 	li	a1,255
800058d4:	0c00203d 	jal	800080f4 <memset>
800058d8:	72063002 	mul	a2,s0,a2
800058dc:	24020001 	li	v0,1
800058e0:	afa20020 	sw	v0,32(sp)
800058e4:	00008021 	move	s0,zero
//test NEW method!
	for(i=0;i<BACKUP_BBT;i++){
	    rc = rtk_read_ecc_page_a(bbt_page+(i*ppb), &NfDataBuf, &NfSpareBuf,page_size);
800058e8:	3c118001 	lui	s1,0x8001
800058ec:	3c148001 	lui	s4,0x8001
800058f0:	3c158002 	lui	s5,0x8002
800058f4:	26b54f04 	addiu	s5,s5,20228
800058f8:	3c128002 	lui	s2,0x8002
800058fc:	26525768 	addiu	s2,s2,22376
			isbbt = NfSpareBuf[0];
		#endif
	    else
		    isbbt = NfSpareBuf[5];
		if(!rc){
		    if(isbbt==BBT_TAG)//check bbt has already created
80005900:	241600bb 	li	s6,187
		return FAIL;
	}

	memset( temp_BBT, 0xff, mem_page_num*page_size);
//test NEW method!
	for(i=0;i<BACKUP_BBT;i++){
80005904:	24170003 	li	s7,3
	    rc = rtk_read_ecc_page_a(bbt_page+(i*ppb), &NfDataBuf, &NfSpareBuf,page_size);
80005908:	8e2475ec 	lw	a0,30188(s1)
8000590c:	72041002 	mul	v0,s0,a0
80005910:	005e2021 	addu	a0,v0,s8
80005914:	02a02821 	move	a1,s5
80005918:	02403021 	move	a2,s2
8000591c:	0c0012a2 	jal	80004a88 <rtk_read_ecc_page_a>
80005920:	8e8775e4 	lw	a3,30180(s4)
		#else
			isbbt = NfSpareBuf[0];
		#endif
	    else
		    isbbt = NfSpareBuf[5];
		if(!rc){
80005924:	14400005 	bnez	v0,8000593c <rtk_nand_scan_bbt+0x19c>
80005928:	92430035 	lbu	v1,53(s2)
		    if(isbbt==BBT_TAG)//check bbt has already created
8000592c:	00761826 	xor	v1,v1,s6
80005930:	8fa20020 	lw	v0,32(sp)
80005934:	0003100a 	movz	v0,zero,v1
80005938:	afa20020 	sw	v0,32(sp)
		return FAIL;
	}

	memset( temp_BBT, 0xff, mem_page_num*page_size);
//test NEW method!
	for(i=0;i<BACKUP_BBT;i++){
8000593c:	26100001 	addiu	s0,s0,1
80005940:	1617fff1 	bne	s0,s7,80005908 <rtk_nand_scan_bbt+0x168>
80005944:	3c028002 	lui	v0,0x8002
80005948:	afa00010 	sw	zero,16(sp)
8000594c:	00009021 	move	s2,zero
	//printf("%s: is_first_boot:%d\n\r",__FUNCTION__, is_first_boot);
	//is_first_boot = 1;
	for(i=0;i<BACKUP_BBT;i++){
		mem_page_num_tmp = mem_page_num;
		page_counter=0;load_bbt_error=0;
		rc = rtk_block_isbad((bbt_page+(i*ppb))*page_size);
80005950:	3c118001 	lui	s1,0x8001
		if(!rc){
			//printf("load bbt table:%d page:%d\n\r",i, (bbt_page+(i*ppb)));
		    rc = rtk_read_ecc_page_a(bbt_page+(i*ppb), &NfDataBuf, &NfSpareBuf,page_size);
80005954:	24424f04 	addiu	v0,v0,20228
80005958:	afa20028 	sw	v0,40(sp)
8000595c:	3c028002 	lui	v0,0x8002
80005960:	24425768 	addiu	v0,v0,22376
80005964:	afa20014 	sw	v0,20(sp)
			    }else{
					//printf("Create bbt table:%d is_first_boot:%d\n\r",i, is_first_boot);
					if(is_first_boot)
					{
						//debug cl for safe boot
						static_for_create_v2r_bbt = 1;
80005968:	24030001 	li	v1,1
8000596c:	afa30038 	sw	v1,56(sp)
// Output:
//		BOOL: 0=>OK, -1=>FAIL 
//####################################################################
static int rtk_create_bbt( int page)
{
    dprintf("[%s:] %d\n",__func__,__LINE__);
80005970:	3c028001 	lui	v0,0x8001
80005974:	24424a50 	addiu	v0,v0,19024
80005978:	afa2002c 	sw	v0,44(sp)
8000597c:	3c028001 	lui	v0,0x8001
80005980:	24420330 	addiu	v0,v0,816
80005984:	afa2003c 	sw	v0,60(sp)
// Output:
//		BOOL: 0=>OK, -1=>FAIL 
//####################################################################
static int scan_last_die_BB(void)
{
    dprintf("[%s:] %d\n",__func__,__LINE__);
80005988:	3c028001 	lui	v0,0x8001
8000598c:	24420354 	addiu	v0,v0,852
80005990:	afa20030 	sw	v0,48(sp)
	int remap_count = 0;
	int i,j, table_index=0 , numchips=1;
	//start_page = BOOT_SIZE;
	block_num = (chip_size/block_size);

    dprintf("[%s:] %d block_num = %d\n",__func__,__LINE__,block_num );
80005994:	3c028001 	lui	v0,0x8001
80005998:	24424a5c 	addiu	v0,v0,19036
8000599c:	afa20040 	sw	v0,64(sp)
	memcpy( temp_BBT, bbt, sizeof(struct BB_t)*RBA );
	while( mem_page_num>0 ){
		//if ( this->write_ecc_page(mtd, 0, page+page_counter, temp_BBT+page_counter*page_size, 
		//	this->g_oobbuf, 1) )
		if(rtk_write_ecc_page_a(page+page_counter,temp_BBT+page_counter*page_size, &NfSpareBuf, page_size))	{
				printf("[%s] write BBT page %d failure!!\n\r", __FUNCTION__, page+page_counter);
800059a0:	3c028001 	lui	v0,0x8001
800059a4:	24424b38 	addiu	v0,v0,19256
800059a8:	afa20044 	sw	v0,68(sp)
	/*search bad block of all Nand flash area.*/
	for( addr=0; addr<chip_size; addr+=block_size ){
		int bb = addr >> block_shift;
		if ( rtk_block_isbad(addr) ){
			block_status[bb] = 0xff;
			printf("block[%d] is bad\n",bb);
800059ac:	3c028001 	lui	v0,0x8001
800059b0:	24424ad8 	addiu	v0,v0,19160
800059b4:	afa20048 	sw	v0,72(sp)
800059b8:	0260b821 	move	s7,s3
	//printf("%s: is_first_boot:%d\n\r",__FUNCTION__, is_first_boot);
	//is_first_boot = 1;
	for(i=0;i<BACKUP_BBT;i++){
		mem_page_num_tmp = mem_page_num;
		page_counter=0;load_bbt_error=0;
		rc = rtk_block_isbad((bbt_page+(i*ppb))*page_size);
800059bc:	3c028001 	lui	v0,0x8001
800059c0:	8c4475ec 	lw	a0,30188(v0)
800059c4:	72441002 	mul	v0,s2,a0
800059c8:	005e2021 	addu	a0,v0,s8
800059cc:	8e2275e4 	lw	v0,30180(s1)
800059d0:	0c001349 	jal	80004d24 <rtk_block_isbad>
800059d4:	70822002 	mul	a0,a0,v0
		if(!rc){
800059d8:	14400129 	bnez	v0,80005e80 <rtk_nand_scan_bbt+0x6e0>
800059dc:	afa20018 	sw	v0,24(sp)
			//printf("load bbt table:%d page:%d\n\r",i, (bbt_page+(i*ppb)));
		    rc = rtk_read_ecc_page_a(bbt_page+(i*ppb), &NfDataBuf, &NfSpareBuf,page_size);
800059e0:	3c028001 	lui	v0,0x8001
800059e4:	8c4475ec 	lw	a0,30188(v0)
800059e8:	72441002 	mul	v0,s2,a0
800059ec:	005e2021 	addu	a0,v0,s8
800059f0:	8fa50028 	lw	a1,40(sp)
800059f4:	8fa60014 	lw	a2,20(sp)
800059f8:	0c0012a2 	jal	80004a88 <rtk_read_ecc_page_a>
800059fc:	8e2775e4 	lw	a3,30180(s1)
80005a00:	afa20018 	sw	v0,24(sp)
		    if(!NAND_ADDR_CYCLE)
		    #ifdef SWAP_2K_DATA
				isbbt = NfSpareBuf[BBI_SWAP_OFFSET];
80005a04:	8fa20014 	lw	v0,20(sp)
80005a08:	90430035 	lbu	v1,53(v0)
			#else
				isbbt = NfSpareBuf[0];
			#endif
		    else
			    isbbt = NfSpareBuf[5];
	        if(!rc){
80005a0c:	8fa20018 	lw	v0,24(sp)
80005a10:	1440011e 	bnez	v0,80005e8c <rtk_nand_scan_bbt+0x6ec>
80005a14:	240200bb 	li	v0,187
			    //if(isbbt == BBT_TAG &&0) //if v2r bbt table write error,can use the code to rebuild table
			    if(isbbt == BBT_TAG){
80005a18:	14620033 	bne	v1,v0,80005ae8 <rtk_nand_scan_bbt+0x348>
80005a1c:	8fa30020 	lw	v1,32(sp)
			        //printf("[%s] have created bbt table:%d on block %d, just loads it !!\n\r", __FUNCTION__,i,(bbt_page/ppb)+i);
			        memcpy( temp_BBT, &NfDataBuf, page_size );
80005a20:	02e02021 	move	a0,s7
80005a24:	8fa50028 	lw	a1,40(sp)
80005a28:	0c002046 	jal	80008118 <memcpy>
80005a2c:	8e2675e4 	lw	a2,30180(s1)
			        page_counter++;
			        mem_page_num_tmp--;
80005a30:	8fa30024 	lw	v1,36(sp)
80005a34:	2473ffff 	addiu	s3,v1,-1
80005a38:	327300ff 	andi	s3,s3,0xff
80005a3c:	24100001 	li	s0,1
			        while( mem_page_num_tmp>0 ){
				        if( rtk_read_ecc_page_a((bbt_page+(i*ppb)+page_counter), &NfDataBuf, &NfSpareBuf, page_size)){
80005a40:	3c148001 	lui	s4,0x8001
			    if(isbbt == BBT_TAG){
			        //printf("[%s] have created bbt table:%d on block %d, just loads it !!\n\r", __FUNCTION__,i,(bbt_page/ppb)+i);
			        memcpy( temp_BBT, &NfDataBuf, page_size );
			        page_counter++;
			        mem_page_num_tmp--;
			        while( mem_page_num_tmp>0 ){
80005a44:	080016ae 	j	80005ab8 <rtk_nand_scan_bbt+0x318>
80005a48:	8fb60028 	lw	s6,40(sp)
				        if( rtk_read_ecc_page_a((bbt_page+(i*ppb)+page_counter), &NfDataBuf, &NfSpareBuf, page_size)){
80005a4c:	8e8475ec 	lw	a0,30188(s4)
80005a50:	72441002 	mul	v0,s2,a0
80005a54:	005e2021 	addu	a0,v0,s8
80005a58:	00902021 	addu	a0,a0,s0
80005a5c:	8fa60014 	lw	a2,20(sp)
80005a60:	0c0012a2 	jal	80004a88 <rtk_read_ecc_page_a>
80005a64:	8e2775e4 	lw	a3,30180(s1)
80005a68:	1040000b 	beqz	v0,80005a98 <rtk_nand_scan_bbt+0x2f8>
80005a6c:	8e2675e4 	lw	a2,30180(s1)
					        printf("[%s] load bbt table%d error!!\n\r", __FUNCTION__,i);
80005a70:	3c048001 	lui	a0,0x8001
80005a74:	24844a30 	addiu	a0,a0,18992
80005a78:	3c058001 	lui	a1,0x8001
80005a7c:	24a5030c 	addiu	a1,a1,780
80005a80:	0c002325 	jal	80008c94 <dprintf>
80005a84:	02403021 	move	a2,s2
					        //free(temp_BBT);
					        //load_bbt1 = 1;
                            load_bbt_error=1;
					        //return -1;
					        //goto TRY_LOAD_BBT1;
			                error_count++;					        
80005a88:	8fa30010 	lw	v1,16(sp)
80005a8c:	24630001 	addiu	v1,v1,1
80005a90:	080017a3 	j	80005e8c <rtk_nand_scan_bbt+0x6ec>
80005a94:	afa30010 	sw	v1,16(sp)
					        break;
				        }
				        memcpy( temp_BBT+page_counter*page_size, &NfDataBuf, page_size );
80005a98:	72061002 	mul	v0,s0,a2
80005a9c:	00572021 	addu	a0,v0,s7
80005aa0:	0c002046 	jal	80008118 <memcpy>
80005aa4:	02c02821 	move	a1,s6
				        page_counter++;
80005aa8:	26100001 	addiu	s0,s0,1
80005aac:	321000ff 	andi	s0,s0,0xff
				        mem_page_num_tmp--;
80005ab0:	2673ffff 	addiu	s3,s3,-1
80005ab4:	327300ff 	andi	s3,s3,0xff
			    if(isbbt == BBT_TAG){
			        //printf("[%s] have created bbt table:%d on block %d, just loads it !!\n\r", __FUNCTION__,i,(bbt_page/ppb)+i);
			        memcpy( temp_BBT, &NfDataBuf, page_size );
			        page_counter++;
			        mem_page_num_tmp--;
			        while( mem_page_num_tmp>0 ){
80005ab8:	1660ffe4 	bnez	s3,80005a4c <rtk_nand_scan_bbt+0x2ac>
80005abc:	02c02821 	move	a1,s6
80005ac0:	02e09821 	move	s3,s7
				        memcpy( temp_BBT+page_counter*page_size, &NfDataBuf, page_size );
				        page_counter++;
				        mem_page_num_tmp--;
			        }
					if(!load_bbt_error){
					    memcpy( bbt, temp_BBT, sizeof(struct BB_t)*RBA );
80005ac4:	3c028002 	lui	v0,0x8002
80005ac8:	8c462e74 	lw	a2,11892(v0)
80005acc:	3c028002 	lui	v0,0x8002
80005ad0:	8c442e78 	lw	a0,11896(v0)
80005ad4:	02e02821 	move	a1,s7
80005ad8:	0c002046 	jal	80008118 <memcpy>
80005adc:	000630c0 	sll	a2,a2,0x3
					    //printf("check bbt table:%d OK\n\r",i);
					    goto CHECK_BBT_OK;
80005ae0:	080017a7 	j	80005e9c <rtk_nand_scan_bbt+0x6fc>
80005ae4:	00000000 	nop
					}
			    }else{
					//printf("Create bbt table:%d is_first_boot:%d\n\r",i, is_first_boot);
					if(is_first_boot)
80005ae8:	106000e8 	beqz	v1,80005e8c <rtk_nand_scan_bbt+0x6ec>
80005aec:	8fa30038 	lw	v1,56(sp)
					{
						//debug cl for safe boot
						static_for_create_v2r_bbt = 1;
80005af0:	3c028002 	lui	v0,0x8002
80005af4:	ac433d84 	sw	v1,15748(v0)
				        rtk_create_bbt(bbt_page+(i*ppb));
80005af8:	3c028001 	lui	v0,0x8001
80005afc:	8c4275ec 	lw	v0,30188(v0)
80005b00:	afa20034 	sw	v0,52(sp)
// Output:
//		BOOL: 0=>OK, -1=>FAIL 
//####################################################################
static int rtk_create_bbt( int page)
{
    dprintf("[%s:] %d\n",__func__,__LINE__);
80005b04:	8fa4002c 	lw	a0,44(sp)
80005b08:	8fa5003c 	lw	a1,60(sp)
80005b0c:	0c002325 	jal	80008c94 <dprintf>
80005b10:	24060bac 	li	a2,2988
// Output:
//		BOOL: 0=>OK, -1=>FAIL 
//####################################################################
static int scan_last_die_BB(void)
{
    dprintf("[%s:] %d\n",__func__,__LINE__);
80005b14:	8fa4002c 	lw	a0,44(sp)
80005b18:	8fa50030 	lw	a1,48(sp)
80005b1c:	0c002325 	jal	80008c94 <dprintf>
80005b20:	24060b42 	li	a2,2882
	//int remap_block[RBA];
	int block_offset=0;
	int remap_count = 0;
	int i,j, table_index=0 , numchips=1;
	//start_page = BOOT_SIZE;
	block_num = (chip_size/block_size);
80005b24:	3c028002 	lui	v0,0x8002
80005b28:	8c543d80 	lw	s4,15744(v0)
80005b2c:	3c028001 	lui	v0,0x8001
80005b30:	8c4275c4 	lw	v0,30148(v0)
80005b34:	0282001b 	divu	zero,s4,v0
80005b38:	004001f4 	teq	v0,zero,0x7
80005b3c:	0000a012 	mflo	s4

    dprintf("[%s:] %d block_num = %d\n",__func__,__LINE__,block_num );
80005b40:	8fa40040 	lw	a0,64(sp)
80005b44:	8fa50030 	lw	a1,48(sp)
80005b48:	24060b4e 	li	a2,2894
80005b4c:	0c002325 	jal	80008c94 <dprintf>
80005b50:	00003812 	mflo	a3
	unsigned char *block_status = (unsigned char *) malloc( block_num );
80005b54:	0c001f55 	jal	80007d54 <malloc>
80005b58:	02802021 	move	a0,s4
	if ( !block_status ){
80005b5c:	14400008 	bnez	v0,80005b80 <rtk_nand_scan_bbt+0x3e0>
80005b60:	0040a821 	move	s5,v0
		printf("%s: Error, no enough memory for block_status\n\r",__FUNCTION__);
80005b64:	3c048001 	lui	a0,0x8001
80005b68:	24844a78 	addiu	a0,a0,19064
80005b6c:	3c058001 	lui	a1,0x8001
80005b70:	0c002325 	jal	80008c94 <dprintf>
80005b74:	24a50340 	addiu	a1,a1,832
	if ( scan_last_die_BB() ){
		printf("[%s] scan_last_die_BB() error !!\n\r", __FUNCTION__);
		return -1;
	}

	mem_page_num = (sizeof(struct BB_t)*RBA + page_size-1 )/page_size;
80005b78:	08001750 	j	80005d40 <rtk_nand_scan_bbt+0x5a0>
80005b7c:	8e2475e4 	lw	a0,30180(s1)
	if ( !block_status ){
		printf("%s: Error, no enough memory for block_status\n\r",__FUNCTION__);
		rc = FAIL;
		goto EXIT;
	}
	memset ( (unsigned int *)block_status, 0, block_num );
80005b80:	00402021 	move	a0,v0
80005b84:	00002821 	move	a1,zero
80005b88:	0c00203d 	jal	800080f4 <memset>
80005b8c:	02803021 	move	a2,s4

	int *remap_block = (unsigned int*)malloc(sizeof(int)*RBA);
80005b90:	3c028002 	lui	v0,0x8002
80005b94:	8c442e74 	lw	a0,11892(v0)
80005b98:	0c001f55 	jal	80007d54 <malloc>
80005b9c:	00042080 	sll	a0,a0,0x2
80005ba0:	afa2001c 	sw	v0,28(sp)
	if ( !remap_block ){
80005ba4:	14400008 	bnez	v0,80005bc8 <rtk_nand_scan_bbt+0x428>
80005ba8:	0040b021 	move	s6,v0
		printf("%s: Error, no enough memory for remap_block\n\r",__FUNCTION__);
80005bac:	3c048001 	lui	a0,0x8001
80005bb0:	24844aa8 	addiu	a0,a0,19112
80005bb4:	3c058001 	lui	a1,0x8001
80005bb8:	0c002325 	jal	80008c94 <dprintf>
80005bbc:	24a50340 	addiu	a1,a1,832
80005bc0:	080017bf 	j	80005efc <rtk_nand_scan_bbt+0x75c>
80005bc4:	00000000 	nop
		rc = FAIL;
		goto EXIT;
	}
	memset ( (unsigned int *)remap_block, 0, sizeof(int)*RBA );
80005bc8:	3c028002 	lui	v0,0x8002
80005bcc:	8c462e74 	lw	a2,11892(v0)
80005bd0:	02c02021 	move	a0,s6
80005bd4:	00002821 	move	a1,zero
80005bd8:	0c00203d 	jal	800080f4 <memset>
80005bdc:	00063080 	sll	a2,a2,0x2
80005be0:	08001709 	j	80005c24 <rtk_nand_scan_bbt+0x484>
80005be4:	00009821 	move	s3,zero


	/*search bad block of all Nand flash area.*/
	for( addr=0; addr<chip_size; addr+=block_size ){
		int bb = addr >> block_shift;
80005be8:	3c028002 	lui	v0,0x8002
80005bec:	8c503d70 	lw	s0,15728(v0)
		if ( rtk_block_isbad(addr) ){
80005bf0:	0c001349 	jal	80004d24 <rtk_block_isbad>
80005bf4:	02602021 	move	a0,s3
80005bf8:	10400008 	beqz	v0,80005c1c <rtk_nand_scan_bbt+0x47c>
80005bfc:	3c038001 	lui	v1,0x8001
	memset ( (unsigned int *)remap_block, 0, sizeof(int)*RBA );


	/*search bad block of all Nand flash area.*/
	for( addr=0; addr<chip_size; addr+=block_size ){
		int bb = addr >> block_shift;
80005c00:	02132806 	srlv	a1,s3,s0
		if ( rtk_block_isbad(addr) ){
			block_status[bb] = 0xff;
80005c04:	02a51021 	addu	v0,s5,a1
80005c08:	2403ffff 	li	v1,-1
80005c0c:	a0430000 	sb	v1,0(v0)
			printf("block[%d] is bad\n",bb);
80005c10:	0c002325 	jal	80008c94 <dprintf>
80005c14:	8fa40048 	lw	a0,72(sp)
	}
	memset ( (unsigned int *)remap_block, 0, sizeof(int)*RBA );


	/*search bad block of all Nand flash area.*/
	for( addr=0; addr<chip_size; addr+=block_size ){
80005c18:	3c038001 	lui	v1,0x8001
80005c1c:	8c6275c4 	lw	v0,30148(v1)
80005c20:	02629821 	addu	s3,s3,v0
80005c24:	3c038002 	lui	v1,0x8002
80005c28:	8c623d80 	lw	v0,15744(v1)
80005c2c:	0262102b 	sltu	v0,s3,v0
80005c30:	1440ffed 	bnez	v0,80005be8 <rtk_nand_scan_bbt+0x448>
80005c34:	02b42021 	addu	a0,s5,s4
80005c38:	2694ffff 	addiu	s4,s4,-1
80005c3c:	00001821 	move	v1,zero




    /*check  bad block in RBA;*/
	for ( i=0; i<RBA; i++){
80005c40:	0800171b 	j	80005c6c <rtk_nand_scan_bbt+0x4cc>
80005c44:	3c068002 	lui	a2,0x8002
		if ( block_status[(block_num-1)-i] == 0x00){
80005c48:	9085ffff 	lbu	a1,-1(a0)
80005c4c:	14a00004 	bnez	a1,80005c60 <rtk_nand_scan_bbt+0x4c0>
80005c50:	00022880 	sll	a1,v0,0x2
			remap_block[remap_count] = (block_num-1)-i;
80005c54:	02c52821 	addu	a1,s6,a1
80005c58:	acb40000 	sw	s4,0(a1)
			//printf("A: remap_block[%d]=%x %x\n",remap_count, remap_block[remap_count], (block_num-1)-i);
			remap_count++;
80005c5c:	24420001 	addiu	v0,v0,1




    /*check  bad block in RBA;*/
	for ( i=0; i<RBA; i++){
80005c60:	24630001 	addiu	v1,v1,1
80005c64:	2484ffff 	addiu	a0,a0,-1
80005c68:	2694ffff 	addiu	s4,s4,-1
80005c6c:	8cc52e74 	lw	a1,11892(a2)
80005c70:	0065382b 	sltu	a3,v1,a1
80005c74:	14e0fff4 	bnez	a3,80005c48 <rtk_nand_scan_bbt+0x4a8>
80005c78:	24a50001 	addiu	a1,a1,1
			remap_count++;
		}
	}

    /*If there are some bad blocks in RBA, the remain remap block just map to RB_INIT*/
	if (remap_count<RBA+1){
80005c7c:	0045282b 	sltu	a1,v0,a1
80005c80:	10a0000f 	beqz	a1,80005cc0 <rtk_nand_scan_bbt+0x520>
80005c84:	00401821 	move	v1,v0
		for (j=remap_count+1; j<RBA+1; j++){
80005c88:	24420001 	addiu	v0,v0,1
80005c8c:	00031880 	sll	v1,v1,0x2
80005c90:	02c31821 	addu	v1,s6,v1
80005c94:	3c058002 	lui	a1,0x8002
			remap_block[j-1] = RB_INIT;
80005c98:	0800172b 	j	80005cac <rtk_nand_scan_bbt+0x50c>
80005c9c:	3404fffd 	li	a0,0xfffd
80005ca0:	ac640000 	sw	a0,0(v1)
		}
	}

    /*If there are some bad blocks in RBA, the remain remap block just map to RB_INIT*/
	if (remap_count<RBA+1){
		for (j=remap_count+1; j<RBA+1; j++){
80005ca4:	24420001 	addiu	v0,v0,1
80005ca8:	24630004 	addiu	v1,v1,4
80005cac:	8ca62e74 	lw	a2,11892(a1)
80005cb0:	24c60001 	addiu	a2,a2,1
80005cb4:	0046302b 	sltu	a2,v0,a2
80005cb8:	14c0fff9 	bnez	a2,80005ca0 <rtk_nand_scan_bbt+0x500>
80005cbc:	00000000 	nop
80005cc0:	8fa5001c 	lw	a1,28(sp)
80005cc4:	00001821 	move	v1,zero
printf("A:bbt[%d].remap_block = %x \n",table_index, bbt[table_index].remap_block);			
			table_index++;
		}
	}
#endif
	for( i=table_index; table_index<RBA; table_index++){
80005cc8:	3c088002 	lui	t0,0x8002
		bbt[table_index].bad_block = BB_INIT;
80005ccc:	3c028002 	lui	v0,0x8002
80005cd0:	2407fffe 	li	a3,-2
		bbt[table_index].BB_die = BB_DIE_INIT;
80005cd4:	08001747 	j	80005d1c <rtk_nand_scan_bbt+0x57c>
80005cd8:	2406eeee 	li	a2,-4370
		}
	}

    /*If there are some bad blocks in RBA, the remain remap block just map to RB_INIT*/
	if (remap_count<RBA+1){
		for (j=remap_count+1; j<RBA+1; j++){
80005cdc:	000420c0 	sll	a0,a0,0x3
			table_index++;
		}
	}
#endif
	for( i=table_index; table_index<RBA; table_index++){
		bbt[table_index].bad_block = BB_INIT;
80005ce0:	8c492e78 	lw	t1,11896(v0)
80005ce4:	01244821 	addu	t1,t1,a0
80005ce8:	a5270002 	sh	a3,2(t1)
		bbt[table_index].BB_die = BB_DIE_INIT;
80005cec:	8c492e78 	lw	t1,11896(v0)
80005cf0:	01244821 	addu	t1,t1,a0
80005cf4:	a5260000 	sh	a2,0(t1)
		bbt[table_index].remap_block = remap_block[table_index];
80005cf8:	8c492e78 	lw	t1,11896(v0)
80005cfc:	01244821 	addu	t1,t1,a0
80005d00:	8caa0000 	lw	t2,0(a1)
80005d04:	a52a0006 	sh	t2,6(t1)
		bbt[table_index].RB_die = numchips-1;
80005d08:	8c492e78 	lw	t1,11896(v0)
80005d0c:	01242021 	addu	a0,t1,a0
80005d10:	a4800004 	sh	zero,4(a0)
printf("A:bbt[%d].remap_block = %x \n",table_index, bbt[table_index].remap_block);			
			table_index++;
		}
	}
#endif
	for( i=table_index; table_index<RBA; table_index++){
80005d14:	24630001 	addiu	v1,v1,1
80005d18:	24a50004 	addiu	a1,a1,4
80005d1c:	8d092e74 	lw	t1,11892(t0)
80005d20:	0069482b 	sltu	t1,v1,t1
80005d24:	1520ffed 	bnez	t1,80005cdc <rtk_nand_scan_bbt+0x53c>
80005d28:	00602021 	move	a0,v1
80005d2c:	080017bf 	j	80005efc <rtk_nand_scan_bbt+0x75c>
80005d30:	00000000 	nop
	if (rc){
		if (block_status)
			free(block_status);	
	}
	if(remap_block)
		free(remap_block);
80005d34:	0c001f86 	jal	80007e18 <free>
80005d38:	02c02021 	move	a0,s6
	if ( scan_last_die_BB() ){
		printf("[%s] scan_last_die_BB() error !!\n\r", __FUNCTION__);
		return -1;
	}

	mem_page_num = (sizeof(struct BB_t)*RBA + page_size-1 )/page_size;
80005d3c:	8e2475e4 	lw	a0,30180(s1)
80005d40:	2483ffff 	addiu	v1,a0,-1
80005d44:	3c028002 	lui	v0,0x8002
80005d48:	8c422e74 	lw	v0,11892(v0)
80005d4c:	000210c0 	sll	v0,v0,0x3
80005d50:	00621021 	addu	v0,v1,v0
80005d54:	0044001b 	divu	zero,v0,a0
80005d58:	008001f4 	teq	a0,zero,0x7
80005d5c:	00009812 	mflo	s3
80005d60:	327300ff 	andi	s3,s3,0xff
	temp_BBT = (unsigned char *) malloc( mem_page_num*page_size);
80005d64:	0c001f55 	jal	80007d54 <malloc>
80005d68:	72642002 	mul	a0,s3,a0
	if ( !temp_BBT ){
80005d6c:	14400008 	bnez	v0,80005d90 <rtk_nand_scan_bbt+0x5f0>
80005d70:	0040a021 	move	s4,v0
		printf("%s: Error, no enough memory for temp_BBT\n\r",__FUNCTION__);
80005d74:	3c048001 	lui	a0,0x8001
80005d78:	24844aec 	addiu	a0,a0,19180
80005d7c:	3c058001 	lui	a1,0x8001
80005d80:	0c002325 	jal	80008c94 <dprintf>
80005d84:	24a50320 	addiu	a1,a1,800
					if(is_first_boot)
					{
						//debug cl for safe boot
						static_for_create_v2r_bbt = 1;
				        rtk_create_bbt(bbt_page+(i*ppb));
						static_for_create_v2r_bbt = 0;
80005d88:	0800179e 	j	80005e78 <rtk_nand_scan_bbt+0x6d8>
80005d8c:	3c038002 	lui	v1,0x8002
					//printf("Create bbt table:%d is_first_boot:%d\n\r",i, is_first_boot);
					if(is_first_boot)
					{
						//debug cl for safe boot
						static_for_create_v2r_bbt = 1;
				        rtk_create_bbt(bbt_page+(i*ppb));
80005d90:	8fa20034 	lw	v0,52(sp)
80005d94:	72421802 	mul	v1,s2,v0
80005d98:	007e8021 	addu	s0,v1,s8
	if ( !temp_BBT ){
		printf("%s: Error, no enough memory for temp_BBT\n\r",__FUNCTION__);
		return -1;
	}

	memset( temp_BBT, 0xff, mem_page_num*page_size);
80005d9c:	8e2675e4 	lw	a2,30180(s1)
80005da0:	02802021 	move	a0,s4
80005da4:	240500ff 	li	a1,255
80005da8:	0c00203d 	jal	800080f4 <memset>
80005dac:	72663002 	mul	a2,s3,a2
	//while(1);//debug cl

  	if ( rtk_erase_block_a( page)){
80005db0:	0c001048 	jal	80004120 <rtk_erase_block_a>
80005db4:	02002021 	move	a0,s0
80005db8:	1040000d 	beqz	v0,80005df0 <rtk_nand_scan_bbt+0x650>
80005dbc:	2402ffbb 	li	v0,-69
		printf("[%s]erase block %d failure !!\n\r", __FUNCTION__, page/ppb);
80005dc0:	3c028001 	lui	v0,0x8001
80005dc4:	8c4675ec 	lw	a2,30188(v0)
80005dc8:	0206001b 	divu	zero,s0,a2
80005dcc:	00c001f4 	teq	a2,zero,0x7
80005dd0:	00003012 	mflo	a2
80005dd4:	3c048001 	lui	a0,0x8001
80005dd8:	24844b18 	addiu	a0,a0,19224
80005ddc:	3c058001 	lui	a1,0x8001
80005de0:	0c002325 	jal	80008c94 <dprintf>
80005de4:	24a50320 	addiu	a1,a1,800
80005de8:	0800179b 	j	80005e6c <rtk_nand_scan_bbt+0x6cc>
80005dec:	00000000 	nop
		rc =  -1;
		goto EXIT;
	}
    if(!NAND_ADDR_CYCLE)
	#ifdef SWAP_2K_DATA
		NfSpareBuf[BBI_SWAP_OFFSET] = BBT_TAG;
80005df0:	8fa30014 	lw	v1,20(sp)
80005df4:	a0620035 	sb	v0,53(v1)
	#else
		NfSpareBuf[0] = BBT_TAG;
	#endif
    else
		NfSpareBuf[5] = BBT_TAG;
	memcpy( temp_BBT, bbt, sizeof(struct BB_t)*RBA );
80005df8:	3c028002 	lui	v0,0x8002
80005dfc:	8c462e74 	lw	a2,11892(v0)
80005e00:	02802021 	move	a0,s4
80005e04:	3c028002 	lui	v0,0x8002
80005e08:	8c452e78 	lw	a1,11896(v0)
80005e0c:	0c002046 	jal	80008118 <memcpy>
80005e10:	000630c0 	sll	a2,a2,0x3
80005e14:	08001799 	j	80005e64 <rtk_nand_scan_bbt+0x6c4>
80005e18:	0000a821 	move	s5,zero
	while( mem_page_num>0 ){
		//if ( this->write_ecc_page(mtd, 0, page+page_counter, temp_BBT+page_counter*page_size, 
		//	this->g_oobbuf, 1) )
		if(rtk_write_ecc_page_a(page+page_counter,temp_BBT+page_counter*page_size, &NfSpareBuf, page_size))	{
80005e1c:	8e2775e4 	lw	a3,30180(s1)
80005e20:	02002021 	move	a0,s0
80005e24:	70f51002 	mul	v0,a3,s5
80005e28:	00542821 	addu	a1,v0,s4
80005e2c:	0c0011da 	jal	80004768 <rtk_write_ecc_page_a>
80005e30:	8fa60014 	lw	a2,20(sp)
80005e34:	26b50001 	addiu	s5,s5,1
80005e38:	10400008 	beqz	v0,80005e5c <rtk_nand_scan_bbt+0x6bc>
80005e3c:	26100001 	addiu	s0,s0,1
				printf("[%s] write BBT page %d failure!!\n\r", __FUNCTION__, page+page_counter);
80005e40:	8fa40044 	lw	a0,68(sp)
80005e44:	3c058001 	lui	a1,0x8001
80005e48:	24a50320 	addiu	a1,a1,800
80005e4c:	0c002325 	jal	80008c94 <dprintf>
80005e50:	02c03021 	move	a2,s6
80005e54:	0800179b 	j	80005e6c <rtk_nand_scan_bbt+0x6cc>
80005e58:	00000000 	nop
				rc =  -1;
				goto EXIT;
		}
		page_counter++;
		mem_page_num--;		
80005e5c:	2673ffff 	addiu	s3,s3,-1
80005e60:	327300ff 	andi	s3,s3,0xff
		NfSpareBuf[0] = BBT_TAG;
	#endif
    else
		NfSpareBuf[5] = BBT_TAG;
	memcpy( temp_BBT, bbt, sizeof(struct BB_t)*RBA );
	while( mem_page_num>0 ){
80005e64:	1660ffed 	bnez	s3,80005e1c <rtk_nand_scan_bbt+0x67c>
80005e68:	0200b021 	move	s6,s0
		mem_page_num--;		
	}

EXIT:
	if (temp_BBT)
		free(temp_BBT);
80005e6c:	0c001f86 	jal	80007e18 <free>
80005e70:	02802021 	move	a0,s4
					if(is_first_boot)
					{
						//debug cl for safe boot
						static_for_create_v2r_bbt = 1;
				        rtk_create_bbt(bbt_page+(i*ppb));
						static_for_create_v2r_bbt = 0;
80005e74:	3c038002 	lui	v1,0x8002
80005e78:	080017a3 	j	80005e8c <rtk_nand_scan_bbt+0x6ec>
80005e7c:	ac603d84 	sw	zero,15748(v1)
					}
			    }
		    }
		}else{
            //printf("bbt table:%d block:%d page:%d is bad\n\r",i,(bbt_page/ppb)+i,bbt_page+(i*ppb));
			error_count++;
80005e80:	8fa20010 	lw	v0,16(sp)
80005e84:	24420001 	addiu	v0,v0,1
80005e88:	afa20010 	sw	v0,16(sp)
				is_first_boot = 0;
		}
	}
	//printf("%s: is_first_boot:%d\n\r",__FUNCTION__, is_first_boot);
	//is_first_boot = 1;
	for(i=0;i<BACKUP_BBT;i++){
80005e8c:	26520001 	addiu	s2,s2,1
80005e90:	24020003 	li	v0,3
80005e94:	1642fec9 	bne	s2,v0,800059bc <rtk_nand_scan_bbt+0x21c>
80005e98:	02e09821 	move	s3,s7
	}
#endif	
	//dump_BBT();

	if (temp_BBT)
		free(temp_BBT);
80005e9c:	0c001f86 	jal	80007e18 <free>
80005ea0:	02602021 	move	a0,s3
    if(error_count >= BACKUP_BBT){
80005ea4:	8fa20010 	lw	v0,16(sp)
80005ea8:	2c430003 	sltiu	v1,v0,3
80005eac:	14600007 	bnez	v1,80005ecc <rtk_nand_scan_bbt+0x72c>
80005eb0:	8fa20018 	lw	v0,24(sp)
        rc = -1;
		printf("%d bbt table are all bad!(T______T)\n\r", BACKUP_BBT);
80005eb4:	3c048001 	lui	a0,0x8001
80005eb8:	24844b5c 	addiu	a0,a0,19292
80005ebc:	0c002325 	jal	80008c94 <dprintf>
80005ec0:	24050003 	li	a1,3
80005ec4:	080017b1 	j	80005ec4 <rtk_nand_scan_bbt+0x724>
80005ec8:	00000000 	nop
		while(1); //debug cl for safe boot.
	}		
	return rc;

}
80005ecc:	8fbf0074 	lw	ra,116(sp)
80005ed0:	8fbe0070 	lw	s8,112(sp)
80005ed4:	8fb7006c 	lw	s7,108(sp)
80005ed8:	8fb60068 	lw	s6,104(sp)
80005edc:	8fb50064 	lw	s5,100(sp)
80005ee0:	8fb40060 	lw	s4,96(sp)
80005ee4:	8fb3005c 	lw	s3,92(sp)
80005ee8:	8fb20058 	lw	s2,88(sp)
80005eec:	8fb10054 	lw	s1,84(sp)
80005ef0:	8fb00050 	lw	s0,80(sp)
80005ef4:	03e00008 	jr	ra
80005ef8:	27bd0078 	addiu	sp,sp,120
	}
	
EXIT:
	if (rc){
		if (block_status)
			free(block_status);	
80005efc:	0c001f86 	jal	80007e18 <free>
80005f00:	02a02021 	move	a0,s5
	}
	if(remap_block)
80005f04:	16c0ff8b 	bnez	s6,80005d34 <rtk_nand_scan_bbt+0x594>
80005f08:	00000000 	nop
	if ( scan_last_die_BB() ){
		printf("[%s] scan_last_die_BB() error !!\n\r", __FUNCTION__);
		return -1;
	}

	mem_page_num = (sizeof(struct BB_t)*RBA + page_size-1 )/page_size;
80005f0c:	08001750 	j	80005d40 <rtk_nand_scan_bbt+0x5a0>
80005f10:	8e2475e4 	lw	a0,30180(s1)

80005f14 <rtk_scan_v2r_bbt>:

}


int rtk_scan_v2r_bbt(void)
{
80005f14:	27bdff90 	addiu	sp,sp,-112
80005f18:	afbf006c 	sw	ra,108(sp)
80005f1c:	afbe0068 	sw	s8,104(sp)
80005f20:	afb70064 	sw	s7,100(sp)
80005f24:	afb60060 	sw	s6,96(sp)
80005f28:	afb5005c 	sw	s5,92(sp)
80005f2c:	afb40058 	sw	s4,88(sp)
80005f30:	afb30054 	sw	s3,84(sp)
80005f34:	afb20050 	sw	s2,80(sp)
80005f38:	afb1004c 	sw	s1,76(sp)
80005f3c:	afb00048 	sw	s0,72(sp)
	unsigned char mem_page_num=0, page_counter=0, mem_page_num_tmp=0;
	unsigned char *temp_BBT=NULL;
	unsigned int block_v2r_num=0;
	unsigned char load_bbt_error = 0, is_first_boot=1;
    //bbt_v2r_page = ((BOOT_SIZE/block_size)-(2*BACKUP_BBT))*ppb;
    bbt_v2r_page = (REMAP_BBT_POS/block_size)*ppb;
80005f40:	3c028001 	lui	v0,0x8001
80005f44:	8c4275c4 	lw	v0,30148(v0)
80005f48:	3c030010 	lui	v1,0x10
80005f4c:	0062001a 	div	zero,v1,v0
80005f50:	004001f4 	teq	v0,zero,0x7
80005f54:	0000a812 	mflo	s5
80005f58:	3c038001 	lui	v1,0x8001
80005f5c:	8c6475ec 	lw	a0,30188(v1)
80005f60:	72a4a802 	mul	s5,s5,a0

	//block_v2r_num = ((BOOT_SIZE + USER_SPACE_SIZE + VIMG_SPACE_SIZE + VIMG_SPACE_SIZE) >> block_shift);//jasonwang
	//block_v2r_num = ((chip_size) >> block_shift);//jasonwang
	/* winfred_wang */
	RBA = ((unsigned int)chip_size/block_size)*RBA_PERCENT / 100;
80005f64:	3c038002 	lui	v1,0x8002
80005f68:	8c633d80 	lw	v1,15744(v1)
80005f6c:	0062001b 	divu	zero,v1,v0
80005f70:	004001f4 	teq	v0,zero,0x7
80005f74:	00001012 	mflo	v0
80005f78:	3c048001 	lui	a0,0x8001
80005f7c:	8c8475c8 	lw	a0,30152(a0)
80005f80:	70441002 	mul	v0,v0,a0
80005f84:	3c0451eb 	lui	a0,0x51eb
80005f88:	3484851f 	ori	a0,a0,0x851f
80005f8c:	00440019 	multu	v0,a0
80005f90:	00001010 	mfhi	v0
80005f94:	00021142 	srl	v0,v0,0x5
80005f98:	3c048002 	lui	a0,0x8002
80005f9c:	ac822e74 	sw	v0,11892(a0)
	block_v2r_num = ((chip_size) >> block_shift) - RBA;
80005fa0:	3c048002 	lui	a0,0x8002
80005fa4:	8c843d70 	lw	a0,15728(a0)
80005fa8:	00831806 	srlv	v1,v1,a0
80005fac:	00621823 	subu	v1,v1,v0
80005fb0:	afa30028 	sw	v1,40(sp)
	dprintf("[%s, line %d] block_v2r_num %d bbt_v2r_page %d\n\r",__FUNCTION__,__LINE__, block_v2r_num, bbt_v2r_page);
#endif	
	//while(1);//debug cl

	//create virtual block to real good block remapping table!!!
	bbt_v2r = (unsigned char *) malloc(sizeof(struct BBT_v2r)*(block_v2r_num));
80005fb4:	00031080 	sll	v0,v1,0x2
80005fb8:	afa20018 	sw	v0,24(sp)
80005fbc:	0c001f55 	jal	80007d54 <malloc>
80005fc0:	00402021 	move	a0,v0
80005fc4:	3c038002 	lui	v1,0x8002
	if(!bbt_v2r){
80005fc8:	14400009 	bnez	v0,80005ff0 <rtk_scan_v2r_bbt+0xdc>
80005fcc:	ac622e70 	sw	v0,11888(v1)
		printf("%s-%d: Error, no enough memory for bbt_v2r\n",__FUNCTION__,__LINE__);
80005fd0:	3c048001 	lui	a0,0x8001
80005fd4:	24844b84 	addiu	a0,a0,19332
80005fd8:	3c058001 	lui	a1,0x8001
80005fdc:	24a50368 	addiu	a1,a1,872
80005fe0:	0c002325 	jal	80008c94 <dprintf>
80005fe4:	24060c60 	li	a2,3168
		return FAIL;
80005fe8:	0800191b 	j	8000646c <rtk_scan_v2r_bbt+0x558>
80005fec:	2413ffff 	li	s3,-1
	}

	mem_page_num = ((sizeof(struct BBT_v2r)*block_v2r_num) + page_size-1 )/page_size;
80005ff0:	3c028001 	lui	v0,0x8001
80005ff4:	8c4475e4 	lw	a0,30180(v0)
80005ff8:	2482ffff 	addiu	v0,a0,-1
80005ffc:	8fa30018 	lw	v1,24(sp)
80006000:	00431021 	addu	v0,v0,v1
80006004:	0044001b 	divu	zero,v0,a0
80006008:	008001f4 	teq	a0,zero,0x7
8000600c:	00001012 	mflo	v0
80006010:	304200ff 	andi	v0,v0,0xff
80006014:	afa20030 	sw	v0,48(sp)
	//printf("[%s, line %d] mem_page_num = %d\n\r",__FUNCTION__,__LINE__,mem_page_num);


	temp_BBT =(unsigned char *)malloc( mem_page_num*page_size );
80006018:	0c001f55 	jal	80007d54 <malloc>
8000601c:	70442002 	mul	a0,v0,a0
	if(!temp_BBT){
80006020:	14400008 	bnez	v0,80006044 <rtk_scan_v2r_bbt+0x130>
80006024:	0040f021 	move	s8,v0
		printf("%s: Error, no enough memory for temp_BBT_v2r\n",__FUNCTION__);
80006028:	3c048001 	lui	a0,0x8001
8000602c:	24844bb0 	addiu	a0,a0,19376
80006030:	3c058001 	lui	a1,0x8001
80006034:	0c002325 	jal	80008c94 <dprintf>
80006038:	24a50368 	addiu	a1,a1,872
		return FAIL;
8000603c:	0800191b 	j	8000646c <rtk_scan_v2r_bbt+0x558>
80006040:	2413ffff 	li	s3,-1
80006044:	24020001 	li	v0,1
80006048:	afa20024 	sw	v0,36(sp)
8000604c:	00008021 	move	s0,zero
	}
//test NEW method!
	for(i=0;i<BACKUP_BBT;i++){
	    rc = rtk_read_ecc_page_a(bbt_v2r_page+(i*ppb), &NfDataBuf, &NfSpareBuf,page_size);
80006050:	3c118001 	lui	s1,0x8001
80006054:	3c138001 	lui	s3,0x8001
80006058:	3c148002 	lui	s4,0x8002
8000605c:	26944f04 	addiu	s4,s4,20228
80006060:	3c128002 	lui	s2,0x8002
80006064:	26525768 	addiu	s2,s2,22376
			isbbt = NfSpareBuf[0];
		#endif
	    else
		    isbbt = NfSpareBuf[5];
		if(!rc){
		    if(isbbt==BBT_TAG)
80006068:	241600bb 	li	s6,187
	if(!temp_BBT){
		printf("%s: Error, no enough memory for temp_BBT_v2r\n",__FUNCTION__);
		return FAIL;
	}
//test NEW method!
	for(i=0;i<BACKUP_BBT;i++){
8000606c:	24170003 	li	s7,3
	    rc = rtk_read_ecc_page_a(bbt_v2r_page+(i*ppb), &NfDataBuf, &NfSpareBuf,page_size);
80006070:	8e2475ec 	lw	a0,30188(s1)
80006074:	72041002 	mul	v0,s0,a0
80006078:	00552021 	addu	a0,v0,s5
8000607c:	02802821 	move	a1,s4
80006080:	02403021 	move	a2,s2
80006084:	0c0012a2 	jal	80004a88 <rtk_read_ecc_page_a>
80006088:	8e6775e4 	lw	a3,30180(s3)
		#else
			isbbt = NfSpareBuf[0];
		#endif
	    else
		    isbbt = NfSpareBuf[5];
		if(!rc){
8000608c:	14400005 	bnez	v0,800060a4 <rtk_scan_v2r_bbt+0x190>
80006090:	92430035 	lbu	v1,53(s2)
		    if(isbbt==BBT_TAG)
80006094:	00761826 	xor	v1,v1,s6
80006098:	8fa40024 	lw	a0,36(sp)
8000609c:	0003200a 	movz	a0,zero,v1
800060a0:	afa40024 	sw	a0,36(sp)
	if(!temp_BBT){
		printf("%s: Error, no enough memory for temp_BBT_v2r\n",__FUNCTION__);
		return FAIL;
	}
//test NEW method!
	for(i=0;i<BACKUP_BBT;i++){
800060a4:	26100001 	addiu	s0,s0,1
800060a8:	1617fff1 	bne	s0,s7,80006070 <rtk_scan_v2r_bbt+0x15c>
800060ac:	3c028002 	lui	v0,0x8002
800060b0:	0000b821 	move	s7,zero
800060b4:	00009021 	move	s2,zero
	//dprintf("[%s:] %d is_first_boot:%d, isbbt = 0x%X\n\r",__FUNCTION__,__LINE__, is_first_boot,isbbt);
	for(i=0;i<BACKUP_BBT;i++){
		mem_page_num_tmp = mem_page_num;
		page_counter=0;load_bbt_error=0;
		
		rc = rtk_block_isbad((bbt_v2r_page+(i*ppb))*page_size);
800060b8:	3c108001 	lui	s0,0x8001
		if(!rc){
			//printf("load v2r bbt table:%d page:%d\n\r",i, (bbt_v2r_page+(i*ppb)));
		    rc = rtk_read_ecc_page_a(bbt_v2r_page+(i*ppb), &NfDataBuf, &NfSpareBuf,page_size);
800060bc:	24424f04 	addiu	v0,v0,20228
800060c0:	afa2001c 	sw	v0,28(sp)
800060c4:	3c168002 	lui	s6,0x8002
800060c8:	26d65768 	addiu	s6,s6,22376
					//printf("Create bbt_v2r table:%d is_first_boot %d\n\r",i,is_first_boot);
					if(is_first_boot)
					{
							//while(1);//debug cl
						//porting cl for debug not heart first two block
						static_for_create_v2r_bbt  = 1;
800060cc:	24020001 	li	v0,1
800060d0:	afa20038 	sw	v0,56(sp)
// Output:
//		BOOL: 0=>OK, -1=>FAIL 
//####################################################################
static int create_v2r_remapping(unsigned int page, unsigned int block_v2r_num)
{
    printf("[%s:] %d block_v2r_num = %d\n",__func__,__LINE__,block_v2r_num);
800060d4:	3c028001 	lui	v0,0x8001
800060d8:	24424c04 	addiu	v0,v0,19460
800060dc:	afa2003c 	sw	v0,60(sp)
800060e0:	3c028001 	lui	v0,0x8001
800060e4:	24420394 	addiu	v0,v0,916
800060e8:	afa20034 	sw	v0,52(sp)
//printf("bbt_v2r[%d].block_r = %d\n",count,bbt_v2r[count].block_r);
			count++;
		}
	}
	
	printf("[%s:] %d bad block number iii = %d\n",__func__,__LINE__,iii);
800060ec:	3c028001 	lui	v0,0x8001
800060f0:	24424c24 	addiu	v0,v0,19492
800060f4:	afa20040 	sw	v0,64(sp)
	if(!temp_BBT){
		printf("%s: Error, no enough memory for temp_BBT_v2r\n",__FUNCTION__);
		return FAIL;
	}
//test NEW method!
	for(i=0;i<BACKUP_BBT;i++){
800060f8:	afb20014 	sw	s2,20(sp)
	//dprintf("[%s:] %d is_first_boot:%d, isbbt = 0x%X\n\r",__FUNCTION__,__LINE__, is_first_boot,isbbt);
	for(i=0;i<BACKUP_BBT;i++){
		mem_page_num_tmp = mem_page_num;
		page_counter=0;load_bbt_error=0;
		
		rc = rtk_block_isbad((bbt_v2r_page+(i*ppb))*page_size);
800060fc:	3c028001 	lui	v0,0x8001
80006100:	8c4475ec 	lw	a0,30188(v0)
80006104:	72441002 	mul	v0,s2,a0
80006108:	00552021 	addu	a0,v0,s5
8000610c:	8e0275e4 	lw	v0,30180(s0)
80006110:	0c001349 	jal	80004d24 <rtk_block_isbad>
80006114:	70822002 	mul	a0,a0,v0
		if(!rc){
80006118:	144000c4 	bnez	v0,8000642c <rtk_scan_v2r_bbt+0x518>
8000611c:	00409821 	move	s3,v0
			//printf("load v2r bbt table:%d page:%d\n\r",i, (bbt_v2r_page+(i*ppb)));
		    rc = rtk_read_ecc_page_a(bbt_v2r_page+(i*ppb), &NfDataBuf, &NfSpareBuf,page_size);
80006120:	3c028001 	lui	v0,0x8001
80006124:	8c4475ec 	lw	a0,30188(v0)
80006128:	8fb20014 	lw	s2,20(sp)
8000612c:	72441002 	mul	v0,s2,a0
80006130:	00552021 	addu	a0,v0,s5
80006134:	8fa5001c 	lw	a1,28(sp)
80006138:	02c03021 	move	a2,s6
8000613c:	0c0012a2 	jal	80004a88 <rtk_read_ecc_page_a>
80006140:	8e0775e4 	lw	a3,30180(s0)
80006144:	00409821 	move	s3,v0
			#else
				isbbt = NfSpareBuf[0];
			#endif
		    else
			    isbbt = NfSpareBuf[5];
	        if(!rc){
80006148:	144000b9 	bnez	v0,80006430 <rtk_scan_v2r_bbt+0x51c>
8000614c:	92c30035 	lbu	v1,53(s6)
			    //if(isbbt == BBT_TAG && 0)
			    if(isbbt == BBT_TAG){
80006150:	240200bb 	li	v0,187
80006154:	1462002b 	bne	v1,v0,80006204 <rtk_scan_v2r_bbt+0x2f0>
80006158:	8fa40024 	lw	a0,36(sp)
			        //printf("[%s] have created bbt_v2r table:%d on block %d, just loads it !!\n\r", __FUNCTION__,i,(bbt_v2r_page/ppb)+i);
			        memcpy( temp_BBT, &NfDataBuf, page_size );
8000615c:	03c02021 	move	a0,s8
80006160:	8fa5001c 	lw	a1,28(sp)
80006164:	0c002046 	jal	80008118 <memcpy>
80006168:	8e0675e4 	lw	a2,30180(s0)
			        page_counter++;
			        mem_page_num_tmp--;
8000616c:	8fa30030 	lw	v1,48(sp)
80006170:	2474ffff 	addiu	s4,v1,-1
80006174:	329400ff 	andi	s4,s4,0xff
			        while( mem_page_num_tmp>0 ){
80006178:	0800187d 	j	800061f4 <rtk_scan_v2r_bbt+0x2e0>
8000617c:	24110001 	li	s1,1
				        if( rtk_read_ecc_page_a((bbt_v2r_page+(i*ppb)+page_counter), &NfDataBuf, &NfSpareBuf, page_size)){
80006180:	afb10010 	sw	s1,16(sp)
80006184:	3c028001 	lui	v0,0x8001
80006188:	8c4475ec 	lw	a0,30188(v0)
8000618c:	8fa20014 	lw	v0,20(sp)
80006190:	70441802 	mul	v1,v0,a0
80006194:	00752021 	addu	a0,v1,s5
80006198:	00912021 	addu	a0,a0,s1
8000619c:	8fa5001c 	lw	a1,28(sp)
800061a0:	0c0012a2 	jal	80004a88 <rtk_read_ecc_page_a>
800061a4:	8e0775e4 	lw	a3,30180(s0)
800061a8:	10400009 	beqz	v0,800061d0 <rtk_scan_v2r_bbt+0x2bc>
800061ac:	8e0675e4 	lw	a2,30180(s0)
					        printf("[%s] load bbt_v2r table%d error!!\n\r", __FUNCTION__,i);
800061b0:	3c048001 	lui	a0,0x8001
800061b4:	24844be0 	addiu	a0,a0,19424
800061b8:	3c058001 	lui	a1,0x8001
800061bc:	24a50368 	addiu	a1,a1,872
800061c0:	0c002325 	jal	80008c94 <dprintf>
800061c4:	02403021 	move	a2,s2
					        //free(temp_BBT);
					        //load_bbt1 = 1;
					        load_bbt_error = 1;
					        //return -1;
					        //goto TRY_LOAD_BBT1;
			                error_count++;					        
800061c8:	0800190c 	j	80006430 <rtk_scan_v2r_bbt+0x51c>
800061cc:	26f70001 	addiu	s7,s7,1
					        break;
				        }
				        memcpy( temp_BBT+page_counter*page_size, &NfDataBuf, page_size );
800061d0:	8fa20010 	lw	v0,16(sp)
800061d4:	70461802 	mul	v1,v0,a2
800061d8:	007e2021 	addu	a0,v1,s8
800061dc:	0c002046 	jal	80008118 <memcpy>
800061e0:	8fa5001c 	lw	a1,28(sp)
				        page_counter++;
800061e4:	26310001 	addiu	s1,s1,1
800061e8:	323100ff 	andi	s1,s1,0xff
				        mem_page_num_tmp--;
800061ec:	2694ffff 	addiu	s4,s4,-1
800061f0:	329400ff 	andi	s4,s4,0xff
			    if(isbbt == BBT_TAG){
			        //printf("[%s] have created bbt_v2r table:%d on block %d, just loads it !!\n\r", __FUNCTION__,i,(bbt_v2r_page/ppb)+i);
			        memcpy( temp_BBT, &NfDataBuf, page_size );
			        page_counter++;
			        mem_page_num_tmp--;
			        while( mem_page_num_tmp>0 ){
800061f4:	1680ffe2 	bnez	s4,80006180 <rtk_scan_v2r_bbt+0x26c>
800061f8:	02c03021 	move	a2,s6
				        memcpy( temp_BBT+page_counter*page_size, &NfDataBuf, page_size );
				        page_counter++;
				        mem_page_num_tmp--;
			        }
					if(!load_bbt_error){
			            memcpy( bbt_v2r, temp_BBT, sizeof(struct BBT_v2r)*(block_v2r_num));
800061fc:	08001928 	j	800064a0 <rtk_scan_v2r_bbt+0x58c>
80006200:	3c028002 	lui	v0,0x8002
					    //printf("check bbt_v2r table:%d OK\n\r",i);
					    goto CHECK_V2R_BBT_OK;
					}
			    }else{
					//printf("Create bbt_v2r table:%d is_first_boot %d\n\r",i,is_first_boot);
					if(is_first_boot)
80006204:	1080008a 	beqz	a0,80006430 <rtk_scan_v2r_bbt+0x51c>
80006208:	8fa30038 	lw	v1,56(sp)
					{
							//while(1);//debug cl
						//porting cl for debug not heart first two block
						static_for_create_v2r_bbt  = 1;
8000620c:	3c028002 	lui	v0,0x8002
80006210:	ac433d84 	sw	v1,15748(v0)
					    create_v2r_remapping(bbt_v2r_page+(i*ppb),block_v2r_num);
80006214:	3c028001 	lui	v0,0x8001
80006218:	8c4275ec 	lw	v0,30188(v0)
8000621c:	afa20020 	sw	v0,32(sp)
// Output:
//		BOOL: 0=>OK, -1=>FAIL 
//####################################################################
static int create_v2r_remapping(unsigned int page, unsigned int block_v2r_num)
{
    printf("[%s:] %d block_v2r_num = %d\n",__func__,__LINE__,block_v2r_num);
80006220:	8fa4003c 	lw	a0,60(sp)
80006224:	8fa50034 	lw	a1,52(sp)
80006228:	24060bec 	li	a2,3052
8000622c:	0c002325 	jal	80008c94 <dprintf>
80006230:	8fa70028 	lw	a3,40(sp)
	//offs_real = start_page;
#if 1
	count = 0;
	//debug cl
	int iii = 0;
	search_region = (block_v2r_num << block_shift);
80006234:	3c048002 	lui	a0,0x8002
80006238:	8c823d70 	lw	v0,15728(a0)
8000623c:	8fa30028 	lw	v1,40(sp)
80006240:	00431004 	sllv	v0,v1,v0
80006244:	afa2002c 	sw	v0,44(sp)
80006248:	0000a021 	move	s4,zero
8000624c:	afa00010 	sw	zero,16(sp)
80006250:	080018ad 	j	800062b4 <rtk_scan_v2r_bbt+0x3a0>
80006254:	00008821 	move	s1,zero
	//just create [bootloader+user+rootfs+rootfs2] region remapping
    while(offs_real < search_region){
		if ( rtk_block_isbad(offs_real) ){
80006258:	0c001349 	jal	80004d24 <rtk_block_isbad>
8000625c:	02202021 	move	a0,s1
80006260:	10400006 	beqz	v0,8000627c <rtk_scan_v2r_bbt+0x368>
80006264:	3c028002 	lui	v0,0x8002
			offs_real += block_size;
80006268:	3c048001 	lui	a0,0x8001
8000626c:	8c8275c4 	lw	v0,30148(a0)
80006270:	02228821 	addu	s1,s1,v0
			iii++;
80006274:	080018ad 	j	800062b4 <rtk_scan_v2r_bbt+0x3a0>
80006278:	26940001 	addiu	s4,s4,1
		}else{
    		//bbt_v2r[count].block_v = (offs >> block_shift);
    		bbt_v2r[count].block_r = (offs_real >> block_shift);			
8000627c:	8c432e70 	lw	v1,11888(v0)
80006280:	8fa40010 	lw	a0,16(sp)
80006284:	00041080 	sll	v0,a0,0x2
80006288:	00621021 	addu	v0,v1,v0
8000628c:	3c048002 	lui	a0,0x8002
80006290:	8c833d70 	lw	v1,15728(a0)
80006294:	00711806 	srlv	v1,s1,v1
80006298:	ac430000 	sw	v1,0(v0)
			offs+=block_size;
			offs_real += block_size;			
8000629c:	3c038001 	lui	v1,0x8001
800062a0:	8c6275c4 	lw	v0,30148(v1)
800062a4:	02228821 	addu	s1,s1,v0
//printf("bbt_v2r[%d].block_v %d,  bbt_v2r[%d].block_r %d\n",count,bbt_v2r[count].block_v,count,bbt_v2r[count].block_r);
//printf("bbt_v2r[%d].block_r = %d\n",count,bbt_v2r[count].block_r);
			count++;
800062a8:	8fa40010 	lw	a0,16(sp)
800062ac:	24840001 	addiu	a0,a0,1
800062b0:	afa40010 	sw	a0,16(sp)
	count = 0;
	//debug cl
	int iii = 0;
	search_region = (block_v2r_num << block_shift);
	//just create [bootloader+user+rootfs+rootfs2] region remapping
    while(offs_real < search_region){
800062b4:	8fa3002c 	lw	v1,44(sp)
800062b8:	0223102b 	sltu	v0,s1,v1
800062bc:	1440ffe6 	bnez	v0,80006258 <rtk_scan_v2r_bbt+0x344>
800062c0:	8fa40040 	lw	a0,64(sp)
//printf("bbt_v2r[%d].block_r = %d\n",count,bbt_v2r[count].block_r);
			count++;
		}
	}
	
	printf("[%s:] %d bad block number iii = %d\n",__func__,__LINE__,iii);
800062c4:	8fa50034 	lw	a1,52(sp)
800062c8:	24060c0a 	li	a2,3082
800062cc:	0c002325 	jal	80008c94 <dprintf>
800062d0:	02803821 	move	a3,s4
	//printf("[%s, line %d] block_v2r_num %d\n\r",__FUNCTION__,__LINE__, block_v2r_num);
#endif
	mem_page_num = ((sizeof(struct BBT_v2r)*block_v2r_num) + page_size-1 )/page_size;
800062d4:	8e0475e4 	lw	a0,30180(s0)
800062d8:	2482ffff 	addiu	v0,a0,-1
800062dc:	8fa30018 	lw	v1,24(sp)
800062e0:	00431021 	addu	v0,v0,v1
800062e4:	0044001b 	divu	zero,v0,a0
800062e8:	008001f4 	teq	a0,zero,0x7
800062ec:	00008812 	mflo	s1
800062f0:	323100ff 	andi	s1,s1,0xff
	//printf("[%s, line %d] mem_page_num = %d\n\r",__FUNCTION__,__LINE__,mem_page_num);

	temp_BBT = (unsigned char *) malloc( mem_page_num*page_size);
800062f4:	afb1002c 	sw	s1,44(sp)
800062f8:	0c001f55 	jal	80007d54 <malloc>
800062fc:	72242002 	mul	a0,s1,a0
	if ( !temp_BBT ){
80006300:	14400008 	bnez	v0,80006324 <rtk_scan_v2r_bbt+0x410>
80006304:	0040a021 	move	s4,v0
		printf("%s: Error, no enough memory for temp_BBT v2r\n\r",__FUNCTION__);
80006308:	3c048001 	lui	a0,0x8001
8000630c:	24844c48 	addiu	a0,a0,19528
80006310:	3c058001 	lui	a1,0x8001
80006314:	0c002325 	jal	80008c94 <dprintf>
80006318:	24a5037c 	addiu	a1,a1,892
					{
							//while(1);//debug cl
						//porting cl for debug not heart first two block
						static_for_create_v2r_bbt  = 1;
					    create_v2r_remapping(bbt_v2r_page+(i*ppb),block_v2r_num);
						static_for_create_v2r_bbt  = 0;
8000631c:	08001909 	j	80006424 <rtk_scan_v2r_bbt+0x510>
80006320:	3c028002 	lui	v0,0x8002
					if(is_first_boot)
					{
							//while(1);//debug cl
						//porting cl for debug not heart first two block
						static_for_create_v2r_bbt  = 1;
					    create_v2r_remapping(bbt_v2r_page+(i*ppb),block_v2r_num);
80006324:	8fa20020 	lw	v0,32(sp)
80006328:	8fa30014 	lw	v1,20(sp)
8000632c:	70432002 	mul	a0,v0,v1
80006330:	00951021 	addu	v0,a0,s5
80006334:	afa20010 	sw	v0,16(sp)
	if ( !temp_BBT ){
		printf("%s: Error, no enough memory for temp_BBT v2r\n\r",__FUNCTION__);
		rc = FAIL;
		goto EXIT_V2R;
	}
	memset( temp_BBT, 0xff, mem_page_num*page_size);
80006338:	8e0675e4 	lw	a2,30180(s0)
8000633c:	02802021 	move	a0,s4
80006340:	240500ff 	li	a1,255
80006344:	8fa2002c 	lw	v0,44(sp)
80006348:	0c00203d 	jal	800080f4 <memset>
8000634c:	70463002 	mul	a2,v0,a2
	//while(1); //debug cl

	if ( rtk_erase_block_a(page)){
80006350:	0c001048 	jal	80004120 <rtk_erase_block_a>
80006354:	8fa40010 	lw	a0,16(sp)
80006358:	1040000d 	beqz	v0,80006390 <rtk_scan_v2r_bbt+0x47c>
8000635c:	3c028001 	lui	v0,0x8001
		printf("[%s]erase block %d failure !!\n\r", __FUNCTION__, page/ppb);
80006360:	8c4275ec 	lw	v0,30188(v0)
80006364:	8fa30010 	lw	v1,16(sp)
80006368:	0062001b 	divu	zero,v1,v0
8000636c:	004001f4 	teq	v0,zero,0x7
80006370:	00003012 	mflo	a2
80006374:	3c048001 	lui	a0,0x8001
80006378:	24844b18 	addiu	a0,a0,19224
8000637c:	3c058001 	lui	a1,0x8001
80006380:	0c002325 	jal	80008c94 <dprintf>
80006384:	24a5037c 	addiu	a1,a1,892
80006388:	0800192e 	j	800064b8 <rtk_scan_v2r_bbt+0x5a4>
8000638c:	00000000 	nop
		rc =  -1;
		goto EXIT_V2R;
	}
	if(!NAND_ADDR_CYCLE)
	#ifdef SWAP_2K_DATA
		NfSpareBuf[BBI_SWAP_OFFSET] = BBT_TAG;
80006390:	2402ffbb 	li	v0,-69
80006394:	a2c20035 	sb	v0,53(s6)
	#else
		NfSpareBuf[0] = BBT_TAG;
	#endif
	else
		NfSpareBuf[5] = BBT_TAG;
	memcpy( temp_BBT, bbt_v2r, sizeof(struct BBT_v2r)*block_v2r_num );
80006398:	02802021 	move	a0,s4
8000639c:	3c028002 	lui	v0,0x8002
800063a0:	8c452e70 	lw	a1,11888(v0)
800063a4:	0c002046 	jal	80008118 <memcpy>
800063a8:	8fa60018 	lw	a2,24(sp)
800063ac:	08001905 	j	80006414 <rtk_scan_v2r_bbt+0x500>
800063b0:	afa00014 	sw	zero,20(sp)
800063b4:	8fa40010 	lw	a0,16(sp)
800063b8:	00641821 	addu	v1,v1,a0
800063bc:	afa30020 	sw	v1,32(sp)
	//dump_mem((unsigned int)temp_BBT,512);
	while( mem_page_num>0 ){
		//if ( this->write_ecc_page(mtd, 0, page+page_counter, temp_BBT+page_counter*page_size, 
		//	this->g_oobbuf, 1) )
		if(rtk_write_ecc_page_a(page+page_counter,temp_BBT+page_counter*page_size, &NfSpareBuf, page_size))	{
800063c0:	8e0775e4 	lw	a3,30180(s0)
800063c4:	00602021 	move	a0,v1
800063c8:	8fa20014 	lw	v0,20(sp)
800063cc:	70e21802 	mul	v1,a3,v0
800063d0:	00742821 	addu	a1,v1,s4
800063d4:	0c0011da 	jal	80004768 <rtk_write_ecc_page_a>
800063d8:	02c03021 	move	a2,s6
800063dc:	8fa40014 	lw	a0,20(sp)
800063e0:	24840001 	addiu	a0,a0,1
800063e4:	10400009 	beqz	v0,8000640c <rtk_scan_v2r_bbt+0x4f8>
800063e8:	afa40014 	sw	a0,20(sp)
				printf("[%s] write BBT page %d failure!!\n\r", __FUNCTION__, page+page_counter);
800063ec:	3c048001 	lui	a0,0x8001
800063f0:	24844b38 	addiu	a0,a0,19256
800063f4:	3c058001 	lui	a1,0x8001
800063f8:	24a5037c 	addiu	a1,a1,892
800063fc:	0c002325 	jal	80008c94 <dprintf>
80006400:	8fa60020 	lw	a2,32(sp)
80006404:	0800192e 	j	800064b8 <rtk_scan_v2r_bbt+0x5a4>
80006408:	00000000 	nop
				rc =  -1;
				goto EXIT_V2R;
		}
//printf("[%s, line %d] mem_page_num = %d page_counter %d\n\r",__FUNCTION__,__LINE__,mem_page_num, page_counter);
			page_counter++;
			mem_page_num--; 	
8000640c:	2631ffff 	addiu	s1,s1,-1
80006410:	323100ff 	andi	s1,s1,0xff
	#endif
	else
		NfSpareBuf[5] = BBT_TAG;
	memcpy( temp_BBT, bbt_v2r, sizeof(struct BBT_v2r)*block_v2r_num );
	//dump_mem((unsigned int)temp_BBT,512);
	while( mem_page_num>0 ){
80006414:	1620ffe7 	bnez	s1,800063b4 <rtk_scan_v2r_bbt+0x4a0>
80006418:	8fa30014 	lw	v1,20(sp)
8000641c:	0800192e 	j	800064b8 <rtk_scan_v2r_bbt+0x5a4>
80006420:	00000000 	nop
					{
							//while(1);//debug cl
						//porting cl for debug not heart first two block
						static_for_create_v2r_bbt  = 1;
					    create_v2r_remapping(bbt_v2r_page+(i*ppb),block_v2r_num);
						static_for_create_v2r_bbt  = 0;
80006424:	0800190c 	j	80006430 <rtk_scan_v2r_bbt+0x51c>
80006428:	ac403d84 	sw	zero,15748(v0)
					}
			    }
		    }
		}else{
            //printf("bbt_v2r table:%d block:%d page:%d is bad\n\r",i,(bbt_v2r_page/ppb)+i,bbt_v2r_page+(i*ppb));
			error_count++;
8000642c:	26f70001 	addiu	s7,s7,1
	//is_first_boot = 1;
	//while(1);


	//dprintf("[%s:] %d is_first_boot:%d, isbbt = 0x%X\n\r",__FUNCTION__,__LINE__, is_first_boot,isbbt);
	for(i=0;i<BACKUP_BBT;i++){
80006430:	26520001 	addiu	s2,s2,1
80006434:	24020003 	li	v0,3
80006438:	1642ff2f 	bne	s2,v0,800060f8 <rtk_scan_v2r_bbt+0x1e4>
8000643c:	00000000 	nop
			}
		}
	}
#endif
	if (temp_BBT)
		free(temp_BBT);
80006440:	0c001f86 	jal	80007e18 <free>
80006444:	03c02021 	move	a0,s8
    if(error_count >= BACKUP_BBT){
80006448:	2af70003 	slti	s7,s7,3
8000644c:	16e00008 	bnez	s7,80006470 <rtk_scan_v2r_bbt+0x55c>
80006450:	02601021 	move	v0,s3
        rc = -1;
		printf("%d v2r table are all bad!(T______T)\n\r", BACKUP_BBT);
80006454:	3c048001 	lui	a0,0x8001
80006458:	24844c78 	addiu	a0,a0,19576
8000645c:	0c002325 	jal	80008c94 <dprintf>
80006460:	24050003 	li	a1,3
80006464:	08001919 	j	80006464 <rtk_scan_v2r_bbt+0x550>
80006468:	00000000 	nop
		while(1); //debug cl porting for safe
	}
    return rc;
}
8000646c:	02601021 	move	v0,s3
80006470:	8fbf006c 	lw	ra,108(sp)
80006474:	8fbe0068 	lw	s8,104(sp)
80006478:	8fb70064 	lw	s7,100(sp)
8000647c:	8fb60060 	lw	s6,96(sp)
80006480:	8fb5005c 	lw	s5,92(sp)
80006484:	8fb40058 	lw	s4,88(sp)
80006488:	8fb30054 	lw	s3,84(sp)
8000648c:	8fb20050 	lw	s2,80(sp)
80006490:	8fb1004c 	lw	s1,76(sp)
80006494:	8fb00048 	lw	s0,72(sp)
80006498:	03e00008 	jr	ra
8000649c:	27bd0070 	addiu	sp,sp,112
				        memcpy( temp_BBT+page_counter*page_size, &NfDataBuf, page_size );
				        page_counter++;
				        mem_page_num_tmp--;
			        }
					if(!load_bbt_error){
			            memcpy( bbt_v2r, temp_BBT, sizeof(struct BBT_v2r)*(block_v2r_num));
800064a0:	8c442e70 	lw	a0,11888(v0)
800064a4:	03c02821 	move	a1,s8
800064a8:	0c002046 	jal	80008118 <memcpy>
800064ac:	8fa60018 	lw	a2,24(sp)
					    //printf("check bbt_v2r table:%d OK\n\r",i);
					    goto CHECK_V2R_BBT_OK;
800064b0:	08001910 	j	80006440 <rtk_scan_v2r_bbt+0x52c>
800064b4:	00000000 	nop
			page_counter++;
			mem_page_num--; 	
	}
	EXIT_V2R:
	if(temp_BBT)
		free(temp_BBT);
800064b8:	0c001f86 	jal	80007e18 <free>
800064bc:	02802021 	move	a0,s4
					{
							//while(1);//debug cl
						//porting cl for debug not heart first two block
						static_for_create_v2r_bbt  = 1;
					    create_v2r_remapping(bbt_v2r_page+(i*ppb),block_v2r_num);
						static_for_create_v2r_bbt  = 0;
800064c0:	08001909 	j	80006424 <rtk_scan_v2r_bbt+0x510>
800064c4:	3c028002 	lui	v0,0x8002

800064c8 <rtk_PIO_read_page>:
                 ew $start_addr2	 = 0x03000000  //page 0x40
                 ...
                 */

int rtk_PIO_read_page (int flash_address,int enable_show_page_content,int report_bad_block)
{
800064c8:	27bdffa8 	addiu	sp,sp,-88
800064cc:	afbf0054 	sw	ra,84(sp)
800064d0:	afbe0050 	sw	s8,80(sp)
800064d4:	afb7004c 	sw	s7,76(sp)
800064d8:	afb60048 	sw	s6,72(sp)
800064dc:	afb50044 	sw	s5,68(sp)
800064e0:	afb40040 	sw	s4,64(sp)
800064e4:	afb3003c 	sw	s3,60(sp)
800064e8:	afb20038 	sw	s2,56(sp)
800064ec:	afb10034 	sw	s1,52(sp)
800064f0:	afb00030 	sw	s0,48(sp)
800064f4:	00809821 	move	s3,a0
800064f8:	00a0b821 	move	s7,a1
    flush_cache ();
800064fc:	0c001eae 	jal	80007ab8 <flush_cache>
80006500:	afa60060 	sw	a2,96(sp)

    if ((flash_address % (page_size + oob_size)) != 0)
80006504:	3c028001 	lui	v0,0x8001
80006508:	8c4575e4 	lw	a1,30180(v0)
8000650c:	3c028001 	lui	v0,0x8001
80006510:	8c4675e8 	lw	a2,30184(v0)
80006514:	00c52021 	addu	a0,a2,a1
80006518:	0264001b 	divu	zero,s3,a0
8000651c:	008001f4 	teq	a0,zero,0x7
80006520:	00001010 	mfhi	v0
80006524:	10400006 	beqz	v0,80006540 <rtk_PIO_read_page+0x78>
80006528:	00000000 	nop
    {
        dprintf ("\n\rflash_address must be page(0x%x+0x%x Bytes) aligned!\n",
8000652c:	3c048001 	lui	a0,0x8001
80006530:	0c002325 	jal	80008c94 <dprintf>
80006534:	24844654 	addiu	a0,a0,18004

    free(ptr_PIO_READ_NADR);

    return block_indicator;

}
80006538:	080019c2 	j	80006708 <rtk_PIO_read_page+0x240>
8000653c:	8fbf0054 	lw	ra,84(sp)

    int block_indicator=1;                           //"1':good block , "0":bad block
    int bad_block_byte_index=0;

                                                     //pre-allocat
    int* ptr_PIO_READ_NADR= malloc (page_size + oob_size);
80006540:	0c001f55 	jal	80007d54 <malloc>
80006544:	3c118001 	lui	s1,0x8001
80006548:	0040f021 	move	s8,v0

    int page_PIO_num = flash_address / (page_size + oob_size);
8000654c:	3c128001 	lui	s2,0x8001
80006550:	8e3475e8 	lw	s4,30184(s1)
80006554:	8e4275e4 	lw	v0,30180(s2)
80006558:	0282a021 	addu	s4,s4,v0
8000655c:	0274001b 	divu	zero,s3,s4
80006560:	028001f4 	teq	s4,zero,0x7
                 //dprintf ("page_PIO_num=0x%x\n", page_PIO_num);

    int i,j;

                 /*PIO read step-1.*/
    check_ready_nand ();
80006564:	0c000f80 	jal	80003e00 <check_ready_nand>
80006568:	0000a012 	mflo	s4

                 //rtk_writel ((rtk_readl (NACR) & ~(ECC_enable)), NACR); //disable ECC function
    check_ready_nand ();
8000656c:	0c000f80 	jal	80003e00 <check_ready_nand>
80006570:	3c15b801 	lui	s5,0xb801

                 /*PIO read step-2.*/
    rtk_writel (0x0, NACMR);
80006574:	36b0a008 	ori	s0,s5,0xa008
80006578:	ae000000 	sw	zero,0(s0)
    rtk_writel ((CECS0 ), NACMR);
8000657c:	3c164000 	lui	s6,0x4000
80006580:	ae160000 	sw	s6,0(s0)
    check_ready_nand ();
                 //dprintf (" c1-NAADR_REG_value=0x%x\n", NAADR_REG_value);
#endif

#ifdef CONFIG_NAND_Flash_Large_Page_128MB_4cycles
    addr_cycle[0] = addr_cycle[1] = 0;               //Basic PIO read is "Page"
80006584:	afa00014 	sw	zero,20(sp)
80006588:	afa00010 	sw	zero,16(sp)

    for (page_shift = 0; page_shift < 2; page_shift++)
    {
        addr_cycle[page_shift + 2] = (page_PIO_num >> (8 * page_shift)) & 0xff;
8000658c:	328200ff 	andi	v0,s4,0xff
80006590:	afa20018 	sw	v0,24(sp)
80006594:	7e943a00 	ext	s4,s4,0x8,0x8
80006598:	afb4001c 	sw	s4,28(sp)
    }

    NAADR_REG_value=enNextAD|AD2EN|AD1EN|AD0EN|(addr_cycle[2]<<CE_ADDR2);
    rtk_writel(NAADR_REG_value,NAADR);
8000659c:	00021400 	sll	v0,v0,0x10
800065a0:	3c030f00 	lui	v1,0xf00
800065a4:	00431025 	or	v0,v0,v1
800065a8:	36b5a00c 	ori	s5,s5,0xa00c
800065ac:	aea20000 	sw	v0,0(s5)
    check_ready_nand ();
800065b0:	0c000f80 	jal	80003e00 <check_ready_nand>
800065b4:	00000000 	nop
                 //dprintf ("c0-NAADR_REG_value=0x%x\n", NAADR_REG_value);

    NAADR_REG_value=(~enNextAD) & AD0EN |(addr_cycle[3]<<CE_ADDR0) ;
    rtk_writel(NAADR_REG_value,NAADR);
800065b8:	3c020100 	lui	v0,0x100
800065bc:	0282a025 	or	s4,s4,v0
800065c0:	aeb40000 	sw	s4,0(s5)
    check_ready_nand ();
800065c4:	0c000f80 	jal	80003e00 <check_ready_nand>
800065c8:	36d60030 	ori	s6,s6,0x30
                   //dprintf ("addr_cycle[1]=0x%x\n", addr_cycle[1]);
                    //dprintf ("addr_cycle[2]=0x%x\n", addr_cycle[2]);
#endif                                           /*  */

                 /*PIO read step-4.*/
    rtk_writel ((CECS0 | CMD_PG_READ_C2), NACMR);
800065cc:	ae160000 	sw	s6,0(s0)
    check_ready_nand ();
800065d0:	0c000f80 	jal	80003e00 <check_ready_nand>
800065d4:	00000000 	nop

                 /*PIO read step-5.*/
#if 1
                 /*before setting CES0 to 1 (step.6) , user can successively read NADR for the continue next 4 bytes*/
    for (i=0;i<((page_size + oob_size)/4);i++)
800065d8:	8e2375e8 	lw	v1,30184(s1)
800065dc:	8e4275e4 	lw	v0,30180(s2)
800065e0:	00621021 	addu	v0,v1,v0
800065e4:	2c420004 	sltiu	v0,v0,4
800065e8:	14400034 	bnez	v0,800066bc <rtk_PIO_read_page+0x1f4>
800065ec:	00009021 	move	s2,zero
800065f0:	00008021 	move	s0,zero
    {
        *(ptr_PIO_READ_NADR+i) = rtk_readl (NADR);
800065f4:	3c14b801 	lui	s4,0xb801
800065f8:	3694a014 	ori	s4,s4,0xa014
            if(i%4==0)
            {
                dprintf ("\n%08X:    ",(i*4)+flash_address);

            }
            dprintf ("%08X    ",*(ptr_PIO_READ_NADR+i));
800065fc:	3c028001 	lui	v0,0x8001
80006600:	24424cac 	addiu	v0,v0,19628
80006604:	afa20028 	sw	v0,40(sp)
            dprintf ("*(ptr_PIO_READ_NADR+%d)=0x%x\n",i,*(ptr_PIO_READ_NADR+i));
#else

            if(i%4==0)
            {
                dprintf ("\n%08X:    ",(i*4)+flash_address);
80006608:	3c028001 	lui	v0,0x8001
8000660c:	24424ca0 	addiu	v0,v0,19616
80006610:	afa2002c 	sw	v0,44(sp)
    check_ready_nand ();

                 /*PIO read step-5.*/
#if 1
                 /*before setting CES0 to 1 (step.6) , user can successively read NADR for the continue next 4 bytes*/
    for (i=0;i<((page_size + oob_size)/4);i++)
80006614:	0220a821 	move	s5,s1
80006618:	3c168001 	lui	s6,0x8001
    {
        *(ptr_PIO_READ_NADR+i) = rtk_readl (NADR);
8000661c:	00128880 	sll	s1,s2,0x2
80006620:	03d18821 	addu	s1,s8,s1
80006624:	8e820000 	lw	v0,0(s4)

        check_ready_nand ();
80006628:	0c000f80 	jal	80003e00 <check_ready_nand>
8000662c:	ae220000 	sw	v0,0(s1)

        if(enable_show_page_content)
80006630:	12e00009 	beqz	s7,80006658 <rtk_PIO_read_page+0x190>
80006634:	32520003 	andi	s2,s2,0x3
        {
#if 0
            dprintf ("*(ptr_PIO_READ_NADR+%d)=0x%x\n",i,*(ptr_PIO_READ_NADR+i));
#else

            if(i%4==0)
80006638:	16400005 	bnez	s2,80006650 <rtk_PIO_read_page+0x188>
8000663c:	8fa40028 	lw	a0,40(sp)
            {
                dprintf ("\n%08X:    ",(i*4)+flash_address);
80006640:	8fa4002c 	lw	a0,44(sp)
80006644:	0c002325 	jal	80008c94 <dprintf>
80006648:	02602821 	move	a1,s3

            }
            dprintf ("%08X    ",*(ptr_PIO_READ_NADR+i));
8000664c:	8fa40028 	lw	a0,40(sp)
80006650:	0c002325 	jal	80008c94 <dprintf>
80006654:	8e250000 	lw	a1,0(s1)
#endif
        }

                 //Show Bad block information and location
        if((*(ptr_PIO_READ_NADR+i)!=0xffffffff)&&(report_bad_block==1))
80006658:	8e260000 	lw	a2,0(s1)
8000665c:	2402ffff 	li	v0,-1
80006660:	10c2000d 	beq	a2,v0,80006698 <rtk_PIO_read_page+0x1d0>
80006664:	8fa30060 	lw	v1,96(sp)
80006668:	24020001 	li	v0,1
8000666c:	1462000b 	bne	v1,v0,8000669c <rtk_PIO_read_page+0x1d4>
80006670:	26100001 	addiu	s0,s0,1
80006674:	2610ffff 	addiu	s0,s0,-1
        {
            block_indicator=0;                       //bad block
            bad_block_byte_index=i;
                 //dprintf ("\nTotal page size=[0x%x]\n",(page_size + oob_size));
            dprintf ("\nNot equal to 0xffffffff at Byte[%d] , data =0x%x\n",i*4,*(ptr_PIO_READ_NADR+bad_block_byte_index));
80006678:	3c048001 	lui	a0,0x8001
8000667c:	24844cb8 	addiu	a0,a0,19640
80006680:	0c002325 	jal	80008c94 <dprintf>
80006684:	00102880 	sll	a1,s0,0x2

            free(ptr_PIO_READ_NADR);
80006688:	0c001f86 	jal	80007e18 <free>
8000668c:	03c02021 	move	a0,s8

            return block_indicator;
80006690:	080019c1 	j	80006704 <rtk_PIO_read_page+0x23c>
80006694:	00001021 	move	v0,zero
    check_ready_nand ();

                 /*PIO read step-5.*/
#if 1
                 /*before setting CES0 to 1 (step.6) , user can successively read NADR for the continue next 4 bytes*/
    for (i=0;i<((page_size + oob_size)/4);i++)
80006698:	26100001 	addiu	s0,s0,1
8000669c:	02009021 	move	s2,s0
800066a0:	8ea375e8 	lw	v1,30184(s5)
800066a4:	8ec275e4 	lw	v0,30180(s6)
800066a8:	00621021 	addu	v0,v1,v0
800066ac:	00021082 	srl	v0,v0,0x2
800066b0:	0202102b 	sltu	v0,s0,v0
800066b4:	1440ffd9 	bnez	v0,8000661c <rtk_PIO_read_page+0x154>
800066b8:	26730004 	addiu	s3,s3,4
        }

    }
#endif

    if(enable_show_page_content)
800066bc:	12e00005 	beqz	s7,800066d4 <rtk_PIO_read_page+0x20c>
800066c0:	3c03b801 	lui	v1,0xb801
        dprintf ("\n");
800066c4:	3c048001 	lui	a0,0x8001
800066c8:	0c002325 	jal	80008c94 <dprintf>
800066cc:	248457b8 	addiu	a0,a0,22456

                 /*PIO read step-6.*/

    rtk_writel (0x0, NACMR);
800066d0:	3c03b801 	lui	v1,0xb801
800066d4:	3462a008 	ori	v0,v1,0xa008
800066d8:	ac400000 	sw	zero,0(v0)
    rtk_writel (0x0, NAADR);
800066dc:	3463a00c 	ori	v1,v1,0xa00c
800066e0:	ac600000 	sw	zero,0(v1)
    rtk_writel ((CECS0 | CMD_RESET), NACMR);         //reset
800066e4:	3c034000 	lui	v1,0x4000
800066e8:	346300ff 	ori	v1,v1,0xff
800066ec:	ac430000 	sw	v1,0(v0)
                 //rtk_nand_read_id () ;
    check_ready_nand ();
800066f0:	0c000f80 	jal	80003e00 <check_ready_nand>
800066f4:	00000000 	nop

                 //dprintf ("page=0x%x\n",page_PIO_num);

                 //dprintf ("ptr_PIO_READ_NADR=0x%x\n",ptr_PIO_READ_NADR);

    free(ptr_PIO_READ_NADR);
800066f8:	0c001f86 	jal	80007e18 <free>
800066fc:	03c02021 	move	a0,s8
80006700:	24020001 	li	v0,1

    return block_indicator;

}
80006704:	8fbf0054 	lw	ra,84(sp)
80006708:	8fbe0050 	lw	s8,80(sp)
8000670c:	8fb7004c 	lw	s7,76(sp)
80006710:	8fb60048 	lw	s6,72(sp)
80006714:	8fb50044 	lw	s5,68(sp)
80006718:	8fb40040 	lw	s4,64(sp)
8000671c:	8fb3003c 	lw	s3,60(sp)
80006720:	8fb20038 	lw	s2,56(sp)
80006724:	8fb10034 	lw	s1,52(sp)
80006728:	8fb00030 	lw	s0,48(sp)
8000672c:	03e00008 	jr	ra
80006730:	27bd0058 	addiu	sp,sp,88

80006734 <rtk_nand_probe>:
}

int
rtk_nand_probe(void
)
{
80006734:	27bdffd8 	addiu	sp,sp,-40
80006738:	afbf0024 	sw	ra,36(sp)
8000673c:	afb30020 	sw	s3,32(sp)
80006740:	afb2001c 	sw	s2,28(sp)
80006744:	afb10018 	sw	s1,24(sp)
80006748:	afb00014 	sw	s0,20(sp)

rtk_nand_strapin_setting();
8000674c:	0c000fc2 	jal	80003f08 <rtk_nand_strapin_setting>
80006750:	00008821 	move	s1,zero
rtk_nand_strapin_setting();
80006754:	0c000fc2 	jal	80003f08 <rtk_nand_strapin_setting>
80006758:	00000000 	nop
rtk_PIO_read_page(0,0,0);
8000675c:	00002021 	move	a0,zero
80006760:	00002821 	move	a1,zero
80006764:	0c001932 	jal	800064c8 <rtk_PIO_read_page>
80006768:	00003021 	move	a2,zero
rtk_nand_strapin_setting();
8000676c:	0c000fc2 	jal	80003f08 <rtk_nand_strapin_setting>
80006770:	00000000 	nop


  int id_chain = rtk_nand_read_id();
80006774:	0c000f87 	jal	80003e1c <rtk_nand_read_id>
80006778:	00000000 	nop
8000677c:	00408021 	move	s0,v0
  }
#endif /*  */

  //int i=0;
  //dprintf("[%s:] %d id_chain = 0x%X\n",__func__,__LINE__,id_chain);
  memset(&nand_info, 0, sizeof(struct device_type));
80006780:	3c048002 	lui	a0,0x8002
80006784:	24845744 	addiu	a0,a0,22340
80006788:	00002821 	move	a1,zero
8000678c:	0c00203d 	jal	800080f4 <memset>
80006790:	24060024 	li	a2,36
  unsigned int ui, uiCount;

  //unsigned char pucBuffer[4];
  uiCount = sizeof(nand_device) / sizeof(struct device_type);
  dprintf("\n\nScanning NAND registered database ...  ");
80006794:	3c048001 	lui	a0,0x8001
80006798:	0c002325 	jal	80008c94 <dprintf>
8000679c:	24844cec 	addiu	a0,a0,19692
  for (ui = 0; ui < uiCount; ui++) {
    //dprintf("\n(Total:%d , Scan = %d)", uiCount, ui + 1);
    if ((nand_device[ui].id) == (id_chain)) {
800067a0:	3c028001 	lui	v0,0x8001
800067a4:	8c5200e4 	lw	s2,228(v0)
800067a8:	12500008 	beq	s2,s0,800067cc <rtk_nand_probe+0x98>
800067ac:	3c028001 	lui	v0,0x8001
800067b0:	24420108 	addiu	v0,v0,264
800067b4:	24110001 	li	s1,1
#endif /*  */
      break;
    }

    else {
      if ((ui + 1) == uiCount)
800067b8:	2404000e 	li	a0,14
  unsigned int ui, uiCount;

  //unsigned char pucBuffer[4];
  uiCount = sizeof(nand_device) / sizeof(struct device_type);
  dprintf("\n\nScanning NAND registered database ...  ");
  for (ui = 0; ui < uiCount; ui++) {
800067bc:	2403000f 	li	v1,15
    //dprintf("\n(Total:%d , Scan = %d)", uiCount, ui + 1);
    if ((nand_device[ui].id) == (id_chain)) {
800067c0:	8c520000 	lw	s2,0(v0)
800067c4:	16500043 	bne	s2,s0,800068d4 <rtk_nand_probe+0x1a0>
800067c8:	00000000 	nop
           nand_device[ui].name, nand_device[ui].id,
           nand_device[ui].chipsize, nand_device[ui].PageSize,
           nand_device[ui].BlockSize);

#else /*  */
      dprintf("\n=> Found registed NAND Flash, info as below:\n");
800067cc:	3c048001 	lui	a0,0x8001
800067d0:	0c002325 	jal	80008c94 <dprintf>
800067d4:	24844d18 	addiu	a0,a0,19736
      dprintf("1.Chip_name= %s\n", nand_device[ui].name);
800067d8:	00118080 	sll	s0,s1,0x2
800067dc:	00111140 	sll	v0,s1,0x5
800067e0:	02028021 	addu	s0,s0,v0
800067e4:	3c028001 	lui	v0,0x8001
800067e8:	244200e0 	addiu	v0,v0,224
800067ec:	02028021 	addu	s0,s0,v0
800067f0:	3c048001 	lui	a0,0x8001
800067f4:	24844d48 	addiu	a0,a0,19784
800067f8:	0c002325 	jal	80008c94 <dprintf>
800067fc:	8e050000 	lw	a1,0(s0)
      dprintf("2.ID= 0x%x\n", nand_device[ui].id);
80006800:	3c048001 	lui	a0,0x8001
80006804:	24844d5c 	addiu	a0,a0,19804
80006808:	0c002325 	jal	80008c94 <dprintf>
8000680c:	02402821 	move	a1,s2
      dprintf("3.Chip_size= %d MB\n", nand_device[ui].size);
80006810:	3c048001 	lui	a0,0x8001
80006814:	24844d68 	addiu	a0,a0,19816
80006818:	0c002325 	jal	80008c94 <dprintf>
8000681c:	8e050008 	lw	a1,8(s0)
      dprintf("4.Block_cnt= %d \n", nand_device[ui].BlockCnt);
80006820:	3c048001 	lui	a0,0x8001
80006824:	24844d7c 	addiu	a0,a0,19836
80006828:	0c002325 	jal	80008c94 <dprintf>
8000682c:	8e050014 	lw	a1,20(s0)
      dprintf("5.Block_size= %d KB\n", nand_device[ui].BlockSize / 0x400);
80006830:	8e120018 	lw	s2,24(s0)
80006834:	3c048001 	lui	a0,0x8001
80006838:	24844d90 	addiu	a0,a0,19856
8000683c:	0c002325 	jal	80008c94 <dprintf>
80006840:	00122a82 	srl	a1,s2,0xa
      dprintf("6.Page_size= %d Bytes\n", nand_device[ui].PageSize);
80006844:	96130010 	lhu	s3,16(s0)
80006848:	3c048001 	lui	a0,0x8001
8000684c:	24844da8 	addiu	a0,a0,19880
80006850:	0c002325 	jal	80008c94 <dprintf>
80006854:	02602821 	move	a1,s3
      dprintf("7.OobSize= %d KB\n", nand_device[ui].OobSize);
80006858:	3c048001 	lui	a0,0x8001
8000685c:	24844dc0 	addiu	a0,a0,19904
80006860:	0c002325 	jal	80008c94 <dprintf>
80006864:	9605001c 	lhu	a1,28(s0)

	  /*debug cl add from patch, global va init*/
	  nand_select=ui;
80006868:	3c028001 	lui	v0,0x8001
8000686c:	ac5175c0 	sw	s1,30144(v0)
	  block_size= nand_device[ui].BlockSize;
80006870:	3c028001 	lui	v0,0x8001
80006874:	ac5275c4 	sw	s2,30148(v0)
	  chip_size=nand_device[ui].chipsize;
80006878:	8e11000c 	lw	s1,12(s0)
8000687c:	3c028002 	lui	v0,0x8002
80006880:	ac513d80 	sw	s1,15744(v0)
	  block_shift = shift_value(nand_device[ui].BlockSize) -1 ;
80006884:	0c000fa7 	jal	80003e9c <shift_value>
80006888:	02402021 	move	a0,s2
8000688c:	2442ffff 	addiu	v0,v0,-1
80006890:	3c038002 	lui	v1,0x8002
80006894:	ac623d70 	sw	v0,15728(v1)
	  page_shift = shift_value(nand_device[ui].PageSize) -1;
80006898:	0c000fa7 	jal	80003e9c <shift_value>
8000689c:	02602021 	move	a0,s3
800068a0:	2442ffff 	addiu	v0,v0,-1
800068a4:	3c038002 	lui	v1,0x8002
800068a8:	ac623d78 	sw	v0,15736(v1)
	  isLastPage = nand_device[ui].isLastPage;
800068ac:	9203001f 	lbu	v1,31(s0)
800068b0:	3c028002 	lui	v0,0x8002
800068b4:	ac433d7c 	sw	v1,15740(v0)
	  pagemask = (nand_device[ui].chipsize/nand_device[ui].PageSize) -1;
800068b8:	0233001b 	divu	zero,s1,s3
800068bc:	026001f4 	teq	s3,zero,0x7
800068c0:	00008812 	mflo	s1
800068c4:	2631ffff 	addiu	s1,s1,-1
800068c8:	3c028002 	lui	v0,0x8002
#endif /*  */
      break;
800068cc:	08001a3f 	j	800068fc <rtk_nand_probe+0x1c8>
800068d0:	ac513d74 	sw	s1,15732(v0)
    }

    else {
      if ((ui + 1) == uiCount)
800068d4:	16240007 	bne	s1,a0,800068f4 <rtk_nand_probe+0x1c0>
800068d8:	26310001 	addiu	s1,s1,1
800068dc:	2631ffff 	addiu	s1,s1,-1
	  {
        dprintf("\nNo registered NAND Flash found!\n");
800068e0:	3c048001 	lui	a0,0x8001
800068e4:	0c002325 	jal	80008c94 <dprintf>
800068e8:	24844dd4 	addiu	a0,a0,19924
800068ec:	08001a3b 	j	800068ec <rtk_nand_probe+0x1b8>
800068f0:	00000000 	nop
  unsigned int ui, uiCount;

  //unsigned char pucBuffer[4];
  uiCount = sizeof(nand_device) / sizeof(struct device_type);
  dprintf("\n\nScanning NAND registered database ...  ");
  for (ui = 0; ui < uiCount; ui++) {
800068f4:	1623ffb2 	bne	s1,v1,800067c0 <rtk_nand_probe+0x8c>
800068f8:	24420024 	addiu	v0,v0,36

 //JSW 20140227:Aggressive parameter (based on K9F2G08R0A and LX 200MHZ=5ns)
  //rtk_writel(ECC_enable | CE_TWP(5) | CE_TWH(5) | CE_TRR(5) | CE_TH(7) | CE_TS(5), NACR);//less error
  //rtk_writel(ECC_enable | CE_TWP(15) | CE_TWH(15) | CE_TRR(15) | CE_TH(15) | CE_TS(1), NACR); //more error
  //rtk_writel(ECC_enable | CE_TWP(3) | CE_TWH(3) | CE_TRR(3) | CE_TH(3) | CE_TS(3), NACR);//more error
   rtk_writel(ECC_enable | CE_TWP(4) | CE_TWH(4) | CE_TRR(5) | CE_TH(5) | CE_TS(3), NACR);//Aggressive parameter
800068fc:	3c02b801 	lui	v0,0xb801
80006900:	3443a004 	ori	v1,v0,0xa004
80006904:	3c044004 	lui	a0,0x4004
80006908:	34844553 	ori	a0,a0,0x4553
8000690c:	ac640000 	sw	a0,0(v1)
//  dprintf("\n========================================= \n");
//   dprintf("\nhw_srtap=0x%X\n",rtk_readl(0xb8000008));
   //debug cl
//   dprintf("\nNASR=0x%X\n",rtk_readl(NASR)); //should be clear ? to check
   //debug cl
  rtk_writel(0x0000000f, NASR); //clear NAND flash status register
80006910:	3442a028 	ori	v0,v0,0xa028
80006914:	2403000f 	li	v1,15
80006918:	ac430000 	sw	v1,0(v0)
    REG32(0xa0601fc4) = 0x3c1bb800;     //j=2033


  }
#endif /*  */
}
8000691c:	8fbf0024 	lw	ra,36(sp)
80006920:	8fb30020 	lw	s3,32(sp)
80006924:	8fb2001c 	lw	s2,28(sp)
80006928:	8fb10018 	lw	s1,24(sp)
8000692c:	8fb00014 	lw	s0,20(sp)
80006930:	03e00008 	jr	ra
80006934:	27bd0028 	addiu	sp,sp,40

80006938 <nand_write_ecc_ob>:
	//printf("out rx:%x\r\n",rc);
	return rc;

}
int nand_write_ecc_ob (unsigned int to, unsigned int len, unsigned char *data_buf, unsigned char *oob_buf)
{
80006938:	27bdff88 	addiu	sp,sp,-120
8000693c:	afbf0074 	sw	ra,116(sp)
80006940:	afbe0070 	sw	s8,112(sp)
80006944:	afb7006c 	sw	s7,108(sp)
80006948:	afb60068 	sw	s6,104(sp)
8000694c:	afb50064 	sw	s5,100(sp)
80006950:	afb40060 	sw	s4,96(sp)
80006954:	afb3005c 	sw	s3,92(sp)
80006958:	afb20058 	sw	s2,88(sp)
8000695c:	afb10054 	sw	s1,84(sp)
80006960:	afb00050 	sw	s0,80(sp)
80006964:	afa5007c 	sw	a1,124(sp)
80006968:	afa60080 	sw	a2,128(sp)
8000696c:	afa70084 	sw	a3,132(sp)
	unsigned int rsv_block = 0;

	//printf("%s-%d: to %d, len %d oob:%x\n\r",__FUNCTION__,__LINE__,to,len,oob_buf);
{
        unsigned int offset=0, aa=0;
		i = (to >> block_shift);//virtual block index
80006970:	3c028002 	lui	v0,0x8002
80006974:	8c423d70 	lw	v0,15728(v0)
        aa = to & ~(block_size - 1);
80006978:	3c038001 	lui	v1,0x8001
8000697c:	8c6375c4 	lw	v1,30148(v1)
80006980:	00031823 	negu	v1,v1
80006984:	00641824 	and	v1,v1,a0
        offset = to - aa;		
80006988:	00442806 	srlv	a1,a0,v0
8000698c:	3c068002 	lui	a2,0x8002
80006990:	8cc62e70 	lw	a2,11888(a2)
80006994:	00052880 	sll	a1,a1,0x2
80006998:	00c52821 	addu	a1,a2,a1
8000699c:	8ca50000 	lw	a1,0(a1)
800069a0:	00451004 	sllv	v0,a1,v0
800069a4:	00822021 	addu	a0,a0,v0
		to = (bbt_v2r[i].block_r << block_shift) + offset;//real block index, addr.
800069a8:	00832823 	subu	a1,a0,v1
		//printf("%s: blockr:%x to:%x offset %x\n\r",__FUNCTION__,bbt_v2r[i].block_r, to, offset);
}

	if ((to + len) > chip_size) {
800069ac:	8fa2007c 	lw	v0,124(sp)
800069b0:	00a21821 	addu	v1,a1,v0
800069b4:	3c028002 	lui	v0,0x8002
800069b8:	8c423d80 	lw	v0,15744(v0)
800069bc:	0043102b 	sltu	v0,v0,v1
800069c0:	10400005 	beqz	v0,800069d8 <nand_write_ecc_ob+0xa0>
800069c4:	3c048001 	lui	a0,0x8001
		printf("nand_write_ecc: Attempt write beyond end of device\n\r");
800069c8:	0c002325 	jal	80008c94 <dprintf>
800069cc:	24844df8 	addiu	a0,a0,19960
		return FAIL;
800069d0:	08001bd7 	j	80006f5c <nand_write_ecc_ob+0x624>
800069d4:	2402ffff 	li	v0,-1
	}

	if ((to & (page_size-1)) ||(len & (page_size-1))) {
800069d8:	8fa4007c 	lw	a0,124(sp)
800069dc:	00a41825 	or	v1,a1,a0
800069e0:	3c028001 	lui	v0,0x8001
800069e4:	8c4275e4 	lw	v0,30180(v0)
800069e8:	2442ffff 	addiu	v0,v0,-1
800069ec:	00621024 	and	v0,v1,v0
800069f0:	10400007 	beqz	v0,80006a10 <nand_write_ecc_ob+0xd8>
800069f4:	3c038001 	lui	v1,0x8001
		printf("nand_write_ecc: Attempt to write not page aligned data, to = 0x%08X, len = %d\n",to,len);
800069f8:	3c048001 	lui	a0,0x8001
800069fc:	24844e30 	addiu	a0,a0,20016
80006a00:	0c002325 	jal	80008c94 <dprintf>
80006a04:	8fa6007c 	lw	a2,124(sp)
		return FAIL;
80006a08:	08001bd7 	j	80006f5c <nand_write_ecc_ob+0x624>
80006a0c:	2402ffff 	li	v0,-1
	}

	realpage = (int)(to >> page_shift);
	chipnr = chipnr_remap = 0;
	old_page = page = realpage & pagemask;
80006a10:	3c028002 	lui	v0,0x8002
80006a14:	8c543d78 	lw	s4,15736(v0)
80006a18:	02852806 	srlv	a1,a1,s4
80006a1c:	3c028002 	lui	v0,0x8002
80006a20:	8c423d74 	lw	v0,15732(v0)
80006a24:	00a2a024 	and	s4,a1,v0
	page_offset = page & (ppb-1);
80006a28:	3c028001 	lui	v0,0x8001
80006a2c:	8c4275ec 	lw	v0,30188(v0)
	block = page/ppb;
80006a30:	0282001b 	divu	zero,s4,v0
80006a34:	004001f4 	teq	v0,zero,0x7
80006a38:	00008012 	mflo	s0
//ccwei 111116
//	rsv_block = RESERVED_AREA/block_size;


	
	if ( numchips == 1 && block != write_block ){
80006a3c:	8c6375d4 	lw	v1,30164(v1)
80006a40:	12030007 	beq	s0,v1,80006a60 <nand_write_ecc_ob+0x128>
80006a44:	3c038001 	lui	v1,0x8001
		//printf("@@@\r\n");
		write_block = block;
80006a48:	ac7075d4 	sw	s0,30164(v1)
		write_remap_block = 0xFFFFFFFF;
80006a4c:	2404ffff 	li	a0,-1
80006a50:	3c038001 	lui	v1,0x8001
80006a54:	ac6475d8 	sw	a0,30168(v1)
		write_has_check_bbt = 0;
80006a58:	3c038002 	lui	v1,0x8002
80006a5c:	ac603d8c 	sw	zero,15756(v1)
	}
	
	data_len = oob_len = 0;

	//dprintf("----------page: %x-->%x\r\n",page,&data_buf[data_len]);
	while ( data_len < len) {
80006a60:	8fa3007c 	lw	v1,124(sp)
80006a64:	1060013c 	beqz	v1,80006f58 <nand_write_ecc_ob+0x620>
80006a68:	02809821 	move	s3,s4
	}

	realpage = (int)(to >> page_shift);
	chipnr = chipnr_remap = 0;
	old_page = page = realpage & pagemask;
	page_offset = page & (ppb-1);
80006a6c:	2442ffff 	addiu	v0,v0,-1
80006a70:	02821024 	and	v0,s4,v0
	block = page/ppb;
80006a74:	0000a821 	move	s5,zero
80006a78:	0000b021 	move	s6,zero
80006a7c:	0000b821 	move	s7,zero
			//printf("[%s] wirte page %x, len %x, data_buf = 0x%p\n\r",__func__, realpage, len , data_buf);
			goto SKIP_BBT_CHECK;
		}
*/		
		if (numchips == 1){
			if ( (page>=block*ppb) && (page<(block+1)*ppb) && write_has_check_bbt==1 )
80006a80:	3c118001 	lui	s1,0x8001
						write_remap_block = block = bbt[i].remap_block;
				}
			}else
				break;
		}
		write_has_check_bbt = 1;
80006a84:	24040001 	li	a0,1
80006a88:	afa4001c 	sw	a0,28(sp)
		}

		for ( i=0; i<RBA; i++){
			if ( bbt[i].bad_block != BB_INIT ){
				if ( block == bbt[i].bad_block ){
						write_remap_block = block = bbt[i].remap_block;
80006a8c:	3c1e8001 	lui	s8,0x8001

		//if( (page % ppb) == 0) printf(".");
		//printf("page: %x-->%x\r\n",page,&data_buf[data_len]);

		//dprintf("page: %x-->%x\r\n",page,&data_buf[data_len]);
		rc = rtk_write_ecc_page_a ( page, &data_buf[data_len], &oob_buf[oob_len], page_size);
80006a90:	3c128001 	lui	s2,0x8001
				printf("[%s] wirte page %x, len %x, data_buf = 0x%p\n\r",__func__, realpage, len , data_buf);
				return -1;		
			}
*/			
			if(rc == -1){
				printf ("%s: write_ecc_page:  write failed\n\r", __FUNCTION__);
80006a94:	3c038001 	lui	v1,0x8001
80006a98:	24634e80 	addiu	v1,v1,20096
80006a9c:	afa30030 	sw	v1,48(sp)
80006aa0:	3c038001 	lui	v1,0x8001
80006aa4:	24630430 	addiu	v1,v1,1072
80006aa8:	afa30034 	sw	v1,52(sp)
				rtk_write_ecc_page_a ( block_remap*ppb+backup_offset, &data_buf[data_len], &oob_buf[oob_len], page_size);
				//printf("[%s] write failure page = %d to %d\n", __FUNCTION__, page, block_remap*ppb+backup_offset);

				if(!NAND_ADDR_CYCLE)
				#ifdef SWAP_2K_DATA
					NfSpareBuf[BBI_SWAP_OFFSET] = 0x00;
80006aac:	3c038002 	lui	v1,0x8002
80006ab0:	24635768 	addiu	v1,v1,22376
80006ab4:	afa30020 	sw	v1,32(sp)
				backup_offset = page&(ppb-1);
				rtk_erase_block_a(block_remap*ppb);
				//printf("[%s] Start to Backup old_page from %d to %d\n\r", __FUNCTION__, block*ppb, block*ppb+backup_offset-1);

				for ( i=0; i<backup_offset; i++){
					rtk_read_ecc_page_a(block*ppb+i ,&NfDataBuf ,&NfSpareBuf ,page_size);
80006ab8:	3c038002 	lui	v1,0x8002
80006abc:	24634f04 	addiu	v1,v1,20228
80006ac0:	afa30038 	sw	v1,56(sp)
			//printf("[%s] wirte page %x, len %x, data_buf = 0x%p\n\r",__func__, realpage, len , data_buf);
			goto SKIP_BBT_CHECK;
		}
*/		
		if (numchips == 1){
			if ( (page>=block*ppb) && (page<(block+1)*ppb) && write_has_check_bbt==1 )
80006ac4:	8e2375ec 	lw	v1,30188(s1)
80006ac8:	72032002 	mul	a0,s0,v1
80006acc:	0284202b 	sltu	a0,s4,a0
80006ad0:	14800005 	bnez	a0,80006ae8 <nand_write_ecc_ob+0x1b0>
80006ad4:	26040001 	addiu	a0,s0,1
80006ad8:	70831802 	mul	v1,a0,v1
80006adc:	0283a02b 	sltu	s4,s4,v1
80006ae0:	1680000d 	bnez	s4,80006b18 <nand_write_ecc_ob+0x1e0>
80006ae4:	3c058002 	lui	a1,0x8002
				goto SKIP_BBT_CHECK;
		}

		for ( i=0; i<RBA; i++){
80006ae8:	3c038002 	lui	v1,0x8002
80006aec:	8c672e74 	lw	a3,11892(v1)
80006af0:	10e0001a 	beqz	a3,80006b5c <nand_write_ecc_ob+0x224>
80006af4:	3c048002 	lui	a0,0x8002
			if ( bbt[i].bad_block != BB_INIT ){
80006af8:	8c862e78 	lw	a2,11896(a0)
80006afc:	94c40002 	lhu	a0,2(a2)
80006b00:	3403fffe 	li	v1,0xfffe
80006b04:	10830015 	beq	a0,v1,80006b5c <nand_write_ecc_ob+0x224>
80006b08:	24c30008 	addiu	v1,a2,8
80006b0c:	00002821 	move	a1,zero
80006b10:	08001acf 	j	80006b3c <nand_write_ecc_ob+0x204>
80006b14:	3408fffe 	li	t0,0xfffe
			//printf("[%s] wirte page %x, len %x, data_buf = 0x%p\n\r",__func__, realpage, len , data_buf);
			goto SKIP_BBT_CHECK;
		}
*/		
		if (numchips == 1){
			if ( (page>=block*ppb) && (page<(block+1)*ppb) && write_has_check_bbt==1 )
80006b18:	8ca33d8c 	lw	v1,15756(a1)
80006b1c:	24040001 	li	a0,1
80006b20:	1464fff2 	bne	v1,a0,80006aec <nand_write_ecc_ob+0x1b4>
80006b24:	3c038002 	lui	v1,0x8002
				break;
		}
		write_has_check_bbt = 1;
SKIP_BBT_CHECK:
		if ( numchips == 1 && write_has_check_bbt==1 ){
				if ( write_remap_block == 0xFFFFFFFF )
80006b28:	08001adb 	j	80006b6c <nand_write_ecc_ob+0x234>
80006b2c:	8fd475d8 	lw	s4,30168(s8)
			if ( (page>=block*ppb) && (page<(block+1)*ppb) && write_has_check_bbt==1 )
				goto SKIP_BBT_CHECK;
		}

		for ( i=0; i<RBA; i++){
			if ( bbt[i].bad_block != BB_INIT ){
80006b30:	94640002 	lhu	a0,2(v1)
80006b34:	10880009 	beq	a0,t0,80006b5c <nand_write_ecc_ob+0x224>
80006b38:	24630008 	addiu	v1,v1,8
				if ( block == bbt[i].bad_block ){
80006b3c:	14900003 	bne	a0,s0,80006b4c <nand_write_ecc_ob+0x214>
80006b40:	00000000 	nop
						write_remap_block = block = bbt[i].remap_block;
80006b44:	94d00006 	lhu	s0,6(a2)
80006b48:	afd075d8 	sw	s0,30168(s8)
		if (numchips == 1){
			if ( (page>=block*ppb) && (page<(block+1)*ppb) && write_has_check_bbt==1 )
				goto SKIP_BBT_CHECK;
		}

		for ( i=0; i<RBA; i++){
80006b4c:	24a50001 	addiu	a1,a1,1
80006b50:	00a7202b 	sltu	a0,a1,a3
80006b54:	1480fff6 	bnez	a0,80006b30 <nand_write_ecc_ob+0x1f8>
80006b58:	00603021 	move	a2,v1
						write_remap_block = block = bbt[i].remap_block;
				}
			}else
				break;
		}
		write_has_check_bbt = 1;
80006b5c:	8fa3001c 	lw	v1,28(sp)
80006b60:	3c058002 	lui	a1,0x8002
80006b64:	aca33d8c 	sw	v1,15756(a1)
SKIP_BBT_CHECK:
		if ( numchips == 1 && write_has_check_bbt==1 ){
				if ( write_remap_block == 0xFFFFFFFF )
80006b68:	8fd475d8 	lw	s4,30168(s8)
80006b6c:	2403ffff 	li	v1,-1
80006b70:	16830005 	bne	s4,v1,80006b88 <nand_write_ecc_ob+0x250>
80006b74:	8e2375ec 	lw	v1,30188(s1)
					page = block*ppb + page_offset;
80006b78:	8e3475ec 	lw	s4,30188(s1)
80006b7c:	72141802 	mul	v1,s0,s4
80006b80:	08001ae4 	j	80006b90 <nand_write_ecc_ob+0x258>
80006b84:	0062a021 	addu	s4,v1,v0
				else	
					page = write_remap_block*ppb + page_offset;
80006b88:	72832002 	mul	a0,s4,v1
80006b8c:	0082a021 	addu	s4,a0,v0

		//if( (page % ppb) == 0) printf(".");
		//printf("page: %x-->%x\r\n",page,&data_buf[data_len]);

		//dprintf("page: %x-->%x\r\n",page,&data_buf[data_len]);
		rc = rtk_write_ecc_page_a ( page, &data_buf[data_len], &oob_buf[oob_len], page_size);
80006b90:	8fa50080 	lw	a1,128(sp)
80006b94:	00b52821 	addu	a1,a1,s5
80006b98:	afa50014 	sw	a1,20(sp)
80006b9c:	afb60018 	sw	s6,24(sp)
80006ba0:	8fa20084 	lw	v0,132(sp)
80006ba4:	00561021 	addu	v0,v0,s6
80006ba8:	afa20010 	sw	v0,16(sp)
80006bac:	02802021 	move	a0,s4
80006bb0:	00403021 	move	a2,v0
80006bb4:	0c0011da 	jal	80004768 <rtk_write_ecc_page_a>
80006bb8:	8e4775e4 	lw	a3,30180(s2)

		if(rc<0){
80006bbc:	044100cb 	bgez	v0,80006eec <nand_write_ecc_ob+0x5b4>
80006bc0:	8fa30080 	lw	v1,128(sp)
			if(block<(rsv_block-2)){
				printf("[%s] wirte page %x, len %x, data_buf = 0x%p\n\r",__func__, realpage, len , data_buf);
				return -1;		
			}
*/			
			if(rc == -1){
80006bc4:	2403ffff 	li	v1,-1
80006bc8:	144300e1 	bne	v0,v1,80006f50 <nand_write_ecc_ob+0x618>
80006bcc:	8fa40030 	lw	a0,48(sp)
				printf ("%s: write_ecc_page:  write failed\n\r", __FUNCTION__);
80006bd0:	0c002325 	jal	80008c94 <dprintf>
80006bd4:	8fa50034 	lw	a1,52(sp)
				int block_remap = 0x12345678;
				/* update BBT */
			    if(check_BBT(page/ppb)==0)
80006bd8:	8e2275ec 	lw	v0,30188(s1)
80006bdc:	0282001b 	divu	zero,s4,v0
80006be0:	004001f4 	teq	v0,zero,0x7
80006be4:	0c0010b8 	jal	800042e0 <check_BBT>
80006be8:	00002012 	mflo	a0
80006bec:	14400037 	bnez	v0,80006ccc <nand_write_ecc_ob+0x394>
80006bf0:	3c028002 	lui	v0,0x8002
			    {				
				    for( i=0; i<RBA; i++){
80006bf4:	8c452e74 	lw	a1,11892(v0)
80006bf8:	10a00012 	beqz	a1,80006c44 <nand_write_ecc_ob+0x30c>
80006bfc:	3c038002 	lui	v1,0x8002
					    if ( bbt[i].bad_block == BB_INIT && bbt[i].remap_block != RB_INIT){
80006c00:	8c672e78 	lw	a3,11896(v1)
80006c04:	00001021 	move	v0,zero
80006c08:	00001821 	move	v1,zero
80006c0c:	3406fffe 	li	a2,0xfffe
80006c10:	3408fffd 	li	t0,0xfffd
80006c14:	000210c0 	sll	v0,v0,0x3
80006c18:	00e22021 	addu	a0,a3,v0
80006c1c:	94890002 	lhu	t1,2(a0)
80006c20:	15260004 	bne	t1,a2,80006c34 <nand_write_ecc_ob+0x2fc>
80006c24:	00000000 	nop
80006c28:	94890006 	lhu	t1,6(a0)
80006c2c:	1528000c 	bne	t1,t0,80006c60 <nand_write_ecc_ob+0x328>
80006c30:	00000000 	nop
				printf ("%s: write_ecc_page:  write failed\n\r", __FUNCTION__);
				int block_remap = 0x12345678;
				/* update BBT */
			    if(check_BBT(page/ppb)==0)
			    {				
				    for( i=0; i<RBA; i++){
80006c34:	24630001 	addiu	v1,v1,1
80006c38:	0065202b 	sltu	a0,v1,a1
80006c3c:	1480fff5 	bnez	a0,80006c14 <nand_write_ecc_ob+0x2dc>
80006c40:	00601021 	move	v0,v1
						    break;
					    }
				    }

				if ( block_remap == 0x12345678 ){
					printf("[%s] RBA do not have free remap block\n\r", __FUNCTION__);
80006c44:	3c048001 	lui	a0,0x8001
80006c48:	24844ea4 	addiu	a0,a0,20132
80006c4c:	3c058001 	lui	a1,0x8001
80006c50:	0c002325 	jal	80008c94 <dprintf>
80006c54:	24a50430 	addiu	a1,a1,1072
					return FAIL;
80006c58:	08001bd7 	j	80006f5c <nand_write_ecc_ob+0x624>
80006c5c:	2402ffff 	li	v0,-1
			    if(check_BBT(page/ppb)==0)
			    {				
				    for( i=0; i<RBA; i++){
					    if ( bbt[i].bad_block == BB_INIT && bbt[i].remap_block != RB_INIT){
						    err_chipnr = chipnr;
						    bbt[i].BB_die = err_chipnr;
80006c60:	a4800000 	sh	zero,0(a0)
						    bbt[i].bad_block = page/ppb;
80006c64:	3c048002 	lui	a0,0x8002
80006c68:	8c832e78 	lw	v1,11896(a0)
80006c6c:	00621821 	addu	v1,v1,v0
80006c70:	8e2475ec 	lw	a0,30188(s1)
80006c74:	0284001b 	divu	zero,s4,a0
80006c78:	008001f4 	teq	a0,zero,0x7
80006c7c:	00002812 	mflo	a1
80006c80:	a4650002 	sh	a1,2(v1)
						    err_chipnr_remap = bbt[i].RB_die;
						    block_remap = bbt[i].remap_block;
80006c84:	3c048002 	lui	a0,0x8002
80006c88:	8c832e78 	lw	v1,11896(a0)
80006c8c:	00621021 	addu	v0,v1,v0
80006c90:	94420006 	lhu	v0,6(v0)
				if ( block_remap == 0x12345678 ){
					printf("[%s] RBA do not have free remap block\n\r", __FUNCTION__);
					return FAIL;
				}
			
				dump_BBT();
80006c94:	0c001392 	jal	80004e48 <dump_BBT>
80006c98:	afa20024 	sw	v0,36(sp)

				    if ( rtk_update_bbt(bbt)){
80006c9c:	3c058002 	lui	a1,0x8002
80006ca0:	0c00154d 	jal	80005534 <rtk_update_bbt>
80006ca4:	8ca42e78 	lw	a0,11896(a1)
80006ca8:	1040000c 	beqz	v0,80006cdc <nand_write_ecc_ob+0x3a4>
80006cac:	8e2475ec 	lw	a0,30188(s1)
					    printf("[%s] rtk_update_bbt() fails\n", __FUNCTION__);
80006cb0:	3c048001 	lui	a0,0x8001
80006cb4:	24844ecc 	addiu	a0,a0,20172
80006cb8:	3c058001 	lui	a1,0x8001
80006cbc:	0c002325 	jal	80008c94 <dprintf>
80006cc0:	24a50430 	addiu	a1,a1,1072
					    return FAIL;
80006cc4:	08001bd7 	j	80006f5c <nand_write_ecc_ob+0x624>
80006cc8:	2402ffff 	li	v0,-1
80006ccc:	3c021234 	lui	v0,0x1234
80006cd0:	34425678 	ori	v0,v0,0x5678
80006cd4:	afa20024 	sw	v0,36(sp)
				    }
			    }

				backup_offset = page&(ppb-1);
80006cd8:	8e2475ec 	lw	a0,30188(s1)
80006cdc:	2482ffff 	addiu	v0,a0,-1
80006ce0:	02821024 	and	v0,s4,v0
80006ce4:	afa20028 	sw	v0,40(sp)
80006ce8:	afa2002c 	sw	v0,44(sp)
				rtk_erase_block_a(block_remap*ppb);
80006cec:	8fa20024 	lw	v0,36(sp)
80006cf0:	0c001048 	jal	80004120 <rtk_erase_block_a>
80006cf4:	70442002 	mul	a0,v0,a0
				//printf("[%s] Start to Backup old_page from %d to %d\n\r", __FUNCTION__, block*ppb, block*ppb+backup_offset-1);

				for ( i=0; i<backup_offset; i++){
80006cf8:	8fa20028 	lw	v0,40(sp)
80006cfc:	18400026 	blez	v0,80006d98 <nand_write_ecc_ob+0x460>
80006d00:	8e2475ec 	lw	a0,30188(s1)
80006d04:	afa0003c 	sw	zero,60(sp)
					if ( NfSpareBuf )
						reverse_to_Yaffs2Tags(&NfSpareBuf); //czyao
#endif
					if(!NAND_ADDR_CYCLE)
					#ifdef SWAP_2K_DATA
						NfSpareBuf[BBI_SWAP_OFFSET] = 0xff;
80006d08:	afb30040 	sw	s3,64(sp)
80006d0c:	afb60044 	sw	s6,68(sp)
80006d10:	afb70048 	sw	s7,72(sp)
80006d14:	8fb7002c 	lw	s7,44(sp)
80006d18:	afb4002c 	sw	s4,44(sp)
80006d1c:	afb5004c 	sw	s5,76(sp)
80006d20:	0200a821 	move	s5,s0
80006d24:	00008021 	move	s0,zero
80006d28:	8fb60024 	lw	s6,36(sp)
80006d2c:	8fb30020 	lw	s3,32(sp)
80006d30:	8fb40038 	lw	s4,56(sp)
				backup_offset = page&(ppb-1);
				rtk_erase_block_a(block_remap*ppb);
				//printf("[%s] Start to Backup old_page from %d to %d\n\r", __FUNCTION__, block*ppb, block*ppb+backup_offset-1);

				for ( i=0; i<backup_offset; i++){
					rtk_read_ecc_page_a(block*ppb+i ,&NfDataBuf ,&NfSpareBuf ,page_size);
80006d34:	8e2475ec 	lw	a0,30188(s1)
80006d38:	72a41002 	mul	v0,s5,a0
80006d3c:	00502021 	addu	a0,v0,s0
80006d40:	02802821 	move	a1,s4
80006d44:	02603021 	move	a2,s3
80006d48:	0c0012a2 	jal	80004a88 <rtk_read_ecc_page_a>
80006d4c:	8e4775e4 	lw	a3,30180(s2)
					if ( NfSpareBuf )
						reverse_to_Yaffs2Tags(&NfSpareBuf); //czyao
#endif
					if(!NAND_ADDR_CYCLE)
					#ifdef SWAP_2K_DATA
						NfSpareBuf[BBI_SWAP_OFFSET] = 0xff;
80006d50:	2403ffff 	li	v1,-1
80006d54:	a2630035 	sb	v1,53(s3)
					#else
						NfSpareBuf[0] = 0xff;
					#endif
					else
						NfSpareBuf[5] = 0xff;
					rtk_write_ecc_page_a(block_remap*ppb+i ,&NfDataBuf ,&NfSpareBuf ,page_size);
80006d58:	8e2475ec 	lw	a0,30188(s1)
80006d5c:	72c41002 	mul	v0,s6,a0
80006d60:	00502021 	addu	a0,v0,s0
80006d64:	02802821 	move	a1,s4
80006d68:	02603021 	move	a2,s3
80006d6c:	0c0011da 	jal	80004768 <rtk_write_ecc_page_a>
80006d70:	8e4775e4 	lw	a3,30180(s2)

				backup_offset = page&(ppb-1);
				rtk_erase_block_a(block_remap*ppb);
				//printf("[%s] Start to Backup old_page from %d to %d\n\r", __FUNCTION__, block*ppb, block*ppb+backup_offset-1);

				for ( i=0; i<backup_offset; i++){
80006d74:	26100001 	addiu	s0,s0,1
80006d78:	0217102a 	slt	v0,s0,s7
80006d7c:	1440ffee 	bnez	v0,80006d38 <nand_write_ecc_ob+0x400>
80006d80:	8e2475ec 	lw	a0,30188(s1)
80006d84:	8fb30040 	lw	s3,64(sp)
80006d88:	8fb60044 	lw	s6,68(sp)
80006d8c:	8fb70048 	lw	s7,72(sp)
80006d90:	8fb4002c 	lw	s4,44(sp)
80006d94:	8fb5004c 	lw	s5,76(sp)
					else
						NfSpareBuf[5] = 0xff;
					rtk_write_ecc_page_a(block_remap*ppb+i ,&NfDataBuf ,&NfSpareBuf ,page_size);
				}
				//Write the written failed page to new block
				rtk_write_ecc_page_a ( block_remap*ppb+backup_offset, &data_buf[data_len], &oob_buf[oob_len], page_size);
80006d98:	8fa20024 	lw	v0,36(sp)
80006d9c:	8fa30028 	lw	v1,40(sp)
80006da0:	70442802 	mul	a1,v0,a0
80006da4:	00a32021 	addu	a0,a1,v1
80006da8:	8fa50014 	lw	a1,20(sp)
80006dac:	8fa60010 	lw	a2,16(sp)
80006db0:	0c0011da 	jal	80004768 <rtk_write_ecc_page_a>
80006db4:	8e4775e4 	lw	a3,30180(s2)
				//printf("[%s] write failure page = %d to %d\n", __FUNCTION__, page, block_remap*ppb+backup_offset);

				if(!NAND_ADDR_CYCLE)
				#ifdef SWAP_2K_DATA
					NfSpareBuf[BBI_SWAP_OFFSET] = 0x00;
80006db8:	8fa20020 	lw	v0,32(sp)
80006dbc:	a0400035 	sb	zero,53(v0)
					NfSpareBuf[0] = 0x00;
				#endif
				else
					NfSpareBuf[5] = 0x00;

				block = page/ppb;
80006dc0:	8e2275ec 	lw	v0,30188(s1)
80006dc4:	0282001b 	divu	zero,s4,v0
80006dc8:	004001f4 	teq	v0,zero,0x7
80006dcc:	00001812 	mflo	v1
80006dd0:	afa30010 	sw	v1,16(sp)

				if ( isLastPage){
80006dd4:	3c048002 	lui	a0,0x8002
80006dd8:	8c823d7c 	lw	v0,15740(a0)
80006ddc:	10400024 	beqz	v0,80006e70 <nand_write_ecc_ob+0x538>
80006de0:	00000000 	nop
					unsigned char *temp_buf = (unsigned char *)malloc(page_size);
80006de4:	0c001f55 	jal	80007d54 <malloc>
80006de8:	8e4475e4 	lw	a0,30180(s2)
80006dec:	00408021 	move	s0,v0
					memset(temp_buf,0xba,sizeof(char)*page_size);
80006df0:	00402021 	move	a0,v0
80006df4:	240500ba 	li	a1,186
80006df8:	0c00203d 	jal	800080f4 <memset>
80006dfc:	8e4675e4 	lw	a2,30180(s2)
					rtk_erase_block_a(block*ppb);
80006e00:	8e2475ec 	lw	a0,30188(s1)
80006e04:	8fa20010 	lw	v0,16(sp)
80006e08:	0c001048 	jal	80004120 <rtk_erase_block_a>
80006e0c:	70442002 	mul	a0,v0,a0
					rtk_write_ecc_page_a(block*ppb+ppb-1,temp_buf ,&NfSpareBuf , page_size);
80006e10:	8fa30010 	lw	v1,16(sp)
80006e14:	24630001 	addiu	v1,v1,1
80006e18:	afa30010 	sw	v1,16(sp)
80006e1c:	8e2475ec 	lw	a0,30188(s1)
80006e20:	70642002 	mul	a0,v1,a0
80006e24:	2484ffff 	addiu	a0,a0,-1
80006e28:	02002821 	move	a1,s0
80006e2c:	8fa60020 	lw	a2,32(sp)
80006e30:	0c0011da 	jal	80004768 <rtk_write_ecc_page_a>
80006e34:	8e4775e4 	lw	a3,30180(s2)
					rtk_write_ecc_page_a(block*ppb+ppb-2,temp_buf ,&NfSpareBuf , page_size);
80006e38:	8e2475ec 	lw	a0,30188(s1)
80006e3c:	8fa20010 	lw	v0,16(sp)
80006e40:	70442002 	mul	a0,v0,a0
80006e44:	2484fffe 	addiu	a0,a0,-2
80006e48:	02002821 	move	a1,s0
80006e4c:	8fa60020 	lw	a2,32(sp)
80006e50:	0c0011da 	jal	80004768 <rtk_write_ecc_page_a>
80006e54:	8e4775e4 	lw	a3,30180(s2)
                    if(temp_buf)
80006e58:	12000023 	beqz	s0,80006ee8 <nand_write_ecc_ob+0x5b0>
80006e5c:	00000000 	nop
 					    free(temp_buf);
80006e60:	0c001f86 	jal	80007e18 <free>
80006e64:	02002021 	move	a0,s0
				return -1;
			}

		}

		if(data_buf)//add by alexchang 0524-2010
80006e68:	08001bbb 	j	80006eec <nand_write_ecc_ob+0x5b4>
80006e6c:	8fa30080 	lw	v1,128(sp)
					rtk_write_ecc_page_a(block*ppb+ppb-1,temp_buf ,&NfSpareBuf , page_size);
					rtk_write_ecc_page_a(block*ppb+ppb-2,temp_buf ,&NfSpareBuf , page_size);
                    if(temp_buf)
 					    free(temp_buf);
				}else{
					unsigned char *temp_buf = (unsigned char *)malloc(page_size);
80006e70:	0c001f55 	jal	80007d54 <malloc>
80006e74:	8e4475e4 	lw	a0,30180(s2)
80006e78:	00408021 	move	s0,v0
					memset(temp_buf,0xba,sizeof(char)*page_size);
80006e7c:	00402021 	move	a0,v0
80006e80:	240500ba 	li	a1,186
80006e84:	0c00203d 	jal	800080f4 <memset>
80006e88:	8e4675e4 	lw	a2,30180(s2)
					rtk_erase_block_a(block*ppb);
80006e8c:	8e2475ec 	lw	a0,30188(s1)
80006e90:	8fa20010 	lw	v0,16(sp)
80006e94:	0c001048 	jal	80004120 <rtk_erase_block_a>
80006e98:	70442002 	mul	a0,v0,a0
					rtk_write_ecc_page_a(block*ppb,temp_buf ,&NfSpareBuf , page_size);
80006e9c:	8e2475ec 	lw	a0,30188(s1)
80006ea0:	8fa20010 	lw	v0,16(sp)
80006ea4:	70442002 	mul	a0,v0,a0
80006ea8:	02002821 	move	a1,s0
80006eac:	8fa60020 	lw	a2,32(sp)
80006eb0:	0c0011da 	jal	80004768 <rtk_write_ecc_page_a>
80006eb4:	8e4775e4 	lw	a3,30180(s2)
					rtk_write_ecc_page_a(block*ppb+1,temp_buf ,&NfSpareBuf , page_size);
80006eb8:	8e2475ec 	lw	a0,30188(s1)
80006ebc:	8fa20010 	lw	v0,16(sp)
80006ec0:	70442002 	mul	a0,v0,a0
80006ec4:	24840001 	addiu	a0,a0,1
80006ec8:	02002821 	move	a1,s0
80006ecc:	8fa60020 	lw	a2,32(sp)
80006ed0:	0c0011da 	jal	80004768 <rtk_write_ecc_page_a>
80006ed4:	8e4775e4 	lw	a3,30180(s2)
                    if(temp_buf)
80006ed8:	12000004 	beqz	s0,80006eec <nand_write_ecc_ob+0x5b4>
80006edc:	8fa30080 	lw	v1,128(sp)
 					    free(temp_buf);
80006ee0:	0c001f86 	jal	80007e18 <free>
80006ee4:	02002021 	move	a0,s0
				return -1;
			}

		}

		if(data_buf)//add by alexchang 0524-2010
80006ee8:	8fa30080 	lw	v1,128(sp)
80006eec:	10600003 	beqz	v1,80006efc <nand_write_ecc_ob+0x5c4>
80006ef0:	8fa40084 	lw	a0,132(sp)
			data_len += page_size;
80006ef4:	8e5775e4 	lw	s7,30180(s2)
80006ef8:	02b7b821 	addu	s7,s5,s7
		if(oob_buf) //add by alexchang 0524-2010
80006efc:	10800004 	beqz	a0,80006f10 <nand_write_ecc_ob+0x5d8>
80006f00:	3c058001 	lui	a1,0x8001
			oob_len += oob_size;
80006f04:	8cb675e8 	lw	s6,30184(a1)
80006f08:	8fa20018 	lw	v0,24(sp)
80006f0c:	0056b021 	addu	s6,v0,s6
		
		old_page++;
		page_offset = old_page & (ppb-1);
80006f10:	8e3075ec 	lw	s0,30188(s1)
		//printf("page_offset:%x old_page:%x  ppb:%x \r\n",page_offset,old_page,ppb);
		if ( data_len<len && !(old_page & pagemask)) {
80006f14:	8fa3007c 	lw	v1,124(sp)
80006f18:	02e3102b 	sltu	v0,s7,v1
80006f1c:	1040000e 	beqz	v0,80006f58 <nand_write_ecc_ob+0x620>
80006f20:	02e0a821 	move	s5,s7
		if(data_buf)//add by alexchang 0524-2010
			data_len += page_size;
		if(oob_buf) //add by alexchang 0524-2010
			oob_len += oob_size;
		
		old_page++;
80006f24:	26620001 	addiu	v0,s3,1
		page_offset = old_page & (ppb-1);
		//printf("page_offset:%x old_page:%x  ppb:%x \r\n",page_offset,old_page,ppb);
		if ( data_len<len && !(old_page & pagemask)) {
80006f28:	3c038002 	lui	v1,0x8002
80006f2c:	8c733d74 	lw	s3,15732(v1)
80006f30:	00539824 	and	s3,v0,s3
80006f34:	0053980b 	movn	s3,v0,s3
			data_len += page_size;
		if(oob_buf) //add by alexchang 0524-2010
			oob_len += oob_size;
		
		old_page++;
		page_offset = old_page & (ppb-1);
80006f38:	2603ffff 	addiu	v1,s0,-1
80006f3c:	00431024 	and	v0,v0,v1
		//printf("page_offset:%x old_page:%x  ppb:%x \r\n",page_offset,old_page,ppb);
		if ( data_len<len && !(old_page & pagemask)) {
			old_page &= pagemask;
		}
		block = old_page/ppb;
80006f40:	0270001b 	divu	zero,s3,s0
80006f44:	020001f4 	teq	s0,zero,0x7
80006f48:	08001ab1 	j	80006ac4 <nand_write_ecc_ob+0x18c>
80006f4c:	00008012 	mflo	s0
			oob_len += oob_size;
		
		old_page++;
		page_offset = old_page & (ppb-1);
		//printf("page_offset:%x old_page:%x  ppb:%x \r\n",page_offset,old_page,ppb);
		if ( data_len<len && !(old_page & pagemask)) {
80006f50:	08001bd7 	j	80006f5c <nand_write_ecc_ob+0x624>
80006f54:	2402ffff 	li	v0,-1
80006f58:	00001021 	move	v0,zero

	}

	return 0;

}
80006f5c:	8fbf0074 	lw	ra,116(sp)
80006f60:	8fbe0070 	lw	s8,112(sp)
80006f64:	8fb7006c 	lw	s7,108(sp)
80006f68:	8fb60068 	lw	s6,104(sp)
80006f6c:	8fb50064 	lw	s5,100(sp)
80006f70:	8fb40060 	lw	s4,96(sp)
80006f74:	8fb3005c 	lw	s3,92(sp)
80006f78:	8fb20058 	lw	s2,88(sp)
80006f7c:	8fb10054 	lw	s1,84(sp)
80006f80:	8fb00050 	lw	s0,80(sp)
80006f84:	03e00008 	jr	ra
80006f88:	27bd0078 	addiu	sp,sp,120

80006f8c <nand_read_ecc_ob>:
 * data_buf:DRAM space for data
 * oob_buff:DRAM space for oob
 *
 * */
int nand_read_ecc_ob (unsigned int from, unsigned int len, unsigned char *data_buf, unsigned char *oob_buf)
{
80006f8c:	27bdffb0 	addiu	sp,sp,-80
80006f90:	afbf004c 	sw	ra,76(sp)
80006f94:	afbe0048 	sw	s8,72(sp)
80006f98:	afb70044 	sw	s7,68(sp)
80006f9c:	afb60040 	sw	s6,64(sp)
80006fa0:	afb5003c 	sw	s5,60(sp)
80006fa4:	afb40038 	sw	s4,56(sp)
80006fa8:	afb30034 	sw	s3,52(sp)
80006fac:	afb20030 	sw	s2,48(sp)
80006fb0:	afb1002c 	sw	s1,44(sp)
80006fb4:	afb00028 	sw	s0,40(sp)
80006fb8:	afa50054 	sw	a1,84(sp)
80006fbc:	afa60058 	sw	a2,88(sp)
80006fc0:	afa7005c 	sw	a3,92(sp)
	int i, old_page, page_offset, block;
	int chipnr, chipnr_remap;
	int numchips=1;
{
    unsigned int offset=0, aa=0;	
	i = (from >> block_shift); //virtual block index
80006fc4:	3c028002 	lui	v0,0x8002
80006fc8:	8c423d70 	lw	v0,15728(v0)
	aa = from & ~(block_size -1);
80006fcc:	3c038001 	lui	v1,0x8001
80006fd0:	8c6375c4 	lw	v1,30148(v1)
80006fd4:	00031823 	negu	v1,v1
80006fd8:	00641824 	and	v1,v1,a0
	offset = from - aa;
80006fdc:	00442806 	srlv	a1,a0,v0
80006fe0:	3c068002 	lui	a2,0x8002
80006fe4:	8cc62e70 	lw	a2,11888(a2)
80006fe8:	00052880 	sll	a1,a1,0x2
80006fec:	00c52821 	addu	a1,a2,a1
80006ff0:	8ca50000 	lw	a1,0(a1)
80006ff4:	00451004 	sllv	v0,a1,v0
80006ff8:	00822021 	addu	a0,a0,v0
	from =  (bbt_v2r[i].block_r << block_shift) + offset;//real block index, addr.
80006ffc:	00832023 	subu	a0,a0,v1
//printf("%s: blockr:%x from:%x offset %x len:%x\n\r",__FUNCTION__,bbt_v2r[i].block_r, from, offset,len);
}
	if ((from + len) > chip_size) {
80007000:	8fa20054 	lw	v0,84(sp)
80007004:	00821821 	addu	v1,a0,v0
80007008:	3c028002 	lui	v0,0x8002
8000700c:	8c423d80 	lw	v0,15744(v0)
80007010:	0043102b 	sltu	v0,v0,v1
80007014:	10400006 	beqz	v0,80007030 <nand_read_ecc_ob+0xa4>
80007018:	8fa20054 	lw	v0,84(sp)
		printf ("nand_read_ecc: Attempt read beyond end of device\n");
8000701c:	3c048001 	lui	a0,0x8001
80007020:	0c002325 	jal	80008c94 <dprintf>
80007024:	24844eec 	addiu	a0,a0,20204
		return FAIL;
80007028:	08001d21 	j	80007484 <nand_read_ecc_ob+0x4f8>
8000702c:	2412ffff 	li	s2,-1
	}

	if ((from & (page_size-1)) ||(len & (page_size-1))) {
80007030:	00821825 	or	v1,a0,v0
80007034:	3c028001 	lui	v0,0x8001
80007038:	8c4275e4 	lw	v0,30180(v0)
8000703c:	2442ffff 	addiu	v0,v0,-1
80007040:	00621024 	and	v0,v1,v0
80007044:	10400006 	beqz	v0,80007060 <nand_read_ecc_ob+0xd4>
80007048:	3c028002 	lui	v0,0x8002
		printf("nand_read_ecc: Attempt to read not page aligned data\n");
8000704c:	3c048001 	lui	a0,0x8001
80007050:	0c002325 	jal	80008c94 <dprintf>
80007054:	24844f20 	addiu	a0,a0,20256
		return FAIL;
80007058:	08001d21 	j	80007484 <nand_read_ecc_ob+0x4f8>
8000705c:	2412ffff 	li	s2,-1

    //dprintf("[%s]:%d page_shift = %d\n",__func__,__LINE__,page_shift );
    //dprintf("[%s]:%d pagemask = 0x%x\n",__func__,__LINE__,pagemask);
	realpage = (int)(from >> page_shift);
	//chipnr = chipnr_remap = (int)(from >> this->chip_shift);
	old_page = page = realpage & pagemask;
80007060:	8c543d78 	lw	s4,15736(v0)
80007064:	02842006 	srlv	a0,a0,s4
80007068:	3c028002 	lui	v0,0x8002
8000706c:	8c423d74 	lw	v0,15732(v0)
80007070:	0082a024 	and	s4,a0,v0
	page_offset = page & (ppb-1);
80007074:	3c028001 	lui	v0,0x8001
80007078:	8c4275ec 	lw	v0,30188(v0)
	block = page/ppb;
8000707c:	0282001b 	divu	zero,s4,v0
80007080:	004001f4 	teq	v0,zero,0x7
80007084:	00003012 	mflo	a2
	//printf("realpage:%x old_page:%x  page_offset:%x\r\n",realpage,old_page,page_offset);

	if (numchips==1 && block != read_block ){
80007088:	3c038001 	lui	v1,0x8001
8000708c:	8c6375cc 	lw	v1,30156(v1)
80007090:	10c30007 	beq	a2,v1,800070b0 <nand_read_ecc_ob+0x124>
80007094:	3c038001 	lui	v1,0x8001
		read_block = block;
80007098:	ac6675cc 	sw	a2,30156(v1)
		read_remap_block = 0xFFFFFFFF;
8000709c:	2404ffff 	li	a0,-1
800070a0:	3c038001 	lui	v1,0x8001
800070a4:	ac6475d0 	sw	a0,30160(v1)
		read_has_check_bbt = 0;
800070a8:	3c038002 	lui	v1,0x8002
800070ac:	ac603d88 	sw	zero,15752(v1)
	}

	data_len = oob_len = 0;

	while(data_len<len){
800070b0:	8fa30054 	lw	v1,84(sp)
800070b4:	106000f3 	beqz	v1,80007484 <nand_read_ecc_ob+0x4f8>
800070b8:	00009021 	move	s2,zero

    //dprintf("[%s]:%d page_shift = %d\n",__func__,__LINE__,page_shift );
    //dprintf("[%s]:%d pagemask = 0x%x\n",__func__,__LINE__,pagemask);
	realpage = (int)(from >> page_shift);
	//chipnr = chipnr_remap = (int)(from >> this->chip_shift);
	old_page = page = realpage & pagemask;
800070bc:	0280a821 	move	s5,s4
	page_offset = page & (ppb-1);
800070c0:	2442ffff 	addiu	v0,v0,-1
800070c4:	02821024 	and	v0,s4,v0
	block = page/ppb;
800070c8:	0000b821 	move	s7,zero
800070cc:	0000b021 	move	s6,zero
800070d0:	0000f021 	move	s8,zero

	data_len = oob_len = 0;

	while(data_len<len){
		if( numchips==1){
			if ( (page>=block*ppb) && (page<(block+1)*ppb) && read_has_check_bbt==1 )
800070d4:	3c118001 	lui	s1,0x8001
					read_remap_block = block = bbt[i].remap_block;
				}
			}else
				break;
		}
		read_has_check_bbt = 1;
800070d8:	24040001 	li	a0,1
800070dc:	afa40018 	sw	a0,24(sp)
			if ( (page>=block*ppb) && (page<(block+1)*ppb) && read_has_check_bbt==1 )
				goto SKIP_BBT_CHECK;
		}

		for ( i=0; i<RBA; i++){
			if ( bbt[i].bad_block != BB_INIT ){
800070e0:	3410fffe 	li	s0,0xfffe
		}else
			page = block*ppb + page_offset;  

		//if((page % ppb)==0)  printf("$");
	
		rc = rtk_read_ecc_page_a(page, &data_buf[data_len], &oob_buf[oob_len], page_size);
800070e4:	3c138001 	lui	s3,0x8001

			    }//check_BBT
			    
			    if(!NAND_ADDR_CYCLE)
			    #ifdef SWAP_2K_DATA
			        NfSpareBuf[BBI_SWAP_OFFSET] = 0x00;
800070e8:	3c038002 	lui	v1,0x8002
800070ec:	24635768 	addiu	v1,v1,22376
800070f0:	afa3001c 	sw	v1,28(sp)
				    rtk_write_ecc_page_a(block*ppb,temp_buf ,&NfSpareBuf , page_size);
				    rtk_write_ecc_page_a(block*ppb+1,temp_buf ,&NfSpareBuf , page_size);
					if(temp_buf)
					    free(temp_buf);
			    }
			    printf("%s: Un-correctable HW ECC Error at page=%d\n\r",__FUNCTION__, page);
800070f4:	3c038001 	lui	v1,0x8001
800070f8:	24634f78 	addiu	v1,v1,20344
800070fc:	afa30020 	sw	v1,32(sp)
80007100:	3c038001 	lui	v1,0x8001
80007104:	24630450 	addiu	v1,v1,1104
80007108:	afa30024 	sw	v1,36(sp)

	data_len = oob_len = 0;

	while(data_len<len){
		if( numchips==1){
			if ( (page>=block*ppb) && (page<(block+1)*ppb) && read_has_check_bbt==1 )
8000710c:	8e2375ec 	lw	v1,30188(s1)
80007110:	70c32002 	mul	a0,a2,v1
80007114:	0284202b 	sltu	a0,s4,a0
80007118:	14800005 	bnez	a0,80007130 <nand_read_ecc_ob+0x1a4>
8000711c:	24c40001 	addiu	a0,a2,1
80007120:	70831802 	mul	v1,a0,v1
80007124:	0283a02b 	sltu	s4,s4,v1
80007128:	1680000b 	bnez	s4,80007158 <nand_read_ecc_ob+0x1cc>
8000712c:	3c048002 	lui	a0,0x8002
				goto SKIP_BBT_CHECK;
		}

		for ( i=0; i<RBA; i++){
80007130:	3c038002 	lui	v1,0x8002
80007134:	8c682e74 	lw	t0,11892(v1)
80007138:	11000019 	beqz	t0,800071a0 <nand_read_ecc_ob+0x214>
8000713c:	3c048002 	lui	a0,0x8002
			if ( bbt[i].bad_block != BB_INIT ){
80007140:	8c832e78 	lw	v1,11896(a0)
80007144:	94650002 	lhu	a1,2(v1)
80007148:	10b00015 	beq	a1,s0,800071a0 <nand_read_ecc_ob+0x214>
8000714c:	24640008 	addiu	a0,v1,8
80007150:	08001c5f 	j	8000717c <nand_read_ecc_ob+0x1f0>
80007154:	00003821 	move	a3,zero

	data_len = oob_len = 0;

	while(data_len<len){
		if( numchips==1){
			if ( (page>=block*ppb) && (page<(block+1)*ppb) && read_has_check_bbt==1 )
80007158:	8c833d88 	lw	v1,15752(a0)
8000715c:	24040001 	li	a0,1
80007160:	1464fff4 	bne	v1,a0,80007134 <nand_read_ecc_ob+0x1a8>
80007164:	3c038002 	lui	v1,0x8002
		read_has_check_bbt = 1;

SKIP_BBT_CHECK:

		if (  read_has_check_bbt==1 ){
			if ( read_remap_block == 0xFFFFFFFF )
80007168:	08001c6c 	j	800071b0 <nand_read_ecc_ob+0x224>
8000716c:	3c048001 	lui	a0,0x8001
			if ( (page>=block*ppb) && (page<(block+1)*ppb) && read_has_check_bbt==1 )
				goto SKIP_BBT_CHECK;
		}

		for ( i=0; i<RBA; i++){
			if ( bbt[i].bad_block != BB_INIT ){
80007170:	94850002 	lhu	a1,2(a0)
80007174:	10b0000a 	beq	a1,s0,800071a0 <nand_read_ecc_ob+0x214>
80007178:	24840008 	addiu	a0,a0,8
				if ( block == bbt[i].bad_block ){
8000717c:	14a60004 	bne	a1,a2,80007190 <nand_read_ecc_ob+0x204>
80007180:	00000000 	nop
					read_remap_block = block = bbt[i].remap_block;
80007184:	94660006 	lhu	a2,6(v1)
80007188:	3c038001 	lui	v1,0x8001
8000718c:	ac6675d0 	sw	a2,30160(v1)
		if( numchips==1){
			if ( (page>=block*ppb) && (page<(block+1)*ppb) && read_has_check_bbt==1 )
				goto SKIP_BBT_CHECK;
		}

		for ( i=0; i<RBA; i++){
80007190:	24e70001 	addiu	a3,a3,1
80007194:	00e8182b 	sltu	v1,a3,t0
80007198:	1460fff5 	bnez	v1,80007170 <nand_read_ecc_ob+0x1e4>
8000719c:	00801821 	move	v1,a0
					read_remap_block = block = bbt[i].remap_block;
				}
			}else
				break;
		}
		read_has_check_bbt = 1;
800071a0:	8fa30018 	lw	v1,24(sp)
800071a4:	3c048002 	lui	a0,0x8002
800071a8:	ac833d88 	sw	v1,15752(a0)

SKIP_BBT_CHECK:

		if (  read_has_check_bbt==1 ){
			if ( read_remap_block == 0xFFFFFFFF )
800071ac:	3c048001 	lui	a0,0x8001
800071b0:	8c9475d0 	lw	s4,30160(a0)
800071b4:	2403ffff 	li	v1,-1
800071b8:	16830005 	bne	s4,v1,800071d0 <nand_read_ecc_ob+0x244>
800071bc:	8e2375ec 	lw	v1,30188(s1)
				page = block*ppb + page_offset;
800071c0:	8e3475ec 	lw	s4,30188(s1)
800071c4:	70d41802 	mul	v1,a2,s4
800071c8:	08001c76 	j	800071d8 <nand_read_ecc_ob+0x24c>
800071cc:	0062a021 	addu	s4,v1,v0
			else	
				page = read_remap_block*ppb + page_offset;
800071d0:	72832002 	mul	a0,s4,v1
800071d4:	0082a021 	addu	s4,a0,v0
		}else
			page = block*ppb + page_offset;  

		//if((page % ppb)==0)  printf("$");
	
		rc = rtk_read_ecc_page_a(page, &data_buf[data_len], &oob_buf[oob_len], page_size);
800071d8:	afb60010 	sw	s6,16(sp)
800071dc:	02802021 	move	a0,s4
800071e0:	8fa20058 	lw	v0,88(sp)
800071e4:	00572821 	addu	a1,v0,s7
800071e8:	8fa3005c 	lw	v1,92(sp)
800071ec:	00763021 	addu	a2,v1,s6
800071f0:	0c0012a2 	jal	80004a88 <rtk_read_ecc_page_a>
800071f4:	8e6775e4 	lw	a3,30180(s3)
		//dprintf("[%s]:%d rc = %d\n",__func__,__LINE__,rc);
		//while(1); //for safe sake

		if (rc < 0) {
800071f8:	04410088 	bgez	v0,8000741c <nand_read_ecc_ob+0x490>
800071fc:	00409021 	move	s2,v0
		    //dprintf("[%s]:%d for safe sake,how can read get good block to bad block now cancel\n",__func__,__LINE__);
		    //while(1); //for safe sake,how can read get good block to bad block
			if(rc==-1){
80007200:	2402ffff 	li	v0,-1
80007204:	1642007d 	bne	s2,v0,800073fc <nand_read_ecc_ob+0x470>
80007208:	8e2275ec 	lw	v0,30188(s1)
				//printf("%s: page %d Un-correctable HW ECC\n\r", __FUNCTION__, page);
				//update BBT
				if(check_BBT(page/ppb)==0){
8000720c:	0282001b 	divu	zero,s4,v0
80007210:	004001f4 	teq	v0,zero,0x7
80007214:	0c0010b8 	jal	800042e0 <check_BBT>
80007218:	00002012 	mflo	a0
8000721c:	1440002d 	bnez	v0,800072d4 <nand_read_ecc_ob+0x348>
80007220:	8fa3001c 	lw	v1,28(sp)
				    for( i=0; i<RBA; i++){
80007224:	3c028002 	lui	v0,0x8002
80007228:	8c462e74 	lw	a2,11892(v0)
8000722c:	10c0001b 	beqz	a2,8000729c <nand_read_ecc_ob+0x310>
80007230:	3c038002 	lui	v1,0x8002
					    if ( bbt[i].bad_block == BB_INIT && bbt[i].remap_block != RB_INIT){
80007234:	8c672e78 	lw	a3,11896(v1)
80007238:	00001021 	move	v0,zero
8000723c:	00001821 	move	v1,zero
80007240:	3408fffd 	li	t0,0xfffd
80007244:	000210c0 	sll	v0,v0,0x3
80007248:	00e22021 	addu	a0,a3,v0
8000724c:	94850002 	lhu	a1,2(a0)
80007250:	14b0000e 	bne	a1,s0,8000728c <nand_read_ecc_ob+0x300>
80007254:	00000000 	nop
80007258:	94850006 	lhu	a1,6(a0)
8000725c:	10a8000c 	beq	a1,t0,80007290 <nand_read_ecc_ob+0x304>
80007260:	24630001 	addiu	v1,v1,1
						    bbt[i].BB_die = numchips-1;
80007264:	a4800000 	sh	zero,0(a0)
						    bbt[i].bad_block = page/ppb;
80007268:	3c048002 	lui	a0,0x8002
8000726c:	8c832e78 	lw	v1,11896(a0)
80007270:	00621021 	addu	v0,v1,v0
80007274:	8e2375ec 	lw	v1,30188(s1)
80007278:	0283001b 	divu	zero,s4,v1
8000727c:	006001f4 	teq	v1,zero,0x7
80007280:	00001812 	mflo	v1
						    break;
80007284:	08001ca7 	j	8000729c <nand_read_ecc_ob+0x310>
80007288:	a4430002 	sh	v1,2(v0)
		    //while(1); //for safe sake,how can read get good block to bad block
			if(rc==-1){
				//printf("%s: page %d Un-correctable HW ECC\n\r", __FUNCTION__, page);
				//update BBT
				if(check_BBT(page/ppb)==0){
				    for( i=0; i<RBA; i++){
8000728c:	24630001 	addiu	v1,v1,1
80007290:	0066202b 	sltu	a0,v1,a2
80007294:	1480ffeb 	bnez	a0,80007244 <nand_read_ecc_ob+0x2b8>
80007298:	00601021 	move	v0,v1
						    bbt[i].BB_die = numchips-1;
						    bbt[i].bad_block = page/ppb;
						    break;
					    }
				    }
					dump_BBT();
8000729c:	0c001392 	jal	80004e48 <dump_BBT>
800072a0:	00000000 	nop
					
					//if ( rtk_update_bbt ( &NfDataBuf, &NfSpareBuf, bbt) )
					if ( rtk_update_bbt (bbt) ){
800072a4:	3c028002 	lui	v0,0x8002
800072a8:	0c00154d 	jal	80005534 <rtk_update_bbt>
800072ac:	8c442e78 	lw	a0,11896(v0)
800072b0:	10400008 	beqz	v0,800072d4 <nand_read_ecc_ob+0x348>
800072b4:	8fa3001c 	lw	v1,28(sp)
							printf("[%s] rtk_update_bbt() fails\n\r", __FUNCTION__);
800072b8:	3c048001 	lui	a0,0x8001
800072bc:	24844f58 	addiu	a0,a0,20312
800072c0:	3c058001 	lui	a1,0x8001
800072c4:	0c002325 	jal	80008c94 <dprintf>
800072c8:	24a50450 	addiu	a1,a1,1104
							return -1;
800072cc:	08001d22 	j	80007488 <nand_read_ecc_ob+0x4fc>
800072d0:	02401021 	move	v0,s2

			    }//check_BBT
			    
			    if(!NAND_ADDR_CYCLE)
			    #ifdef SWAP_2K_DATA
			        NfSpareBuf[BBI_SWAP_OFFSET] = 0x00;
800072d4:	a0600035 	sb	zero,53(v1)
					NfSpareBuf[0] = 0x00;
			    #endif
			    else
				    NfSpareBuf[5] = 0x00;

				block = page/ppb;
800072d8:	8e3275ec 	lw	s2,30188(s1)
800072dc:	0292001b 	divu	zero,s4,s2
800072e0:	024001f4 	teq	s2,zero,0x7

			    if ( isLastPage){
800072e4:	3c038002 	lui	v1,0x8002
800072e8:	8c623d7c 	lw	v0,15740(v1)
800072ec:	10400021 	beqz	v0,80007374 <nand_read_ecc_ob+0x3e8>
800072f0:	00009012 	mflo	s2
					unsigned char *temp_buf = (unsigned char *)malloc(page_size);
800072f4:	0c001f55 	jal	80007d54 <malloc>
800072f8:	8e6475e4 	lw	a0,30180(s3)
800072fc:	afa20014 	sw	v0,20(sp)
					memset(temp_buf,0xba,sizeof(char)*page_size);
80007300:	00402021 	move	a0,v0
80007304:	240500ba 	li	a1,186
80007308:	0c00203d 	jal	800080f4 <memset>
8000730c:	8e6675e4 	lw	a2,30180(s3)
					rtk_erase_block_a(block*ppb);
80007310:	8e2475ec 	lw	a0,30188(s1)
80007314:	0c001048 	jal	80004120 <rtk_erase_block_a>
80007318:	72442002 	mul	a0,s2,a0
				    rtk_write_ecc_page_a(block*ppb+ppb-1,temp_buf ,&NfSpareBuf , page_size);
8000731c:	26520001 	addiu	s2,s2,1
80007320:	8e2475ec 	lw	a0,30188(s1)
80007324:	72442002 	mul	a0,s2,a0
80007328:	2484ffff 	addiu	a0,a0,-1
8000732c:	8fa50014 	lw	a1,20(sp)
80007330:	8fa6001c 	lw	a2,28(sp)
80007334:	0c0011da 	jal	80004768 <rtk_write_ecc_page_a>
80007338:	8e6775e4 	lw	a3,30180(s3)
				    rtk_write_ecc_page_a(block*ppb+ppb-2,temp_buf ,&NfSpareBuf , page_size);
8000733c:	8e2275ec 	lw	v0,30188(s1)
80007340:	72429002 	mul	s2,s2,v0
80007344:	2644fffe 	addiu	a0,s2,-2
80007348:	8fa50014 	lw	a1,20(sp)
8000734c:	8fa6001c 	lw	a2,28(sp)
80007350:	0c0011da 	jal	80004768 <rtk_write_ecc_page_a>
80007354:	8e6775e4 	lw	a3,30180(s3)
					if(temp_buf)
80007358:	8fa20014 	lw	v0,20(sp)
8000735c:	10400021 	beqz	v0,800073e4 <nand_read_ecc_ob+0x458>
80007360:	00000000 	nop
					    free(temp_buf);
80007364:	0c001f86 	jal	80007e18 <free>
80007368:	00402021 	move	a0,v0
				    rtk_write_ecc_page_a(block*ppb,temp_buf ,&NfSpareBuf , page_size);
				    rtk_write_ecc_page_a(block*ppb+1,temp_buf ,&NfSpareBuf , page_size);
					if(temp_buf)
					    free(temp_buf);
			    }
			    printf("%s: Un-correctable HW ECC Error at page=%d\n\r",__FUNCTION__, page);
8000736c:	08001cfa 	j	800073e8 <nand_read_ecc_ob+0x45c>
80007370:	8fa40020 	lw	a0,32(sp)
				    rtk_write_ecc_page_a(block*ppb+ppb-1,temp_buf ,&NfSpareBuf , page_size);
				    rtk_write_ecc_page_a(block*ppb+ppb-2,temp_buf ,&NfSpareBuf , page_size);
					if(temp_buf)
					    free(temp_buf);
			    }else{
					unsigned char *temp_buf = (unsigned char *)malloc(page_size);
80007374:	0c001f55 	jal	80007d54 <malloc>
80007378:	8e6475e4 	lw	a0,30180(s3)
8000737c:	afa20014 	sw	v0,20(sp)
					memset(temp_buf,0xba,sizeof(char)*page_size);
80007380:	00402021 	move	a0,v0
80007384:	240500ba 	li	a1,186
80007388:	0c00203d 	jal	800080f4 <memset>
8000738c:	8e6675e4 	lw	a2,30180(s3)
					rtk_erase_block_a(block*ppb);
80007390:	8e2475ec 	lw	a0,30188(s1)
80007394:	0c001048 	jal	80004120 <rtk_erase_block_a>
80007398:	72442002 	mul	a0,s2,a0
				    rtk_write_ecc_page_a(block*ppb,temp_buf ,&NfSpareBuf , page_size);
8000739c:	8e2475ec 	lw	a0,30188(s1)
800073a0:	72442002 	mul	a0,s2,a0
800073a4:	8fa50014 	lw	a1,20(sp)
800073a8:	8fa6001c 	lw	a2,28(sp)
800073ac:	0c0011da 	jal	80004768 <rtk_write_ecc_page_a>
800073b0:	8e6775e4 	lw	a3,30180(s3)
				    rtk_write_ecc_page_a(block*ppb+1,temp_buf ,&NfSpareBuf , page_size);
800073b4:	8e2475ec 	lw	a0,30188(s1)
800073b8:	72442002 	mul	a0,s2,a0
800073bc:	24840001 	addiu	a0,a0,1
800073c0:	8fa50014 	lw	a1,20(sp)
800073c4:	8fa6001c 	lw	a2,28(sp)
800073c8:	0c0011da 	jal	80004768 <rtk_write_ecc_page_a>
800073cc:	8e6775e4 	lw	a3,30180(s3)
					if(temp_buf)
800073d0:	8fa20014 	lw	v0,20(sp)
800073d4:	10400004 	beqz	v0,800073e8 <nand_read_ecc_ob+0x45c>
800073d8:	8fa40020 	lw	a0,32(sp)
					    free(temp_buf);
800073dc:	0c001f86 	jal	80007e18 <free>
800073e0:	00402021 	move	a0,v0
			    }
			    printf("%s: Un-correctable HW ECC Error at page=%d\n\r",__FUNCTION__, page);
800073e4:	8fa40020 	lw	a0,32(sp)
800073e8:	8fa50024 	lw	a1,36(sp)
800073ec:	0c002325 	jal	80008c94 <dprintf>
800073f0:	02803021 	move	a2,s4
800073f4:	08001d07 	j	8000741c <nand_read_ecc_ob+0x490>
800073f8:	00009021 	move	s2,zero
				rc = 0;
		    }else{
				printf("%s: page %d failed\n", __FUNCTION__, page);
800073fc:	3c048001 	lui	a0,0x8001
80007400:	24844fa8 	addiu	a0,a0,20392
80007404:	3c058001 	lui	a1,0x8001
80007408:	24a50450 	addiu	a1,a1,1104
8000740c:	0c002325 	jal	80008c94 <dprintf>
80007410:	02803021 	move	a2,s4
				return -1;
80007414:	08001d21 	j	80007484 <nand_read_ecc_ob+0x4f8>
80007418:	2412ffff 	li	s2,-1
			}
		}
		if(data_buf)//add by alexchang 0524-2010
8000741c:	8fa30058 	lw	v1,88(sp)
80007420:	10600003 	beqz	v1,80007430 <nand_read_ecc_ob+0x4a4>
80007424:	8fa4005c 	lw	a0,92(sp)
		data_len += page_size;
80007428:	8e7e75e4 	lw	s8,30180(s3)
8000742c:	02fef021 	addu	s8,s7,s8

		if(oob_buf)//add by alexchang 0524-2010
80007430:	10800004 	beqz	a0,80007444 <nand_read_ecc_ob+0x4b8>
80007434:	3c028001 	lui	v0,0x8001
		oob_len += oob_size;
80007438:	8c5675e8 	lw	s6,30184(v0)
8000743c:	8fa30010 	lw	v1,16(sp)
80007440:	0076b021 	addu	s6,v1,s6
		
		old_page++;
		page_offset = old_page & (ppb-1);
80007444:	8e2375ec 	lw	v1,30188(s1)
		if ( data_len<len && !(old_page &  pagemask)) {
80007448:	8fa40054 	lw	a0,84(sp)
8000744c:	03c4102b 	sltu	v0,s8,a0
80007450:	1040000c 	beqz	v0,80007484 <nand_read_ecc_ob+0x4f8>
80007454:	03c0b821 	move	s7,s8
		data_len += page_size;

		if(oob_buf)//add by alexchang 0524-2010
		oob_len += oob_size;
		
		old_page++;
80007458:	26a20001 	addiu	v0,s5,1
		page_offset = old_page & (ppb-1);
		if ( data_len<len && !(old_page &  pagemask)) {
8000745c:	3c048002 	lui	a0,0x8002
80007460:	8c953d74 	lw	s5,15732(a0)
80007464:	0055a824 	and	s5,v0,s5
80007468:	0055a80b 	movn	s5,v0,s5

		if(oob_buf)//add by alexchang 0524-2010
		oob_len += oob_size;
		
		old_page++;
		page_offset = old_page & (ppb-1);
8000746c:	2464ffff 	addiu	a0,v1,-1
80007470:	00441024 	and	v0,v0,a0
		if ( data_len<len && !(old_page &  pagemask)) {
			old_page &= pagemask;
		}
		
		block = old_page/ppb;
80007474:	02a3001b 	divu	zero,s5,v1
80007478:	006001f4 	teq	v1,zero,0x7
8000747c:	08001c44 	j	80007110 <nand_read_ecc_ob+0x184>
80007480:	00003012 	mflo	a2
	}
    //while(1); //debug cl for safe sake
	//printf("out rx:%x\r\n",rc);
	return rc;

}
80007484:	02401021 	move	v0,s2
80007488:	8fbf004c 	lw	ra,76(sp)
8000748c:	8fbe0048 	lw	s8,72(sp)
80007490:	8fb70044 	lw	s7,68(sp)
80007494:	8fb60040 	lw	s6,64(sp)
80007498:	8fb5003c 	lw	s5,60(sp)
8000749c:	8fb40038 	lw	s4,56(sp)
800074a0:	8fb30034 	lw	s3,52(sp)
800074a4:	8fb20030 	lw	s2,48(sp)
800074a8:	8fb1002c 	lw	s1,44(sp)
800074ac:	8fb00028 	lw	s0,40(sp)
800074b0:	03e00008 	jr	ra
800074b4:	27bd0050 	addiu	sp,sp,80

800074b8 <nand_erase_nand>:

#endif  /*  */

 #ifdef CONFIG_RTK_NAND_BBT
int nand_erase_nand (unsigned int addr, unsigned int len)
{
800074b8:	27bdffa8 	addiu	sp,sp,-88
800074bc:	afbf0054 	sw	ra,84(sp)
800074c0:	afbe0050 	sw	s8,80(sp)
800074c4:	afb7004c 	sw	s7,76(sp)
800074c8:	afb60048 	sw	s6,72(sp)
800074cc:	afb50044 	sw	s5,68(sp)
800074d0:	afb40040 	sw	s4,64(sp)
800074d4:	afb3003c 	sw	s3,60(sp)
800074d8:	afb20038 	sw	s2,56(sp)
800074dc:	afb10034 	sw	s1,52(sp)
800074e0:	afb00030 	sw	s0,48(sp)
800074e4:	afa5005c 	sw	a1,92(sp)
	int err_chipnr = 0, err_chipnr_remap = 1;
	int numchips=1, page_offset=0;

	{
	unsigned int real_addr;
	i = (addr >> block_shift);
800074e8:	3c028002 	lui	v0,0x8002
800074ec:	8c423d70 	lw	v0,15728(v0)
	
	real_addr = (bbt_v2r[i].block_r << block_shift);//real block index, addr.
800074f0:	00441806 	srlv	v1,a0,v0
800074f4:	3c048002 	lui	a0,0x8002
800074f8:	8c852e70 	lw	a1,11888(a0)
800074fc:	00031880 	sll	v1,v1,0x2
80007500:	00a31821 	addu	v1,a1,v1
80007504:	8c630000 	lw	v1,0(v1)
80007508:	00431804 	sllv	v1,v1,v0
8000750c:	afa30020 	sw	v1,32(sp)
	addr = real_addr;
	//printf("%s: blockr:%x addr:%x pagemask%x \n\r",__FUNCTION__,bbt_v2r[i].block_r, addr,pagemask);
	}
	realpage = (int) (addr >> page_shift);
80007510:	3c028002 	lui	v0,0x8002
80007514:	8c533d78 	lw	s3,15736(v0)
	chipnr = chipnr_remap = 0;
	old_page = page = realpage & pagemask;
80007518:	3c028002 	lui	v0,0x8002
8000751c:	8c433d74 	lw	v1,15732(v0)
	page_offset = page & (ppb-1);
	block = page/ppb;
80007520:	3c028001 	lui	v0,0x8001
80007524:	8c5475ec 	lw	s4,30188(v0)

	if ((addr + len) > chip_size) {
80007528:	3c028002 	lui	v0,0x8002
8000752c:	8c423d80 	lw	v0,15744(v0)
80007530:	8fa5005c 	lw	a1,92(sp)
80007534:	8fa60020 	lw	a2,32(sp)
80007538:	00a62021 	addu	a0,a1,a2
8000753c:	0044202b 	sltu	a0,v0,a0
80007540:	14800005 	bnez	a0,80007558 <nand_erase_nand+0xa0>
80007544:	00000000 	nop
		printf("%s: Attempt erase beyond end of device add:%x len:%x cs:%x\n\r",__FUNCTION__,addr,len,chip_size);
		return FAIL;
	}
	
 	while (elen < len) {
80007548:	14a000b4 	bnez	a1,8000781c <nand_erase_nand+0x364>
8000754c:	00009021 	move	s2,zero
		for ( i=0; i<RBA; i++){			
			if ( bbt[i].bad_block != BB_INIT ){
80007550:	08001e27 	j	8000789c <nand_erase_nand+0x3e4>
80007554:	00001021 	move	v0,zero
	old_page = page = realpage & pagemask;
	page_offset = page & (ppb-1);
	block = page/ppb;

	if ((addr + len) > chip_size) {
		printf("%s: Attempt erase beyond end of device add:%x len:%x cs:%x\n\r",__FUNCTION__,addr,len,chip_size);
80007558:	afa20010 	sw	v0,16(sp)
8000755c:	3c048001 	lui	a0,0x8001
80007560:	24844fbc 	addiu	a0,a0,20412
80007564:	3c058001 	lui	a1,0x8001
80007568:	24a50478 	addiu	a1,a1,1144
8000756c:	8fa60020 	lw	a2,32(sp)
80007570:	0c002325 	jal	80008c94 <dprintf>
80007574:	8fa7005c 	lw	a3,92(sp)
		return FAIL;
80007578:	08001e27 	j	8000789c <nand_erase_nand+0x3e4>
8000757c:	2402ffff 	li	v0,-1
	}
	
 	while (elen < len) {
		for ( i=0; i<RBA; i++){			
			if ( bbt[i].bad_block != BB_INIT ){
80007580:	94430002 	lhu	v1,2(v0)
80007584:	10700008 	beq	v1,s0,800075a8 <nand_erase_nand+0xf0>
80007588:	24420008 	addiu	v0,v0,8
				if ( block == bbt[i].bad_block ){
8000758c:	14740002 	bne	v1,s4,80007598 <nand_erase_nand+0xe0>
80007590:	00000000 	nop
					block = bbt[i].remap_block;
80007594:	94b40006 	lhu	s4,6(a1)
		printf("%s: Attempt erase beyond end of device add:%x len:%x cs:%x\n\r",__FUNCTION__,addr,len,chip_size);
		return FAIL;
	}
	
 	while (elen < len) {
		for ( i=0; i<RBA; i++){			
80007598:	24840001 	addiu	a0,a0,1
8000759c:	0086182b 	sltu	v1,a0,a2
800075a0:	1460fff7 	bnez	v1,80007580 <nand_erase_nand+0xc8>
800075a4:	00402821 	move	a1,v0
				}			
			}else				
			break;		
		}

		page = block*ppb;
800075a8:	8e3575ec 	lw	s5,30188(s1)
800075ac:	7295a802 	mul	s5,s4,s5
		//printf("Ready to Erase blk %x\n\r",page/ppb);
		
		rc = rtk_erase_block_a(page);
800075b0:	0c001048 	jal	80004120 <rtk_erase_block_a>
800075b4:	02a02021 	move	a0,s5
			
		if (rc) {
800075b8:	1040008a 	beqz	v0,800077e4 <nand_erase_nand+0x32c>
800075bc:	8ec375c4 	lw	v1,30148(s6)
		    printf("%s: block erase failed at page address=0x%08x\n", __FUNCTION__, addr);
800075c0:	8fa40028 	lw	a0,40(sp)
800075c4:	8fa5002c 	lw	a1,44(sp)
800075c8:	0c002325 	jal	80008c94 <dprintf>
800075cc:	8fa60020 	lw	a2,32(sp)
			int block_remap = 0x12345678;
            /* update BBT */
			if(check_BBT(page/ppb)==0)
800075d0:	8e2275ec 	lw	v0,30188(s1)
800075d4:	02a2001b 	divu	zero,s5,v0
800075d8:	004001f4 	teq	v0,zero,0x7
800075dc:	0c0010b8 	jal	800042e0 <check_BBT>
800075e0:	00002012 	mflo	a0

                dump_BBT();

                if ( rtk_update_bbt(bbt)){
	                printf("[%s] rtk_update_bbt() fails\n", __FUNCTION__);
	                return FAIL;
800075e4:	8fa30024 	lw	v1,36(sp)
			
		if (rc) {
		    printf("%s: block erase failed at page address=0x%08x\n", __FUNCTION__, addr);
			int block_remap = 0x12345678;
            /* update BBT */
			if(check_BBT(page/ppb)==0)
800075e8:	14400038 	bnez	v0,800076cc <nand_erase_nand+0x214>
800075ec:	afa3001c 	sw	v1,28(sp)
			{				
                for( i=0; i<RBA; i++){
800075f0:	3c048002 	lui	a0,0x8002
800075f4:	8c862e74 	lw	a2,11892(a0)
800075f8:	10c00020 	beqz	a2,8000767c <nand_erase_nand+0x1c4>
800075fc:	8ee72e78 	lw	a3,11896(s7)
	                if ( bbt[i].bad_block == BB_INIT && bbt[i].remap_block != RB_INIT){
80007600:	03c01021 	move	v0,s8
80007604:	03c01821 	move	v1,s8
80007608:	000210c0 	sll	v0,v0,0x3
8000760c:	00e22021 	addu	a0,a3,v0
80007610:	94850002 	lhu	a1,2(a0)
80007614:	14b00015 	bne	a1,s0,8000766c <nand_erase_nand+0x1b4>
80007618:	3408fffd 	li	t0,0xfffd
8000761c:	94850006 	lhu	a1,6(a0)
80007620:	10a80013 	beq	a1,t0,80007670 <nand_erase_nand+0x1b8>
80007624:	24630001 	addiu	v1,v1,1
		                err_chipnr = chipnr;
		                bbt[i].BB_die = err_chipnr;
80007628:	a4800000 	sh	zero,0(a0)
		                bbt[i].bad_block = page/ppb;
8000762c:	8ee32e78 	lw	v1,11896(s7)
80007630:	00621821 	addu	v1,v1,v0
80007634:	8e2475ec 	lw	a0,30188(s1)
80007638:	02a4001b 	divu	zero,s5,a0
8000763c:	008001f4 	teq	a0,zero,0x7
80007640:	0000a812 	mflo	s5
80007644:	a4750002 	sh	s5,2(v1)
		                err_chipnr_remap = bbt[i].RB_die;
		                block_remap = bbt[i].remap_block;
80007648:	8ee32e78 	lw	v1,11896(s7)
8000764c:	00621021 	addu	v0,v1,v0
80007650:	94420006 	lhu	v0,6(v0)
80007654:	afa2001c 	sw	v0,28(sp)
		                break;
	                }
                }

                if( block_remap == 0x12345678 ){
80007658:	8fa30024 	lw	v1,36(sp)
8000765c:	1443000e 	bne	v0,v1,80007698 <nand_erase_nand+0x1e0>
80007660:	3c048001 	lui	a0,0x8001
	                 printf("[%s] RBA do not have free remap block\n\r", __FUNCTION__);
80007664:	08001da1 	j	80007684 <nand_erase_nand+0x1cc>
80007668:	24844ea4 	addiu	a0,a0,20132
		    printf("%s: block erase failed at page address=0x%08x\n", __FUNCTION__, addr);
			int block_remap = 0x12345678;
            /* update BBT */
			if(check_BBT(page/ppb)==0)
			{				
                for( i=0; i<RBA; i++){
8000766c:	24630001 	addiu	v1,v1,1
80007670:	0066202b 	sltu	a0,v1,a2
80007674:	1480ffe4 	bnez	a0,80007608 <nand_erase_nand+0x150>
80007678:	00601021 	move	v0,v1
		                break;
	                }
                }

                if( block_remap == 0x12345678 ){
	                 printf("[%s] RBA do not have free remap block\n\r", __FUNCTION__);
8000767c:	3c048001 	lui	a0,0x8001
80007680:	24844ea4 	addiu	a0,a0,20132
80007684:	3c058001 	lui	a1,0x8001
80007688:	0c002325 	jal	80008c94 <dprintf>
8000768c:	24a50478 	addiu	a1,a1,1144
	                 return FAIL;
80007690:	08001e27 	j	8000789c <nand_erase_nand+0x3e4>
80007694:	2402ffff 	li	v0,-1
                }

                dump_BBT();
80007698:	0c001392 	jal	80004e48 <dump_BBT>
8000769c:	00000000 	nop

                if ( rtk_update_bbt(bbt)){
800076a0:	0c00154d 	jal	80005534 <rtk_update_bbt>
800076a4:	8ee42e78 	lw	a0,11896(s7)
800076a8:	10400009 	beqz	v0,800076d0 <nand_erase_nand+0x218>
800076ac:	8fa40018 	lw	a0,24(sp)
	                printf("[%s] rtk_update_bbt() fails\n", __FUNCTION__);
800076b0:	3c048001 	lui	a0,0x8001
800076b4:	24844ecc 	addiu	a0,a0,20172
800076b8:	3c058001 	lui	a1,0x8001
800076bc:	0c002325 	jal	80008c94 <dprintf>
800076c0:	24a50478 	addiu	a1,a1,1144
	                return FAIL;
800076c4:	08001e27 	j	8000789c <nand_erase_nand+0x3e4>
800076c8:	2402ffff 	li	v0,-1
                }
			}
		
		     if(!NAND_ADDR_CYCLE)
		     #ifdef SWAP_2K_DATA
			     NfSpareBuf[BBI_SWAP_OFFSET] = 0x00;
800076cc:	8fa40018 	lw	a0,24(sp)
800076d0:	a0800035 	sb	zero,53(a0)
				NfSpareBuf[0] = 0x00;
			 #endif
		     else
			     NfSpareBuf[5] = 0x00;
		
		     if ( isLastPage){
800076d4:	3c058002 	lui	a1,0x8002
800076d8:	8ca23d7c 	lw	v0,15740(a1)
800076dc:	10400021 	beqz	v0,80007764 <nand_erase_nand+0x2ac>
800076e0:	3c038001 	lui	v1,0x8001
				 unsigned char *temp_buf = (unsigned char *)malloc(page_size);
800076e4:	3c068001 	lui	a2,0x8001
800076e8:	0c001f55 	jal	80007d54 <malloc>
800076ec:	8cc475e4 	lw	a0,30180(a2)
800076f0:	0040a821 	move	s5,v0
				 memset(temp_buf,0xba,sizeof(char)*page_size);
800076f4:	00402021 	move	a0,v0
800076f8:	240500ba 	li	a1,186
800076fc:	3c088001 	lui	t0,0x8001
80007700:	0c00203d 	jal	800080f4 <memset>
80007704:	8d0675e4 	lw	a2,30180(t0)
			     rtk_write_ecc_page_a(block*ppb+ppb-1,temp_buf ,&NfSpareBuf , page_size);
80007708:	26940001 	addiu	s4,s4,1
8000770c:	8e2475ec 	lw	a0,30188(s1)
80007710:	72842002 	mul	a0,s4,a0
80007714:	2484ffff 	addiu	a0,a0,-1
80007718:	02a02821 	move	a1,s5
8000771c:	8fa60018 	lw	a2,24(sp)
80007720:	3c028001 	lui	v0,0x8001
80007724:	0c0011da 	jal	80004768 <rtk_write_ecc_page_a>
80007728:	8c4775e4 	lw	a3,30180(v0)
			     rtk_write_ecc_page_a(block*ppb+ppb-2,temp_buf ,&NfSpareBuf , page_size);
8000772c:	8e2275ec 	lw	v0,30188(s1)
80007730:	7282a002 	mul	s4,s4,v0
80007734:	2684fffe 	addiu	a0,s4,-2
80007738:	02a02821 	move	a1,s5
8000773c:	8fa60018 	lw	a2,24(sp)
80007740:	3c028001 	lui	v0,0x8001
80007744:	0c0011da 	jal	80004768 <rtk_write_ecc_page_a>
80007748:	8c4775e4 	lw	a3,30180(v0)
	             if(temp_buf)
8000774c:	12a00020 	beqz	s5,800077d0 <nand_erase_nand+0x318>
80007750:	00000000 	nop
                     free(temp_buf);				 
80007754:	0c001f86 	jal	80007e18 <free>
80007758:	02a02021 	move	a0,s5
				 if(temp_buf)
					 free(temp_buf);

		     }
			 //erase the remapping block!!
			 rc = rtk_erase_block_a(block_remap*ppb);
8000775c:	08001df5 	j	800077d4 <nand_erase_nand+0x31c>
80007760:	8e2475ec 	lw	a0,30188(s1)
			     rtk_write_ecc_page_a(block*ppb+ppb-1,temp_buf ,&NfSpareBuf , page_size);
			     rtk_write_ecc_page_a(block*ppb+ppb-2,temp_buf ,&NfSpareBuf , page_size);
	             if(temp_buf)
                     free(temp_buf);				 
		     }else{
				 unsigned char *temp_buf = (unsigned char *)malloc(page_size);
80007764:	0c001f55 	jal	80007d54 <malloc>
80007768:	8c6475e4 	lw	a0,30180(v1)
8000776c:	0040a821 	move	s5,v0
				 memset(temp_buf,0xba,sizeof(char)*page_size);
80007770:	00402021 	move	a0,v0
80007774:	240500ba 	li	a1,186
80007778:	3c088001 	lui	t0,0x8001
8000777c:	0c00203d 	jal	800080f4 <memset>
80007780:	8d0675e4 	lw	a2,30180(t0)
			     rtk_write_ecc_page_a(block*ppb,temp_buf ,&NfSpareBuf , page_size);
80007784:	8e2475ec 	lw	a0,30188(s1)
80007788:	72842002 	mul	a0,s4,a0
8000778c:	02a02821 	move	a1,s5
80007790:	8fa60018 	lw	a2,24(sp)
80007794:	3c028001 	lui	v0,0x8001
80007798:	0c0011da 	jal	80004768 <rtk_write_ecc_page_a>
8000779c:	8c4775e4 	lw	a3,30180(v0)
			     rtk_write_ecc_page_a(block*ppb+1,temp_buf ,&NfSpareBuf , page_size);
800077a0:	8e2475ec 	lw	a0,30188(s1)
800077a4:	72842002 	mul	a0,s4,a0
800077a8:	24840001 	addiu	a0,a0,1
800077ac:	02a02821 	move	a1,s5
800077b0:	8fa60018 	lw	a2,24(sp)
800077b4:	3c028001 	lui	v0,0x8001
800077b8:	0c0011da 	jal	80004768 <rtk_write_ecc_page_a>
800077bc:	8c4775e4 	lw	a3,30180(v0)
				 if(temp_buf)
800077c0:	12a00003 	beqz	s5,800077d0 <nand_erase_nand+0x318>
800077c4:	00000000 	nop
					 free(temp_buf);
800077c8:	0c001f86 	jal	80007e18 <free>
800077cc:	02a02021 	move	a0,s5

		     }
			 //erase the remapping block!!
			 rc = rtk_erase_block_a(block_remap*ppb);
800077d0:	8e2475ec 	lw	a0,30188(s1)
800077d4:	8fa2001c 	lw	v0,28(sp)
800077d8:	0c001048 	jal	80004120 <rtk_erase_block_a>
800077dc:	70442002 	mul	a0,v0,a0
			 
		}
		
			
		elen += block_size;
800077e0:	8ec375c4 	lw	v1,30148(s6)
800077e4:	02439021 	addu	s2,s2,v1

		old_page += ppb;
		
		if ( elen<len && !(old_page & pagemask)) {
800077e8:	8fa4005c 	lw	a0,92(sp)
800077ec:	0244182b 	sltu	v1,s2,a0
800077f0:	1060002a 	beqz	v1,8000789c <nand_erase_nand+0x3e4>
800077f4:	8e3475ec 	lw	s4,30188(s1)
		}
		
			
		elen += block_size;

		old_page += ppb;
800077f8:	02749821 	addu	s3,s3,s4
		
		if ( elen<len && !(old_page & pagemask)) {
800077fc:	3c058002 	lui	a1,0x8002
80007800:	8ca23d74 	lw	v0,15732(a1)
80007804:	02621024 	and	v0,s3,v0
80007808:	0042980a 	movz	s3,v0,v0
			old_page &= pagemask;
		}

		block = old_page/ppb;
8000780c:	0274001b 	divu	zero,s3,s4
80007810:	028001f4 	teq	s4,zero,0x7
80007814:	08001e1e 	j	80007878 <nand_erase_nand+0x3c0>
80007818:	0000a012 	mflo	s4
	addr = real_addr;
	//printf("%s: blockr:%x addr:%x pagemask%x \n\r",__FUNCTION__,bbt_v2r[i].block_r, addr,pagemask);
	}
	realpage = (int) (addr >> page_shift);
	chipnr = chipnr_remap = 0;
	old_page = page = realpage & pagemask;
8000781c:	8fa20020 	lw	v0,32(sp)
80007820:	02629806 	srlv	s3,v0,s3
80007824:	02639824 	and	s3,s3,v1
	page_offset = page & (ppb-1);
	block = page/ppb;
80007828:	0274001b 	divu	zero,s3,s4
8000782c:	028001f4 	teq	s4,zero,0x7
80007830:	0000a012 	mflo	s4
		return FAIL;
	}
	
 	while (elen < len) {
		for ( i=0; i<RBA; i++){			
			if ( bbt[i].bad_block != BB_INIT ){
80007834:	3c178002 	lui	s7,0x8002
80007838:	3410fffe 	li	s0,0xfffe
8000783c:	0000f021 	move	s8,zero
				}			
			}else				
			break;		
		}

		page = block*ppb;
80007840:	3c118001 	lui	s1,0x8001
		//printf("Ready to Erase blk %x\n\r",page/ppb);
		
		rc = rtk_erase_block_a(page);
			
		if (rc) {
		    printf("%s: block erase failed at page address=0x%08x\n", __FUNCTION__, addr);
80007844:	3c028001 	lui	v0,0x8001
80007848:	24424ffc 	addiu	v0,v0,20476
8000784c:	afa20028 	sw	v0,40(sp)
80007850:	3c028001 	lui	v0,0x8001
80007854:	24420478 	addiu	v0,v0,1144
80007858:	afa2002c 	sw	v0,44(sp)
                }
			}
		
		     if(!NAND_ADDR_CYCLE)
		     #ifdef SWAP_2K_DATA
			     NfSpareBuf[BBI_SWAP_OFFSET] = 0x00;
8000785c:	3c028002 	lui	v0,0x8002
80007860:	24425768 	addiu	v0,v0,22376
80007864:	afa20018 	sw	v0,24(sp)

                dump_BBT();

                if ( rtk_update_bbt(bbt)){
	                printf("[%s] rtk_update_bbt() fails\n", __FUNCTION__);
	                return FAIL;
80007868:	3c021234 	lui	v0,0x1234
8000786c:	34425678 	ori	v0,v0,0x5678
80007870:	afa20024 	sw	v0,36(sp)
			 rc = rtk_erase_block_a(block_remap*ppb);
			 
		}
		
			
		elen += block_size;
80007874:	3c168001 	lui	s6,0x8001
		printf("%s: Attempt erase beyond end of device add:%x len:%x cs:%x\n\r",__FUNCTION__,addr,len,chip_size);
		return FAIL;
	}
	
 	while (elen < len) {
		for ( i=0; i<RBA; i++){			
80007878:	3c028002 	lui	v0,0x8002
8000787c:	8c462e74 	lw	a2,11892(v0)
80007880:	10c0ff49 	beqz	a2,800075a8 <nand_erase_nand+0xf0>
80007884:	8ee52e78 	lw	a1,11896(s7)
			if ( bbt[i].bad_block != BB_INIT ){
80007888:	94a30002 	lhu	v1,2(a1)
8000788c:	1070ff46 	beq	v1,s0,800075a8 <nand_erase_nand+0xf0>
80007890:	24a20008 	addiu	v0,a1,8
80007894:	08001d63 	j	8000758c <nand_erase_nand+0xd4>
80007898:	03c02021 	move	a0,s8

		block = old_page/ppb;
	}

	return rc;
}  
8000789c:	8fbf0054 	lw	ra,84(sp)
800078a0:	8fbe0050 	lw	s8,80(sp)
800078a4:	8fb7004c 	lw	s7,76(sp)
800078a8:	8fb60048 	lw	s6,72(sp)
800078ac:	8fb50044 	lw	s5,68(sp)
800078b0:	8fb40040 	lw	s4,64(sp)
800078b4:	8fb3003c 	lw	s3,60(sp)
800078b8:	8fb20038 	lw	s2,56(sp)
800078bc:	8fb10034 	lw	s1,52(sp)
800078c0:	8fb00030 	lw	s0,48(sp)
800078c4:	03e00008 	jr	ra
800078c8:	27bd0058 	addiu	sp,sp,88
800078cc:	00000000 	nop

800078d0 <init_icache>:
	#define KSEG0BASE                 0x80000000
	#define CONFIG_SYS_CACHELINE_SIZE 32

	unsigned int t;
	t=0;
	write_32bit_cp0_register_sel( 29,t, 0);  //CP0_ITagHi
800078d0:	00001021 	move	v0,zero
800078d4:	00424825 	or	t1,v0,v0
800078d8:	4089e800 	mtc0	t1,c0_taghi
800078dc:	00000040 	ssnop
800078e0:	00000040 	ssnop
800078e4:	00000040 	ssnop
800078e8:	00000040 	ssnop
	write_32bit_cp0_register_sel( 28,t, 0);  //CP0_ITagLo
800078ec:	00424825 	or	t1,v0,v0
800078f0:	4089e000 	mtc0	t1,c0_taglo
800078f4:	00000040 	ssnop
800078f8:	00000040 	ssnop
800078fc:	00000040 	ssnop
80007900:	00000040 	ssnop
	unsigned long addr = KSEG0BASE;
	unsigned long aend = addr+(64<<10)-lsize;   //DCACHE=64K

	while (1) 
	{
		cache_op(Index_Store_Tag_I, addr);
80007904:	3c028000 	lui	v0,0x8000
80007908:	bc480000 	cache	0x8,0(v0)
		if (addr >= aend)
8000790c:	3c048000 	lui	a0,0x8000
80007910:	3483ffe0 	ori	v1,a0,0xffe0
			break;
		addr += lsize;
80007914:	24420020 	addiu	v0,v0,32
	unsigned long addr = KSEG0BASE;
	unsigned long aend = addr+(64<<10)-lsize;   //DCACHE=64K

	while (1) 
	{
		cache_op(Index_Store_Tag_I, addr);
80007918:	bc480000 	cache	0x8,0(v0)
		if (addr >= aend)
8000791c:	1443fffe 	bne	v0,v1,80007918 <init_icache+0x48>
80007920:	24420020 	addiu	v0,v0,32
			break;
		addr += lsize;
	}

}
80007924:	03e00008 	jr	ra
80007928:	00000000 	nop

8000792c <init_dcache>:
	#define KSEG0BASE                 0x80000000
	#define CONFIG_SYS_CACHELINE_SIZE 32

	unsigned int t;
	t=0;
	write_32bit_cp0_register_sel( 29, t, 2);  //CP0_DTagHi
8000792c:	00001021 	move	v0,zero
80007930:	00424825 	or	t1,v0,v0
80007934:	4089e802 	mtc0	t1,c0_taghi1
80007938:	00000040 	ssnop
8000793c:	00000040 	ssnop
80007940:	00000040 	ssnop
80007944:	00000040 	ssnop
	write_32bit_cp0_register_sel( 28, t, 2);  //CP0_DTagLo
80007948:	00424825 	or	t1,v0,v0
8000794c:	4089e002 	mtc0	t1,c0_taglo1
80007950:	00000040 	ssnop
80007954:	00000040 	ssnop
80007958:	00000040 	ssnop
8000795c:	00000040 	ssnop
	unsigned long addr = KSEG0BASE;
	unsigned long aend = addr+(32<<10)-lsize;   //DCACHE=32K

	while (1) 
	{
		cache_op(Index_Store_Tag_D, addr);
80007960:	3c028000 	lui	v0,0x8000
80007964:	bc490000 	cache	0x9,0(v0)
		if (addr >= aend)
80007968:	3c048000 	lui	a0,0x8000
8000796c:	34837fe0 	ori	v1,a0,0x7fe0
			break;
		addr += lsize;
80007970:	24420020 	addiu	v0,v0,32
	unsigned long addr = KSEG0BASE;
	unsigned long aend = addr+(32<<10)-lsize;   //DCACHE=32K

	while (1) 
	{
		cache_op(Index_Store_Tag_D, addr);
80007974:	bc490000 	cache	0x9,0(v0)
		if (addr >= aend)
80007978:	1443fffe 	bne	v0,v1,80007974 <init_dcache+0x48>
8000797c:	24420020 	addiu	v0,v0,32
			break;
		addr += lsize;
	}

}
80007980:	03e00008 	jr	ra
80007984:	00000000 	nop

80007988 <enable_flash_mapping>:
//============================================================================
enable_flash_mapping()
{
	REG32(0xb8001000)&=~(1<<18);
80007988:	3c02b800 	lui	v0,0xb800
8000798c:	34421000 	ori	v0,v0,0x1000
80007990:	8c440000 	lw	a0,0(v0)
80007994:	3c03fffb 	lui	v1,0xfffb
80007998:	3463ffff 	ori	v1,v1,0xffff
8000799c:	00831824 	and	v1,a0,v1
800079a0:	ac430000 	sw	v1,0(v0)
}
800079a4:	03e00008 	jr	ra
800079a8:	00000000 	nop

800079ac <init_cpu_config>:
init_cpu_config()
{
	unsigned int s;
#if 1	
	//setting K23, KU, MM
	s = read_32bit_cp0_register(CP0_CONFIG);
800079ac:	40038000 	mfc0	v1,c0_config
	s &= ~((3<<28) | (3<<25) | (1<<18));
800079b0:	3c02c9fb 	lui	v0,0xc9fb
800079b4:	3442ffff 	ori	v0,v0,0xffff
800079b8:	00621024 	and	v0,v1,v0
	s |=  ((3<<28) | (3<<25) | (1<<18));
	write_32bit_cp0_register(CP0_CONFIG, s);
800079bc:	3c033604 	lui	v1,0x3604
800079c0:	00431025 	or	v0,v0,v1
800079c4:	40828000 	mtc0	v0,c0_config
800079c8:	00000040 	ssnop
800079cc:	00000040 	ssnop
800079d0:	00000040 	ssnop
800079d4:	00000040 	ssnop
	//set_cp0_config(0x07, 2); //2:uncache
	//set_cp0_config(0x07, 3); //3:cache
#endif

	
	s = read_32bit_cp0_register(CP0_STATUS);
800079d8:	40036000 	mfc0	v1,c0_status
	s &= ~(ST0_CU1|ST0_CU2|ST0_CU3);
800079dc:	3c021fff 	lui	v0,0x1fff
800079e0:	3442ffff 	ori	v0,v0,0xffff
800079e4:	00621024 	and	v0,v1,v0
	s |= ST0_CU0;
	write_32bit_cp0_register(CP0_STATUS, s);
800079e8:	3c031000 	lui	v1,0x1000
800079ec:	00431025 	or	v0,v0,v1
800079f0:	40826000 	mtc0	v0,c0_status
800079f4:	00000040 	ssnop
800079f8:	00000040 	ssnop
800079fc:	00000040 	ssnop
80007a00:	00000040 	ssnop
80007a04:	000000c0 	ehb
#endif
	

//	sys_init_icache();
//	sys_init_dcache();	
}
80007a08:	03e00008 	jr	ra
80007a0c:	00000000 	nop

80007a10 <enable_GIC_mapping>:
//============================================================================

enable_GIC_mapping()
{
	//setting GIC base
	REG32(GCR_BASE_ADDR+0x0080)=Virtual2Physical(GIC_BASE_ADDR)|0x01;
80007a10:	3c02bfbf 	lui	v0,0xbfbf
80007a14:	34438080 	ori	v1,v0,0x8080
80007a18:	3c041bdc 	lui	a0,0x1bdc
80007a1c:	34840001 	ori	a0,a0,0x1
80007a20:	ac640000 	sw	a0,0(v1)

	REG32(GCR_BASE_ADDR+0x0088)=Virtual2Physical(CPC_BASE_ADDR)|0x01;
80007a24:	34428088 	ori	v0,v0,0x8088
80007a28:	3c031bde 	lui	v1,0x1bde
80007a2c:	34630001 	ori	v1,v1,0x1
80007a30:	ac430000 	sw	v1,0(v0)


	//IP inverter
	REG32(GIC_BASE_ADDR+0x100)=0xffffffff;
80007a34:	3c02bbdc 	lui	v0,0xbbdc
80007a38:	34430100 	ori	v1,v0,0x100
80007a3c:	2404ffff 	li	a0,-1
80007a40:	ac640000 	sw	a0,0(v1)
	REG32(GIC_BASE_ADDR+0x104)=0x0003FFFF;	
80007a44:	34420104 	ori	v0,v0,0x104
80007a48:	3c030003 	lui	v1,0x3
80007a4c:	3463ffff 	ori	v1,v1,0xffff
80007a50:	ac430000 	sw	v1,0(v0)
	//map2pin
	//REG32(GIC_BASE_ADDR+0x500)=0x80000000;

	//map2vpe
	//REG32(GIC_BASE_ADDR+0x2000)=0x1;
}
80007a54:	03e00008 	jr	ra
80007a58:	00000000 	nop

80007a5c <init_arch>:

//============================================================================
	
asmlinkage void init_arch(int argc, char **argv, char **envp, int *prom_vec)
{
80007a5c:	27bdffe8 	addiu	sp,sp,-24
80007a60:	afbf0014 	sw	ra,20(sp)
	//init_icache();
	//init_icache();		
	
	enable_flash_mapping();	
80007a64:	0c001e62 	jal	80007988 <enable_flash_mapping>
80007a68:	00000000 	nop
	init_cpu_config();	
80007a6c:	0c001e6b 	jal	800079ac <init_cpu_config>
80007a70:	00000000 	nop
	enable_GIC_mapping();
80007a74:	0c001e84 	jal	80007a10 <enable_GIC_mapping>
80007a78:	00000000 	nop
#ifdef CONFIG_NAND_FLASH_BOOTING
	jmp=((int)start_kernel); //jump to un cache address
#else
	jmp=((int)start_kernel)& ~UNCACHE_MASK;
#endif
	jmp();
80007a7c:	0c001f04 	jal	80007c10 <start_kernel>
80007a80:	00000000 	nop
}
80007a84:	8fbf0014 	lw	ra,20(sp)
80007a88:	03e00008 	jr	ra
80007a8c:	27bd0018 	addiu	sp,sp,24

80007a90 <flush_dcache_range>:
		if (addr == aend)
			break;
		addr += lsize;
	}
#endif
}
80007a90:	03e00008 	jr	ra
80007a94:	00000000 	nop

80007a98 <flush_cache_range>:
		if (addr == aend)
			break;
		addr += lsize;
	}
#endif
}
80007a98:	03e00008 	jr	ra
80007a9c:	00000000 	nop

80007aa0 <invalidate_dcache_range>:
		if (addr == aend)
			break;
		addr += lsize;
	}
#endif
}
80007aa0:	03e00008 	jr	ra
80007aa4:	00000000 	nop

80007aa8 <invalidate_icache_range>:
		if (addr == aend)
			break;
		addr += lsize;
	}
#endif
}
80007aa8:	03e00008 	jr	ra
80007aac:	00000000 	nop

80007ab0 <invalidate_cache>:
#ifndef CONFIG_NAND_FLASH_BOOTING
	#define START_ADDR 0x80000000
	invalidate_dcache_range(START_ADDR, START_ADDR+_DCACHE_SIZE);
	invalidate_icache_range(START_ADDR, START_ADDR+_ICACHE_SIZE);	
#endif
}
80007ab0:	03e00008 	jr	ra
80007ab4:	00000000 	nop

80007ab8 <flush_cache>:
	flush_cache_range(START_ADDR, _DCACHE_SIZE);
	//flush_dcache_range(START_ADDR, START_ADDR+_DCACHE_SIZE);
#endif	
	//winfred_wang
	invalidate_cache();
}
80007ab8:	03e00008 	jr	ra
80007abc:	00000000 	nop

80007ac0 <showBoardInfo>:
}

//-------------------------------------------------------
//show board info
void showBoardInfo(void)
{
80007ac0:	27bdffc8 	addiu	sp,sp,-56
80007ac4:	afbf0034 	sw	ra,52(sp)
80007ac8:	afb10030 	sw	s1,48(sp)
80007acc:	afb0002c 	sw	s0,44(sp)
	volatile int cpu_speed = 0;
80007ad0:	afa00020 	sw	zero,32(sp)
80007ad4:	40097801 	mfc0	t1,c0_ebase
	int cpu_num=read_32bit_cp0_register_sel(15, 1)&0x3f;
80007ad8:	01298825 	or	s1,t1,t1
80007adc:	3231003f 	andi	s1,s1,0x3f
#if 1//patch for ESD
        REG32(0xb800311c)=0xa5000000;	
80007ae0:	3c10b800 	lui	s0,0xb800
80007ae4:	3602311c 	ori	v0,s0,0x311c
80007ae8:	3c03a500 	lui	v1,0xa500
80007aec:	ac430000 	sw	v1,0(v0)
#endif
#if 1
	#define SYS_INT_STATUS 0xb8000004
	REG32(SYS_INT_STATUS)=(1<<1);  //clear wakeup interrupt	
80007af0:	36020004 	ori	v0,s0,0x4
80007af4:	24030002 	li	v1,2
80007af8:	ac430000 	sw	v1,0(v0)
	REG32(SYS_INT_STATUS)=(1<<1);  //clear wakeup interrupt	
#endif

	//REG32(0xb8000010)|=0xffff800;
#ifdef CONFIG_NAND_FLASH_BOOTING 
	cpu_speed = check_cpu_speed();	
80007afc:	0c003f06 	jal	8000fc18 <check_cpu_speed>
80007b00:	ac430000 	sw	v1,0(v0)
80007b04:	afa20020 	sw	v0,32(sp)
	cpu_speed = 450 + ((REG32(SYS_HW_STRAP) & 0x78000) >> 15) * 50;
80007b08:	36100008 	ori	s0,s0,0x8
80007b0c:	8e020000 	lw	v0,0(s0)
80007b10:	3c030007 	lui	v1,0x7
80007b14:	34638000 	ori	v1,v1,0x8000
80007b18:	00431824 	and	v1,v0,v1
80007b1c:	00031bc2 	srl	v1,v1,0xf
80007b20:	00031040 	sll	v0,v1,0x1
80007b24:	000318c0 	sll	v1,v1,0x3
80007b28:	00431021 	addu	v0,v0,v1
80007b2c:	00021880 	sll	v1,v0,0x2
80007b30:	00431021 	addu	v0,v0,v1
80007b34:	244201c2 	addiu	v0,v0,450
80007b38:	afa20020 	sw	v0,32(sp)
#endif
#if defined(CONFIG_NAND_FLASH_BOOTING)
	#if defined(CONFIG_DDR2_SDRAM)
		prom_printf("DDR2:");
	#elif defined(CONFIG_DDR3_SDRAM)
		prom_printf("DDR3:");
80007b3c:	3c048001 	lui	a0,0x8001
80007b40:	0c0023a7 	jal	80008e9c <prom_printf>
80007b44:	248450fc 	addiu	a0,a0,20732
	#elif defined(CONFIG_DDR2_64MB_16bit)
		prom_printf("64 MB\n");
	#elif defined(CONFIG_DDR2_128MB_16bit)
		prom_printf("128 MB\n");
	#elif defined(CONFIG_DDR3_128MB_16bit)
		prom_printf("128 MB\n");
80007b48:	3c048001 	lui	a0,0x8001
80007b4c:	0c0023a7 	jal	80008e9c <prom_printf>
80007b50:	24845104 	addiu	a0,a0,20740

	#define POLLING_REG 0xb800006c
  	#define PATT_SLEEP  0x3333		
  	#define PATT_READY  0x5555
		
	prom_printf("%s",((*(volatile unsigned int *)(0xb8000008)) & (0x1<<22))?"Reboot Result from Watchdog Timeout!\n":" ");
80007b54:	8e020000 	lw	v0,0(s0)
80007b58:	7c420580 	ext	v0,v0,0x16,0x1
80007b5c:	14400003 	bnez	v0,80007b6c <showBoardInfo+0xac>
80007b60:	3c058001 	lui	a1,0x8001
80007b64:	08001edd 	j	80007b74 <showBoardInfo+0xb4>
80007b68:	24a54d14 	addiu	a1,a1,19732
80007b6c:	3c058001 	lui	a1,0x8001
80007b70:	24a5510c 	addiu	a1,a1,20748
80007b74:	3c048001 	lui	a0,0x8001
80007b78:	0c0023a7 	jal	80008e9c <prom_printf>
80007b7c:	248442bc 	addiu	a0,a0,17084
	
	prom_printf("\n---Realtek RTL8198C boot code at %s %s (%dMHz) [C%d running][C%d %s]\n", BOOT_CODE_TIME,B_VERSION,  cpu_speed, cpu_num, 1-cpu_num, 
80007b80:	8fa70020 	lw	a3,32(sp)
	(REG32(POLLING_REG)==PATT_SLEEP)  ? "sleep": 
80007b84:	3c02b800 	lui	v0,0xb800
80007b88:	3442006c 	ori	v0,v0,0x6c
80007b8c:	8c430000 	lw	v1,0(v0)
  	#define PATT_SLEEP  0x3333		
  	#define PATT_READY  0x5555
		
	prom_printf("%s",((*(volatile unsigned int *)(0xb8000008)) & (0x1<<22))?"Reboot Result from Watchdog Timeout!\n":" ");
	
	prom_printf("\n---Realtek RTL8198C boot code at %s %s (%dMHz) [C%d running][C%d %s]\n", BOOT_CODE_TIME,B_VERSION,  cpu_speed, cpu_num, 1-cpu_num, 
80007b90:	24023333 	li	v0,13107
80007b94:	14620004 	bne	v1,v0,80007ba8 <showBoardInfo+0xe8>
80007b98:	3c02b800 	lui	v0,0xb800
80007b9c:	3c038001 	lui	v1,0x8001
80007ba0:	08001ef3 	j	80007bcc <showBoardInfo+0x10c>
80007ba4:	24635134 	addiu	v1,v1,20788
	(REG32(POLLING_REG)==PATT_SLEEP)  ? "sleep": 
	(REG32(POLLING_REG)==PATT_READY)  ? "ready":	"miss"	);	
80007ba8:	3442006c 	ori	v0,v0,0x6c
80007bac:	8c430000 	lw	v1,0(v0)
  	#define PATT_SLEEP  0x3333		
  	#define PATT_READY  0x5555
		
	prom_printf("%s",((*(volatile unsigned int *)(0xb8000008)) & (0x1<<22))?"Reboot Result from Watchdog Timeout!\n":" ");
	
	prom_printf("\n---Realtek RTL8198C boot code at %s %s (%dMHz) [C%d running][C%d %s]\n", BOOT_CODE_TIME,B_VERSION,  cpu_speed, cpu_num, 1-cpu_num, 
80007bb0:	24025555 	li	v0,21845
80007bb4:	10620003 	beq	v1,v0,80007bc4 <showBoardInfo+0x104>
80007bb8:	3c038001 	lui	v1,0x8001
80007bbc:	08001ef3 	j	80007bcc <showBoardInfo+0x10c>
80007bc0:	2463513c 	addiu	v1,v1,20796
80007bc4:	3c038001 	lui	v1,0x8001
80007bc8:	24635144 	addiu	v1,v1,20804
80007bcc:	afb10010 	sw	s1,16(sp)
80007bd0:	24020001 	li	v0,1
80007bd4:	00518823 	subu	s1,v0,s1
80007bd8:	afb10014 	sw	s1,20(sp)
80007bdc:	afa30018 	sw	v1,24(sp)
80007be0:	3c048001 	lui	a0,0x8001
80007be4:	2484514c 	addiu	a0,a0,20812
80007be8:	3c058001 	lui	a1,0x8001
80007bec:	24a55194 	addiu	a1,a1,20884
80007bf0:	3c068001 	lui	a2,0x8001
80007bf4:	0c0023a7 	jal	80008e9c <prom_printf>
80007bf8:	24c675f0 	addiu	a2,a2,30192
	(REG32(POLLING_REG)==PATT_SLEEP)  ? "sleep": 
	(REG32(POLLING_REG)==PATT_READY)  ? "ready":	"miss"	);	

    //cpu_num=read_32bit_cp0_register_sel(15, 1)&0x3f;
	//prom_printf("cpu id=%x\n",cpu_num);	
}
80007bfc:	8fbf0034 	lw	ra,52(sp)
80007c00:	8fb10030 	lw	s1,48(sp)
80007c04:	8fb0002c 	lw	s0,44(sp)
80007c08:	03e00008 	jr	ra
80007c0c:	27bd0038 	addiu	sp,sp,56

80007c10 <start_kernel>:
	return 1;
}
#endif

void start_kernel(void)
{
80007c10:	27bdffd0 	addiu	sp,sp,-48
80007c14:	afbf002c 	sw	ra,44(sp)

	int ret;

	gCHKKEY_HIT = 0;
80007c18:	3c028002 	lui	v0,0x8002
80007c1c:	ac403e50 	sw	zero,15952(v0)
	gCHKKEY_CNT = 0;
80007c20:	3c028002 	lui	v0,0x8002
80007c24:	ac403e54 	sw	zero,15956(v0)

#ifdef CONFIG_NAND_FLASH_BOOTING 
    //for piggy.bin debug safe
    //debug cl because of no bss clear when use boot_test directly, global init.
#ifdef CONFIG_RTK_NAND_BBT
	read_has_check_bbt = 0;
80007c28:	3c028002 	lui	v0,0x8002
80007c2c:	ac403d88 	sw	zero,15752(v0)
	write_has_check_bbt = 0;
80007c30:	3c028002 	lui	v0,0x8002
80007c34:	ac403d8c 	sw	zero,15756(v0)
	erase_has_check_bbt = 0;
80007c38:	3c028002 	lui	v0,0x8002
80007c3c:	ac403d90 	sw	zero,15760(v0)
	static_for_create_v2r_bbt = 0;
80007c40:	3c028002 	lui	v0,0x8002
80007c44:	ac403d84 	sw	zero,15748(v0)
	RBA = 0;
80007c48:	3c028002 	lui	v0,0x8002
80007c4c:	ac402e74 	sw	zero,11892(v0)
	bbt = NULL;
80007c50:	3c028002 	lui	v0,0x8002
80007c54:	ac402e78 	sw	zero,11896(v0)
	bbt_v2r = NULL;
80007c58:	3c028002 	lui	v0,0x8002
80007c5c:	ac402e70 	sw	zero,11888(v0)
#endif
	jump_to_test = 0;
80007c60:	3c028002 	lui	v0,0x8002

	IMG_HEADER_T header;
	SETTING_HEADER_T setting_header;

//-------------------------------------------------------
	setClkInitConsole();
80007c64:	0c0036ad 	jal	8000dab4 <setClkInitConsole>
80007c68:	ac402fc0 	sw	zero,12224(v0)

	initHeap();
80007c6c:	0c0036c0 	jal	8000db00 <initHeap>
80007c70:	00000000 	nop
		
	initInterrupt();
80007c74:	0c0002f4 	jal	80000bd0 <initInterrupt>
80007c78:	00000000 	nop

	initFlash();
80007c7c:	0c0036b5 	jal	8000dad4 <initFlash>
80007c80:	00000000 	nop

#if defined(CONFIG_POST_ENABLE)
	ret = POSTRW_API();
#endif	

	showBoardInfo();
80007c84:	0c001eb0 	jal	80007ac0 <showBoardInfo>
80007c88:	00000000 	nop
	if(ret == 0)
		return;
#endif

#ifdef CONFIG_BOOT_RESET_ENABLE	
	RTL_W32(RTL_GPIO_MUX4, (RTL_R32(RTL_GPIO_MUX4) | (RTL_GPIO_RESET_BTN_MUX))); 
80007c8c:	3c02b800 	lui	v0,0xb800
80007c90:	3443010c 	ori	v1,v0,0x10c
80007c94:	8c650000 	lw	a1,0(v1)
80007c98:	3c040180 	lui	a0,0x180
80007c9c:	00a42025 	or	a0,a1,a0
80007ca0:	ac640000 	sw	a0,0(v1)
	RTL_W32(RESET_PIN_IOBASE, (RTL_R32(RESET_PIN_IOBASE) & (~(1 << RESET_BTN_PIN))));
80007ca4:	3444351c 	ori	a0,v0,0x351c
80007ca8:	8c850000 	lw	a1,0(a0)
80007cac:	3c03dfff 	lui	v1,0xdfff
80007cb0:	3463ffff 	ori	v1,v1,0xffff
80007cb4:	00a32824 	and	a1,a1,v1
80007cb8:	ac850000 	sw	a1,0(a0)
	RTL_W32(RESET_PIN_DIRBASE, (RTL_R32(RESET_PIN_DIRBASE) & (~(1 << RESET_BTN_PIN))));
80007cbc:	34423524 	ori	v0,v0,0x3524
80007cc0:	8c440000 	lw	a0,0(v0)
80007cc4:	00831824 	and	v1,a0,v1
80007cc8:	ac430000 	sw	v1,0(v0)
	eth_startup(0); 
	sti();			
	tftpd_entry(1);
#endif

	return_addr=0;
80007ccc:	3c028002 	lui	v0,0x8002
80007cd0:	ac402e7c 	sw	zero,11900(v0)
	ret=check_image	(&header,&setting_header);
80007cd4:	27a40010 	addiu	a0,sp,16
80007cd8:	0c0038a4 	jal	8000e290 <check_image>
80007cdc:	27a50020 	addiu	a1,sp,32

#ifdef CONFIG_NAND_FLASH
 	#define MAX_MOUNT_ROOTFS_TIMES	5
	if(REG32(0xb8019004) > MAX_MOUNT_ROOTFS_TIMES){
80007ce0:	3c03b801 	lui	v1,0xb801
80007ce4:	34639004 	ori	v1,v1,0x9004
80007ce8:	8c630000 	lw	v1,0(v1)
80007cec:	2c630006 	sltiu	v1,v1,6
80007cf0:	14600006 	bnez	v1,80007d0c <start_kernel+0xfc>
80007cf4:	00402021 	move	a0,v0
		REG32(0xb8019004) = 0;
80007cf8:	3c02b801 	lui	v0,0xb801
80007cfc:	34429004 	ori	v0,v0,0x9004
80007d00:	ac400000 	sw	zero,0(v0)
80007d04:	00001021 	move	v0,zero
		ret = 0;
	}
#endif
	doBooting(ret, return_addr, &header);
80007d08:	00402021 	move	a0,v0
80007d0c:	3c028002 	lui	v0,0x8002
80007d10:	8c452e7c 	lw	a1,11900(v0)
80007d14:	0c003743 	jal	8000dd0c <doBooting>
80007d18:	27a60010 	addiu	a2,sp,16
}
80007d1c:	8fbf002c 	lw	ra,44(sp)
80007d20:	03e00008 	jr	ra
80007d24:	27bd0030 	addiu	sp,sp,48
	...

80007d30 <i_alloc>:
        _heapstart is the first byte allocated to the heap.
        _heapend is the last.
*/
{
        /* initialize the allocator */
        frhd = (HEADER *) _heapstart;
80007d30:	3c028002 	lui	v0,0x8002
80007d34:	ac443da0 	sw	a0,15776(v0)
        frhd->ptr = NULL;
80007d38:	ac800000 	sw	zero,0(a0)
        frhd->size = (_heapend - _heapstart) / sizeof(HEADER);
80007d3c:	00a42823 	subu	a1,a1,a0
80007d40:	000528c2 	srl	a1,a1,0x3
80007d44:	ac850004 	sw	a1,4(a0)
        memleft = frhd->size; /* initial size in 4-byte units */
80007d48:	3c028002 	lui	v0,0x8002
}
80007d4c:	03e00008 	jr	ra
80007d50:	ac453da4 	sw	a1,15780(v0)

80007d54 <malloc>:
                enough. If block is larger than needed, break                           
                the block into two pieces and allocate the                              
                portion higher up in memory. Otherwise, just
                allocate the entire block.
        */
        for (prev=NULL,nxt=frhd; nxt; nxt = nxt->ptr)
80007d54:	27bdffe8 	addiu	sp,sp,-24
80007d58:	afbf0014 	sw	ra,20(sp)
80007d5c:	3c028002 	lui	v0,0x8002
80007d60:	8c423da0 	lw	v0,15776(v0)
80007d64:	10400027 	beqz	v0,80007e04 <malloc+0xb0>
80007d68:	24830007 	addiu	v1,a0,7
void * malloc(uint32 nbytes)                /* bytes to allocate */
{
        HEADER      *nxt, *prev;
        uint32      nunits;

        nunits = (nbytes+sizeof(HEADER)-1)
80007d6c:	000318c2 	srl	v1,v1,0x3
80007d70:	24630001 	addiu	v1,v1,1
                portion higher up in memory. Otherwise, just
                allocate the entire block.
        */
        for (prev=NULL,nxt=frhd; nxt; nxt = nxt->ptr)
        {
                if (nxt->size >= nunits) /* big enough */
80007d74:	8c440004 	lw	a0,4(v0)
80007d78:	0083282b 	sltu	a1,a0,v1
80007d7c:	14a0001e 	bnez	a1,80007df8 <malloc+0xa4>
80007d80:	0064202b 	sltu	a0,v1,a0
80007d84:	08001f67 	j	80007d9c <malloc+0x48>
80007d88:	00000000 	nop
80007d8c:	8c440004 	lw	a0,4(v0)
80007d90:	0083282b 	sltu	a1,a0,v1
80007d94:	14a00018 	bnez	a1,80007df8 <malloc+0xa4>
80007d98:	0064202b 	sltu	a0,v1,a0
                {
                        if (nxt->size > nunits)
80007d9c:	1080000c 	beqz	a0,80007dd0 <malloc+0x7c>
80007da0:	3c048002 	lui	a0,0x8002
                                nxt->size = nunits;
                        }
#else
                        /* allocate head end */
                        {
                                HEADER  *seg = nxt + nunits;
80007da4:	000320c0 	sll	a0,v1,0x3
80007da8:	00442021 	addu	a0,v0,a0
                                if (prev==NULL) frhd = seg;
80007dac:	3c058002 	lui	a1,0x8002
80007db0:	aca43da0 	sw	a0,15776(a1)
                                else prev->ptr = seg;
                                seg->ptr = nxt->ptr;
80007db4:	8c450000 	lw	a1,0(v0)
80007db8:	ac850000 	sw	a1,0(a0)
                                seg->size = nxt->size - nunits;
80007dbc:	8c450004 	lw	a1,4(v0)
80007dc0:	00a32823 	subu	a1,a1,v1
80007dc4:	ac850004 	sw	a1,4(a0)
                                
                                /* nxt now == ptr to alloc */
                                nxt->size = nunits;
80007dc8:	08001f76 	j	80007dd8 <malloc+0x84>
80007dcc:	ac430004 	sw	v1,4(v0)
                        }
#endif
                        else
                        {
                                if (prev==NULL) frhd = nxt->ptr;
80007dd0:	8c450000 	lw	a1,0(v0)
80007dd4:	ac853da0 	sw	a1,15776(a0)
                                else prev->ptr = nxt->ptr;
                        }
                        memleft -= nunits;
80007dd8:	3c048002 	lui	a0,0x8002
80007ddc:	8c853da4 	lw	a1,15780(a0)
80007de0:	00a31823 	subu	v1,a1,v1
80007de4:	ac833da4 	sw	v1,15780(a0)
                        */
                }
        }
        printf("\nAllocation Failed!");
        while(1);
}
80007de8:	24420008 	addiu	v0,v0,8
80007dec:	8fbf0014 	lw	ra,20(sp)
80007df0:	03e00008 	jr	ra
80007df4:	27bd0018 	addiu	sp,sp,24
                enough. If block is larger than needed, break                           
                the block into two pieces and allocate the                              
                portion higher up in memory. Otherwise, just
                allocate the entire block.
        */
        for (prev=NULL,nxt=frhd; nxt; nxt = nxt->ptr)
80007df8:	8c420000 	lw	v0,0(v0)
80007dfc:	1440ffe3 	bnez	v0,80007d8c <malloc+0x38>
80007e00:	00000000 	nop
                                Return a pointer past the header to                                     
                                the actual space requested.
                        */
                }
        }
        printf("\nAllocation Failed!");
80007e04:	3c048001 	lui	a0,0x8001
80007e08:	0c002325 	jal	80008c94 <dprintf>
80007e0c:	248451ac 	addiu	a0,a0,20908
80007e10:	08001f84 	j	80007e10 <malloc+0xbc>
80007e14:	00000000 	nop

80007e18 <free>:
            free() or malloc(), otherwise free list will be null.
*/
{
        HEADER  *nxt, *prev, *f;
        
        ASSERT_CSP(ap);
80007e18:	27bdffe8 	addiu	sp,sp,-24
80007e1c:	afbf0014 	sw	ra,20(sp)
80007e20:	14800006 	bnez	a0,80007e3c <free+0x24>
80007e24:	3c038002 	lui	v1,0x8002
80007e28:	3c048001 	lui	a0,0x8001
80007e2c:	0c002325 	jal	80008c94 <dprintf>
80007e30:	2484462c 	addiu	a0,a0,17964
80007e34:	08001f8d 	j	80007e34 <free+0x1c>
80007e38:	00000000 	nop
        ASSERT_CSP(frhd);
80007e3c:	8c653da0 	lw	a1,15776(v1)
80007e40:	14a00006 	bnez	a1,80007e5c <free+0x44>
80007e44:	3c038002 	lui	v1,0x8002
80007e48:	3c048001 	lui	a0,0x8001
80007e4c:	0c002325 	jal	80008c94 <dprintf>
80007e50:	2484462c 	addiu	a0,a0,17964
80007e54:	08001f95 	j	80007e54 <free+0x3c>
80007e58:	00000000 	nop

        f = (HEADER *)ap - 1;
80007e5c:	2484fff8 	addiu	a0,a0,-8
        /* pt to header of block being returned */
        memleft += f->size;
80007e60:	8c870004 	lw	a3,4(a0)
80007e64:	8c663da4 	lw	a2,15780(v1)
80007e68:	00c73021 	addu	a2,a2,a3
80007e6c:	ac663da4 	sw	a2,15780(v1)
        /*
                Note: frhd is never NULL unless i_alloc() was                           
                    never called to initialize package.
        */
        if (frhd > f)
80007e70:	0085182b 	sltu	v1,a0,a1
80007e74:	1460000a 	bnez	v1,80007ea0 <free+0x88>
80007e78:	00a4182b 	sltu	v1,a1,a0
                points past the block, make a new entry and
                link it.  If next pointer + its size points to the                              
                block form one contiguous block.
        */
        nxt = frhd;
        for (nxt=frhd; nxt && nxt < f; prev=nxt,nxt=nxt->ptr)
80007e7c:	1060002f 	beqz	v1,80007f3c <free+0x124>
80007e80:	00000000 	nop
        {
                if (nxt+nxt->size == f)
80007e84:	8ca20004 	lw	v0,4(a1)
80007e88:	000218c0 	sll	v1,v0,0x3
80007e8c:	00a31821 	addu	v1,a1,v1
80007e90:	14830023 	bne	a0,v1,80007f20 <free+0x108>
80007e94:	00471021 	addu	v0,v0,a3
                {
                        /* they are contiguous */
                        nxt->size += f->size;   
80007e98:	08001fbd 	j	80007ef4 <free+0xdc>
80007e9c:	aca20004 	sw	v0,4(a1)
        /*
                free queue head is higher up in memory 
                than returnee 
        */
                nxt = frhd;                     /* old head */
                frhd = f;                       /* new head */
80007ea0:	3c028002 	lui	v0,0x8002
80007ea4:	ac443da0 	sw	a0,15776(v0)
                prev = f + f->size;     /* right after new head */

                if (prev==nxt) /* old and new are contiguous */
80007ea8:	000710c0 	sll	v0,a3,0x3
80007eac:	00821021 	addu	v0,a0,v0
80007eb0:	14a20007 	bne	a1,v0,80007ed0 <free+0xb8>
80007eb4:	00000000 	nop
                {
                        f->size += nxt->size;
80007eb8:	8ca20004 	lw	v0,4(a1)
80007ebc:	00473821 	addu	a3,v0,a3
80007ec0:	ac870004 	sw	a3,4(a0)
                        f->ptr = nxt->ptr;      /* contiguate */
80007ec4:	8ca20000 	lw	v0,0(a1)
80007ec8:	08001fdc 	j	80007f70 <free+0x158>
80007ecc:	ac820000 	sw	v0,0(a0)
                }
                else f->ptr = nxt;
80007ed0:	08001fdc 	j	80007f70 <free+0x158>
80007ed4:	ac850000 	sw	a1,0(a0)
                block form one contiguous block.
        */
        nxt = frhd;
        for (nxt=frhd; nxt && nxt < f; prev=nxt,nxt=nxt->ptr)
        {
                if (nxt+nxt->size == f)
80007ed8:	8c620004 	lw	v0,4(v1)
80007edc:	000228c0 	sll	a1,v0,0x3
80007ee0:	00652821 	addu	a1,v1,a1
80007ee4:	1485000e 	bne	a0,a1,80007f20 <free+0x108>
80007ee8:	00602821 	move	a1,v1
                {
                        /* they are contiguous */
                        nxt->size += f->size;   
80007eec:	00471021 	addu	v0,v0,a3
80007ef0:	aca20004 	sw	v0,4(a1)
                        /* form one block */
                        f = nxt + nxt->size;
                        if (f==nxt->ptr)
80007ef4:	8ca30000 	lw	v1,0(a1)
80007ef8:	000220c0 	sll	a0,v0,0x3
80007efc:	00a42021 	addu	a0,a1,a0
80007f00:	1464001c 	bne	v1,a0,80007f74 <free+0x15c>
80007f04:	8fbf0014 	lw	ra,20(sp)
                                continue this checking since if the                                     
                                block following this free one was                                               
                                free, the two would have been                                           
                                made one already.
                        */
                                nxt->size += f->size;
80007f08:	8c640004 	lw	a0,4(v1)
80007f0c:	00441021 	addu	v0,v0,a0
80007f10:	aca20004 	sw	v0,4(a1)
                                nxt->ptr = f->ptr;
80007f14:	8c620000 	lw	v0,0(v1)
80007f18:	08001fdc 	j	80007f70 <free+0x158>
80007f1c:	aca20000 	sw	v0,0(a1)
                points past the block, make a new entry and
                link it.  If next pointer + its size points to the                              
                block form one contiguous block.
        */
        nxt = frhd;
        for (nxt=frhd; nxt && nxt < f; prev=nxt,nxt=nxt->ptr)
80007f20:	8ca30000 	lw	v1,0(a1)
80007f24:	10600003 	beqz	v1,80007f34 <free+0x11c>
80007f28:	0064302b 	sltu	a2,v1,a0
80007f2c:	14c0ffea 	bnez	a2,80007ed8 <free+0xc0>
80007f30:	00000000 	nop
80007f34:	00a01021 	move	v0,a1
80007f38:	00602821 	move	a1,v1
                the end of the queue was reached. If at end, just                       
                link to the end of the queue.  Therefore, 'nxt' is                      
                either NULL or points to a block higher up in                           
                memory than the one being returned.
        */                                              
        prev->ptr = f;  /* link to queue */
80007f3c:	ac440000 	sw	a0,0(v0)
        prev = f + f->size;     /* right after space to free */
80007f40:	8c830004 	lw	v1,4(a0)
80007f44:	000310c0 	sll	v0,v1,0x3
80007f48:	00821021 	addu	v0,a0,v0
        if (prev == nxt)        /* f and nxt are contiguous */
80007f4c:	14450007 	bne	v0,a1,80007f6c <free+0x154>
80007f50:	00000000 	nop
        {
                f->size += nxt->size;
80007f54:	8c450004 	lw	a1,4(v0)
80007f58:	00a31821 	addu	v1,a1,v1
80007f5c:	ac830004 	sw	v1,4(a0)
                /* form a larger contiguous block */
                f->ptr = nxt->ptr;
80007f60:	8c420000 	lw	v0,0(v0)
80007f64:	08001fdc 	j	80007f70 <free+0x158>
80007f68:	ac820000 	sw	v0,0(a0)
        }
        else f->ptr = nxt;
80007f6c:	ac850000 	sw	a1,0(a0)
        return;
}
80007f70:	8fbf0014 	lw	ra,20(sp)
80007f74:	03e00008 	jr	ra
80007f78:	27bd0018 	addiu	sp,sp,24
80007f7c:	00000000 	nop

80007f80 <serial_outc>:




void serial_outc(char c)
{
80007f80:	7c042420 	seb	a0,a0
80007f84:	24020001 	li	v0,1
#if 1	
		i++;
		if (i >=6540)
			break;
#endif		
		if 	(rtl_inb(UART_LSR) & 0x60)
80007f88:	3c05b800 	lui	a1,0xb800
80007f8c:	34a52014 	ori	a1,a1,0x2014
#if 1
    while (1)
	{
#if 1	
		i++;
		if (i >=6540)
80007f90:	08001fe8 	j	80007fa0 <serial_outc+0x20>
80007f94:	2406198c 	li	a2,6540
80007f98:	10460006 	beq	v0,a2,80007fb4 <serial_outc+0x34>
80007f9c:	308300ff 	andi	v1,a0,0xff
			break;
#endif		
		if 	(rtl_inb(UART_LSR) & 0x60)
80007fa0:	90a30000 	lbu	v1,0(a1)
80007fa4:	30630060 	andi	v1,v1,0x60
80007fa8:	1060fffb 	beqz	v1,80007f98 <serial_outc+0x18>
80007fac:	24420001 	addiu	v0,v0,1
			break;	
	}
#endif

	//for(i=0; i<0xff00;i++);
 	rtl_outb(UART_THR, c);  
80007fb0:	308300ff 	andi	v1,a0,0xff
80007fb4:	3c02b800 	lui	v0,0xb800
80007fb8:	34422000 	ori	v0,v0,0x2000
80007fbc:	a0430000 	sb	v1,0(v0)
		  
	if (c == 0x0a)
80007fc0:	2402000a 	li	v0,10
80007fc4:	14820004 	bne	a0,v0,80007fd8 <serial_outc+0x58>
80007fc8:	2403000d 	li	v1,13
		rtl_outb(UART_THR, 0x0d);  
80007fcc:	3c02b800 	lui	v0,0xb800
80007fd0:	34422000 	ori	v0,v0,0x2000
80007fd4:	a0430000 	sb	v1,0(v0)
80007fd8:	03e00008 	jr	ra
80007fdc:	00000000 	nop

80007fe0 <serial_inc>:
#if defined(CONFIG_TFTP_COMMAND)
	tickStart=get_timer_jiffies();
#endif
    while (1)
	{
		if 	(rtl_inb(UART_LSR) & 0x1)
80007fe0:	3c03b800 	lui	v1,0xb800
80007fe4:	34632014 	ori	v1,v1,0x2014
80007fe8:	90620000 	lbu	v0,0(v1)
80007fec:	30420001 	andi	v0,v0,0x1
80007ff0:	1040fffd 	beqz	v0,80007fe8 <serial_inc+0x8>
80007ff4:	3c02b800 	lui	v0,0xb800
        if(time_after((get_timer_jiffies()),(tickStart+18000)))
		//if((get_timer_jiffies() - tickStart) > 18000) //3min=18000  1min=6000
		    autoreboot();
#endif
	}	
	i=rtl_inb(UART_RBR);
80007ff8:	34422000 	ori	v0,v0,0x2000
80007ffc:	90420000 	lbu	v0,0(v0)
	return (i & 0xff);
	// ----------------------------------------------------
	// above is UART0, and below is SC16IS7x0 
	// ----------------------------------------------------
	
}
80008000:	03e00008 	jr	ra
80008004:	7c021420 	seb	v0,v0

80008008 <isspace>:

int isspace(char ch)
{
80008008:	7c042420 	seb	a0,a0
    return (unsigned int)(ch - 9) < 5u  ||  ch == ' ';	
8000800c:	2483fff7 	addiu	v1,a0,-9
80008010:	2c630005 	sltiu	v1,v1,5
80008014:	14600003 	bnez	v1,80008024 <isspace+0x1c>
80008018:	24020001 	li	v0,1
8000801c:	38820020 	xori	v0,a0,0x20
80008020:	2c420001 	sltiu	v0,v0,1
}
80008024:	03e00008 	jr	ra
80008028:	00000000 	nop
8000802c:	00000000 	nop

80008030 <strcpy>:
#if 1
char * strcpy(char * dest,const char *src)
{
	char *tmp = dest;

	while ((*dest++ = *src++) != '\0')
80008030:	00801021 	move	v0,a0
80008034:	00801821 	move	v1,a0
80008038:	80a40000 	lb	a0,0(a1)
8000803c:	a0640000 	sb	a0,0(v1)
80008040:	24630001 	addiu	v1,v1,1
80008044:	1480fffc 	bnez	a0,80008038 <strcpy+0x8>
80008048:	24a50001 	addiu	a1,a1,1
		/* nothing */;
	return tmp;
}
8000804c:	03e00008 	jr	ra
80008050:	00000000 	nop

80008054 <strcmp>:
int strcmp(const char * cs,const char * ct)
{
	register signed char __res;

	while (1) {
		if ((__res = *cs - *ct++) != 0 || !*cs++)
80008054:	80830000 	lb	v1,0(a0)
80008058:	90a20000 	lbu	v0,0(a1)
8000805c:	00621023 	subu	v0,v1,v0
80008060:	7c021420 	seb	v0,v0
80008064:	14400003 	bnez	v0,80008074 <strcmp+0x20>
80008068:	24a50001 	addiu	a1,a1,1
8000806c:	1460fff9 	bnez	v1,80008054 <strcmp>
80008070:	24840001 	addiu	a0,a0,1
			break;
	}

	return __res;
}
80008074:	03e00008 	jr	ra
80008078:	00000000 	nop

8000807c <strchr>:
}
#endif

char * strchr(const char * s, int c)
{
	for(; *s != (char) c; ++s)
8000807c:	80830000 	lb	v1,0(a0)
80008080:	7c052c20 	seb	a1,a1
80008084:	1065000c 	beq	v1,a1,800080b8 <strchr+0x3c>
80008088:	00801021 	move	v0,a0
		if (*s == '\0')
8000808c:	14600007 	bnez	v1,800080ac <strchr+0x30>
80008090:	24420001 	addiu	v0,v0,1
80008094:	2442ffff 	addiu	v0,v0,-1
}
#endif

char * strchr(const char * s, int c)
{
	for(; *s != (char) c; ++s)
80008098:	03e00008 	jr	ra
8000809c:	00001021 	move	v0,zero
		if (*s == '\0')
800080a0:	10600007 	beqz	v1,800080c0 <strchr+0x44>
800080a4:	00000000 	nop
}
#endif

char * strchr(const char * s, int c)
{
	for(; *s != (char) c; ++s)
800080a8:	24420001 	addiu	v0,v0,1
800080ac:	80430000 	lb	v1,0(v0)
800080b0:	1465fffb 	bne	v1,a1,800080a0 <strchr+0x24>
800080b4:	00000000 	nop
800080b8:	03e00008 	jr	ra
800080bc:	00000000 	nop
800080c0:	00001021 	move	v0,zero
		if (*s == '\0')
			return NULL;
	return (char *) s;
}
800080c4:	03e00008 	jr	ra
800080c8:	00000000 	nop

800080cc <strlen>:
#endif
size_t strlen(const char * s)
{
	const char *sc;

	for (sc = s; *sc != '\0'; ++sc)
800080cc:	80830000 	lb	v1,0(a0)
800080d0:	10600006 	beqz	v1,800080ec <strlen+0x20>
800080d4:	00801021 	move	v0,a0
800080d8:	24420001 	addiu	v0,v0,1
800080dc:	80430000 	lb	v1,0(v0)
800080e0:	1460fffe 	bnez	v1,800080dc <strlen+0x10>
800080e4:	24420001 	addiu	v0,v0,1
800080e8:	2442ffff 	addiu	v0,v0,-1
		/* nothing */;
	return sc - s;
}
800080ec:	03e00008 	jr	ra
800080f0:	00441023 	subu	v0,v0,a0

800080f4 <memset>:

void * memset(void * s,int c, size_t count)
{
	char *xs = (char *) s;

	while (count--)
800080f4:	10c00006 	beqz	a2,80008110 <memset+0x1c>
800080f8:	00801021 	move	v0,a0
}
#endif

void * memset(void * s,int c, size_t count)
{
	char *xs = (char *) s;
800080fc:	00801821 	move	v1,a0

	while (count--)
		*xs++ = c;
80008100:	a0650000 	sb	a1,0(v1)
80008104:	24c6ffff 	addiu	a2,a2,-1

void * memset(void * s,int c, size_t count)
{
	char *xs = (char *) s;

	while (count--)
80008108:	14c0fffd 	bnez	a2,80008100 <memset+0xc>
8000810c:	24630001 	addiu	v1,v1,1
		*xs++ = c;

	return s;
}
80008110:	03e00008 	jr	ra
80008114:	00000000 	nop

80008118 <memcpy>:
#endif
void * memcpy(void * dest,const void *src,size_t count)
{
	char *tmp = (char *) dest, *s = (char *) src;

	while (count--)
80008118:	10c00008 	beqz	a2,8000813c <memcpy+0x24>
8000811c:	00801021 	move	v0,a0
80008120:	00001821 	move	v1,zero
		*tmp++ = *s++;
80008124:	00432021 	addu	a0,v0,v1
80008128:	00a33821 	addu	a3,a1,v1
8000812c:	90e70000 	lbu	a3,0(a3)
80008130:	24630001 	addiu	v1,v1,1
#endif
void * memcpy(void * dest,const void *src,size_t count)
{
	char *tmp = (char *) dest, *s = (char *) src;

	while (count--)
80008134:	1466fffb 	bne	v1,a2,80008124 <memcpy+0xc>
80008138:	a0870000 	sb	a3,0(a0)
		*tmp++ = *s++;

	return dest;
}
8000813c:	03e00008 	jr	ra
80008140:	00000000 	nop

80008144 <memcmp>:
int memcmp(const void * cs,const void * ct,size_t count)
{
	const unsigned char *su1, *su2;
	signed char res = 0;

	for( su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
80008144:	10c00007 	beqz	a2,80008164 <memcmp+0x20>
80008148:	00001021 	move	v0,zero
		if ((res = *su1 - *su2) != 0)
8000814c:	90830000 	lbu	v1,0(a0)
80008150:	90a20000 	lbu	v0,0(a1)
80008154:	00621023 	subu	v0,v1,v0
80008158:	7c021420 	seb	v0,v0
8000815c:	1040000a 	beqz	v0,80008188 <memcmp+0x44>
80008160:	00001821 	move	v1,zero
80008164:	03e00008 	jr	ra
80008168:	00000000 	nop
8000816c:	00a31021 	addu	v0,a1,v1
80008170:	90e70001 	lbu	a3,1(a3)
80008174:	90420001 	lbu	v0,1(v0)
80008178:	00e21023 	subu	v0,a3,v0
8000817c:	7c021420 	seb	v0,v0
80008180:	1440fff8 	bnez	v0,80008164 <memcmp+0x20>
80008184:	24630001 	addiu	v1,v1,1
int memcmp(const void * cs,const void * ct,size_t count)
{
	const unsigned char *su1, *su2;
	signed char res = 0;

	for( su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
80008188:	24c6ffff 	addiu	a2,a2,-1
8000818c:	14c0fff7 	bnez	a2,8000816c <memcmp+0x28>
80008190:	00833821 	addu	a3,a0,v1
		if ((res = *su1 - *su2) != 0)
			break;
	return res;
}
80008194:	03e00008 	jr	ra
80008198:	00000000 	nop

8000819c <strstr>:
#endif
char * strstr(const char * s1,const char * s2)
{
	int l1, l2;

	l2 = strlen(s2);
8000819c:	27bdffd8 	addiu	sp,sp,-40
800081a0:	afbf0024 	sw	ra,36(sp)
800081a4:	afb40020 	sw	s4,32(sp)
800081a8:	afb3001c 	sw	s3,28(sp)
800081ac:	afb20018 	sw	s2,24(sp)
800081b0:	afb10014 	sw	s1,20(sp)
800081b4:	afb00010 	sw	s0,16(sp)
800081b8:	00808021 	move	s0,a0
800081bc:	00a09021 	move	s2,a1
800081c0:	0c002033 	jal	800080cc <strlen>
800081c4:	00a02021 	move	a0,a1
800081c8:	00408821 	move	s1,v0
	if (!l2)
800081cc:	10400011 	beqz	v0,80008214 <strstr+0x78>
800081d0:	0040a021 	move	s4,v0
		return (char *) s1;
	l1 = strlen(s1);
800081d4:	0c002033 	jal	800080cc <strlen>
800081d8:	02002021 	move	a0,s0
800081dc:	00409821 	move	s3,v0
	while (l1 >= l2) {
800081e0:	0051102a 	slt	v0,v0,s1
800081e4:	1440000a 	bnez	v0,80008210 <strstr+0x74>
800081e8:	00000000 	nop
		l1--;
		if (!memcmp(s1,s2,l2))
800081ec:	02002021 	move	a0,s0
800081f0:	02402821 	move	a1,s2
800081f4:	0c002051 	jal	80008144 <memcmp>
800081f8:	02203021 	move	a2,s1
800081fc:	10400005 	beqz	v0,80008214 <strstr+0x78>
80008200:	2673ffff 	addiu	s3,s3,-1

	l2 = strlen(s2);
	if (!l2)
		return (char *) s1;
	l1 = strlen(s1);
	while (l1 >= l2) {
80008204:	0274102a 	slt	v0,s3,s4
80008208:	1040fff8 	beqz	v0,800081ec <strstr+0x50>
8000820c:	26100001 	addiu	s0,s0,1
		l1--;
		if (!memcmp(s1,s2,l2))
			return (char *) s1;
		s1++;
80008210:	00008021 	move	s0,zero
	}
	return NULL;
}
80008214:	02001021 	move	v0,s0
80008218:	8fbf0024 	lw	ra,36(sp)
8000821c:	8fb40020 	lw	s4,32(sp)
80008220:	8fb3001c 	lw	s3,28(sp)
80008224:	8fb20018 	lw	s2,24(sp)
80008228:	8fb10014 	lw	s1,20(sp)
8000822c:	8fb00010 	lw	s0,16(sp)
80008230:	03e00008 	jr	ra
80008234:	27bd0028 	addiu	sp,sp,40
	...

80008240 <strtol>:
#include <limits.h>


#define ABS_LONG_MIN 2147483648UL
long int strtol(const char *nptr, char **endptr, int base)
{
80008240:	27bdffd8 	addiu	sp,sp,-40
80008244:	afbf0024 	sw	ra,36(sp)
80008248:	afb40020 	sw	s4,32(sp)
8000824c:	afb3001c 	sw	s3,28(sp)
80008250:	afb20018 	sw	s2,24(sp)
80008254:	afb10014 	sw	s1,20(sp)
80008258:	afb00010 	sw	s0,16(sp)
8000825c:	00808021 	move	s0,a0
80008260:	00a09821 	move	s3,a1
80008264:	00c0a021 	move	s4,a2
  int neg=0;
  unsigned long int v;

  while(isspace(*nptr)) nptr++;
80008268:	82110000 	lb	s1,0(s0)
8000826c:	0c002002 	jal	80008008 <isspace>
80008270:	02202021 	move	a0,s1
80008274:	1440fffc 	bnez	v0,80008268 <strtol+0x28>
80008278:	26100001 	addiu	s0,s0,1
8000827c:	2610ffff 	addiu	s0,s0,-1

  if (*nptr == '-') { neg=-1; ++nptr; }
80008280:	2402002d 	li	v0,45
80008284:	16220003 	bne	s1,v0,80008294 <strtol+0x54>
80008288:	00009021 	move	s2,zero
8000828c:	26100001 	addiu	s0,s0,1
80008290:	2412ffff 	li	s2,-1
  v=strtoul(nptr,endptr,base);
80008294:	02002021 	move	a0,s0
80008298:	02602821 	move	a1,s3
8000829c:	0c0020c4 	jal	80008310 <strtoul>
800082a0:	02803021 	move	a2,s4
  if (v>=ABS_LONG_MIN) {
800082a4:	0441000c 	bgez	v0,800082d8 <strtol+0x98>
800082a8:	00021823 	negu	v1,v0
    if (v==ABS_LONG_MIN && neg) {
800082ac:	3c048000 	lui	a0,0x8000
800082b0:	14440005 	bne	v0,a0,800082c8 <strtol+0x88>
800082b4:	00000000 	nop
800082b8:	12400009 	beqz	s2,800082e0 <strtol+0xa0>
800082bc:	8fbf0024 	lw	ra,36(sp)
    }
   // errno=ERANGE;
    return (neg?LONG_MIN:LONG_MAX);
  }
  return (neg?-v:v);
}
800082c0:	080020bc 	j	800082f0 <strtol+0xb0>
800082c4:	8fb40020 	lw	s4,32(sp)
    if (v==ABS_LONG_MIN && neg) {
      //errno=0;
      return v;
    }
   // errno=ERANGE;
    return (neg?LONG_MIN:LONG_MAX);
800082c8:	12400005 	beqz	s2,800082e0 <strtol+0xa0>
800082cc:	3c028000 	lui	v0,0x8000
  }
  return (neg?-v:v);
}
800082d0:	080020bb 	j	800082ec <strtol+0xac>
800082d4:	8fbf0024 	lw	ra,36(sp)
      return v;
    }
   // errno=ERANGE;
    return (neg?LONG_MIN:LONG_MAX);
  }
  return (neg?-v:v);
800082d8:	080020ba 	j	800082e8 <strtol+0xa8>
800082dc:	0072100b 	movn	v0,v1,s2
800082e0:	3c027fff 	lui	v0,0x7fff
800082e4:	3442ffff 	ori	v0,v0,0xffff
}
800082e8:	8fbf0024 	lw	ra,36(sp)
800082ec:	8fb40020 	lw	s4,32(sp)
800082f0:	8fb3001c 	lw	s3,28(sp)
800082f4:	8fb20018 	lw	s2,24(sp)
800082f8:	8fb10014 	lw	s1,20(sp)
800082fc:	8fb00010 	lw	s0,16(sp)
80008300:	03e00008 	jr	ra
80008304:	27bd0028 	addiu	sp,sp,40
	...

80008310 <strtoul>:

#include <limits.h>

unsigned long int strtoul(const char *nptr, char **endptr, int base)
{
80008310:	27bdffd8 	addiu	sp,sp,-40
80008314:	afbf0024 	sw	ra,36(sp)
80008318:	afb30020 	sw	s3,32(sp)
8000831c:	afb2001c 	sw	s2,28(sp)
80008320:	afb10018 	sw	s1,24(sp)
80008324:	afb00014 	sw	s0,20(sp)
80008328:	00808021 	move	s0,a0
8000832c:	00a09821 	move	s3,a1
80008330:	00c08821 	move	s1,a2
  unsigned long int v=0;

  while(isspace(*nptr)) ++nptr;
80008334:	82120000 	lb	s2,0(s0)
80008338:	0c002002 	jal	80008008 <isspace>
8000833c:	02402021 	move	a0,s2
80008340:	1440fffc 	bnez	v0,80008334 <strtoul+0x24>
80008344:	26100001 	addiu	s0,s0,1
80008348:	2610ffff 	addiu	s0,s0,-1
  if (*nptr == '+') ++nptr;
8000834c:	26020001 	addiu	v0,s0,1
80008350:	3a52002b 	xori	s2,s2,0x2b
80008354:	0052800a 	movz	s0,v0,s2
  if (base==16 && nptr[0]=='0') goto skip0x;
80008358:	24020010 	li	v0,16
8000835c:	16220006 	bne	s1,v0,80008378 <strtoul+0x68>
80008360:	24020030 	li	v0,48
80008364:	82030000 	lb	v1,0(s0)
80008368:	14620012 	bne	v1,v0,800083b4 <strtoul+0xa4>
8000836c:	00000000 	nop
  if (!base) {
    if (*nptr=='0') {
      base=8;
skip0x:
      if (nptr[1]=='x'||nptr[1]=='X') {
80008370:	080020e5 	j	80008394 <strtoul+0x84>
80008374:	82020001 	lb	v0,1(s0)
  unsigned long int v=0;

  while(isspace(*nptr)) ++nptr;
  if (*nptr == '+') ++nptr;
  if (base==16 && nptr[0]=='0') goto skip0x;
  if (!base) {
80008378:	1620000d 	bnez	s1,800083b0 <strtoul+0xa0>
8000837c:	00000000 	nop
    if (*nptr=='0') {
80008380:	82030000 	lb	v1,0(s0)
80008384:	1462000b 	bne	v1,v0,800083b4 <strtoul+0xa4>
80008388:	2411000a 	li	s1,10
8000838c:	24110008 	li	s1,8
      base=8;
skip0x:
      if (nptr[1]=='x'||nptr[1]=='X') {
80008390:	82020001 	lb	v0,1(s0)
80008394:	24030078 	li	v1,120
80008398:	10430003 	beq	v0,v1,800083a8 <strtoul+0x98>
8000839c:	24030058 	li	v1,88
800083a0:	14430003 	bne	v0,v1,800083b0 <strtoul+0xa0>
800083a4:	00000000 	nop
	nptr+=2;
800083a8:	26100002 	addiu	s0,s0,2
800083ac:	24110010 	li	s1,16
	base=16;
      }
    } else
      base=10;
  }
  while(*nptr) {
800083b0:	82030000 	lb	v1,0(s0)
800083b4:	00001021 	move	v0,zero
800083b8:	1060001f 	beqz	v1,80008438 <strtoul+0x128>
800083bc:	240600ff 	li	a2,255
    register unsigned char c=*nptr;
800083c0:	306300ff 	andi	v1,v1,0xff
    c=(c>='a'?c-'a'+10:c>='A'?c-'A'+10:c<='9'?c-'0':0xff);
800083c4:	2c640061 	sltiu	a0,v1,97
800083c8:	14800004 	bnez	a0,800083dc <strtoul+0xcc>
800083cc:	00000000 	nop
800083d0:	2463ffa9 	addiu	v1,v1,-87
800083d4:	08002101 	j	80008404 <strtoul+0xf4>
800083d8:	306400ff 	andi	a0,v1,0xff
800083dc:	2c640041 	sltiu	a0,v1,65
800083e0:	14800004 	bnez	a0,800083f4 <strtoul+0xe4>
800083e4:	2c65003a 	sltiu	a1,v1,58
800083e8:	2463ffc9 	addiu	v1,v1,-55
800083ec:	08002101 	j	80008404 <strtoul+0xf4>
800083f0:	306400ff 	andi	a0,v1,0xff
800083f4:	10a00003 	beqz	a1,80008404 <strtoul+0xf4>
800083f8:	00c02021 	move	a0,a2
800083fc:	2463ffd0 	addiu	v1,v1,-48
80008400:	306400ff 	andi	a0,v1,0xff
    if (c>=base) break;
80008404:	0091182a 	slt	v1,a0,s1
80008408:	1060000b 	beqz	v1,80008438 <strtoul+0x128>
8000840c:	00000000 	nop
    {
      register unsigned long int w=v*base;
80008410:	70511802 	mul	v1,v0,s1
      if (w<v) {
80008414:	0062102b 	sltu	v0,v1,v0
80008418:	10400003 	beqz	v0,80008428 <strtoul+0x118>
8000841c:	26100001 	addiu	s0,s0,1
80008420:	08002111 	j	80008444 <strtoul+0x134>
80008424:	2402ffff 	li	v0,-1
	//errno=ERANGE;
	return ULONG_MAX;
      }
      v=w+c;
80008428:	00831021 	addu	v0,a0,v1
	base=16;
      }
    } else
      base=10;
  }
  while(*nptr) {
8000842c:	82030000 	lb	v1,0(s0)
80008430:	1460ffe3 	bnez	v1,800083c0 <strtoul+0xb0>
80008434:	00000000 	nop
      }
      v=w+c;
    }
    ++nptr;
  }
  if (endptr) *endptr=(char *)nptr;
80008438:	12600003 	beqz	s3,80008448 <strtoul+0x138>
8000843c:	8fbf0024 	lw	ra,36(sp)
80008440:	ae700000 	sw	s0,0(s3)
  //errno=0;	/* in case v==ULONG_MAX, ugh! */
  return v;
}
80008444:	8fbf0024 	lw	ra,36(sp)
80008448:	8fb30020 	lw	s3,32(sp)
8000844c:	8fb2001c 	lw	s2,28(sp)
80008450:	8fb10018 	lw	s1,24(sp)
80008454:	8fb00014 	lw	s0,20(sp)
80008458:	03e00008 	jr	ra
8000845c:	27bd0028 	addiu	sp,sp,40

80008460 <StrUpr>:
char* StrUpr( char* string ){
	char*		p ;
	const int	det = 'a' - 'A';

	p = string ;
	while( *p ){
80008460:	80850000 	lb	a1,0(a0)
80008464:	10a0000d 	beqz	a1,8000849c <StrUpr+0x3c>
80008468:	00801021 	move	v0,a0
8000846c:	00801821 	move	v1,a0
		if( *p >= 'a'  &&  *p <= 'z' ){
80008470:	30a500ff 	andi	a1,a1,0xff
80008474:	24a6ff9f 	addiu	a2,a1,-97
80008478:	30c600ff 	andi	a2,a2,0xff
8000847c:	2cc6001a 	sltiu	a2,a2,26
80008480:	10c00002 	beqz	a2,8000848c <StrUpr+0x2c>
80008484:	24a5ffe0 	addiu	a1,a1,-32
			*p -= det ;
80008488:	a0650000 	sb	a1,0(v1)
		}
		p++ ;
8000848c:	24630001 	addiu	v1,v1,1
char* StrUpr( char* string ){
	char*		p ;
	const int	det = 'a' - 'A';

	p = string ;
	while( *p ){
80008490:	80650000 	lb	a1,0(v1)
80008494:	14a0fff7 	bnez	a1,80008474 <StrUpr+0x14>
80008498:	30a500ff 	andi	a1,a1,0xff
			*p -= det ;
		}
		p++ ;
	}
	return string ;
}
8000849c:	03e00008 	jr	ra
800084a0:	00000000 	nop

800084a4 <GetArgc>:
;			argument number
;   Destroy:
---------------------------------------------------------------------------
*/
int GetArgc( const char* string )
{
800084a4:	00003021 	move	a2,zero
	int			argc;
	char*		p ;

	argc = 0 ;
	p = (char* )string ;
	while( *p )
800084a8:	08002138 	j	800084e0 <GetArgc+0x3c>
800084ac:	24050020 	li	a1,32
	{
		if( *p != ' '  &&  *p )
800084b0:	1065000a 	beq	v1,a1,800084dc <GetArgc+0x38>
800084b4:	00000000 	nop
		{
			argc++ ;
800084b8:	24c60001 	addiu	a2,a2,1
			while( *p != ' '  &&  *p ) p++ ;
800084bc:	24840001 	addiu	a0,a0,1
800084c0:	80830000 	lb	v1,0(a0)
800084c4:	10650007 	beq	v1,a1,800084e4 <GetArgc+0x40>
800084c8:	00000000 	nop
800084cc:	1460fffc 	bnez	v1,800084c0 <GetArgc+0x1c>
800084d0:	24840001 	addiu	a0,a0,1
800084d4:	08002139 	j	800084e4 <GetArgc+0x40>
800084d8:	2484ffff 	addiu	a0,a0,-1
			continue ;
		}
		p++ ;
800084dc:	24840001 	addiu	a0,a0,1
	int			argc;
	char*		p ;

	argc = 0 ;
	p = (char* )string ;
	while( *p )
800084e0:	80830000 	lb	v1,0(a0)
800084e4:	1460fff2 	bnez	v1,800084b0 <GetArgc+0xc>
800084e8:	24020013 	li	v0,19
800084ec:	28c30014 	slti	v1,a2,20
		}
		p++ ;
	}
	if (argc >= MAX_ARGV) argc = MAX_ARGV - 1;
	return argc ;
}
800084f0:	03e00008 	jr	ra
800084f4:	00c3100b 	movn	v0,a2,v1

800084f8 <Hex2Val>:
	unsigned long				sum,csum;
	register unsigned char		c,HexValue;

	sum = csum = 0;
	ptrb = HexStr;
	while(c=*ptrb++)
800084f8:	08002159 	j	80008564 <Hex2Val+0x6c>
800084fc:	00003021 	move	a2,zero
	{
		if( c>='0' && c<='9')		HexValue = c - '0';
80008500:	2443ffd0 	addiu	v1,v0,-48
80008504:	306300ff 	andi	v1,v1,0xff
80008508:	2c67000a 	sltiu	a3,v1,10
8000850c:	14e00010 	bnez	a3,80008550 <Hex2Val+0x58>
80008510:	00000000 	nop
		else if( c>='a' && c<='f')	HexValue = c - 'a' + 10;
80008514:	2443ff9f 	addiu	v1,v0,-97
80008518:	306300ff 	andi	v1,v1,0xff
8000851c:	2c630006 	sltiu	v1,v1,6
80008520:	10600004 	beqz	v1,80008534 <Hex2Val+0x3c>
80008524:	00000000 	nop
80008528:	2442ffa9 	addiu	v0,v0,-87
8000852c:	08002154 	j	80008550 <Hex2Val+0x58>
80008530:	304300ff 	andi	v1,v0,0xff
		else if( c>='A' && c<='F')  HexValue = c - 'A' + 10;
80008534:	2443ffbf 	addiu	v1,v0,-65
80008538:	306300ff 	andi	v1,v1,0xff
8000853c:	2c630006 	sltiu	v1,v1,6
80008540:	1060000e 	beqz	v1,8000857c <Hex2Val+0x84>
80008544:	00000000 	nop
80008548:	2442ffc9 	addiu	v0,v0,-55
8000854c:	304300ff 	andi	v1,v0,0xff
		else return FALSE;				// character invalid
		sum = csum*16 + HexValue;
80008550:	00061100 	sll	v0,a2,0x4
80008554:	00621821 	addu	v1,v1,v0
		if(sum < csum) return FALSE;	// value overlow
80008558:	0066302b 	sltu	a2,v1,a2
8000855c:	14c00007 	bnez	a2,8000857c <Hex2Val+0x84>
80008560:	00603021 	move	a2,v1
	unsigned long				sum,csum;
	register unsigned char		c,HexValue;

	sum = csum = 0;
	ptrb = HexStr;
	while(c=*ptrb++)
80008564:	90820000 	lbu	v0,0(a0)
80008568:	1440ffe5 	bnez	v0,80008500 <Hex2Val+0x8>
8000856c:	24840001 	addiu	a0,a0,1
		else return FALSE;				// character invalid
		sum = csum*16 + HexValue;
		if(sum < csum) return FALSE;	// value overlow
		csum = sum;
	}
	*PVal = csum;
80008570:	aca60000 	sw	a2,0(a1)
	return TRUE;
80008574:	03e00008 	jr	ra
80008578:	24020001 	li	v0,1
}
8000857c:	03e00008 	jr	ra
80008580:	00001021 	move	v0,zero

80008584 <GetArgv>:
;			argument string end by zero character
;   Destroy:
---------------------------------------------------------------------------
*/
char** GetArgv(const char* string)
{
80008584:	27bdffe0 	addiu	sp,sp,-32
80008588:	afbf001c 	sw	ra,28(sp)
8000858c:	afb10018 	sw	s1,24(sp)
80008590:	afb00014 	sw	s0,20(sp)
80008594:	00808821 	move	s1,a0
	char*			p ;
	int				n;

	n = 0 ;
	memset( ArgvArray, 0, MAX_ARGV*sizeof(char *) );
80008598:	3c108002 	lui	s0,0x8002
8000859c:	26103db0 	addiu	s0,s0,15792
800085a0:	02002021 	move	a0,s0
800085a4:	00002821 	move	a1,zero
800085a8:	0c00203d 	jal	800080f4 <memset>
800085ac:	24060050 	li	a2,80
;			argument string array, argv[0], argv[1],...
;			argument string end by zero character
;   Destroy:
---------------------------------------------------------------------------
*/
char** GetArgv(const char* string)
800085b0:	3c048002 	lui	a0,0x8002
800085b4:	24843e00 	addiu	a0,a0,15872
	int				n;

	n = 0 ;
	memset( ArgvArray, 0, MAX_ARGV*sizeof(char *) );
	p = (char* )string ;
	while( *p )
800085b8:	0800218a 	j	80008628 <GetArgv+0xa4>
800085bc:	24030020 	li	v1,32
	{
		ArgvArray[n] = p ;
800085c0:	ae110000 	sw	s1,0(s0)
		while( *p != ' '  &&  *p ) p++ ;
800085c4:	82220000 	lb	v0,0(s1)
800085c8:	1043000a 	beq	v0,v1,800085f4 <GetArgv+0x70>
800085cc:	00000000 	nop
800085d0:	10400008 	beqz	v0,800085f4 <GetArgv+0x70>
800085d4:	00000000 	nop
800085d8:	26310001 	addiu	s1,s1,1
800085dc:	82220000 	lb	v0,0(s1)
800085e0:	10430004 	beq	v0,v1,800085f4 <GetArgv+0x70>
800085e4:	00000000 	nop
800085e8:	1440fffc 	bnez	v0,800085dc <GetArgv+0x58>
800085ec:	26310001 	addiu	s1,s1,1
800085f0:	2631ffff 	addiu	s1,s1,-1
		*p++ = '\0';
800085f4:	a2200000 	sb	zero,0(s1)
800085f8:	26310001 	addiu	s1,s1,1
		while( *p == ' '  &&  *p ) p++ ;
800085fc:	82220000 	lb	v0,0(s1)
80008600:	14430006 	bne	v0,v1,8000861c <GetArgv+0x98>
80008604:	00000000 	nop
80008608:	26310001 	addiu	s1,s1,1
8000860c:	82220000 	lb	v0,0(s1)
80008610:	1043fffe 	beq	v0,v1,8000860c <GetArgv+0x88>
80008614:	26310001 	addiu	s1,s1,1
80008618:	2631ffff 	addiu	s1,s1,-1
8000861c:	26100004 	addiu	s0,s0,4
		n++ ;
		if (n == MAX_ARGV) break;
80008620:	12040004 	beq	s0,a0,80008634 <GetArgv+0xb0>
80008624:	3c028002 	lui	v0,0x8002
	int				n;

	n = 0 ;
	memset( ArgvArray, 0, MAX_ARGV*sizeof(char *) );
	p = (char* )string ;
	while( *p )
80008628:	82220000 	lb	v0,0(s1)
8000862c:	1440ffe4 	bnez	v0,800085c0 <GetArgv+0x3c>
80008630:	3c028002 	lui	v0,0x8002
		while( *p == ' '  &&  *p ) p++ ;
		n++ ;
		if (n == MAX_ARGV) break;
	}
	return (char** )&ArgvArray ;
}
80008634:	24423db0 	addiu	v0,v0,15792
80008638:	8fbf001c 	lw	ra,28(sp)
8000863c:	8fb10018 	lw	s1,24(sp)
80008640:	8fb00014 	lw	s0,20(sp)
80008644:	03e00008 	jr	ra
80008648:	27bd0020 	addiu	sp,sp,32

8000864c <GetLine>:
unsigned char history_cmd[HISTORY_CMD_ELN][ MAX_MONITOR_BUFFER +1 ]={0};
int hist_save_idx=0;
int hist_see_idx=0;
#endif
void GetLine( char * buffer, const unsigned int size, int EchoFlag )
{
8000864c:	27bdffc8 	addiu	sp,sp,-56
80008650:	afbf0034 	sw	ra,52(sp)
80008654:	afbe0030 	sw	s8,48(sp)
80008658:	afb7002c 	sw	s7,44(sp)
8000865c:	afb60028 	sw	s6,40(sp)
80008660:	afb50024 	sw	s5,36(sp)
80008664:	afb40020 	sw	s4,32(sp)
80008668:	afb3001c 	sw	s3,28(sp)
8000866c:	afb20018 	sw	s2,24(sp)
80008670:	afb10014 	sw	s1,20(sp)
80008674:	afb00010 	sw	s0,16(sp)
80008678:	afa40038 	sw	a0,56(sp)
8000867c:	00a0b021 	move	s6,a1
	int		c;
	char*		p = buffer ;
	unsigned int	n = 0L ;
	int		i ;

	while( n < size )
80008680:	10a0003a 	beqz	a1,8000876c <GetLine+0x120>
80008684:	00c0a821 	move	s5,a2
80008688:	00809821 	move	s3,a0
8000868c:	00009021 	move	s2,zero
	{
		c = GetChar() ;
		if( c == -1 )
80008690:	2417ffff 	li	s7,-1
		}

#endif
		    break ;
		}
		else if ((ch == KEYCODE_BS) || (ch == KEYCODE_CTRL_BS))
80008694:	24140008 	li	s4,8
		}
		else if( ch == KEYCODE_TAB )
		{
		    for( i=0 ; i < TAB ; i++ )
		    {
			    *p++ = ' ' ;
80008698:	241e0020 	li	s8,32
	unsigned int	n = 0L ;
	int		i ;

	while( n < size )
	{
		c = GetChar() ;
8000869c:	0c001ff8 	jal	80007fe0 <serial_inc>
800086a0:	00000000 	nop
		if( c == -1 )
800086a4:	1057002e 	beq	v0,s7,80008760 <GetLine+0x114>
800086a8:	7c022420 	seb	a0,v0
		{
		    continue;
		}
		ch = c;
		//dprintf("%x ",ch);
		if( ch == KEYCODE_LF )
800086ac:	2402000a 	li	v0,10
800086b0:	1082002e 	beq	a0,v0,8000876c <GetLine+0x120>
800086b4:	2402000d 	li	v0,13
		    *--p = 0 ;
		    n-- ;
		    #endif // USE_LF
		    break ;
		}
		else if( ch == KEYCODE_CR )
800086b8:	14820003 	bne	a0,v0,800086c8 <GetLine+0x7c>
800086bc:	00000000 	nop
			(hist_save_idx >= HISTORY_CMD_ELN-1) ? hist_save_idx=0 : hist_save_idx++;
			hist_see_idx=hist_save_idx;
		}

#endif
		    break ;
800086c0:	080021db 	j	8000876c <GetLine+0x120>
800086c4:	a2600000 	sb	zero,0(s3)
		}
		else if ((ch == KEYCODE_BS) || (ch == KEYCODE_CTRL_BS))
800086c8:	10940003 	beq	a0,s4,800086d8 <GetLine+0x8c>
800086cc:	2402007f 	li	v0,127
800086d0:	1482000f 	bne	a0,v0,80008710 <GetLine+0xc4>
800086d4:	24020009 	li	v0,9
		{
		    if( p != buffer )
800086d8:	8fa20038 	lw	v0,56(sp)
800086dc:	12620021 	beq	s3,v0,80008764 <GetLine+0x118>
800086e0:	0256102b 	sltu	v0,s2,s6
		    {
			    p-- ;
800086e4:	2673ffff 	addiu	s3,s3,-1
			    n-- ;
							if(EchoFlag)
800086e8:	12a0001d 	beqz	s5,80008760 <GetLine+0x114>
800086ec:	2652ffff 	addiu	s2,s2,-1
							{
								PutChar(KEYCODE_BS);
800086f0:	0c001fe0 	jal	80007f80 <serial_outc>
800086f4:	02802021 	move	a0,s4
								PutChar(' ');
800086f8:	0c001fe0 	jal	80007f80 <serial_outc>
800086fc:	24040020 	li	a0,32
								PutChar(KEYCODE_BS);
80008700:	0c001fe0 	jal	80007f80 <serial_outc>
80008704:	02802021 	move	a0,s4
	int		c;
	char*		p = buffer ;
	unsigned int	n = 0L ;
	int		i ;

	while( n < size )
80008708:	080021d9 	j	80008764 <GetLine+0x118>
8000870c:	0256102b 	sltu	v0,s2,s6
								PutChar(' ');
								PutChar(KEYCODE_BS);
							}
		    }
		}
		else if( ch == KEYCODE_TAB )
80008710:	1482000d 	bne	a0,v0,80008748 <GetLine+0xfc>
80008714:	02608021 	move	s0,s3
80008718:	00008821 	move	s1,zero
		{
		    for( i=0 ; i < TAB ; i++ )
		    {
			    *p++ = ' ' ;
8000871c:	a21e0000 	sb	s8,0(s0)
			    n++ ;
							if(EchoFlag) PutChar(' ');
80008720:	12a00003 	beqz	s5,80008730 <GetLine+0xe4>
80008724:	26100001 	addiu	s0,s0,1
80008728:	0c001fe0 	jal	80007f80 <serial_outc>
8000872c:	24040020 	li	a0,32
							}
		    }
		}
		else if( ch == KEYCODE_TAB )
		{
		    for( i=0 ; i < TAB ; i++ )
80008730:	26310001 	addiu	s1,s1,1
80008734:	1634fff9 	bne	s1,s4,8000871c <GetLine+0xd0>
80008738:	00000000 	nop
8000873c:	26730008 	addiu	s3,s3,8
80008740:	080021d8 	j	80008760 <GetLine+0x114>
80008744:	26520008 	addiu	s2,s2,8
			
		}
#endif
		else
		{
		    *p++ = ch ;
80008748:	a2640000 	sb	a0,0(s3)
8000874c:	26730001 	addiu	s3,s3,1
		    n++ ;
					if(EchoFlag) PutChar(ch);
80008750:	12a00003 	beqz	s5,80008760 <GetLine+0x114>
80008754:	26520001 	addiu	s2,s2,1
80008758:	0c001fe0 	jal	80007f80 <serial_outc>
8000875c:	00000000 	nop
	int		c;
	char*		p = buffer ;
	unsigned int	n = 0L ;
	int		i ;

	while( n < size )
80008760:	0256102b 	sltu	v0,s2,s6
80008764:	1440ffcd 	bnez	v0,8000869c <GetLine+0x50>
80008768:	00000000 	nop
		    *p++ = ch ;
		    n++ ;
					if(EchoFlag) PutChar(ch);
		}
	}
}
8000876c:	8fbf0034 	lw	ra,52(sp)
80008770:	8fbe0030 	lw	s8,48(sp)
80008774:	8fb7002c 	lw	s7,44(sp)
80008778:	8fb60028 	lw	s6,40(sp)
8000877c:	8fb50024 	lw	s5,36(sp)
80008780:	8fb40020 	lw	s4,32(sp)
80008784:	8fb3001c 	lw	s3,28(sp)
80008788:	8fb20018 	lw	s2,24(sp)
8000878c:	8fb10014 	lw	s1,20(sp)
80008790:	8fb00010 	lw	s0,16(sp)
80008794:	03e00008 	jr	ra
80008798:	27bd0038 	addiu	sp,sp,56
8000879c:	00000000 	nop

800087a0 <strcasecmp>:
/**************************************************************************
STRCASECMP (not entirely correct, but this will do for our purposes)
**************************************************************************/
int strcasecmp(char *a, char *b)
{
	while (*a && *b && (*a & ~0x20) == (*b & ~0x20)) {a++; b++; }
800087a0:	80820000 	lb	v0,0(a0)
800087a4:	10400013 	beqz	v0,800087f4 <strcasecmp+0x54>
800087a8:	2403ffdf 	li	v1,-33
800087ac:	80a30000 	lb	v1,0(a1)
800087b0:	1060000f 	beqz	v1,800087f0 <strcasecmp+0x50>
800087b4:	00621826 	xor	v1,v1,v0
800087b8:	2406ffdf 	li	a2,-33
800087bc:	00661824 	and	v1,v1,a2
800087c0:	1460000c 	bnez	v1,800087f4 <strcasecmp+0x54>
800087c4:	2403ffdf 	li	v1,-33
800087c8:	24840001 	addiu	a0,a0,1
800087cc:	80820000 	lb	v0,0(a0)
800087d0:	10400007 	beqz	v0,800087f0 <strcasecmp+0x50>
800087d4:	24a50001 	addiu	a1,a1,1
800087d8:	80a30000 	lb	v1,0(a1)
800087dc:	10600004 	beqz	v1,800087f0 <strcasecmp+0x50>
800087e0:	00621826 	xor	v1,v1,v0
800087e4:	00661824 	and	v1,v1,a2
800087e8:	1060fff8 	beqz	v1,800087cc <strcasecmp+0x2c>
800087ec:	24840001 	addiu	a0,a0,1
800087f0:	2403ffdf 	li	v1,-33
800087f4:	00431024 	and	v0,v0,v1
800087f8:	90a40000 	lbu	a0,0(a1)
800087fc:	00831824 	and	v1,a0,v1
80008800:	7c031c20 	seb	v1,v1
	return((*a & ~0x20) - (*b & ~0x20));
}
80008804:	03e00008 	jr	ra
80008808:	00431023 	subu	v0,v0,v1

8000880c <getdec>:
}


int getdec(char **ptr)
{
	char *p = *ptr;
8000880c:	8c830000 	lw	v1,0(a0)
	int ret=0;
	if ((*p < '0') || (*p > '9')) return(-1);
80008810:	80650000 	lb	a1,0(v1)
80008814:	24a6ffd0 	addiu	a2,a1,-48
80008818:	30c600ff 	andi	a2,a2,0xff
8000881c:	2cc6000a 	sltiu	a2,a2,10
80008820:	14c00003 	bnez	a2,80008830 <getdec+0x24>
80008824:	00001021 	move	v0,zero
80008828:	03e00008 	jr	ra
8000882c:	2402ffff 	li	v0,-1
	while ((*p >= '0') && (*p <= '9')) {
		ret = ret*10 + (*p - '0');
80008830:	00023040 	sll	a2,v0,0x1
80008834:	000210c0 	sll	v0,v0,0x3
80008838:	00c21021 	addu	v0,a2,v0
8000883c:	00451021 	addu	v0,v0,a1
		p++;
80008840:	24630001 	addiu	v1,v1,1
int getdec(char **ptr)
{
	char *p = *ptr;
	int ret=0;
	if ((*p < '0') || (*p > '9')) return(-1);
	while ((*p >= '0') && (*p <= '9')) {
80008844:	80650000 	lb	a1,0(v1)
80008848:	24a6ffd0 	addiu	a2,a1,-48
8000884c:	30c600ff 	andi	a2,a2,0xff
80008850:	2cc6000a 	sltiu	a2,a2,10
80008854:	14c0fff6 	bnez	a2,80008830 <getdec+0x24>
80008858:	2442ffd0 	addiu	v0,v0,-48
		ret = ret*10 + (*p - '0');
		p++;
	}
	*ptr = p;
	return(ret);
}
8000885c:	03e00008 	jr	ra
80008860:	ac830000 	sw	v1,0(a0)

80008864 <delay_ms>:
   preTime = get_timer_jiffies();
   while ( get_timer_jiffies()-preTime <  time_sec*100 );
}
//-----------------------------------------
void delay_ms(unsigned int time_ms)
{
80008864:	27bdffe0 	addiu	sp,sp,-32
80008868:	afbf001c 	sw	ra,28(sp)
8000886c:	afb10018 	sw	s1,24(sp)
80008870:	afb00014 	sw	s0,20(sp)
	
   unsigned int preTime;
   
   preTime = get_timer_jiffies();
80008874:	0c0038f0 	jal	8000e3c0 <get_timer_jiffies>
80008878:	00808821 	move	s1,a0
8000887c:	00408021 	move	s0,v0
   while ( get_timer_jiffies()-preTime <  time_ms/10 );
80008880:	3c02cccc 	lui	v0,0xcccc
80008884:	3442cccd 	ori	v0,v0,0xcccd
80008888:	02220019 	multu	s1,v0
8000888c:	00008810 	mfhi	s1
80008890:	001188c2 	srl	s1,s1,0x3
80008894:	0c0038f0 	jal	8000e3c0 <get_timer_jiffies>
80008898:	00000000 	nop
8000889c:	00501023 	subu	v0,v0,s0
800088a0:	0051102b 	sltu	v0,v0,s1
800088a4:	1440fffb 	bnez	v0,80008894 <delay_ms+0x30>
800088a8:	8fbf001c 	lw	ra,28(sp)
}
800088ac:	8fb10018 	lw	s1,24(sp)
800088b0:	8fb00014 	lw	s0,20(sp)
800088b4:	03e00008 	jr	ra
800088b8:	27bd0020 	addiu	sp,sp,32

800088bc <delay_sec>:
   preTime = get_timer_jiffies();
   while ( get_timer_jiffies()-preTime <  time_ms/10 );
}
//-----------------------------------------
void delay_sec(unsigned int time_sec)
{
800088bc:	27bdffe0 	addiu	sp,sp,-32
800088c0:	afbf001c 	sw	ra,28(sp)
800088c4:	afb20018 	sw	s2,24(sp)
800088c8:	afb10014 	sw	s1,20(sp)
800088cc:	afb00010 	sw	s0,16(sp)
   unsigned int preTime;
   
   preTime = get_timer_jiffies();
800088d0:	0c0038f0 	jal	8000e3c0 <get_timer_jiffies>
800088d4:	00809021 	move	s2,a0
800088d8:	00408021 	move	s0,v0
   while ( get_timer_jiffies()-preTime <  time_sec*100 );
800088dc:	00128880 	sll	s1,s2,0x2
800088e0:	00129100 	sll	s2,s2,0x4
800088e4:	02329021 	addu	s2,s1,s2
800088e8:	00128880 	sll	s1,s2,0x2
800088ec:	02518821 	addu	s1,s2,s1
800088f0:	0c0038f0 	jal	8000e3c0 <get_timer_jiffies>
800088f4:	00000000 	nop
800088f8:	00501023 	subu	v0,v0,s0
800088fc:	0051102b 	sltu	v0,v0,s1
80008900:	1440fffb 	bnez	v0,800088f0 <delay_sec+0x34>
80008904:	8fbf001c 	lw	ra,28(sp)
}
80008908:	8fb20018 	lw	s2,24(sp)
8000890c:	8fb10014 	lw	s1,20(sp)
80008910:	8fb00010 	lw	s0,16(sp)
80008914:	03e00008 	jr	ra
80008918:	27bd0020 	addiu	sp,sp,32

8000891c <delay>:



//-----------------------------------------
void delay(unsigned int time_ms)
{
8000891c:	27bdffe0 	addiu	sp,sp,-32
80008920:	afbf001c 	sw	ra,28(sp)
80008924:	afb10018 	sw	s1,24(sp)
80008928:	afb00014 	sw	s0,20(sp)
   unsigned int preTime;
   
   preTime = get_timer_jiffies();
8000892c:	0c0038f0 	jal	8000e3c0 <get_timer_jiffies>
80008930:	00808821 	move	s1,a0
80008934:	00408021 	move	s0,v0
   while ( get_timer_jiffies()-preTime <  time_ms/10 );
80008938:	3c02cccc 	lui	v0,0xcccc
8000893c:	3442cccd 	ori	v0,v0,0xcccd
80008940:	02220019 	multu	s1,v0
80008944:	00008810 	mfhi	s1
80008948:	001188c2 	srl	s1,s1,0x3
8000894c:	0c0038f0 	jal	8000e3c0 <get_timer_jiffies>
80008950:	00000000 	nop
80008954:	00501023 	subu	v0,v0,s0
80008958:	0051102b 	sltu	v0,v0,s1
8000895c:	1440fffb 	bnez	v0,8000894c <delay+0x30>
80008960:	8fbf001c 	lw	ra,28(sp)
}
80008964:	8fb10018 	lw	s1,24(sp)
80008968:	8fb00014 	lw	s0,20(sp)
8000896c:	03e00008 	jr	ra
80008970:	27bd0020 	addiu	sp,sp,32

80008974 <twiddle>:
**************************************************************************/

static int twiddle_count;

void twiddle(void)
{
80008974:	27bdffe8 	addiu	sp,sp,-24
80008978:	afbf0014 	sw	ra,20(sp)
	static const char tiddles[]="-\\|/";
	putchar(tiddles[(twiddle_count++)&3]);
8000897c:	3c028002 	lui	v0,0x8002
80008980:	8c433e00 	lw	v1,15872(v0)
80008984:	30650003 	andi	a1,v1,0x3
80008988:	3c048001 	lui	a0,0x8001
8000898c:	248404a0 	addiu	a0,a0,1184
80008990:	00a42021 	addu	a0,a1,a0
80008994:	80840000 	lb	a0,0(a0)
80008998:	24630001 	addiu	v1,v1,1
8000899c:	0c001fe0 	jal	80007f80 <serial_outc>
800089a0:	ac433e00 	sw	v1,15872(v0)
	putchar('\b');
800089a4:	0c001fe0 	jal	80007f80 <serial_outc>
800089a8:	24040008 	li	a0,8
}
800089ac:	8fbf0014 	lw	ra,20(sp)
800089b0:	03e00008 	jr	ra
800089b4:	27bd0018 	addiu	sp,sp,24

800089b8 <vsprintf>:
int vsprintf(char *buf, const char *fmt, const int *dp)
{
	char *p, *s;

	s = buf;
	for ( ; *fmt != '\0'; ++fmt) {
800089b8:	27bdffa8 	addiu	sp,sp,-88
800089bc:	afbf0054 	sw	ra,84(sp)
800089c0:	afbe0050 	sw	s8,80(sp)
800089c4:	afb7004c 	sw	s7,76(sp)
800089c8:	afb60048 	sw	s6,72(sp)
800089cc:	afb50044 	sw	s5,68(sp)
800089d0:	afb40040 	sw	s4,64(sp)
800089d4:	afb3003c 	sw	s3,60(sp)
800089d8:	afb20038 	sw	s2,56(sp)
800089dc:	afb10034 	sw	s1,52(sp)
800089e0:	afb00030 	sw	s0,48(sp)
800089e4:	0080a021 	move	s4,a0
800089e8:	00a09021 	move	s2,a1
800089ec:	00c0b821 	move	s7,a2
800089f0:	80a40000 	lb	a0,0(a1)
800089f4:	10800098 	beqz	a0,80008c58 <vsprintf+0x2a0>
800089f8:	02808821 	move	s1,s4
		if (*fmt != '%') {
800089fc:	24150025 	li	s5,37
			else if (*fmt == 'c')
				*q++ = *dp++;
			else
				*q++ = *fmt;
			/* now output the saved string */
			for (p = tmp; p < q; ++p)
80008a00:	27be0010 	addiu	s8,sp,16
				if (alt) {
					*q++ = '0';
					*q++ = 'X' | ncase;
				}
				for ( ; shift >= 0; shift -= 4)
					*q++ = "0123456789ABCDEF"[(h >> shift) & 0xF] | ncase;
80008a04:	3c168001 	lui	s6,0x8001
80008a08:	26d651c0 	addiu	s6,s6,20928
					*q++ = '-';
					i = -i;
				}
				p = q;		/* save beginning of digits */
				do {
					*q++ = '0' + (i % 10);
80008a0c:	3c026666 	lui	v0,0x6666
80008a10:	34426667 	ori	v0,v0,0x6667
80008a14:	afa20028 	sw	v0,40(sp)
{
	char *p, *s;

	s = buf;
	for ( ; *fmt != '\0'; ++fmt) {
		if (*fmt != '%') {
80008a18:	1095000a 	beq	a0,s5,80008a44 <vsprintf+0x8c>
80008a1c:	24020073 	li	v0,115
			buf ? *s++ = *fmt : putchar(*fmt);
80008a20:	12800004 	beqz	s4,80008a34 <vsprintf+0x7c>
80008a24:	00000000 	nop
80008a28:	a2240000 	sb	a0,0(s1)
80008a2c:	08002312 	j	80008c48 <vsprintf+0x290>
80008a30:	26310001 	addiu	s1,s1,1
80008a34:	0c001fe0 	jal	80007f80 <serial_outc>
80008a38:	26520001 	addiu	s2,s2,1
int vsprintf(char *buf, const char *fmt, const int *dp)
{
	char *p, *s;

	s = buf;
	for ( ; *fmt != '\0'; ++fmt) {
80008a3c:	08002314 	j	80008c50 <vsprintf+0x298>
80008a40:	82440000 	lb	a0,0(s2)
		if (*fmt != '%') {
			buf ? *s++ = *fmt : putchar(*fmt);
			continue;
		}
		if (*++fmt == 's') {
80008a44:	26520001 	addiu	s2,s2,1
80008a48:	82430000 	lb	v1,0(s2)
80008a4c:	14620012 	bne	v1,v0,80008a98 <vsprintf+0xe0>
80008a50:	00002021 	move	a0,zero
			for (p = (char *)*dp++; *p != '\0'; p++)
80008a54:	8ef00000 	lw	s0,0(s7)
80008a58:	82040000 	lb	a0,0(s0)
80008a5c:	1080007a 	beqz	a0,80008c48 <vsprintf+0x290>
80008a60:	26f70004 	addiu	s7,s7,4
				buf ? *s++ = *p : putchar(*p);
80008a64:	12800004 	beqz	s4,80008a78 <vsprintf+0xc0>
80008a68:	00000000 	nop
80008a6c:	a2240000 	sb	a0,0(s1)
80008a70:	080022a0 	j	80008a80 <vsprintf+0xc8>
80008a74:	26310001 	addiu	s1,s1,1
80008a78:	0c001fe0 	jal	80007f80 <serial_outc>
80008a7c:	00000000 	nop
		if (*fmt != '%') {
			buf ? *s++ = *fmt : putchar(*fmt);
			continue;
		}
		if (*++fmt == 's') {
			for (p = (char *)*dp++; *p != '\0'; p++)
80008a80:	26100001 	addiu	s0,s0,1
80008a84:	82040000 	lb	a0,0(s0)
80008a88:	1480fff6 	bnez	a0,80008a64 <vsprintf+0xac>
80008a8c:	00000000 	nop
int vsprintf(char *buf, const char *fmt, const int *dp)
{
	char *p, *s;

	s = buf;
	for ( ; *fmt != '\0'; ++fmt) {
80008a90:	08002313 	j	80008c4c <vsprintf+0x294>
80008a94:	26520001 	addiu	s2,s2,1
			char tmp[20], *q = tmp;
			int alt = 0;
			int shift = 28;

#if 1   //wei patch for %02x
			if ((*fmt  >= '0') && (*fmt  <= '9'))
80008a98:	306300ff 	andi	v1,v1,0xff
80008a9c:	2465ffd0 	addiu	a1,v1,-48
80008aa0:	30a500ff 	andi	a1,a1,0xff
80008aa4:	2ca5000a 	sltiu	a1,a1,10
80008aa8:	10a0000f 	beqz	a1,80008ae8 <vsprintf+0x130>
80008aac:	2402001c 	li	v0,28
			{
				int width;
				unsigned char fch = *fmt;
		                for (width=0; (fch>='0') && (fch<='9'); fch=*++fmt)
		                {    width = width * 10 + fch - '0';
80008ab0:	00041040 	sll	v0,a0,0x1
80008ab4:	000420c0 	sll	a0,a0,0x3
80008ab8:	00442021 	addu	a0,v0,a0
80008abc:	00831821 	addu	v1,a0,v1
80008ac0:	2464ffd0 	addiu	a0,v1,-48
#if 1   //wei patch for %02x
			if ((*fmt  >= '0') && (*fmt  <= '9'))
			{
				int width;
				unsigned char fch = *fmt;
		                for (width=0; (fch>='0') && (fch<='9'); fch=*++fmt)
80008ac4:	26520001 	addiu	s2,s2,1
80008ac8:	92430000 	lbu	v1,0(s2)
80008acc:	2462ffd0 	addiu	v0,v1,-48
80008ad0:	304200ff 	andi	v0,v0,0xff
80008ad4:	2c42000a 	sltiu	v0,v0,10
80008ad8:	1440fff6 	bnez	v0,80008ab4 <vsprintf+0xfc>
80008adc:	00041040 	sll	v0,a0,0x1
		                {    width = width * 10 + fch - '0';
		                }
				  shift=(width-1)*4;
80008ae0:	2482ffff 	addiu	v0,a0,-1
80008ae4:	00021080 	sll	v0,v0,0x2

			/*
			 * Before each format q points to tmp buffer
			 * After each format q points past end of item
			 */
			if ((*fmt == 'x')||(*fmt == 'X')) {
80008ae8:	82460000 	lb	a2,0(s2)
80008aec:	24030078 	li	v1,120
80008af0:	10c30003 	beq	a2,v1,80008b00 <vsprintf+0x148>
80008af4:	24050058 	li	a1,88
80008af8:	14c50012 	bne	a2,a1,80008b44 <vsprintf+0x18c>
80008afc:	00000000 	nop
				/* With x86 gcc, sizeof(long) == sizeof(int) */
				const long *lp = (const long *)dp;
				long h = *lp++;
80008b00:	8ee40000 	lw	a0,0(s7)
80008b04:	26e50004 	addiu	a1,s7,4
				int ncase = (*fmt & 0x20);
80008b08:	30c60020 	andi	a2,a2,0x20
				dp = (const int *)lp;
				if (alt) {
					*q++ = '0';
					*q++ = 'X' | ncase;
				}
				for ( ; shift >= 0; shift -= 4)
80008b0c:	03c09821 	move	s3,s8
80008b10:	0440004d 	bltz	v0,80008c48 <vsprintf+0x290>
80008b14:	00a0b821 	move	s7,a1
					*q++ = "0123456789ABCDEF"[(h >> shift) & 0xF] | ncase;
80008b18:	00441807 	srav	v1,a0,v0
80008b1c:	3063000f 	andi	v1,v1,0xf
80008b20:	00761821 	addu	v1,v1,s6
80008b24:	90630000 	lbu	v1,0(v1)
80008b28:	00661825 	or	v1,v1,a2
80008b2c:	a2630000 	sb	v1,0(s3)
				dp = (const int *)lp;
				if (alt) {
					*q++ = '0';
					*q++ = 'X' | ncase;
				}
				for ( ; shift >= 0; shift -= 4)
80008b30:	2442fffc 	addiu	v0,v0,-4
80008b34:	0441fff8 	bgez	v0,80008b18 <vsprintf+0x160>
80008b38:	26730001 	addiu	s3,s3,1
80008b3c:	08002302 	j	80008c08 <vsprintf+0x250>
80008b40:	00a0b821 	move	s7,a1
					*q++ = "0123456789ABCDEF"[(h >> shift) & 0xF] | ncase;
			}
			else if (*fmt == 'd') {
80008b44:	24020064 	li	v0,100
80008b48:	14c20028 	bne	a2,v0,80008bec <vsprintf+0x234>
80008b4c:	24020063 	li	v0,99
				int i = *dp++;
80008b50:	8ee20000 	lw	v0,0(s7)
80008b54:	26f70004 	addiu	s7,s7,4
				char *r;
				if (i < 0) {
80008b58:	04410005 	bgez	v0,80008b70 <vsprintf+0x1b8>
80008b5c:	03c02021 	move	a0,s8
					*q++ = '-';
80008b60:	2403002d 	li	v1,45
80008b64:	a3a30010 	sb	v1,16(sp)
					i = -i;
80008b68:	00021023 	negu	v0,v0
80008b6c:	27a40011 	addiu	a0,sp,17
80008b70:	00809821 	move	s3,a0
				}
				p = q;		/* save beginning of digits */
				do {
					*q++ = '0' + (i % 10);
80008b74:	8fa50028 	lw	a1,40(sp)
80008b78:	00450018 	mult	v0,a1
80008b7c:	00001810 	mfhi	v1
80008b80:	00031883 	sra	v1,v1,0x2
80008b84:	00022fc3 	sra	a1,v0,0x1f
80008b88:	00651823 	subu	v1,v1,a1
80008b8c:	00033040 	sll	a2,v1,0x1
80008b90:	000328c0 	sll	a1,v1,0x3
80008b94:	00c52821 	addu	a1,a2,a1
80008b98:	00451023 	subu	v0,v0,a1
80008b9c:	24420030 	addiu	v0,v0,48
80008ba0:	a2620000 	sb	v0,0(s3)
80008ba4:	26730001 	addiu	s3,s3,1
					i /= 10;
				} while (i);
80008ba8:	1460fff2 	bnez	v1,80008b74 <vsprintf+0x1bc>
80008bac:	00601021 	move	v0,v1
				/* reverse digits, stop in middle */
				r = q;		/* don't alter q */
				while (--r > p) {
80008bb0:	2662ffff 	addiu	v0,s3,-1
80008bb4:	0082182b 	sltu	v1,a0,v0
80008bb8:	10600013 	beqz	v1,80008c08 <vsprintf+0x250>
80008bbc:	00000000 	nop
					i = *r;
80008bc0:	80430000 	lb	v1,0(v0)
					*r = *p;
80008bc4:	90850000 	lbu	a1,0(a0)
80008bc8:	a0450000 	sb	a1,0(v0)
					*p++ = i;
80008bcc:	a0830000 	sb	v1,0(a0)
80008bd0:	24840001 	addiu	a0,a0,1
					*q++ = '0' + (i % 10);
					i /= 10;
				} while (i);
				/* reverse digits, stop in middle */
				r = q;		/* don't alter q */
				while (--r > p) {
80008bd4:	2442ffff 	addiu	v0,v0,-1
80008bd8:	0082182b 	sltu	v1,a0,v0
80008bdc:	1460fff8 	bnez	v1,80008bc0 <vsprintf+0x208>
80008be0:	00000000 	nop
			else if (*fmt == 'c')
				*q++ = *dp++;
			else
				*q++ = *fmt;
			/* now output the saved string */
			for (p = tmp; p < q; ++p)
80008be4:	08002303 	j	80008c0c <vsprintf+0x254>
80008be8:	03d3102b 	sltu	v0,s8,s3
				for (r = p + ETH_ALEN; p < r; ++p)
					q += SprintF(q, "%hhX:", *p);
				--q;
			}
#endif			
			else if (*fmt == 'c')
80008bec:	14c20005 	bne	a2,v0,80008c04 <vsprintf+0x24c>
80008bf0:	27b30011 	addiu	s3,sp,17
				*q++ = *dp++;
80008bf4:	8ee20000 	lw	v0,0(s7)
80008bf8:	a3a20010 	sb	v0,16(sp)
80008bfc:	08002302 	j	80008c08 <vsprintf+0x250>
80008c00:	26f70004 	addiu	s7,s7,4
			else
				*q++ = *fmt;
80008c04:	a3a60010 	sb	a2,16(sp)
			/* now output the saved string */
			for (p = tmp; p < q; ++p)
80008c08:	03d3102b 	sltu	v0,s8,s3
80008c0c:	1040000e 	beqz	v0,80008c48 <vsprintf+0x290>
80008c10:	00000000 	nop
80008c14:	03c08021 	move	s0,s8
				buf ? *s++ = *p : putchar(*p);
80008c18:	12800005 	beqz	s4,80008c30 <vsprintf+0x278>
80008c1c:	00000000 	nop
80008c20:	92020000 	lbu	v0,0(s0)
80008c24:	a2220000 	sb	v0,0(s1)
80008c28:	0800230e 	j	80008c38 <vsprintf+0x280>
80008c2c:	26310001 	addiu	s1,s1,1
80008c30:	0c001fe0 	jal	80007f80 <serial_outc>
80008c34:	82040000 	lb	a0,0(s0)
			else if (*fmt == 'c')
				*q++ = *dp++;
			else
				*q++ = *fmt;
			/* now output the saved string */
			for (p = tmp; p < q; ++p)
80008c38:	26100001 	addiu	s0,s0,1
80008c3c:	0213102b 	sltu	v0,s0,s3
80008c40:	1440fff5 	bnez	v0,80008c18 <vsprintf+0x260>
80008c44:	00000000 	nop
int vsprintf(char *buf, const char *fmt, const int *dp)
{
	char *p, *s;

	s = buf;
	for ( ; *fmt != '\0'; ++fmt) {
80008c48:	26520001 	addiu	s2,s2,1
80008c4c:	82440000 	lb	a0,0(s2)
80008c50:	1480ff71 	bnez	a0,80008a18 <vsprintf+0x60>
80008c54:	00000000 	nop
			/* now output the saved string */
			for (p = tmp; p < q; ++p)
				buf ? *s++ = *p : putchar(*p);
		}
	}
	if (buf)
80008c58:	12800002 	beqz	s4,80008c64 <vsprintf+0x2ac>
80008c5c:	02341023 	subu	v0,s1,s4
		*s = '\0';
80008c60:	a2200000 	sb	zero,0(s1)
	return (s - buf);
}
80008c64:	8fbf0054 	lw	ra,84(sp)
80008c68:	8fbe0050 	lw	s8,80(sp)
80008c6c:	8fb7004c 	lw	s7,76(sp)
80008c70:	8fb60048 	lw	s6,72(sp)
80008c74:	8fb50044 	lw	s5,68(sp)
80008c78:	8fb40040 	lw	s4,64(sp)
80008c7c:	8fb3003c 	lw	s3,60(sp)
80008c80:	8fb20038 	lw	s2,56(sp)
80008c84:	8fb10034 	lw	s1,52(sp)
80008c88:	8fb00030 	lw	s0,48(sp)
80008c8c:	03e00008 	jr	ra
80008c90:	27bd0058 	addiu	sp,sp,88

80008c94 <dprintf>:
*/
#include <stdarg.h>


int dprintf(char *fmt, ...)
{
80008c94:	27bdffe8 	addiu	sp,sp,-24
80008c98:	afbf0014 	sw	ra,20(sp)
80008c9c:	afa5001c 	sw	a1,28(sp)
80008ca0:	afa60020 	sw	a2,32(sp)
80008ca4:	afa70024 	sw	a3,36(sp)
80008ca8:	afa40018 	sw	a0,24(sp)
	(void)vsprintf(0, fmt, ((const int *)&fmt)+1);	
80008cac:	00802821 	move	a1,a0
80008cb0:	00002021 	move	a0,zero
80008cb4:	0c00226e 	jal	800089b8 <vsprintf>
80008cb8:	27a6001c 	addiu	a2,sp,28
}
80008cbc:	8fbf0014 	lw	ra,20(sp)
80008cc0:	03e00008 	jr	ra
80008cc4:	27bd0018 	addiu	sp,sp,24

80008cc8 <ddump>:
//----------------------------------------------------------------
//----------------------------------------------------------------

void ddump(unsigned char * pData, int len)
{
80008cc8:	27bdffc0 	addiu	sp,sp,-64
80008ccc:	afbf003c 	sw	ra,60(sp)
80008cd0:	afbe0038 	sw	s8,56(sp)
80008cd4:	afb70034 	sw	s7,52(sp)
80008cd8:	afb60030 	sw	s6,48(sp)
80008cdc:	afb5002c 	sw	s5,44(sp)
80008ce0:	afb40028 	sw	s4,40(sp)
80008ce4:	afb30024 	sw	s3,36(sp)
80008ce8:	afb20020 	sw	s2,32(sp)
80008cec:	afb1001c 	sw	s1,28(sp)
80008cf0:	afb00018 	sw	s0,24(sp)
80008cf4:	0080b821 	move	s7,a0
80008cf8:	afa50044 	sw	a1,68(sp)
	unsigned char *sbuf = pData;	
	int length=len;

	int i=0,j,offset;
	dprintf(" [Addr]   .0 .1 .2 .3 .4 .5 .6 .7 .8 .9 .A .B .C .D .E .F\r\n" );
80008cfc:	3c048001 	lui	a0,0x8001
80008d00:	0c002325 	jal	80008c94 <dprintf>
80008d04:	248451d4 	addiu	a0,a0,20948

	while(i< length)
80008d08:	8fa20044 	lw	v0,68(sp)
80008d0c:	1840004d 	blez	v0,80008e44 <ddump+0x17c>
80008d10:	0000f021 	move	s8,zero
80008d14:	afa20010 	sw	v0,16(sp)
			else			
				offset=length-i;
			

			for(j=0; j<offset; j++)
				dprintf("%02x ", sbuf[i+j]);	
80008d18:	3c138001 	lui	s3,0x8001
80008d1c:	26735218 	addiu	s3,s3,21016

			for(j=0;j<16-offset;j++)	//a last line
			dprintf("   ");
80008d20:	3c148001 	lui	s4,0x8001
80008d24:	269460dc 	addiu	s4,s4,24796
			for(j=0;  j<offset; j++)
			{	
				if( ' ' <= sbuf[i+j]  && sbuf[i+j] <= '~')
					dprintf("%c", sbuf[i+j]);
				else
					dprintf(".");
80008d28:	3c158001 	lui	s5,0x8001
80008d2c:	26b56e08 	addiu	s5,s5,28168
			dprintf("    ");		//between byte and char
			
			for(j=0;  j<offset; j++)
			{	
				if( ' ' <= sbuf[i+j]  && sbuf[i+j] <= '~')
					dprintf("%c", sbuf[i+j]);
80008d30:	3c168001 	lui	s6,0x8001
80008d34:	26d65220 	addiu	s6,s6,21024
	dprintf(" [Addr]   .0 .1 .2 .3 .4 .5 .6 .7 .8 .9 .A .B .C .D .E .F\r\n" );

	while(i< length)
	{		
			
			dprintf("%08X: ", (sbuf+i) );
80008d38:	3c048001 	lui	a0,0x8001
80008d3c:	24845210 	addiu	a0,a0,21008
80008d40:	0c002325 	jal	80008c94 <dprintf>
80008d44:	02e02821 	move	a1,s7

			if(i+16 < length)
80008d48:	27de0010 	addiu	s8,s8,16
80008d4c:	8fa30044 	lw	v1,68(sp)
80008d50:	03c3102a 	slt	v0,s8,v1
80008d54:	10400004 	beqz	v0,80008d68 <ddump+0xa0>
80008d58:	24120010 	li	s2,16
80008d5c:	02e08021 	move	s0,s7
80008d60:	0800235f 	j	80008d7c <ddump+0xb4>
80008d64:	00008821 	move	s1,zero
80008d68:	8fb20010 	lw	s2,16(sp)
				offset=16;
			else			
				offset=length-i;
			

			for(j=0; j<offset; j++)
80008d6c:	1e40fffb 	bgtz	s2,80008d5c <ddump+0x94>
80008d70:	24020010 	li	v0,16
				dprintf("%02x ", sbuf[i+j]);	

			for(j=0;j<16-offset;j++)	//a last line
80008d74:	08002368 	j	80008da0 <ddump+0xd8>
80008d78:	00528823 	subu	s1,v0,s2
			else			
				offset=length-i;
			

			for(j=0; j<offset; j++)
				dprintf("%02x ", sbuf[i+j]);	
80008d7c:	02602021 	move	a0,s3
80008d80:	0c002325 	jal	80008c94 <dprintf>
80008d84:	92050000 	lbu	a1,0(s0)
				offset=16;
			else			
				offset=length-i;
			

			for(j=0; j<offset; j++)
80008d88:	26310001 	addiu	s1,s1,1
80008d8c:	0232102a 	slt	v0,s1,s2
80008d90:	1440fffa 	bnez	v0,80008d7c <ddump+0xb4>
80008d94:	26100001 	addiu	s0,s0,1
				dprintf("%02x ", sbuf[i+j]);	

			for(j=0;j<16-offset;j++)	//a last line
80008d98:	24020010 	li	v0,16
80008d9c:	00528823 	subu	s1,v0,s2
80008da0:	1a200008 	blez	s1,80008dc4 <ddump+0xfc>
80008da4:	3c048001 	lui	a0,0x8001
80008da8:	00008021 	move	s0,zero
			dprintf("   ");
80008dac:	0c002325 	jal	80008c94 <dprintf>
80008db0:	02802021 	move	a0,s4
			

			for(j=0; j<offset; j++)
				dprintf("%02x ", sbuf[i+j]);	

			for(j=0;j<16-offset;j++)	//a last line
80008db4:	26100001 	addiu	s0,s0,1
80008db8:	0211102a 	slt	v0,s0,s1
80008dbc:	1440fffb 	bnez	v0,80008dac <ddump+0xe4>
80008dc0:	3c048001 	lui	a0,0x8001
			dprintf("   ");


			dprintf("    ");		//between byte and char
80008dc4:	0c002325 	jal	80008c94 <dprintf>
80008dc8:	24844cb0 	addiu	a0,a0,19632
			
			for(j=0;  j<offset; j++)
80008dcc:	1a400014 	blez	s2,80008e20 <ddump+0x158>
80008dd0:	3c048001 	lui	a0,0x8001
80008dd4:	02e08021 	move	s0,s7
80008dd8:	00008821 	move	s1,zero
			{	
				if( ' ' <= sbuf[i+j]  && sbuf[i+j] <= '~')
80008ddc:	92050000 	lbu	a1,0(s0)
80008de0:	24a2ffe0 	addiu	v0,a1,-32
80008de4:	304200ff 	andi	v0,v0,0xff
80008de8:	2c42005f 	sltiu	v0,v0,95
80008dec:	10400005 	beqz	v0,80008e04 <ddump+0x13c>
80008df0:	00000000 	nop
					dprintf("%c", sbuf[i+j]);
80008df4:	0c002325 	jal	80008c94 <dprintf>
80008df8:	02c02021 	move	a0,s6
			dprintf("   ");


			dprintf("    ");		//between byte and char
			
			for(j=0;  j<offset; j++)
80008dfc:	08002384 	j	80008e10 <ddump+0x148>
80008e00:	26310001 	addiu	s1,s1,1
			{	
				if( ' ' <= sbuf[i+j]  && sbuf[i+j] <= '~')
					dprintf("%c", sbuf[i+j]);
				else
					dprintf(".");
80008e04:	0c002325 	jal	80008c94 <dprintf>
80008e08:	02a02021 	move	a0,s5
			dprintf("   ");


			dprintf("    ");		//between byte and char
			
			for(j=0;  j<offset; j++)
80008e0c:	26310001 	addiu	s1,s1,1
80008e10:	0232102a 	slt	v0,s1,s2
80008e14:	1440fff1 	bnez	v0,80008ddc <ddump+0x114>
80008e18:	26100001 	addiu	s0,s0,1
				if( ' ' <= sbuf[i+j]  && sbuf[i+j] <= '~')
					dprintf("%c", sbuf[i+j]);
				else
					dprintf(".");
			}
			dprintf("\n\r");
80008e1c:	3c048001 	lui	a0,0x8001
80008e20:	0c002325 	jal	80008c94 <dprintf>
80008e24:	24844b58 	addiu	a0,a0,19288
80008e28:	8fa30010 	lw	v1,16(sp)
80008e2c:	2463fff0 	addiu	v1,v1,-16
80008e30:	afa30010 	sw	v1,16(sp)
	int length=len;

	int i=0,j,offset;
	dprintf(" [Addr]   .0 .1 .2 .3 .4 .5 .6 .7 .8 .9 .A .B .C .D .E .F\r\n" );

	while(i< length)
80008e34:	8fa30044 	lw	v1,68(sp)
80008e38:	03c3102a 	slt	v0,s8,v1
80008e3c:	1440ffbe 	bnez	v0,80008d38 <ddump+0x70>
80008e40:	26f70010 	addiu	s7,s7,16

	//dprintf("\n\r");


	
}
80008e44:	8fbf003c 	lw	ra,60(sp)
80008e48:	8fbe0038 	lw	s8,56(sp)
80008e4c:	8fb70034 	lw	s7,52(sp)
80008e50:	8fb60030 	lw	s6,48(sp)
80008e54:	8fb5002c 	lw	s5,44(sp)
80008e58:	8fb40028 	lw	s4,40(sp)
80008e5c:	8fb30024 	lw	s3,36(sp)
80008e60:	8fb20020 	lw	s2,32(sp)
80008e64:	8fb1001c 	lw	s1,28(sp)
80008e68:	8fb00018 	lw	s0,24(sp)
80008e6c:	03e00008 	jr	ra
80008e70:	27bd0040 	addiu	sp,sp,64

80008e74 <SprintF>:
{
	(void)vsprintf(0, fmt, ((const int *)&fmt)+1);	
}

int SprintF(char *buf, const char *fmt, ...)
{
80008e74:	27bdffe8 	addiu	sp,sp,-24
80008e78:	afbf0014 	sw	ra,20(sp)
80008e7c:	afa60020 	sw	a2,32(sp)
80008e80:	afa70024 	sw	a3,36(sp)
80008e84:	afa5001c 	sw	a1,28(sp)
	return vsprintf(buf, fmt, ((const int *)&fmt)+1);
80008e88:	0c00226e 	jal	800089b8 <vsprintf>
80008e8c:	27a60020 	addiu	a2,sp,32
}
80008e90:	8fbf0014 	lw	ra,20(sp)
80008e94:	03e00008 	jr	ra
80008e98:	27bd0018 	addiu	sp,sp,24

80008e9c <prom_printf>:
		*s = '\0';
	return (s - buf);
}

void prom_printf(const char *fmt, ...)
{
80008e9c:	27bdffe8 	addiu	sp,sp,-24
80008ea0:	afbf0014 	sw	ra,20(sp)
80008ea4:	afa5001c 	sw	a1,28(sp)
80008ea8:	afa60020 	sw	a2,32(sp)
80008eac:	afa70024 	sw	a3,36(sp)
80008eb0:	afa40018 	sw	a0,24(sp)
	(void)vsprintf(0, fmt, ((const int *)&fmt)+1);	
80008eb4:	00802821 	move	a1,a0
80008eb8:	00002021 	move	a0,zero
80008ebc:	0c00226e 	jal	800089b8 <vsprintf>
80008ec0:	27a6001c 	addiu	a2,sp,28
}
80008ec4:	8fbf0014 	lw	ra,20(sp)
80008ec8:	03e00008 	jr	ra
80008ecc:	27bd0018 	addiu	sp,sp,24

80008ed0 <rtl8168_tx>:
//===============================================================================
void rtl8168_tx(unsigned char *content, unsigned int size, int portnum)
{
   unsigned int i;

   if ( (portnum == 0) || (portnum== 2) )
80008ed0:	10c00004 	beqz	a2,80008ee4 <rtl8168_tx+0x14>
80008ed4:	3c04a053 	lui	a0,0xa053
80008ed8:	24020002 	li	v0,2
80008edc:	14c2001b 	bne	a2,v0,80008f4c <rtl8168_tx+0x7c>
80008ee0:	00000000 	nop
   {
      // Fill RX Descriptor
      WRITE_MEM32(RX1_DESC_ADDR + 0x08, htonl(PADDR(RX1_BUFF_ADDR)));  // RX Buffer Address
80008ee4:	34820008 	ori	v0,a0,0x8
80008ee8:	24035a00 	li	v1,23040
80008eec:	ac430000 	sw	v1,0(v0)
      WRITE_MEM32(RX1_DESC_ADDR + 0x18, htonl(PADDR(RX1_BUFF_ADDR)));  // RX Buffer Address
80008ef0:	34840018 	ori	a0,a0,0x18
80008ef4:	ac830000 	sw	v1,0(a0)

      // Ensure Descriptor is updated
      READ_MEM32(RX1_DESC_ADDR + 0x8);
80008ef8:	8c420000 	lw	v0,0(v0)

      // Enable TX/RX (This seems to trigger NIC prefetching RX descriptor)
      WRITE_MEM8(PCIE1_EP_MEM + ChipCmd, 0x0C);
80008efc:	2403000c 	li	v1,12
80008f00:	3c02b900 	lui	v0,0xb900
80008f04:	34420037 	ori	v0,v0,0x37
80008f08:	a0430000 	sb	v1,0(v0)

      #if 1
      // Fill Descriptor
      WRITE_MEM32(TX1_DESC_ADDR + 0x0, htonl(DescOwn | FirstFrag | LastFrag | RingEnd | size));
80008f0c:	00051a02 	srl	v1,a1,0x8
80008f10:	3063ff00 	andi	v1,v1,0xff00
80008f14:	30a2ff00 	andi	v0,a1,0xff00
80008f18:	00021200 	sll	v0,v0,0x8
80008f1c:	00621825 	or	v1,v1,v0
80008f20:	00051600 	sll	v0,a1,0x18
80008f24:	00621825 	or	v1,v1,v0
80008f28:	7ca21e00 	ext	v0,a1,0x18,0x4
80008f2c:	344200f0 	ori	v0,v0,0xf0
80008f30:	00621825 	or	v1,v1,v0
80008f34:	3c02a052 	lui	v0,0xa052
80008f38:	ac430000 	sw	v1,0(v0)
      WRITE_MEM32(TX1_DESC_ADDR + 0x8, htonl(PADDR((unsigned int) TX1_BUFF_ADDR)));
80008f3c:	34420008 	ori	v0,v0,0x8
80008f40:	24035800 	li	v1,22528
80008f44:	ac430000 	sw	v1,0(v0)

      // Ensure Descriptor is updated
      READ_MEM32(TX1_DESC_ADDR + 0x8);
80008f48:	8c420000 	lw	v0,0(v0)
      }
      #endif
   }

  #if (TEST_8196_PCIE_P1)
   if ( (portnum == 1) || (portnum== 2) )//PORT1
80008f4c:	24c6ffff 	addiu	a2,a2,-1
80008f50:	2cc60002 	sltiu	a2,a2,2
80008f54:	10c0001b 	beqz	a2,80008fc4 <rtl8168_tx+0xf4>
80008f58:	3c04a063 	lui	a0,0xa063
   {
      // Fill RX Descriptor
      WRITE_MEM32(RX2_DESC_ADDR + 0x08, htonl(PADDR(RX2_BUFF_ADDR)));  // RX Buffer Address
80008f5c:	34820008 	ori	v0,a0,0x8
80008f60:	24036a00 	li	v1,27136
80008f64:	ac430000 	sw	v1,0(v0)
      WRITE_MEM32(RX2_DESC_ADDR + 0x18, htonl(PADDR(RX2_BUFF_ADDR)));  // RX Buffer Address
80008f68:	34840018 	ori	a0,a0,0x18
80008f6c:	ac830000 	sw	v1,0(a0)

      // Ensure Descriptor is updated
      READ_MEM32(RX2_DESC_ADDR + 0x8);
80008f70:	8c420000 	lw	v0,0(v0)

      // Enable TX/RX (This seems to trigger NIC prefetching RX descriptor)
      WRITE_MEM8(PCIE2_EP_MEM + ChipCmd, 0x0C);
80008f74:	2403000c 	li	v1,12
80008f78:	3c02ba00 	lui	v0,0xba00
80008f7c:	34420037 	ori	v0,v0,0x37
80008f80:	a0430000 	sb	v1,0(v0)

      #if 1
      // Fill Descriptor
      WRITE_MEM32(TX2_DESC_ADDR + 0x0, htonl(DescOwn | FirstFrag | LastFrag | RingEnd | size));
80008f84:	00051a02 	srl	v1,a1,0x8
80008f88:	3063ff00 	andi	v1,v1,0xff00
80008f8c:	30a2ff00 	andi	v0,a1,0xff00
80008f90:	00021200 	sll	v0,v0,0x8
80008f94:	00621025 	or	v0,v1,v0
80008f98:	00051e00 	sll	v1,a1,0x18
80008f9c:	00431025 	or	v0,v0,v1
80008fa0:	7ca51e00 	ext	a1,a1,0x18,0x4
80008fa4:	34a500f0 	ori	a1,a1,0xf0
80008fa8:	00452825 	or	a1,v0,a1
80008fac:	3c02a062 	lui	v0,0xa062
80008fb0:	ac450000 	sw	a1,0(v0)
      WRITE_MEM32(TX2_DESC_ADDR + 0x8, htonl(PADDR((unsigned int) TX2_BUFF_ADDR)));
80008fb4:	34420008 	ori	v0,v0,0x8
80008fb8:	24036800 	li	v1,26624
80008fbc:	ac430000 	sw	v1,0(v0)

      // Ensure Descriptor is updated
      READ_MEM32(TX2_DESC_ADDR + 0x8);
80008fc0:	8c420000 	lw	v0,0(v0)
80008fc4:	03e00008 	jr	ra
80008fc8:	00000000 	nop

80008fcc <rtl8168_tx_trigger>:
   return 0;
}
//===============================================================================
void rtl8168_tx_trigger(int portnum)
{
	if ((portnum == 0) |(portnum== 2) )   //Port 0
80008fcc:	10800004 	beqz	a0,80008fe0 <rtl8168_tx_trigger+0x14>
80008fd0:	24030040 	li	v1,64
80008fd4:	24020002 	li	v0,2
80008fd8:	14820004 	bne	a0,v0,80008fec <rtl8168_tx_trigger+0x20>
80008fdc:	00000000 	nop
	{		
		WRITE_MEM8(PCIE1_EP_MEM + TxPoll, 0x40);	// Indicate TX Packet
80008fe0:	3c02b900 	lui	v0,0xb900
80008fe4:	34420038 	ori	v0,v0,0x38
80008fe8:	a0430000 	sb	v1,0(v0)
	}
  
	if ((portnum == 1) |(portnum == 2) )   //PORT1
80008fec:	2484ffff 	addiu	a0,a0,-1
80008ff0:	2c840002 	sltiu	a0,a0,2
80008ff4:	10800004 	beqz	a0,80009008 <rtl8168_tx_trigger+0x3c>
80008ff8:	24030040 	li	v1,64
	{	     
	      WRITE_MEM8(PCIE2_EP_MEM + TxPoll, 0x40);	 // Indicate TX Packet
80008ffc:	3c02ba00 	lui	v0,0xba00
80009000:	34420038 	ori	v0,v0,0x38
80009004:	a0430000 	sb	v1,0(v0)
80009008:	03e00008 	jr	ra
8000900c:	00000000 	nop

80009010 <PCIE_isr>:


volatile unsigned int grxok=0;
volatile unsigned int gtxok=0;
static void PCIE_isr(void)
{
80009010:	27bdffe8 	addiu	sp,sp,-24
80009014:	afbf0014 	sw	ra,20(sp)
80009018:	afb00010 	sw	s0,16(sp)
		addr=PCIE2_EP_MEM;
	}


//	printf("PCIE ISR\n");	
	unsigned int r=READ_MEM16(addr + IntrStatus);
8000901c:	3c02b900 	lui	v0,0xb900
80009020:	3442003e 	ori	v0,v0,0x3e
80009024:	94500000 	lhu	s0,0(v0)
80009028:	3210ffff 	andi	s0,s0,0xffff
	if((r==0) || (r==0xffff))
8000902c:	12000041 	beqz	s0,80009134 <PCIE_isr+0x124>
80009030:	3402ffff 	li	v0,0xffff
80009034:	12020040 	beq	s0,v0,80009138 <PCIE_isr+0x128>
80009038:	8fbf0014 	lw	ra,20(sp)
		return 0;
	
	printf("\n=>ISR=%x \n", r);
8000903c:	3c048001 	lui	a0,0x8001
80009040:	24845224 	addiu	a0,a0,21028
80009044:	0c002325 	jal	80008c94 <dprintf>
80009048:	02002821 	move	a1,s0

	if(r & RxOK)   // bit 0
8000904c:	32020001 	andi	v0,s0,0x1
80009050:	10400008 	beqz	v0,80009074 <PCIE_isr+0x64>
80009054:	32020002 	andi	v0,s0,0x2
	{
		printf("RxOK\n");	
80009058:	3c048001 	lui	a0,0x8001
8000905c:	0c002325 	jal	80008c94 <dprintf>
80009060:	24845230 	addiu	a0,a0,21040
		grxok=1;
80009064:	24030001 	li	v1,1
80009068:	3c028002 	lui	v0,0x8002
8000906c:	ac433e10 	sw	v1,15888(v0)
	}
	if(r &RxErr)   // bit 1
80009070:	32020002 	andi	v0,s0,0x2
80009074:	10400005 	beqz	v0,8000908c <PCIE_isr+0x7c>
80009078:	32020004 	andi	v0,s0,0x4
	{
		printf("RxErr\n");	
8000907c:	3c048001 	lui	a0,0x8001
80009080:	0c002325 	jal	80008c94 <dprintf>
80009084:	24845238 	addiu	a0,a0,21048
	}
	if(r & TxOK)   //bit 2
80009088:	32020004 	andi	v0,s0,0x4
8000908c:	10400008 	beqz	v0,800090b0 <PCIE_isr+0xa0>
80009090:	32020008 	andi	v0,s0,0x8
	{
		printf("TxOK\n");	
80009094:	3c048001 	lui	a0,0x8001
80009098:	0c002325 	jal	80008c94 <dprintf>
8000909c:	24845240 	addiu	a0,a0,21056
		gtxok=1;
800090a0:	24030001 	li	v1,1
800090a4:	3c028002 	lui	v0,0x8002
800090a8:	ac433e14 	sw	v1,15892(v0)
	}
	if(r &TxErr)  //bit 3
800090ac:	32020008 	andi	v0,s0,0x8
800090b0:	10400005 	beqz	v0,800090c8 <PCIE_isr+0xb8>
800090b4:	32020010 	andi	v0,s0,0x10
	{
		printf("TxErr\n");	
800090b8:	3c048001 	lui	a0,0x8001
800090bc:	0c002325 	jal	80008c94 <dprintf>
800090c0:	24845248 	addiu	a0,a0,21064
	}
	
	if(r & RxDescUnavail)  //bit 4
800090c4:	32020010 	andi	v0,s0,0x10
800090c8:	10400005 	beqz	v0,800090e0 <PCIE_isr+0xd0>
800090cc:	32020020 	andi	v0,s0,0x20
	{
		printf("RxDescUnavail\n");	
800090d0:	3c048001 	lui	a0,0x8001
800090d4:	0c002325 	jal	80008c94 <dprintf>
800090d8:	24845250 	addiu	a0,a0,21072
	}
	if(r &LinkChg)   //bit 5
800090dc:	32020020 	andi	v0,s0,0x20
800090e0:	10400005 	beqz	v0,800090f8 <PCIE_isr+0xe8>
800090e4:	32020040 	andi	v0,s0,0x40
	{
		printf("LinkChg\n");	
800090e8:	3c048001 	lui	a0,0x8001
800090ec:	0c002325 	jal	80008c94 <dprintf>
800090f0:	24845260 	addiu	a0,a0,21088
	}
	if(r &RxFIFOOver)   //bit 6
800090f4:	32020040 	andi	v0,s0,0x40
800090f8:	10400004 	beqz	v0,8000910c <PCIE_isr+0xfc>
800090fc:	00000000 	nop
	{
		printf("RxFIFOOver\n");	
80009100:	3c048001 	lui	a0,0x8001
80009104:	0c002325 	jal	80008c94 <dprintf>
80009108:	2484526c 	addiu	a0,a0,21100
	}	
	if(r &TxDescUnavail)   //bit 7
8000910c:	32100080 	andi	s0,s0,0x80
80009110:	12000005 	beqz	s0,80009128 <PCIE_isr+0x118>
80009114:	2403ffff 	li	v1,-1
	{
		printf("TxDescUnavail\n");	
80009118:	3c048001 	lui	a0,0x8001
8000911c:	0c002325 	jal	80008c94 <dprintf>
80009120:	24845278 	addiu	a0,a0,21112
	{
		printf("SYSErr\n");	
	}		
*/
	
	WRITE_MEM16(addr + IntrStatus, 0xffff);
80009124:	2403ffff 	li	v1,-1
80009128:	3c02b900 	lui	v0,0xb900
8000912c:	3442003e 	ori	v0,v0,0x3e
80009130:	a4430000 	sh	v1,0(v0)
}
80009134:	8fbf0014 	lw	ra,20(sp)
80009138:	8fb00010 	lw	s0,16(sp)
8000913c:	03e00008 	jr	ra
80009140:	27bd0018 	addiu	sp,sp,24

80009144 <rtl8168_rx>:
//===============================================================================

 

int rtl8168_rx(unsigned char *content, unsigned int size, int portnum)
{
80009144:	27bdffc8 	addiu	sp,sp,-56
80009148:	afbf0034 	sw	ra,52(sp)
8000914c:	afb50030 	sw	s5,48(sp)
80009150:	afb4002c 	sw	s4,44(sp)
80009154:	afb30028 	sw	s3,40(sp)
80009158:	afb20024 	sw	s2,36(sp)
8000915c:	afb10020 	sw	s1,32(sp)
80009160:	afb0001c 	sw	s0,28(sp)
80009164:	00809021 	move	s2,a0
80009168:	00a08821 	move	s1,a1
8000916c:	00c09821 	move	s3,a2
 

   
   
  #if DBG	  
     prom_printf("\nTest Rx Bytes=%d\n",size); //OK   
80009170:	3c048001 	lui	a0,0x8001
80009174:	0c0023a7 	jal	80008e9c <prom_printf>
80009178:	24845288 	addiu	a0,a0,21128
     prom_printf("P0 PCIE Error count: %d\n",P0_PCIE_error_count);
8000917c:	3c048001 	lui	a0,0x8001
80009180:	2484529c 	addiu	a0,a0,21148
80009184:	0c0023a7 	jal	80008e9c <prom_printf>
80009188:	00002821 	move	a1,zero
  #if (TEST_8196_PCIE_P1) 
     prom_printf("P1 PCIE Error count: %d\n",P1_PCIE_error_count);
8000918c:	3c048001 	lui	a0,0x8001
80009190:	248452b8 	addiu	a0,a0,21176
80009194:	0c0023a7 	jal	80008e9c <prom_printf>
80009198:	00002821 	move	a1,zero
  #endif
  #endif 
   
  
    if ((portnum == 0) || (portnum == 2) )
8000919c:	12600004 	beqz	s3,800091b0 <rtl8168_rx+0x6c>
800091a0:	3c03a053 	lui	v1,0xa053
800091a4:	24020002 	li	v0,2
800091a8:	16620055 	bne	s3,v0,80009300 <rtl8168_rx+0x1bc>
800091ac:	00000000 	nop
   {
      // Wait RX Packet   
		  //loop here when OWN bit=1 (means Memory is owned by PCIE IP)
		 //dprintf("Wait Rx own bit \n");
		  while ((READ_MEM32(RX1_DESC_ADDR) & htonl(DescOwn)) != 0)
800091b0:	8c620000 	lw	v0,0(v1)
800091b4:	30420080 	andi	v0,v0,0x80
800091b8:	1440fffd 	bnez	v0,800091b0 <rtl8168_rx+0x6c>
800091bc:	00000000 	nop
		 //dprintf("got Rx own bit \n");
		 
      // Check RX Packet Content
      int i2;
	   
      for (i = 0; i < size; i++)        
800091c0:	1220004f 	beqz	s1,80009300 <rtl8168_rx+0x1bc>
800091c4:	3c02a05a 	lui	v0,0xa05a
      {
      
         if (READ_MEM8(RX1_BUFF_ADDR + i) != content[i])
800091c8:	90430000 	lbu	v1,0(v0)
800091cc:	306300ff 	andi	v1,v1,0xff
800091d0:	92420000 	lbu	v0,0(s2)
		   prom_printf("\nCheck last 4 Bytes,Rx(0x%x) content=%x\n",(0xa0630000+i-4),READ_MEM32(0xa0630000+i-4));
		   
		   
		 //#if 1 //for 2 port
		 		 	
		 	return -1; // RX Error
800091d4:	00008021 	move	s0,zero
      int i2;
	   
      for (i = 0; i < size; i++)        
      {
      
         if (READ_MEM8(RX1_BUFF_ADDR + i) != content[i])
800091d8:	10620045 	beq	v1,v0,800092f0 <rtl8168_rx+0x1ac>
800091dc:	3c05a05a 	lui	a1,0xa05a
800091e0:	08002481 	j	80009204 <rtl8168_rx+0xc0>
800091e4:	3c03a05a 	lui	v1,0xa05a
800091e8:	90640000 	lbu	a0,0(v1)
800091ec:	308400ff 	andi	a0,a0,0xff
800091f0:	02501021 	addu	v0,s2,s0
800091f4:	90420000 	lbu	v0,0(v0)
800091f8:	1082003e 	beq	a0,v0,800092f4 <rtl8168_rx+0x1b0>
800091fc:	26100001 	addiu	s0,s0,1
80009200:	2610ffff 	addiu	s0,s0,-1
         {
           #if DBG//JSW:DEBUG_PRINT
		  P0_PCIE_error_count++;
		     		  
	         prom_printf("Compare Error, No: Port0, Size: %d, Offset: %d, Content: 0x%X, Expected: 0x%X \n",
	                     size, i, READ_MEM8(RX1_BUFF_ADDR + i), content[i]);
80009204:	90670000 	lbu	a3,0(v1)
         if (READ_MEM8(RX1_BUFF_ADDR + i) != content[i])
         {
           #if DBG//JSW:DEBUG_PRINT
		  P0_PCIE_error_count++;
		     		  
	         prom_printf("Compare Error, No: Port0, Size: %d, Offset: %d, Content: 0x%X, Expected: 0x%X \n",
80009208:	afa20010 	sw	v0,16(sp)
8000920c:	3c048001 	lui	a0,0x8001
80009210:	248452d4 	addiu	a0,a0,21204
80009214:	02202821 	move	a1,s1
80009218:	02003021 	move	a2,s0
8000921c:	0c0023a7 	jal	80008e9c <prom_printf>
80009220:	30e700ff 	andi	a3,a3,0xff
80009224:	3c13a05a 	lui	s3,0xa05a
80009228:	36710001 	ori	s1,s3,0x1
8000922c:	02118821 	addu	s1,s0,s1
80009230:	02509021 	addu	s2,s2,s0
}
//===============================================================================

 

int rtl8168_rx(unsigned char *content, unsigned int size, int portnum)
80009234:	36730005 	ori	s3,s3,0x5
80009238:	02139821 	addu	s3,s0,s3
	         prom_printf("Compare Error, No: Port0, Size: %d, Offset: %d, Content: 0x%X, Expected: 0x%X \n",
	                     size, i, READ_MEM8(RX1_BUFF_ADDR + i), content[i]);
		   
		   for (i2=1;i2<=4;i2++)
		   {
		   	 prom_printf("\nOffset(%d),Content:%x,Expected:%x\n",(i+i2),READ_MEM8(RX1_BUFF_ADDR + i+i2),content[i+i2]);
8000923c:	3c145fa6 	lui	s4,0x5fa6
80009240:	3c158001 	lui	s5,0x8001
80009244:	26b55324 	addiu	s5,s5,21284
80009248:	92260000 	lbu	a2,0(s1)
8000924c:	02a02021 	move	a0,s5
80009250:	02342821 	addu	a1,s1,s4
80009254:	30c600ff 	andi	a2,a2,0xff
80009258:	0c0023a7 	jal	80008e9c <prom_printf>
8000925c:	92470001 	lbu	a3,1(s2)
80009260:	26310001 	addiu	s1,s1,1
		  P0_PCIE_error_count++;
		     		  
	         prom_printf("Compare Error, No: Port0, Size: %d, Offset: %d, Content: 0x%X, Expected: 0x%X \n",
	                     size, i, READ_MEM8(RX1_BUFF_ADDR + i), content[i]);
		   
		   for (i2=1;i2<=4;i2++)
80009264:	1633fff8 	bne	s1,s3,80009248 <rtl8168_rx+0x104>
80009268:	26520001 	addiu	s2,s2,1

		   }
		   
		  
		   //prom_printf("\ncontent=%x\n",&content);
		   prom_printf("\n==================================\n");
8000926c:	3c118001 	lui	s1,0x8001
80009270:	0c0023a7 	jal	80008e9c <prom_printf>
80009274:	26245348 	addiu	a0,s1,21320
		   prom_printf("\nOK Tx(0x%x) content=%x\n",(0xa0420000+i),READ_MEM32(0xa0420000+i));
80009278:	3c05a042 	lui	a1,0xa042
8000927c:	02052821 	addu	a1,s0,a1
80009280:	8ca60000 	lw	a2,0(a1)
80009284:	3c048001 	lui	a0,0x8001
80009288:	0c0023a7 	jal	80008e9c <prom_printf>
8000928c:	24845370 	addiu	a0,a0,21360
		   prom_printf("\nFail Rx(0x%x) content=%x\n",(0xa0630000+i),READ_MEM32(0xa0630000+i));
80009290:	3c05a063 	lui	a1,0xa063
80009294:	02052821 	addu	a1,s0,a1
80009298:	8ca60000 	lw	a2,0(a1)
8000929c:	3c048001 	lui	a0,0x8001
800092a0:	0c0023a7 	jal	80008e9c <prom_printf>
800092a4:	2484538c 	addiu	a0,a0,21388
		   prom_printf("\n==================================\n");
800092a8:	0c0023a7 	jal	80008e9c <prom_printf>
800092ac:	26245348 	addiu	a0,s1,21320

		
		   prom_printf("\nCheck last 4 Bytes,Tx(0x%x) content=%x\n",(0xa0420000+i-4),READ_MEM32(0xa0420000+i-4));
800092b0:	3c05a041 	lui	a1,0xa041
800092b4:	34a5fffc 	ori	a1,a1,0xfffc
800092b8:	02052821 	addu	a1,s0,a1
800092bc:	8ca60000 	lw	a2,0(a1)
800092c0:	3c048001 	lui	a0,0x8001
800092c4:	0c0023a7 	jal	80008e9c <prom_printf>
800092c8:	248453a8 	addiu	a0,a0,21416
		   prom_printf("\nCheck last 4 Bytes,Rx(0x%x) content=%x\n",(0xa0630000+i-4),READ_MEM32(0xa0630000+i-4));
800092cc:	3c05a062 	lui	a1,0xa062
800092d0:	34a5fffc 	ori	a1,a1,0xfffc
800092d4:	02052821 	addu	a1,s0,a1
800092d8:	8ca60000 	lw	a2,0(a1)
800092dc:	3c048001 	lui	a0,0x8001
800092e0:	0c0023a7 	jal	80008e9c <prom_printf>
800092e4:	248453d4 	addiu	a0,a0,21460
		   
		   
		 //#if 1 //for 2 port
		 		 	
		 	return -1; // RX Error
800092e8:	0800251c 	j	80009470 <rtl8168_rx+0x32c>
800092ec:	2402ffff 	li	v0,-1
		 //dprintf("got Rx own bit \n");
		 
      // Check RX Packet Content
      int i2;
	   
      for (i = 0; i < size; i++)        
800092f0:	26100001 	addiu	s0,s0,1
800092f4:	0211102b 	sltu	v0,s0,s1
800092f8:	1440ffbb 	bnez	v0,800091e8 <rtl8168_rx+0xa4>
800092fc:	02051821 	addu	v1,s0,a1
         }
      }
   }
//-------------------------------------------------
  #if (TEST_8196_PCIE_P1)
    if( (portnum == 1) || (portnum == 2) )//PORT1
80009300:	2673ffff 	addiu	s3,s3,-1
80009304:	2e730002 	sltiu	s3,s3,2
80009308:	12600059 	beqz	s3,80009470 <rtl8168_rx+0x32c>
8000930c:	00001021 	move	v0,zero
				   break;
			    }
	      }		 	 
	    
	#else
		  while ((READ_MEM32(RX2_DESC_ADDR) & htonl(DescOwn)) != 0);
80009310:	3c03a063 	lui	v1,0xa063
80009314:	8c620000 	lw	v0,0(v1)
80009318:	30420080 	andi	v0,v0,0x80
8000931c:	1440fffd 	bnez	v0,80009314 <rtl8168_rx+0x1d0>
80009320:	00000000 	nop
#endif
       #endif

       int i3;
      // Check RX Packet Content
        for (i = 0; i < size; i++)        
80009324:	12200051 	beqz	s1,8000946c <rtl8168_rx+0x328>
80009328:	3c02a06a 	lui	v0,0xa06a
      {
      
         if (READ_MEM8(RX2_BUFF_ADDR + i) != content[i])
8000932c:	90430000 	lbu	v1,0(v0)
80009330:	306300ff 	andi	v1,v1,0xff
80009334:	92420000 	lbu	v0,0(s2)
		   prom_printf("\n================================================\n");

		   prom_printf("\nCheck last 4 Bytes,Tx(0x%x) content=%x\n",(0xa0820000+i-4),READ_MEM32(0xa0820000+i-4));
		   prom_printf("\nCheck last 4 Bytes,Rx(0x%x) content=%x\n",(0xa0a30000+i-4),READ_MEM32(0xa0a30000+i-4));
		   prom_printf("\n================================================\n");
		   return -1;
80009338:	00008021 	move	s0,zero
       int i3;
      // Check RX Packet Content
        for (i = 0; i < size; i++)        
      {
      
         if (READ_MEM8(RX2_BUFF_ADDR + i) != content[i])
8000933c:	10620047 	beq	v1,v0,8000945c <rtl8168_rx+0x318>
80009340:	3c05a06a 	lui	a1,0xa06a
80009344:	080024da 	j	80009368 <rtl8168_rx+0x224>
80009348:	3c03a06a 	lui	v1,0xa06a
8000934c:	90640000 	lbu	a0,0(v1)
80009350:	308400ff 	andi	a0,a0,0xff
80009354:	02501021 	addu	v0,s2,s0
80009358:	90420000 	lbu	v0,0(v0)
8000935c:	10820040 	beq	a0,v0,80009460 <rtl8168_rx+0x31c>
80009360:	26100001 	addiu	s0,s0,1
80009364:	2610ffff 	addiu	s0,s0,-1
         {
           #if DBG//JSW:DEBUG_PRINT
		   P1_PCIE_error_count++;	
		  
	         prom_printf("Compare Error, No: Port1, Size: %d, Offset: %d, Content: 0x%X, Expected: 0x%X\n",
	                     size, i, READ_MEM8(RX2_BUFF_ADDR + i), content[i]);
80009368:	90670000 	lbu	a3,0(v1)
         if (READ_MEM8(RX2_BUFF_ADDR + i) != content[i])
         {
           #if DBG//JSW:DEBUG_PRINT
		   P1_PCIE_error_count++;	
		  
	         prom_printf("Compare Error, No: Port1, Size: %d, Offset: %d, Content: 0x%X, Expected: 0x%X\n",
8000936c:	afa20010 	sw	v0,16(sp)
80009370:	3c048001 	lui	a0,0x8001
80009374:	24845400 	addiu	a0,a0,21504
80009378:	02202821 	move	a1,s1
8000937c:	02003021 	move	a2,s0
80009380:	0c0023a7 	jal	80008e9c <prom_printf>
80009384:	30e700ff 	andi	a3,a3,0xff
80009388:	3c13a06a 	lui	s3,0xa06a
8000938c:	36710001 	ori	s1,s3,0x1
80009390:	02118821 	addu	s1,s0,s1
80009394:	02509021 	addu	s2,s2,s0
}
//===============================================================================

 

int rtl8168_rx(unsigned char *content, unsigned int size, int portnum)
80009398:	36730005 	ori	s3,s3,0x5
8000939c:	02139821 	addu	s3,s0,s3
	         prom_printf("Compare Error, No: Port1, Size: %d, Offset: %d, Content: 0x%X, Expected: 0x%X\n",
	                     size, i, READ_MEM8(RX2_BUFF_ADDR + i), content[i]);
		   //prom_printf("PCIE Mac LoopBack Compare Error!!! \n");
		   for (i3=1;i3<=4;i3++)
		   {
		   	 prom_printf("\nOffset(%d),Content:%x,Expected:%x\n",(i+i3),READ_MEM8(RX2_BUFF_ADDR + i+i3),content[i+i3]);
800093a0:	3c145f96 	lui	s4,0x5f96
800093a4:	3c158001 	lui	s5,0x8001
800093a8:	26b55324 	addiu	s5,s5,21284
800093ac:	92260000 	lbu	a2,0(s1)
800093b0:	02a02021 	move	a0,s5
800093b4:	02342821 	addu	a1,s1,s4
800093b8:	30c600ff 	andi	a2,a2,0xff
800093bc:	0c0023a7 	jal	80008e9c <prom_printf>
800093c0:	92470001 	lbu	a3,1(s2)
800093c4:	26310001 	addiu	s1,s1,1
		   P1_PCIE_error_count++;	
		  
	         prom_printf("Compare Error, No: Port1, Size: %d, Offset: %d, Content: 0x%X, Expected: 0x%X\n",
	                     size, i, READ_MEM8(RX2_BUFF_ADDR + i), content[i]);
		   //prom_printf("PCIE Mac LoopBack Compare Error!!! \n");
		   for (i3=1;i3<=4;i3++)
800093c8:	1633fff8 	bne	s1,s3,800093ac <rtl8168_rx+0x268>
800093cc:	26520001 	addiu	s2,s2,1
		   }
		   		   
			  
  		   
		   //prom_printf("\ncontent=%x\n",&content);
		   prom_printf("\n================================================\n");
800093d0:	3c118001 	lui	s1,0x8001
800093d4:	0c0023a7 	jal	80008e9c <prom_printf>
800093d8:	26245450 	addiu	a0,s1,21584
		   prom_printf("\nOK Tx(0x%x) content=%x\n",(0xa0820000+i),READ_MEM32(0xa0820000+i));
800093dc:	3c05a082 	lui	a1,0xa082
800093e0:	02052821 	addu	a1,s0,a1
800093e4:	8ca60000 	lw	a2,0(a1)
800093e8:	3c048001 	lui	a0,0x8001
800093ec:	0c0023a7 	jal	80008e9c <prom_printf>
800093f0:	24845370 	addiu	a0,a0,21360
		   prom_printf("\nFail Rx(0x%x) content=%x\n",(0xa0a30000+i),READ_MEM32(0xa0a30000+i));
800093f4:	3c05a0a3 	lui	a1,0xa0a3
800093f8:	02052821 	addu	a1,s0,a1
800093fc:	8ca60000 	lw	a2,0(a1)
80009400:	3c048001 	lui	a0,0x8001
80009404:	0c0023a7 	jal	80008e9c <prom_printf>
80009408:	2484538c 	addiu	a0,a0,21388
		   prom_printf("\n================================================\n");
8000940c:	0c0023a7 	jal	80008e9c <prom_printf>
80009410:	26245450 	addiu	a0,s1,21584

		   prom_printf("\nCheck last 4 Bytes,Tx(0x%x) content=%x\n",(0xa0820000+i-4),READ_MEM32(0xa0820000+i-4));
80009414:	3c05a081 	lui	a1,0xa081
80009418:	34a5fffc 	ori	a1,a1,0xfffc
8000941c:	02052821 	addu	a1,s0,a1
80009420:	8ca60000 	lw	a2,0(a1)
80009424:	3c048001 	lui	a0,0x8001
80009428:	0c0023a7 	jal	80008e9c <prom_printf>
8000942c:	248453a8 	addiu	a0,a0,21416
		   prom_printf("\nCheck last 4 Bytes,Rx(0x%x) content=%x\n",(0xa0a30000+i-4),READ_MEM32(0xa0a30000+i-4));
80009430:	3c05a0a2 	lui	a1,0xa0a2
80009434:	34a5fffc 	ori	a1,a1,0xfffc
80009438:	02052821 	addu	a1,s0,a1
8000943c:	8ca60000 	lw	a2,0(a1)
80009440:	3c048001 	lui	a0,0x8001
80009444:	0c0023a7 	jal	80008e9c <prom_printf>
80009448:	248453d4 	addiu	a0,a0,21460
		   prom_printf("\n================================================\n");
8000944c:	0c0023a7 	jal	80008e9c <prom_printf>
80009450:	26245450 	addiu	a0,s1,21584
		   return -1;
80009454:	0800251c 	j	80009470 <rtl8168_rx+0x32c>
80009458:	2402ffff 	li	v0,-1
#endif
       #endif

       int i3;
      // Check RX Packet Content
        for (i = 0; i < size; i++)        
8000945c:	26100001 	addiu	s0,s0,1
80009460:	0211102b 	sltu	v0,s0,s1
80009464:	1440ffb9 	bnez	v0,8000934c <rtl8168_rx+0x208>
80009468:	02051821 	addu	v1,s0,a1
8000946c:	00001021 	move	v0,zero
      }
   }
 #endif

   return 0;
}
80009470:	8fbf0034 	lw	ra,52(sp)
80009474:	8fb50030 	lw	s5,48(sp)
80009478:	8fb4002c 	lw	s4,44(sp)
8000947c:	8fb30028 	lw	s3,40(sp)
80009480:	8fb20024 	lw	s2,36(sp)
80009484:	8fb10020 	lw	s1,32(sp)
80009488:	8fb0001c 	lw	s0,28(sp)
8000948c:	03e00008 	jr	ra
80009490:	27bd0038 	addiu	sp,sp,56

80009494 <EnIRQ>:
#define NULL 0
struct irqaction irq_PCIE = {PCIE_isr, (unsigned long)NULL, (unsigned long)PCIE_IRQ_NO,"PCIE", (void *)NULL, (struct irqaction *)NULL};   


void EnIRQ(int portnum, int enableirq)
{
80009494:	27bdffe8 	addiu	sp,sp,-24
80009498:	afbf0014 	sw	ra,20(sp)
	unsigned int addr;
	if(portnum==0)
8000949c:	3c02ba00 	lui	v0,0xba00
800094a0:	3c03b900 	lui	v1,0xb900
	{
		addr=PCIE2_EP_MEM;
	}

	
	if(enableirq)
800094a4:	10a00017 	beqz	a1,80009504 <EnIRQ+0x70>
800094a8:	0064100a 	movz	v0,v1,a0
	{

		WRITE_MEM16(addr + IntrMask, 0xffff);
800094ac:	2442003c 	addiu	v0,v0,60
800094b0:	2403ffff 	li	v1,-1
800094b4:	a4430000 	sh	v1,0(v0)

		
		int irraddr=IRR_REG+PCIE_IRR_NO*4;		
	  	REG32(irraddr) = (REG32(irraddr) &~(0x0f<<PCIE_IRR_OFFSET)) | (4<<PCIE_IRR_OFFSET);	
800094b8:	3c02b800 	lui	v0,0xb800
800094bc:	34423010 	ori	v0,v0,0x3010
800094c0:	8c440000 	lw	a0,0(v0)
800094c4:	3c03ff0f 	lui	v1,0xff0f
800094c8:	3463ffff 	ori	v1,v1,0xffff
800094cc:	00831824 	and	v1,a0,v1
800094d0:	3c040040 	lui	a0,0x40
800094d4:	00641825 	or	v1,v1,a0
800094d8:	ac430000 	sw	v1,0(v0)
		request_IRQ(PCIE_IRQ_NO, &irq_PCIE, NULL); 
800094dc:	24040015 	li	a0,21
800094e0:	3c058001 	lui	a1,0x8001
800094e4:	24a57600 	addiu	a1,a1,30208
800094e8:	0c000274 	jal	800009d0 <request_IRQ>
800094ec:	00003021 	move	a2,zero
		dprintf("Enable PCIE ISR \n");
800094f0:	3c048001 	lui	a0,0x8001
800094f4:	0c002325 	jal	80008c94 <dprintf>
800094f8:	24845484 	addiu	a0,a0,21636
		WRITE_MEM16(addr + IntrMask, 0);
		free_IRQ(PCIE_IRQ_NO);
		dprintf("Disable PCIE ISR\r\n");

	}
}
800094fc:	08002549 	j	80009524 <EnIRQ+0x90>
80009500:	8fbf0014 	lw	ra,20(sp)
		request_IRQ(PCIE_IRQ_NO, &irq_PCIE, NULL); 
		dprintf("Enable PCIE ISR \n");
	}
	else
	{
		WRITE_MEM16(addr + IntrMask, 0);
80009504:	2442003c 	addiu	v0,v0,60
80009508:	a4400000 	sh	zero,0(v0)
		free_IRQ(PCIE_IRQ_NO);
8000950c:	0c000289 	jal	80000a24 <free_IRQ>
80009510:	24040015 	li	a0,21
		dprintf("Disable PCIE ISR\r\n");
80009514:	3c048001 	lui	a0,0x8001
80009518:	0c002325 	jal	80008c94 <dprintf>
8000951c:	24845498 	addiu	a0,a0,21656

	}
}
80009520:	8fbf0014 	lw	ra,20(sp)
80009524:	03e00008 	jr	ra
80009528:	27bd0018 	addiu	sp,sp,24

8000952c <rtl8168_init>:

	
}
//===============================================================================
void rtl8168_init(int portnum, int en_loopback)
{
8000952c:	27bdffe0 	addiu	sp,sp,-32
80009530:	afbf001c 	sw	ra,28(sp)
80009534:	afb10018 	sw	s1,24(sp)
80009538:	afb00014 	sw	s0,20(sp)
8000953c:	00808021 	move	s0,a0
   int i;

   if( (portnum == 0) || (portnum == 2) )
80009540:	10800004 	beqz	a0,80009554 <rtl8168_init+0x28>
80009544:	00a08821 	move	s1,a1
80009548:	24020002 	li	v0,2
8000954c:	14820088 	bne	a0,v0,80009770 <rtl8168_init+0x244>
80009550:	00000000 	nop
   {
      // 0. Set PCIE RootComplex
      WRITE_MEM32(PCIE1_RC_CFG + 0x04, 0x00100007);
80009554:	3c04b8b0 	lui	a0,0xb8b0
80009558:	34820004 	ori	v0,a0,0x4
8000955c:	3c030010 	lui	v1,0x10
80009560:	34630007 	ori	v1,v1,0x7
80009564:	ac430000 	sw	v1,0(v0)
      WRITE_MEM8(PCIE1_RC_CFG + 0x78, (READ_MEM8(PCIE1_EP_CFG + 0x78) & (~0xE0)) | MAX_PAYLOAD_SIZE_128B);  // Set MAX_PAYLOAD_SIZE to 128B,default
80009568:	3c02b8b1 	lui	v0,0xb8b1
8000956c:	34430078 	ori	v1,v0,0x78
80009570:	90650000 	lbu	a1,0(v1)
80009574:	30a5001f 	andi	a1,a1,0x1f
80009578:	34840078 	ori	a0,a0,0x78
8000957c:	a0850000 	sb	a1,0(a0)
      //WRITE_MEM8(PCIE1_RC_CFG + 0x78, (READ_MEM8(PCIE1_EP_CFG + 0x78) & (~0xE0)) | MAX_PAYLOAD_SIZE_256B);  // Set MAX_PAYLOAD_SIZE to 256B

      // 1. Set 8111C EP
      WRITE_MEM32(PCIE1_EP_CFG + 0x04, 0x00180007);  // Mem, IO Enable
80009580:	34440004 	ori	a0,v0,0x4
80009584:	3c050018 	lui	a1,0x18
80009588:	34a50007 	ori	a1,a1,0x7
8000958c:	ac850000 	sw	a1,0(a0)
      WRITE_MEM32(PCIE1_EP_CFG + 0x10, (PCIE1_EP_IO | 0x00000001) & 0x1FFFFFFF);  // Set BAR
80009590:	34440010 	ori	a0,v0,0x10
80009594:	3c0518c0 	lui	a1,0x18c0
80009598:	34a50001 	ori	a1,a1,0x1
8000959c:	ac850000 	sw	a1,0(a0)
      WRITE_MEM32(PCIE1_EP_CFG + 0x18, (PCIE1_EP_MEM | 0x00000004) & 0x1FFFFFFF);  // Set BAR
800095a0:	34440018 	ori	a0,v0,0x18
800095a4:	3c051900 	lui	a1,0x1900
800095a8:	34a50004 	ori	a1,a1,0x4
800095ac:	ac850000 	sw	a1,0(a0)

      WRITE_MEM8(PCIE1_EP_CFG + 0x78, (READ_MEM8(PCIE1_EP_CFG + 0x78) & (~0xE0)) | MAX_PAYLOAD_SIZE_128B);  // Set MAX_PAYLOAD_SIZE to 128B
800095b0:	90640000 	lbu	a0,0(v1)
800095b4:	3084001f 	andi	a0,a0,0x1f
800095b8:	a0640000 	sb	a0,0(v1)
     // WRITE_MEM8(PCIE1_EP_CFG + 0x79, (READ_MEM8(PCIE1_EP_CFG + 0x79) & (~0x70)) | MAX_READ_REQSIZE_128B);  // Set MAX_REQ_SIZE to 128B 
      WRITE_MEM8(PCIE1_EP_CFG + 0x79, (READ_MEM8(PCIE1_EP_CFG + 0x79) & (~0x70)) | MAX_READ_REQSIZE_256B);  // Set MAX_REQ_SIZE to 256B,default
800095bc:	34420079 	ori	v0,v0,0x79
800095c0:	90430000 	lbu	v1,0(v0)
800095c4:	2404ff8f 	li	a0,-113
800095c8:	00831824 	and	v1,a0,v1
800095cc:	34630010 	ori	v1,v1,0x10
800095d0:	306300ff 	andi	v1,v1,0xff
800095d4:	a0430000 	sb	v1,0(v0)

      // 2. Reset EP
      WRITE_MEM8(PCIE1_EP_MEM + ChipCmd, 0x10);
800095d8:	24030010 	li	v1,16
800095dc:	3c02b900 	lui	v0,0xb900
800095e0:	34420037 	ori	v0,v0,0x37
800095e4:	a0430000 	sb	v1,0(v0)

      // 3. Set MAC Loopback & Disable TX CRC & TxDMA Size
      if(en_loopback)      WRITE_MEM32(PCIE1_EP_MEM + TxConfig, (READ_MEM32(PCIE1_EP_MEM + TxConfig) & (~0x700)) | TxDMA1KB | TxMACLoopBack | (1 << 16));  //wei del
800095e8:	1220000c 	beqz	s1,8000961c <rtl8168_init+0xf0>
800095ec:	3c02b900 	lui	v0,0xb900
800095f0:	34420040 	ori	v0,v0,0x40
800095f4:	8c440000 	lw	a0,0(v0)
800095f8:	3c03fffc 	lui	v1,0xfffc
800095fc:	3463f8ff 	ori	v1,v1,0xf8ff
80009600:	00832024 	and	a0,a0,v1
80009604:	3c030003 	lui	v1,0x3
80009608:	34630600 	ori	v1,v1,0x600
8000960c:	00831825 	or	v1,a0,v1
80009610:	ac430000 	sw	v1,0(v0)
     else 				     WRITE_MEM32(PCIE1_EP_MEM + TxConfig, (READ_MEM32(PCIE1_EP_MEM + TxConfig) & (~0x700)) | TxDMA1KB |  (0 << 16));
	  
      // Enable Runt & Error Accept of RX Config
      WRITE_MEM32(PCIE1_EP_MEM + RxConfig, (READ_MEM32(PCIE1_EP_MEM + RxConfig) & (~0x700)) | RxDMA512B | AcceptErr | AcceptRunt | (1 << 7));
80009614:	0800258e 	j	80009638 <rtl8168_init+0x10c>
80009618:	3c02b900 	lui	v0,0xb900
      // 2. Reset EP
      WRITE_MEM8(PCIE1_EP_MEM + ChipCmd, 0x10);

      // 3. Set MAC Loopback & Disable TX CRC & TxDMA Size
      if(en_loopback)      WRITE_MEM32(PCIE1_EP_MEM + TxConfig, (READ_MEM32(PCIE1_EP_MEM + TxConfig) & (~0x700)) | TxDMA1KB | TxMACLoopBack | (1 << 16));  //wei del
     else 				     WRITE_MEM32(PCIE1_EP_MEM + TxConfig, (READ_MEM32(PCIE1_EP_MEM + TxConfig) & (~0x700)) | TxDMA1KB |  (0 << 16));
8000961c:	34420040 	ori	v0,v0,0x40
80009620:	8c440000 	lw	a0,0(v0)
80009624:	2403f8ff 	li	v1,-1793
80009628:	00831824 	and	v1,a0,v1
8000962c:	34630600 	ori	v1,v1,0x600
80009630:	ac430000 	sw	v1,0(v0)
	  
      // Enable Runt & Error Accept of RX Config
      WRITE_MEM32(PCIE1_EP_MEM + RxConfig, (READ_MEM32(PCIE1_EP_MEM + RxConfig) & (~0x700)) | RxDMA512B | AcceptErr | AcceptRunt | (1 << 7));
80009634:	3c02b900 	lui	v0,0xb900
80009638:	34430044 	ori	v1,v0,0x44
8000963c:	8c650000 	lw	a1,0(v1)
80009640:	2404f84f 	li	a0,-1969
80009644:	00a42024 	and	a0,a1,a0
80009648:	348405b0 	ori	a0,a0,0x5b0
8000964c:	ac640000 	sw	a0,0(v1)

      // 4. Set TX/RX Desciptor Starting Address
      WRITE_MEM32(PCIE1_EP_MEM + TxDescStartAddrLow, PADDR(TX1_DESC_ADDR));
80009650:	34430020 	ori	v1,v0,0x20
80009654:	3c040052 	lui	a0,0x52
80009658:	ac640000 	sw	a0,0(v1)
      WRITE_MEM32(PCIE1_EP_MEM + TxDescStartAddrHigh, 0);
8000965c:	34430024 	ori	v1,v0,0x24
80009660:	ac600000 	sw	zero,0(v1)
      WRITE_MEM32(PCIE1_EP_MEM + RxDescAddrLow, PADDR(RX1_DESC_ADDR));
80009664:	344300e4 	ori	v1,v0,0xe4
80009668:	3c040053 	lui	a0,0x53
8000966c:	ac640000 	sw	a0,0(v1)
      WRITE_MEM32(PCIE1_EP_MEM + RxDescAddrHigh, 0);
80009670:	344200e8 	ori	v0,v0,0xe8
80009674:	ac400000 	sw	zero,0(v0)
80009678:	3c02a052 	lui	v0,0xa052
static __inline void *memset(void *s, int c, int size)
{
   unsigned char *__s = (unsigned char *) s;
   unsigned char __c = (unsigned char) c;

   while (size--)
8000967c:	3c03a052 	lui	v1,0xa052
80009680:	34630400 	ori	v1,v1,0x400
      *__s++ = __c;
80009684:	a0400000 	sb	zero,0(v0)
80009688:	24420001 	addiu	v0,v0,1
static __inline void *memset(void *s, int c, int size)
{
   unsigned char *__s = (unsigned char *) s;
   unsigned char __c = (unsigned char) c;

   while (size--)
8000968c:	1443fffd 	bne	v0,v1,80009684 <rtl8168_init+0x158>
80009690:	00000000 	nop
      memset((unsigned char *) TX1_DESC_ADDR, 0x0, NUM_TX_DESC * TX1_DESC_SIZE);

      for (i = 0; i < NUM_TX_DESC; i++)
      {
         if(i == (NUM_TX_DESC - 1))
            WRITE_MEM32(TX1_DESC_ADDR + TX1_DESC_SIZE * i, htonl(PADDR(RingEnd)));
80009694:	080025ae 	j	800096b8 <rtl8168_init+0x18c>
80009698:	00001021 	move	v0,zero
      // 5. Set TX Ring - Descriptor Assigned to CPU
      memset((unsigned char *) TX1_DESC_ADDR, 0x0, NUM_TX_DESC * TX1_DESC_SIZE);

      for (i = 0; i < NUM_TX_DESC; i++)
      {
         if(i == (NUM_TX_DESC - 1))
8000969c:	14430008 	bne	v0,v1,800096c0 <rtl8168_init+0x194>
800096a0:	00000000 	nop
            WRITE_MEM32(TX1_DESC_ADDR + TX1_DESC_SIZE * i, htonl(PADDR(RingEnd)));
800096a4:	3c02a052 	lui	v0,0xa052
800096a8:	344203f0 	ori	v0,v0,0x3f0
800096ac:	ac400000 	sw	zero,0(v0)
800096b0:	080025b4 	j	800096d0 <rtl8168_init+0x1a4>
800096b4:	3c02a053 	lui	v0,0xa053
      WRITE_MEM32(PCIE1_EP_MEM + RxDescAddrHigh, 0);

      // 5. Set TX Ring - Descriptor Assigned to CPU
      memset((unsigned char *) TX1_DESC_ADDR, 0x0, NUM_TX_DESC * TX1_DESC_SIZE);

      for (i = 0; i < NUM_TX_DESC; i++)
800096b8:	24040040 	li	a0,64
      {
         if(i == (NUM_TX_DESC - 1))
800096bc:	2403003f 	li	v1,63
      WRITE_MEM32(PCIE1_EP_MEM + RxDescAddrHigh, 0);

      // 5. Set TX Ring - Descriptor Assigned to CPU
      memset((unsigned char *) TX1_DESC_ADDR, 0x0, NUM_TX_DESC * TX1_DESC_SIZE);

      for (i = 0; i < NUM_TX_DESC; i++)
800096c0:	24420001 	addiu	v0,v0,1
800096c4:	1444fff5 	bne	v0,a0,8000969c <rtl8168_init+0x170>
800096c8:	00000000 	nop
800096cc:	3c02a053 	lui	v0,0xa053
static __inline void *memset(void *s, int c, int size)
{
   unsigned char *__s = (unsigned char *) s;
   unsigned char __c = (unsigned char) c;

   while (size--)
800096d0:	3c03a053 	lui	v1,0xa053
800096d4:	34630400 	ori	v1,v1,0x400
      *__s++ = __c;
800096d8:	a0400000 	sb	zero,0(v0)
800096dc:	24420001 	addiu	v0,v0,1
static __inline void *memset(void *s, int c, int size)
{
   unsigned char *__s = (unsigned char *) s;
   unsigned char __c = (unsigned char) c;

   while (size--)
800096e0:	1443fffd 	bne	v0,v1,800096d8 <rtl8168_init+0x1ac>
800096e4:	00000000 	nop
      for (i = 0; i < NUM_RX_DESC; i++)
      {
         if(i == (NUM_RX_DESC - 1))
            WRITE_MEM32(RX1_DESC_ADDR + RX1_DESC_SIZE * i, htonl(DescOwn | RingEnd | RX1_BUFF_SIZE));
         else
            WRITE_MEM32(RX1_DESC_ADDR + RX1_DESC_SIZE * i, htonl(DescOwn | RX1_BUFF_SIZE));
800096e8:	080025d4 	j	80009750 <rtl8168_init+0x224>
800096ec:	3c030010 	lui	v1,0x10
static __inline void *memset(void *s, int c, int size)
{
   unsigned char *__s = (unsigned char *) s;
   unsigned char __c = (unsigned char) c;

   while (size--)
800096f0:	24420010 	addiu	v0,v0,16
      // 6. Set RX Ring - Descriptor Assigned to NIC
      memset((unsigned char *) RX1_DESC_ADDR, 0x0, NUM_RX_DESC * RX1_DESC_SIZE);

      for (i = 0; i < NUM_RX_DESC; i++)
      {
         if(i == (NUM_RX_DESC - 1))
800096f4:	144300ab 	bne	v0,v1,800099a4 <rtl8168_init+0x478>
800096f8:	00000000 	nop
            WRITE_MEM32(RX1_DESC_ADDR + RX1_DESC_SIZE * i, htonl(DescOwn | RingEnd | RX1_BUFF_SIZE));
800096fc:	3c02a053 	lui	v0,0xa053
80009700:	344303f0 	ori	v1,v0,0x3f0
80009704:	3c040010 	lui	a0,0x10
80009708:	348400c0 	ori	a0,a0,0xc0
8000970c:	ac640000 	sw	a0,0(v1)
         else
            WRITE_MEM32(RX1_DESC_ADDR + RX1_DESC_SIZE * i, htonl(DescOwn | RX1_BUFF_SIZE));
      }

      tx1_desc_addr = (unsigned char *) TX1_DESC_ADDR;
80009710:	3c04a052 	lui	a0,0xa052
80009714:	3c038002 	lui	v1,0x8002
80009718:	ac642e88 	sw	a0,11912(v1)
      tx1_buff_addr = (unsigned char *) TX1_BUFF_ADDR;
8000971c:	3c04a058 	lui	a0,0xa058
80009720:	3c038002 	lui	v1,0x8002
80009724:	ac642e8c 	sw	a0,11916(v1)
      rx1_desc_addr = (unsigned char *) RX1_DESC_ADDR;
80009728:	3c038002 	lui	v1,0x8002
8000972c:	ac622e90 	sw	v0,11920(v1)
      rx1_buff_addr = (unsigned char *) RX1_BUFF_ADDR;
80009730:	3c03a05a 	lui	v1,0xa05a
80009734:	3c028002 	lui	v0,0x8002
80009738:	ac432ea4 	sw	v1,11940(v0)
	  
#if USING_INTERRUPT
	EnIRQ(0, 1);
8000973c:	00002021 	move	a0,zero
80009740:	0c002525 	jal	80009494 <EnIRQ>
80009744:	24050001 	li	a1,1

   //else  
	//------------------------------------------------------------------	
   
   #if (TEST_8196_PCIE_P1)
   if ( (portnum == 1) || (portnum== 2) )//PORT1
80009748:	080025dd 	j	80009774 <rtl8168_init+0x248>
8000974c:	2610ffff 	addiu	s0,s0,-1
      for (i = 0; i < NUM_RX_DESC; i++)
      {
         if(i == (NUM_RX_DESC - 1))
            WRITE_MEM32(RX1_DESC_ADDR + RX1_DESC_SIZE * i, htonl(DescOwn | RingEnd | RX1_BUFF_SIZE));
         else
            WRITE_MEM32(RX1_DESC_ADDR + RX1_DESC_SIZE * i, htonl(DescOwn | RX1_BUFF_SIZE));
80009750:	34630080 	ori	v1,v1,0x80
80009754:	3c02a053 	lui	v0,0xa053
80009758:	ac430000 	sw	v1,0(v0)
      // 6. Set RX Ring - Descriptor Assigned to NIC
      memset((unsigned char *) RX1_DESC_ADDR, 0x0, NUM_RX_DESC * RX1_DESC_SIZE);

      for (i = 0; i < NUM_RX_DESC; i++)
      {
         if(i == (NUM_RX_DESC - 1))
8000975c:	3c03a053 	lui	v1,0xa053
80009760:	346303f0 	ori	v1,v1,0x3f0
            WRITE_MEM32(RX1_DESC_ADDR + RX1_DESC_SIZE * i, htonl(DescOwn | RingEnd | RX1_BUFF_SIZE));
         else
            WRITE_MEM32(RX1_DESC_ADDR + RX1_DESC_SIZE * i, htonl(DescOwn | RX1_BUFF_SIZE));
80009764:	3c040010 	lui	a0,0x10
80009768:	080025bc 	j	800096f0 <rtl8168_init+0x1c4>
8000976c:	34840080 	ori	a0,a0,0x80

   //else  
	//------------------------------------------------------------------	
   
   #if (TEST_8196_PCIE_P1)
   if ( (portnum == 1) || (portnum== 2) )//PORT1
80009770:	2610ffff 	addiu	s0,s0,-1
80009774:	2e100002 	sltiu	s0,s0,2
80009778:	1200008e 	beqz	s0,800099b4 <rtl8168_init+0x488>
8000977c:	8fbf001c 	lw	ra,28(sp)
   {
      // 0. Set PCIE RootComplex
      WRITE_MEM32(PCIE2_RC_CFG + 0x04, 0x00100007);
80009780:	3c04b8b2 	lui	a0,0xb8b2
80009784:	34820004 	ori	v0,a0,0x4
80009788:	3c030010 	lui	v1,0x10
8000978c:	34630007 	ori	v1,v1,0x7
80009790:	ac430000 	sw	v1,0(v0)
      WRITE_MEM8(PCIE2_RC_CFG + 0x78, (READ_MEM8(PCIE2_EP_CFG + 0x78) & (~0xE0)) | MAX_PAYLOAD_SIZE_128B);  // Set MAX_PAYLOAD_SIZE to 128B
80009794:	3c02b8b3 	lui	v0,0xb8b3
80009798:	34430078 	ori	v1,v0,0x78
8000979c:	90650000 	lbu	a1,0(v1)
800097a0:	30a5001f 	andi	a1,a1,0x1f
800097a4:	34840078 	ori	a0,a0,0x78
800097a8:	a0850000 	sb	a1,0(a0)

      // 1. Set 8111C EP
      WRITE_MEM32(PCIE2_EP_CFG + 0x04, 0x00180007);  // Mem, IO Enable
800097ac:	34440004 	ori	a0,v0,0x4
800097b0:	3c050018 	lui	a1,0x18
800097b4:	34a50007 	ori	a1,a1,0x7
800097b8:	ac850000 	sw	a1,0(a0)
      WRITE_MEM32(PCIE2_EP_CFG + 0x10, (PCIE2_EP_IO | 0x00000001) & 0x1FFFFFFF);  // Set BAR
800097bc:	34440010 	ori	a0,v0,0x10
800097c0:	3c0518e0 	lui	a1,0x18e0
800097c4:	34a50001 	ori	a1,a1,0x1
800097c8:	ac850000 	sw	a1,0(a0)
      WRITE_MEM32(PCIE2_EP_CFG + 0x18, (PCIE2_EP_MEM | 0x00000004) & 0x1FFFFFFF);  // Set BAR
800097cc:	34440018 	ori	a0,v0,0x18
800097d0:	3c051a00 	lui	a1,0x1a00
800097d4:	34a50004 	ori	a1,a1,0x4
800097d8:	ac850000 	sw	a1,0(a0)

      WRITE_MEM8(PCIE2_EP_CFG + 0x78, (READ_MEM8(PCIE2_EP_CFG + 0x78) & (~0xE0)) | MAX_PAYLOAD_SIZE_128B);  // Set MAX_PAYLOAD_SIZE to 128B
800097dc:	90640000 	lbu	a0,0(v1)
800097e0:	3084001f 	andi	a0,a0,0x1f
800097e4:	a0640000 	sb	a0,0(v1)
      WRITE_MEM8(PCIE2_EP_CFG + 0x79, (READ_MEM8(PCIE2_EP_CFG + 0x79) & (~0x70)) | MAX_READ_REQSIZE_256B);  // Set MAX_REQ_SIZE to 128B
800097e8:	34420079 	ori	v0,v0,0x79
800097ec:	90430000 	lbu	v1,0(v0)
800097f0:	2404ff8f 	li	a0,-113
800097f4:	00831824 	and	v1,a0,v1
800097f8:	34630010 	ori	v1,v1,0x10
800097fc:	306300ff 	andi	v1,v1,0xff
80009800:	a0430000 	sb	v1,0(v0)

      // 2. Reset EP
      WRITE_MEM8(PCIE2_EP_MEM + ChipCmd, 0x10);
80009804:	24030010 	li	v1,16
80009808:	3c02ba00 	lui	v0,0xba00
8000980c:	34420037 	ori	v0,v0,0x37
80009810:	a0430000 	sb	v1,0(v0)

      // 3. Set MAC Loopback & Disable TX CRC & TxDMA Size
     if(en_loopback)      	WRITE_MEM32(PCIE2_EP_MEM + TxConfig, (READ_MEM32(PCIE2_EP_MEM + TxConfig) & (~0x700)) | TxDMA1KB | TxMACLoopBack | (1 << 16));
80009814:	1220000c 	beqz	s1,80009848 <rtl8168_init+0x31c>
80009818:	3c02ba00 	lui	v0,0xba00
8000981c:	34420040 	ori	v0,v0,0x40
80009820:	8c440000 	lw	a0,0(v0)
80009824:	3c03fffc 	lui	v1,0xfffc
80009828:	3463f8ff 	ori	v1,v1,0xf8ff
8000982c:	00832024 	and	a0,a0,v1
80009830:	3c030003 	lui	v1,0x3
80009834:	34630600 	ori	v1,v1,0x600
80009838:	00831825 	or	v1,a0,v1
8000983c:	ac430000 	sw	v1,0(v0)
	else  				WRITE_MEM32(PCIE2_EP_MEM + TxConfig, (READ_MEM32(PCIE2_EP_MEM + TxConfig) & (~0x700)) | TxDMA1KB |  (1 << 16));
	
      // Enable Runt & Error Accept of RX Config
      WRITE_MEM32(PCIE2_EP_MEM + RxConfig, (READ_MEM32(PCIE2_EP_MEM + RxConfig) & (~0x700)) | RxDMA512B | AcceptErr | AcceptRunt | (1 << 7));
80009840:	0800261c 	j	80009870 <rtl8168_init+0x344>
80009844:	3c02ba00 	lui	v0,0xba00
      // 2. Reset EP
      WRITE_MEM8(PCIE2_EP_MEM + ChipCmd, 0x10);

      // 3. Set MAC Loopback & Disable TX CRC & TxDMA Size
     if(en_loopback)      	WRITE_MEM32(PCIE2_EP_MEM + TxConfig, (READ_MEM32(PCIE2_EP_MEM + TxConfig) & (~0x700)) | TxDMA1KB | TxMACLoopBack | (1 << 16));
	else  				WRITE_MEM32(PCIE2_EP_MEM + TxConfig, (READ_MEM32(PCIE2_EP_MEM + TxConfig) & (~0x700)) | TxDMA1KB |  (1 << 16));
80009848:	34420040 	ori	v0,v0,0x40
8000984c:	8c440000 	lw	a0,0(v0)
80009850:	3c03fffe 	lui	v1,0xfffe
80009854:	3463f8ff 	ori	v1,v1,0xf8ff
80009858:	00832024 	and	a0,a0,v1
8000985c:	3c030001 	lui	v1,0x1
80009860:	34630600 	ori	v1,v1,0x600
80009864:	00831825 	or	v1,a0,v1
80009868:	ac430000 	sw	v1,0(v0)
	
      // Enable Runt & Error Accept of RX Config
      WRITE_MEM32(PCIE2_EP_MEM + RxConfig, (READ_MEM32(PCIE2_EP_MEM + RxConfig) & (~0x700)) | RxDMA512B | AcceptErr | AcceptRunt | (1 << 7));
8000986c:	3c02ba00 	lui	v0,0xba00
80009870:	34430044 	ori	v1,v0,0x44
80009874:	8c650000 	lw	a1,0(v1)
80009878:	2404f84f 	li	a0,-1969
8000987c:	00a42024 	and	a0,a1,a0
80009880:	348405b0 	ori	a0,a0,0x5b0
80009884:	ac640000 	sw	a0,0(v1)

      // 4. Set TX/RX Desciptor Starting Address
      WRITE_MEM32(PCIE2_EP_MEM + TxDescStartAddrLow, PADDR(TX2_DESC_ADDR));
80009888:	34430020 	ori	v1,v0,0x20
8000988c:	3c040062 	lui	a0,0x62
80009890:	ac640000 	sw	a0,0(v1)
      WRITE_MEM32(PCIE2_EP_MEM + TxDescStartAddrHigh, 0);
80009894:	34430024 	ori	v1,v0,0x24
80009898:	ac600000 	sw	zero,0(v1)
      WRITE_MEM32(PCIE2_EP_MEM + RxDescAddrLow, PADDR(RX2_DESC_ADDR));
8000989c:	344300e4 	ori	v1,v0,0xe4
800098a0:	3c040063 	lui	a0,0x63
800098a4:	ac640000 	sw	a0,0(v1)
      WRITE_MEM32(PCIE2_EP_MEM + RxDescAddrHigh, 0);
800098a8:	344200e8 	ori	v0,v0,0xe8
800098ac:	ac400000 	sw	zero,0(v0)
800098b0:	3c02a062 	lui	v0,0xa062
static __inline void *memset(void *s, int c, int size)
{
   unsigned char *__s = (unsigned char *) s;
   unsigned char __c = (unsigned char) c;

   while (size--)
800098b4:	3c03a062 	lui	v1,0xa062
800098b8:	34630400 	ori	v1,v1,0x400
      *__s++ = __c;
800098bc:	a0400000 	sb	zero,0(v0)
800098c0:	24420001 	addiu	v0,v0,1
static __inline void *memset(void *s, int c, int size)
{
   unsigned char *__s = (unsigned char *) s;
   unsigned char __c = (unsigned char) c;

   while (size--)
800098c4:	1443fffd 	bne	v0,v1,800098bc <rtl8168_init+0x390>
800098c8:	00000000 	nop
      memset((unsigned char *) TX2_DESC_ADDR, 0x0, NUM_TX_DESC * TX2_DESC_SIZE);

      for (i = 0; i < NUM_TX_DESC; i++)
      {
         if(i == (NUM_TX_DESC - 1))
            WRITE_MEM32(TX2_DESC_ADDR + TX2_DESC_SIZE * i, htonl(PADDR(RingEnd)));
800098cc:	0800263c 	j	800098f0 <rtl8168_init+0x3c4>
800098d0:	00001021 	move	v0,zero
      // 5. Set TX Ring - Descriptor Assigned to CPU
      memset((unsigned char *) TX2_DESC_ADDR, 0x0, NUM_TX_DESC * TX2_DESC_SIZE);

      for (i = 0; i < NUM_TX_DESC; i++)
      {
         if(i == (NUM_TX_DESC - 1))
800098d4:	14430008 	bne	v0,v1,800098f8 <rtl8168_init+0x3cc>
800098d8:	00000000 	nop
            WRITE_MEM32(TX2_DESC_ADDR + TX2_DESC_SIZE * i, htonl(PADDR(RingEnd)));
800098dc:	3c02a062 	lui	v0,0xa062
800098e0:	344203f0 	ori	v0,v0,0x3f0
800098e4:	ac400000 	sw	zero,0(v0)
800098e8:	08002642 	j	80009908 <rtl8168_init+0x3dc>
800098ec:	3c02a063 	lui	v0,0xa063
      WRITE_MEM32(PCIE2_EP_MEM + RxDescAddrHigh, 0);

      // 5. Set TX Ring - Descriptor Assigned to CPU
      memset((unsigned char *) TX2_DESC_ADDR, 0x0, NUM_TX_DESC * TX2_DESC_SIZE);

      for (i = 0; i < NUM_TX_DESC; i++)
800098f0:	24040040 	li	a0,64
      {
         if(i == (NUM_TX_DESC - 1))
800098f4:	2403003f 	li	v1,63
      WRITE_MEM32(PCIE2_EP_MEM + RxDescAddrHigh, 0);

      // 5. Set TX Ring - Descriptor Assigned to CPU
      memset((unsigned char *) TX2_DESC_ADDR, 0x0, NUM_TX_DESC * TX2_DESC_SIZE);

      for (i = 0; i < NUM_TX_DESC; i++)
800098f8:	24420001 	addiu	v0,v0,1
800098fc:	1444fff5 	bne	v0,a0,800098d4 <rtl8168_init+0x3a8>
80009900:	00000000 	nop
80009904:	3c02a063 	lui	v0,0xa063
static __inline void *memset(void *s, int c, int size)
{
   unsigned char *__s = (unsigned char *) s;
   unsigned char __c = (unsigned char) c;

   while (size--)
80009908:	3c03a063 	lui	v1,0xa063
8000990c:	34630400 	ori	v1,v1,0x400
      *__s++ = __c;
80009910:	a0400000 	sb	zero,0(v0)
80009914:	24420001 	addiu	v0,v0,1
static __inline void *memset(void *s, int c, int size)
{
   unsigned char *__s = (unsigned char *) s;
   unsigned char __c = (unsigned char) c;

   while (size--)
80009918:	1443fffd 	bne	v0,v1,80009910 <rtl8168_init+0x3e4>
8000991c:	00000000 	nop
      for (i = 0; i < NUM_RX_DESC; i++)
      {
         if(i == (NUM_RX_DESC - 1))
            WRITE_MEM32(RX2_DESC_ADDR + RX2_DESC_SIZE * i, htonl(DescOwn | RingEnd | RX2_BUFF_SIZE));
         else
            WRITE_MEM32(RX2_DESC_ADDR + RX2_DESC_SIZE * i, htonl(DescOwn | RX2_BUFF_SIZE));
80009920:	0800265e 	j	80009978 <rtl8168_init+0x44c>
80009924:	3c030010 	lui	v1,0x10
static __inline void *memset(void *s, int c, int size)
{
   unsigned char *__s = (unsigned char *) s;
   unsigned char __c = (unsigned char) c;

   while (size--)
80009928:	24420010 	addiu	v0,v0,16
      // 6. Set RX Ring - Descriptor Assigned to NIC
      memset((unsigned char *) RX2_DESC_ADDR, 0x0, NUM_RX_DESC * RX2_DESC_SIZE);

      for (i = 0; i < NUM_RX_DESC; i++)
      {
         if(i == (NUM_RX_DESC - 1))
8000992c:	1443001a 	bne	v0,v1,80009998 <rtl8168_init+0x46c>
80009930:	00000000 	nop
            WRITE_MEM32(RX2_DESC_ADDR + RX2_DESC_SIZE * i, htonl(DescOwn | RingEnd | RX2_BUFF_SIZE));
80009934:	3c02a063 	lui	v0,0xa063
80009938:	344303f0 	ori	v1,v0,0x3f0
8000993c:	3c040010 	lui	a0,0x10
80009940:	348400c0 	ori	a0,a0,0xc0
80009944:	ac640000 	sw	a0,0(v1)
         else
            WRITE_MEM32(RX2_DESC_ADDR + RX2_DESC_SIZE * i, htonl(DescOwn | RX2_BUFF_SIZE));
      }

      tx2_desc_addr = (unsigned char *) TX2_DESC_ADDR;
80009948:	3c04a062 	lui	a0,0xa062
8000994c:	3c038002 	lui	v1,0x8002
80009950:	ac642e9c 	sw	a0,11932(v1)
      tx2_buff_addr = (unsigned char *) TX2_BUFF_ADDR;
80009954:	3c04a068 	lui	a0,0xa068
80009958:	3c038002 	lui	v1,0x8002
8000995c:	ac642e98 	sw	a0,11928(v1)
      rx2_desc_addr = (unsigned char *) RX2_DESC_ADDR;
80009960:	3c038002 	lui	v1,0x8002
80009964:	ac622e94 	sw	v0,11924(v1)
      rx2_buff_addr = (unsigned char *) RX2_BUFF_ADDR;
80009968:	3c03a06a 	lui	v1,0xa06a
8000996c:	3c028002 	lui	v0,0x8002
80009970:	0800266c 	j	800099b0 <rtl8168_init+0x484>
80009974:	ac432ea0 	sw	v1,11936(v0)
      for (i = 0; i < NUM_RX_DESC; i++)
      {
         if(i == (NUM_RX_DESC - 1))
            WRITE_MEM32(RX2_DESC_ADDR + RX2_DESC_SIZE * i, htonl(DescOwn | RingEnd | RX2_BUFF_SIZE));
         else
            WRITE_MEM32(RX2_DESC_ADDR + RX2_DESC_SIZE * i, htonl(DescOwn | RX2_BUFF_SIZE));
80009978:	34630080 	ori	v1,v1,0x80
8000997c:	3c02a063 	lui	v0,0xa063
80009980:	ac430000 	sw	v1,0(v0)
      // 6. Set RX Ring - Descriptor Assigned to NIC
      memset((unsigned char *) RX2_DESC_ADDR, 0x0, NUM_RX_DESC * RX2_DESC_SIZE);

      for (i = 0; i < NUM_RX_DESC; i++)
      {
         if(i == (NUM_RX_DESC - 1))
80009984:	3c03a063 	lui	v1,0xa063
80009988:	346303f0 	ori	v1,v1,0x3f0
            WRITE_MEM32(RX2_DESC_ADDR + RX2_DESC_SIZE * i, htonl(DescOwn | RingEnd | RX2_BUFF_SIZE));
         else
            WRITE_MEM32(RX2_DESC_ADDR + RX2_DESC_SIZE * i, htonl(DescOwn | RX2_BUFF_SIZE));
8000998c:	3c040010 	lui	a0,0x10
80009990:	0800264a 	j	80009928 <rtl8168_init+0x3fc>
80009994:	34840080 	ori	a0,a0,0x80
80009998:	ac440000 	sw	a0,0(v0)
static __inline void *memset(void *s, int c, int size)
{
   unsigned char *__s = (unsigned char *) s;
   unsigned char __c = (unsigned char) c;

   while (size--)
8000999c:	0800264b 	j	8000992c <rtl8168_init+0x400>
800099a0:	24420010 	addiu	v0,v0,16
      for (i = 0; i < NUM_RX_DESC; i++)
      {
         if(i == (NUM_RX_DESC - 1))
            WRITE_MEM32(RX1_DESC_ADDR + RX1_DESC_SIZE * i, htonl(DescOwn | RingEnd | RX1_BUFF_SIZE));
         else
            WRITE_MEM32(RX1_DESC_ADDR + RX1_DESC_SIZE * i, htonl(DescOwn | RX1_BUFF_SIZE));
800099a4:	ac440000 	sw	a0,0(v0)
static __inline void *memset(void *s, int c, int size)
{
   unsigned char *__s = (unsigned char *) s;
   unsigned char __c = (unsigned char) c;

   while (size--)
800099a8:	080025bd 	j	800096f4 <rtl8168_init+0x1c8>
800099ac:	24420010 	addiu	v0,v0,16
      rx2_desc_addr = (unsigned char *) RX2_DESC_ADDR;
      rx2_buff_addr = (unsigned char *) RX2_BUFF_ADDR;
   }
  #endif
	//------------------------------------------------------------------------   
}
800099b0:	8fbf001c 	lw	ra,28(sp)
800099b4:	8fb10018 	lw	s1,24(sp)
800099b8:	8fb00014 	lw	s0,20(sp)
800099bc:	03e00008 	jr	ra
800099c0:	27bd0020 	addiu	sp,sp,32

800099c4 <example>:
#endif

//===============================================================================
//unsigned short example();
unsigned short example(int portnum, int quietmode)     // 0:port 0, 1:port 1,  2:port 0 and port 1, rc=0, fail, rc=1 pass
{
800099c4:	27bdffd8 	addiu	sp,sp,-40
800099c8:	afbf0024 	sw	ra,36(sp)
800099cc:	afb40020 	sw	s4,32(sp)
800099d0:	afb3001c 	sw	s3,28(sp)
800099d4:	afb20018 	sw	s2,24(sp)
800099d8:	afb10014 	sw	s1,20(sp)
800099dc:	afb00010 	sw	s0,16(sp)
800099e0:	00808821 	move	s1,a0
   /* Get Random Data Length */
   #if PCIE_Test_With_8102E
          length1 = rand2() & 0x5ff; // limit to1535 ,OK for 8102E FT2
  	   //length1 = rand2() & 0x700; // limit to 1972 ,OK with 8102E
   #else
        length1 = rand2() & 0xfff; // limit to 64~4095
800099e4:	0c00390f 	jal	8000e43c <rand2>
800099e8:	00a09821 	move	s3,a1
800099ec:	30420fff 	andi	v0,v0,0xfff
        //length1 = 1024 ; // fixed to 4092 ,error
	 //dprintf("Len=%x \n", length1);
   #endif   
   length1 = (length1 < 64) ? 64 : length1; 
800099f0:	28500040 	slti	s0,v0,64
800099f4:	24030040 	li	v1,64
800099f8:	0050180a 	movz	v1,v0,s0
//-----------------------------------------------

   /* Set MAC */
  if ( (portnum == 0) || (portnum== 2) )//PORT1
800099fc:	12200004 	beqz	s1,80009a10 <example+0x4c>
80009a00:	00608021 	move	s0,v1
80009a04:	24020002 	li	v0,2
80009a08:	16220013 	bne	s1,v0,80009a58 <example+0x94>
80009a0c:	2632ffff 	addiu	s2,s1,-1
  {

   rx1_str[0] = 0x00;
80009a10:	3c02a058 	lui	v0,0xa058
80009a14:	a0400000 	sb	zero,0(v0)
   rx1_str[1] = 0x11;
80009a18:	34430001 	ori	v1,v0,0x1
80009a1c:	24040011 	li	a0,17
80009a20:	a0640000 	sb	a0,0(v1)
   rx1_str[2] = 0x22;
80009a24:	34430002 	ori	v1,v0,0x2
80009a28:	24040022 	li	a0,34
80009a2c:	a0640000 	sb	a0,0(v1)
   rx1_str[3] = 0x33;
80009a30:	34430003 	ori	v1,v0,0x3
80009a34:	24040033 	li	a0,51
80009a38:	a0640000 	sb	a0,0(v1)
   rx1_str[4] = 0x44;
80009a3c:	34430004 	ori	v1,v0,0x4
80009a40:	24040044 	li	a0,68
80009a44:	a0640000 	sb	a0,0(v1)
   rx1_str[5] = 0x55;
80009a48:	34420005 	ori	v0,v0,0x5
80009a4c:	24030055 	li	v1,85
80009a50:	a0430000 	sb	v1,0(v0)

   
  }
	
    #if (TEST_8196_PCIE_P1)
	  if ( (portnum == 1) || (portnum== 2) )//PORT1
80009a54:	2632ffff 	addiu	s2,s1,-1
80009a58:	2e430002 	sltiu	v1,s2,2
80009a5c:	10600013 	beqz	v1,80009aac <example+0xe8>
80009a60:	00001021 	move	v0,zero
	   {
	   	   //prom_printf("\nTest PCIE P1 \n");
		   rx2_str[0] = 0x00;
80009a64:	3c02a068 	lui	v0,0xa068
80009a68:	a0400000 	sb	zero,0(v0)
		   rx2_str[1] = 0x11;
80009a6c:	34430001 	ori	v1,v0,0x1
80009a70:	24040011 	li	a0,17
80009a74:	a0640000 	sb	a0,0(v1)
		   rx2_str[2] = 0x22;
80009a78:	34430002 	ori	v1,v0,0x2
80009a7c:	24040022 	li	a0,34
80009a80:	a0640000 	sb	a0,0(v1)
		   rx2_str[3] = 0x33;
80009a84:	34430003 	ori	v1,v0,0x3
80009a88:	24040033 	li	a0,51
80009a8c:	a0640000 	sb	a0,0(v1)
		   rx2_str[4] = 0x44;
80009a90:	34430004 	ori	v1,v0,0x4
80009a94:	24040044 	li	a0,68
80009a98:	a0640000 	sb	a0,0(v1)
		   rx2_str[5] = 0x55;
80009a9c:	34420005 	ori	v0,v0,0x5
80009aa0:	24030055 	li	v1,85
80009aa4:	a0430000 	sb	v1,0(v0)
80009aa8:	00001021 	move	v0,zero
   
   /* Set Sequential Data */   
   for (i = 6; i < length1; i++)  //wei add
	
   {
            rx1_str[i] = (i - 6) & 0xFF; //default
80009aac:	3c06a058 	lui	a2,0xa058
80009ab0:	34c60006 	ori	a2,a2,0x6
        //   rx1_str[i] = ((i - 6) & 0xFF)|0x10;//JSW 20090214: test for PCIE_MacLoopBack ,bit4 always 1

		 
	 #if (TEST_8196_PCIE_P1)
	  if ( (portnum == 1) || (portnum== 2) )//PORT1
80009ab4:	2e450002 	sltiu	a1,s2,2
	   {
     		 rx2_str[i] = (i - 6) & 0xFF;	
80009ab8:	3c07a068 	lui	a3,0xa068
80009abc:	34e70006 	ori	a3,a3,0x6
		   rx2_str[0] = 0x00;
		   rx2_str[1] = 0x11;
		   rx2_str[2] = 0x22;
		   rx2_str[3] = 0x33;
		   rx2_str[4] = 0x44;
		   rx2_str[5] = 0x55;
80009ac0:	304300ff 	andi	v1,v0,0xff
   
   /* Set Sequential Data */   
   for (i = 6; i < length1; i++)  //wei add
	
   {
            rx1_str[i] = (i - 6) & 0xFF; //default
80009ac4:	00462021 	addu	a0,v0,a2
        //   rx1_str[i] = ((i - 6) & 0xFF)|0x10;//JSW 20090214: test for PCIE_MacLoopBack ,bit4 always 1

		 
	 #if (TEST_8196_PCIE_P1)
	  if ( (portnum == 1) || (portnum== 2) )//PORT1
80009ac8:	10a00003 	beqz	a1,80009ad8 <example+0x114>
80009acc:	a0830000 	sb	v1,0(a0)
	   {
     		 rx2_str[i] = (i - 6) & 0xFF;	
80009ad0:	00472021 	addu	a0,v0,a3
80009ad4:	a0830000 	sb	v1,0(a0)
80009ad8:	24420001 	addiu	v0,v0,1
//-----------------------------------------------


   
   /* Set Sequential Data */   
   for (i = 6; i < length1; i++)  //wei add
80009adc:	24430006 	addiu	v1,v0,6
80009ae0:	0070182a 	slt	v1,v1,s0
80009ae4:	1460fff6 	bnez	v1,80009ac0 <example+0xfc>
80009ae8:	00000000 	nop
   /*
    * READ ID Test:
    * Read 8111C Vendor/Device ID
    */
 
   if ( (portnum == 0) || (portnum== 2) )
80009aec:	12200005 	beqz	s1,80009b04 <example+0x140>
80009af0:	3c02b8b1 	lui	v0,0xb8b1
80009af4:	24020002 	li	v0,2
80009af8:	1622002b 	bne	s1,v0,80009ba8 <example+0x1e4>
80009afc:	2e420002 	sltiu	v0,s2,2
   {
	  if ((READ_MEM32(PCIE1_EP_CFG) == 0x816810EC) |(READ_MEM32(PCIE1_EP_CFG) == 0x819210EC)|\
80009b00:	3c02b8b1 	lui	v0,0xb8b1
80009b04:	8c430000 	lw	v1,0(v0)
80009b08:	8c440000 	lw	a0,0(v0)
		(READ_MEM32(PCIE1_EP_CFG) == 0x813610EC) )//  //
80009b0c:	8c450000 	lw	a1,0(v0)
    * Read 8111C Vendor/Device ID
    */
 
   if ( (portnum == 0) || (portnum== 2) )
   {
	  if ((READ_MEM32(PCIE1_EP_CFG) == 0x816810EC) |(READ_MEM32(PCIE1_EP_CFG) == 0x819210EC)|\
80009b10:	3c028168 	lui	v0,0x8168
80009b14:	344210ec 	ori	v0,v0,0x10ec
80009b18:	10620009 	beq	v1,v0,80009b40 <example+0x17c>
80009b1c:	3c148001 	lui	s4,0x8001
80009b20:	3c028192 	lui	v0,0x8192
80009b24:	344210ec 	ori	v0,v0,0x10ec
80009b28:	10820005 	beq	a0,v0,80009b40 <example+0x17c>
80009b2c:	00000000 	nop
80009b30:	3c028136 	lui	v0,0x8136
80009b34:	344210ec 	ori	v0,v0,0x10ec
80009b38:	14a2000f 	bne	a1,v0,80009b78 <example+0x1b4>
80009b3c:	00000000 	nop
		(READ_MEM32(PCIE1_EP_CFG) == 0x813610EC) )//  //
	   {
	      // Successful 	     
	       #if DBG
		      dprintf("\n======================================\n");
80009b40:	0c002325 	jal	80008c94 <dprintf>
80009b44:	268454ac 	addiu	a0,s4,21676
		      dprintf("\nRead 8111/8192/8102 ID PASS !");	      
80009b48:	3c048001 	lui	a0,0x8001
80009b4c:	0c002325 	jal	80008c94 <dprintf>
80009b50:	248454d8 	addiu	a0,a0,21720
		      dprintf("\n=>PASS,PCIE P0's ID (0xb8b10000)=%x\n",READ_MEM32(PCIE1_EP_CFG)); 
80009b54:	3c02b8b1 	lui	v0,0xb8b1
80009b58:	8c450000 	lw	a1,0(v0)
80009b5c:	3c048001 	lui	a0,0x8001
80009b60:	0c002325 	jal	80008c94 <dprintf>
80009b64:	248454f8 	addiu	a0,a0,21752
		      dprintf("\n======================================\n");
80009b68:	0c002325 	jal	80008c94 <dprintf>
80009b6c:	268454ac 	addiu	a0,s4,21676
   }
//---------------------------------------------------------------------------------------------

 //Auto-test PCIE Port1 by recognize Bond_Option	
 #if (TEST_8196_PCIE_P1)	
	if ( (portnum == 1) || (portnum== 2) )//PORT1
80009b70:	080026ea 	j	80009ba8 <example+0x1e4>
80009b74:	2e420002 	sltiu	v0,s2,2
	   {

	      // Failed 
	     
	      #if DBG
		      dprintf("\nRead 8111/8192/8102 ID Fail ! \n");				
80009b78:	3c048001 	lui	a0,0x8001
80009b7c:	0c002325 	jal	80008c94 <dprintf>
80009b80:	24845520 	addiu	a0,a0,21792
	      #endif
		  
		  if(quietmode==0)
80009b84:	1660006b 	bnez	s3,80009d34 <example+0x370>
80009b88:	00001021 	move	v0,zero
		 dprintf("\n=>Fail,PCIE P0's ID (0xb8b10000)=%x\n",READ_MEM32(PCIE1_EP_CFG)); 	
80009b8c:	3c02b8b1 	lui	v0,0xb8b1
80009b90:	8c450000 	lw	a1,0(v0)
80009b94:	3c048001 	lui	a0,0x8001
80009b98:	0c002325 	jal	80008c94 <dprintf>
80009b9c:	24845544 	addiu	a0,a0,21828
80009ba0:	0800274d 	j	80009d34 <example+0x370>
80009ba4:	00001021 	move	v0,zero
   }
//---------------------------------------------------------------------------------------------

 //Auto-test PCIE Port1 by recognize Bond_Option	
 #if (TEST_8196_PCIE_P1)	
	if ( (portnum == 1) || (portnum== 2) )//PORT1
80009ba8:	10400028 	beqz	v0,80009c4c <example+0x288>
80009bac:	02202021 	move	a0,s1
	 {
	   if ((READ_MEM32(PCIE2_EP_CFG) == 0x816810EC) |(READ_MEM32(PCIE2_EP_CFG) == 0x819210EC)|\
80009bb0:	3c02b8b3 	lui	v0,0xb8b3
80009bb4:	8c430000 	lw	v1,0(v0)
80009bb8:	8c440000 	lw	a0,0(v0)
			(READ_MEM32(PCIE2_EP_CFG) == 0x813610EC) )//  //
80009bbc:	8c450000 	lw	a1,0(v0)

 //Auto-test PCIE Port1 by recognize Bond_Option	
 #if (TEST_8196_PCIE_P1)	
	if ( (portnum == 1) || (portnum== 2) )//PORT1
	 {
	   if ((READ_MEM32(PCIE2_EP_CFG) == 0x816810EC) |(READ_MEM32(PCIE2_EP_CFG) == 0x819210EC)|\
80009bc0:	3c028168 	lui	v0,0x8168
80009bc4:	344210ec 	ori	v0,v0,0x10ec
80009bc8:	10620008 	beq	v1,v0,80009bec <example+0x228>
80009bcc:	3c148001 	lui	s4,0x8001
80009bd0:	3c028192 	lui	v0,0x8192
80009bd4:	344210ec 	ori	v0,v0,0x10ec
80009bd8:	10820004 	beq	a0,v0,80009bec <example+0x228>
80009bdc:	3c028136 	lui	v0,0x8136
80009be0:	344210ec 	ori	v0,v0,0x10ec
80009be4:	14a2000f 	bne	a1,v0,80009c24 <example+0x260>
80009be8:	00000000 	nop
			(READ_MEM32(PCIE2_EP_CFG) == 0x813610EC) )//  //
	   {
	      // Successful 

	       #if DBG
		      dprintf("\n======================================\n");
80009bec:	0c002325 	jal	80008c94 <dprintf>
80009bf0:	268454ac 	addiu	a0,s4,21676
		      dprintf("\nRead 8111/8192/8102 ID PASS !");		
80009bf4:	3c048001 	lui	a0,0x8001
80009bf8:	0c002325 	jal	80008c94 <dprintf>
80009bfc:	248454d8 	addiu	a0,a0,21720
		      dprintf("\n=>PASS,PCIE P1's ID (0xb8b30000)=%x\n",READ_MEM32(PCIE2_EP_CFG)); 	
80009c00:	3c02b8b3 	lui	v0,0xb8b3
80009c04:	8c450000 	lw	a1,0(v0)
80009c08:	3c048001 	lui	a0,0x8001
80009c0c:	0c002325 	jal	80008c94 <dprintf>
80009c10:	2484556c 	addiu	a0,a0,21868
		      dprintf("\n======================================\n");
80009c14:	0c002325 	jal	80008c94 <dprintf>
80009c18:	268454ac 	addiu	a0,s4,21676
	    * MAC Loopback Test:
	    * TX 1 Packet and then RX compare
	    */

	  /*"2"=test P1 and P0  , "1"=test P1 , "0"= test P0  */
	   rtl8168_init(portnum, en_loopback ); 
80009c1c:	08002713 	j	80009c4c <example+0x288>
80009c20:	02202021 	move	a0,s1
	   else
	   {
	      // Failed 
	      
	       #if DBG
		      dprintf("\nRead 8111/8192/8102 ID Fail !\n");		     
80009c24:	3c048001 	lui	a0,0x8001
80009c28:	0c002325 	jal	80008c94 <dprintf>
80009c2c:	24845594 	addiu	a0,a0,21908
		      dprintf("\n=>Fail,PCIE P1's ID (0xb8b30000)=%x\n",READ_MEM32(PCIE2_EP_CFG)); 	
80009c30:	3c02b8b3 	lui	v0,0xb8b3
80009c34:	8c450000 	lw	a1,0(v0)
80009c38:	3c048001 	lui	a0,0x8001
80009c3c:	0c002325 	jal	80008c94 <dprintf>
80009c40:	248455b4 	addiu	a0,a0,21940
			
	      #endif
			return 0;
80009c44:	0800274d 	j	80009d34 <example+0x370>
80009c48:	00001021 	move	v0,zero
	    * MAC Loopback Test:
	    * TX 1 Packet and then RX compare
	    */

	  /*"2"=test P1 and P0  , "1"=test P1 , "0"= test P0  */
	   rtl8168_init(portnum, en_loopback ); 
80009c4c:	0c00254b 	jal	8000952c <rtl8168_init>
80009c50:	24050001 	li	a1,1
      for (i = 0; i < 64; i++)  //wei add
            rx1_str[i] = tx_buffer[i]; 
            
#endif    	  
	   //-------------------------------------------------------------------	
	  if ( (portnum == 0) || (portnum== 2) )
80009c54:	12200003 	beqz	s1,80009c64 <example+0x2a0>
80009c58:	24020002 	li	v0,2
80009c5c:	16220006 	bne	s1,v0,80009c78 <example+0x2b4>
80009c60:	2e420002 	sltiu	v0,s2,2
	  {
	  	 rtl8168_tx(rx1_str, length1, portnum);
80009c64:	3c04a058 	lui	a0,0xa058
80009c68:	02002821 	move	a1,s0
80009c6c:	0c0023b4 	jal	80008ed0 <rtl8168_tx>
80009c70:	02203021 	move	a2,s1
	  }
	   //-------------------------------------------------------------------
	    #if (TEST_8196_PCIE_P1)
		if ( (portnum == 1) || (portnum== 2) )
80009c74:	2e420002 	sltiu	v0,s2,2
80009c78:	10400004 	beqz	v0,80009c8c <example+0x2c8>
80009c7c:	3c04a068 	lui	a0,0xa068
	   	  {
	 	  	rtl8168_tx(rx2_str, length1, portnum);
80009c80:	02002821 	move	a1,s0
80009c84:	0c0023b4 	jal	80008ed0 <rtl8168_tx>
80009c88:	02203021 	move	a2,s1
	   	  }
	   #endif
	   //-------------------------------------------------------------------
	   rtl8168_tx_trigger(portnum);
80009c8c:	0c0023f3 	jal	80008fcc <rtl8168_tx_trigger>
80009c90:	02202021 	move	a0,s1
	   //-------------------------------------------------------------------
	  if ( (portnum == 0) || (portnum== 2) )
80009c94:	12200003 	beqz	s1,80009ca4 <example+0x2e0>
80009c98:	24020002 	li	v0,2
80009c9c:	16220011 	bne	s1,v0,80009ce4 <example+0x320>
80009ca0:	00000000 	nop
	   {
		   if (rtl8168_rx(rx1_str, length1, portnum) == 0)   //"0"==compare OK,"-1"=fail
80009ca4:	3c04a058 	lui	a0,0xa058
80009ca8:	02002821 	move	a1,s0
80009cac:	0c002451 	jal	80009144 <rtl8168_rx>
80009cb0:	02203021 	move	a2,s1
80009cb4:	14400006 	bnez	v0,80009cd0 <example+0x30c>
80009cb8:	00000000 	nop
		   {		      
			// if(quietmode==0)
			  dprintf("PCIE_P0 => PASS !\n");		
80009cbc:	3c048001 	lui	a0,0x8001
80009cc0:	0c002325 	jal	80008c94 <dprintf>
80009cc4:	248455dc 	addiu	a0,a0,21980
				return 0;
		   }
	   }	
	   //-------------------------------------------------------------------
	    #if (TEST_8196_PCIE_P1)		   	  
  		 if ( (portnum == 1) || (portnum== 2) )
80009cc8:	0800273a 	j	80009ce8 <example+0x324>
80009ccc:	2e520002 	sltiu	s2,s2,2
			  dprintf("PCIE_P0 => PASS !\n");		
		   }
		   else
		   {		      
			 //if(quietmode==0)			      
    			      dprintf("PCIE_P0 => Fail ! \n");			
80009cd0:	3c048001 	lui	a0,0x8001
80009cd4:	0c002325 	jal	80008c94 <dprintf>
80009cd8:	248455f0 	addiu	a0,a0,22000

				return 0;
80009cdc:	0800274d 	j	80009d34 <example+0x370>
80009ce0:	00001021 	move	v0,zero
		   }
	   }	
	   //-------------------------------------------------------------------
	    #if (TEST_8196_PCIE_P1)		   	  
  		 if ( (portnum == 1) || (portnum== 2) )
80009ce4:	2e520002 	sltiu	s2,s2,2
80009ce8:	12400012 	beqz	s2,80009d34 <example+0x370>
80009cec:	24020001 	li	v0,1
	   	  {
			  if (rtl8168_rx(rx2_str, length1, portnum) == 0)   //"0"==compare OK,"-1"=fail
80009cf0:	3c04a068 	lui	a0,0xa068
80009cf4:	02002821 	move	a1,s0
80009cf8:	0c002451 	jal	80009144 <rtl8168_rx>
80009cfc:	02203021 	move	a2,s1
80009d00:	14400007 	bnez	v0,80009d20 <example+0x35c>
80009d04:	3c048001 	lui	a0,0x8001
			   {		
			 	if(quietmode==0)			   
80009d08:	16600009 	bnez	s3,80009d30 <example+0x36c>
80009d0c:	3c048001 	lui	a0,0x8001
				 	dprintf("PCIE_P1 => PASS !\n");				
80009d10:	0c002325 	jal	80008c94 <dprintf>
80009d14:	24845604 	addiu	a0,a0,22020
80009d18:	0800274d 	j	80009d34 <example+0x370>
80009d1c:	24020001 	li	v0,1
			   }
			   else
			   { 
			   	//if(quietmode==0)
					dprintf("PCIE_P1 => Fail !\n");					
80009d20:	0c002325 	jal	80008c94 <dprintf>
80009d24:	24845618 	addiu	a0,a0,22040
					return 0;
80009d28:	0800274d 	j	80009d34 <example+0x370>
80009d2c:	00001021 	move	v0,zero
80009d30:	24020001 	li	v0,1

		  return 1;
	

	
}
80009d34:	8fbf0024 	lw	ra,36(sp)
80009d38:	8fb40020 	lw	s4,32(sp)
80009d3c:	8fb3001c 	lw	s3,28(sp)
80009d40:	8fb20018 	lw	s2,24(sp)
80009d44:	8fb10014 	lw	s1,20(sp)
80009d48:	8fb00010 	lw	s0,16(sp)
80009d4c:	03e00008 	jr	ra
80009d50:	27bd0028 	addiu	sp,sp,40
	...

80009d60 <CmdCore1Wakeup>:
  		#define PATT_SLEEP  0x3333		
  		#define PATT_READY  0x5555

	//Let Core 1 wakeup
	#define GIC_WAKEUP_IRQ 43
	REG32(GIC_BASE_ADDR+0x2000+GIC_WAKEUP_IRQ*0x20)=2;  //map2vpe
80009d60:	3c02bbdc 	lui	v0,0xbbdc
80009d64:	34432560 	ori	v1,v0,0x2560
80009d68:	24040002 	li	a0,2
80009d6c:	ac640000 	sw	a0,0(v1)
	REG32(GIC_BASE_ADDR+0x184)=0x800;  //trg edge type 
80009d70:	34430184 	ori	v1,v0,0x184
80009d74:	24040800 	li	a0,2048
80009d78:	ac640000 	sw	a0,0(v1)
		
	REG32(GIC_BASE_ADDR+0x280)=0x80000000 | GIC_WAKEUP_IRQ;  //sw int
80009d7c:	34420280 	ori	v0,v0,0x280
80009d80:	3c048000 	lui	a0,0x8000
80009d84:	3484002b 	ori	a0,a0,0x2b
80009d88:	ac440000 	sw	a0,0(v0)
//	delay_ms(10);
	REG32(GIC_BASE_ADDR+0x280)=0x00000000 | GIC_WAKEUP_IRQ;	
80009d8c:	2404002b 	li	a0,43
80009d90:	ac440000 	sw	a0,0(v0)
	REG32(GIC_BASE_ADDR+0x184)=0x0;  //trg edge type 
80009d94:	ac600000 	sw	zero,0(v1)
80009d98:	24020063 	li	v0,99
#if 1
	int i=100;
	while(i--)
	{
		if(REG32(POLLING_REG)!=PATT_SLEEP)
80009d9c:	3c05b800 	lui	a1,0xb800
80009da0:	34a5006c 	ori	a1,a1,0x6c
80009da4:	24043333 	li	a0,13107
80009da8:	8ca30000 	lw	v1,0(a1)
80009dac:	14640005 	bne	v1,a0,80009dc4 <CmdCore1Wakeup+0x64>
80009db0:	00000000 	nop
//	delay_ms(10);
	REG32(GIC_BASE_ADDR+0x280)=0x00000000 | GIC_WAKEUP_IRQ;	
	REG32(GIC_BASE_ADDR+0x184)=0x0;  //trg edge type 
#if 1
	int i=100;
	while(i--)
80009db4:	10400003 	beqz	v0,80009dc4 <CmdCore1Wakeup+0x64>
80009db8:	00000000 	nop
80009dbc:	0800276a 	j	80009da8 <CmdCore1Wakeup+0x48>
80009dc0:	2442ffff 	addiu	v0,v0,-1
#endif

#ifdef _verbose
	printf("Core 1 cannot Wakeup, ret=%x\n", REG32(POLLING_REG));
#endif
}
80009dc4:	03e00008 	jr	ra
80009dc8:	00000000 	nop

80009dcc <SPEED_isr>:
}
//==============================================================


static void SPEED_isr(void)
{
80009dcc:	27bdffe0 	addiu	sp,sp,-32
80009dd0:	afbf001c 	sw	ra,28(sp)
80009dd4:	afb10018 	sw	s1,24(sp)
80009dd8:	afb00014 	sw	s0,20(sp)
	unsigned int isr=REG32(GISR_REG);
80009ddc:	3c02b800 	lui	v0,0xb800
80009de0:	34433004 	ori	v1,v0,0x3004
80009de4:	8c700000 	lw	s0,0(v1)
	unsigned int cpu_status=REG32(SYS_INT_STATUS);
80009de8:	34420004 	ori	v0,v0,0x4
80009dec:	8c510000 	lw	s1,0(v0)
	
	dprintf("=>CPU Wake-up interrupt happen! GISR=%08x \n", isr);
80009df0:	3c048001 	lui	a0,0x8001
80009df4:	24845634 	addiu	a0,a0,22068
80009df8:	0c002325 	jal	80008c94 <dprintf>
80009dfc:	02002821 	move	a1,s0

	if( (isr & (1<<27))==0)   //check isr==1
80009e00:	7e0206c0 	ext	v0,s0,0x1b,0x1
80009e04:	14400008 	bnez	v0,80009e28 <SPEED_isr+0x5c>
80009e08:	32220002 	andi	v0,s1,0x2
	{	dprintf("Check Fail, GISR=%x bit %d is not 1\n", isr, 27);
80009e0c:	3c048001 	lui	a0,0x8001
80009e10:	24845660 	addiu	a0,a0,22112
80009e14:	02002821 	move	a1,s0
80009e18:	0c002325 	jal	80008c94 <dprintf>
80009e1c:	2406001b 	li	a2,27
80009e20:	08002788 	j	80009e20 <SPEED_isr+0x54>
80009e24:	00000000 	nop
		while(1) ;
	}

	if((cpu_status & (1<<1))==0)  //check source==1
80009e28:	14400008 	bnez	v0,80009e4c <SPEED_isr+0x80>
80009e2c:	24030002 	li	v1,2
	{	dprintf("Fail, Source=%x bit %d is not 1 \n", cpu_status, 1);
80009e30:	3c048001 	lui	a0,0x8001
80009e34:	24845688 	addiu	a0,a0,22152
80009e38:	02202821 	move	a1,s1
80009e3c:	0c002325 	jal	80008c94 <dprintf>
80009e40:	24060001 	li	a2,1
80009e44:	08002791 	j	80009e44 <SPEED_isr+0x78>
80009e48:	00000000 	nop
		while(1) ;
	}
		
	REG32(SYS_INT_STATUS)=(1<<1);  //enable cpu wakeup interrupt mask
80009e4c:	3c02b800 	lui	v0,0xb800
80009e50:	34420004 	ori	v0,v0,0x4
80009e54:	ac430000 	sw	v1,0(v0)
//	REG32(GISR_REG)=1<<SPEED_IRQ_NO;	//write to clear, but cannot clear


//	REG32(GIMR_REG)= REG32(GIMR_REG) & ~(1<<SPEED_IRQ_NO);	//so, disable interrupt		
}
80009e58:	8fbf001c 	lw	ra,28(sp)
80009e5c:	8fb10018 	lw	s1,24(sp)
80009e60:	8fb00014 	lw	s0,20(sp)
80009e64:	03e00008 	jr	ra
80009e68:	27bd0020 	addiu	sp,sp,32

80009e6c <SettingM2xClk>:
extern unsigned long glexra_clock;

//---------------------------------------------------------------------------

int SettingM2xClk(int clk_sel)
{
80009e6c:	27bdffe8 	addiu	sp,sp,-24
80009e70:	afbf0014 	sw	ra,20(sp)
	int	tmp=REG32(SYS_HW_STRAP) & ~(CK_M2X_FREQ_SEL);
80009e74:	3c02b800 	lui	v0,0xb800
80009e78:	34430008 	ori	v1,v0,0x8
80009e7c:	8c660000 	lw	a2,0(v1)
	
		#if 1  //lock bus			
			REG32(SYS_LX_CTRL) |= (1<<2) ;	  //lock bus arb2
80009e80:	34420014 	ori	v0,v0,0x14
80009e84:	8c430000 	lw	v1,0(v0)
80009e88:	34630004 	ori	v1,v1,0x4
80009e8c:	ac430000 	sw	v1,0(v0)
			while( (REG32(SYS_BIST_DONE)&(1<<0))==0)  ; //wait bit to 1, is mean lock ok	
80009e90:	3c05b800 	lui	a1,0xb800
80009e94:	34a50020 	ori	a1,a1,0x20
80009e98:	8ca30000 	lw	v1,0(a1)
80009e9c:	30630001 	andi	v1,v1,0x1
80009ea0:	1060fffd 	beqz	v1,80009e98 <SettingM2xClk+0x2c>
80009ea4:	3c02b800 	lui	v0,0xb800

			REG32(SYS_LX_CTRL) |= (1<<3) ;	  //lock bus arb4
80009ea8:	34420014 	ori	v0,v0,0x14
80009eac:	8c430000 	lw	v1,0(v0)
80009eb0:	34630008 	ori	v1,v1,0x8
80009eb4:	ac430000 	sw	v1,0(v0)
			while( (REG32(SYS_BIST_DONE)&(1<<1))==0)  ; //wait bit to 1, is mean lock ok		
80009eb8:	3c05b800 	lui	a1,0xb800
80009ebc:	34a50020 	ori	a1,a1,0x20
80009ec0:	8ca30000 	lw	v1,0(a1)
80009ec4:	30630002 	andi	v1,v1,0x2
80009ec8:	1060fffd 	beqz	v1,80009ec0 <SettingM2xClk+0x54>
80009ecc:	3c02b800 	lui	v0,0xb800

			REG32(SYS_LX_CTRL) |= (1<<4) ;	  //lock bus arb6
80009ed0:	34420014 	ori	v0,v0,0x14
80009ed4:	8c430000 	lw	v1,0(v0)
80009ed8:	34630010 	ori	v1,v1,0x10
80009edc:	ac430000 	sw	v1,0(v0)
			while( (REG32(SYS_BIST_DONE)&(1<<2))==0)  ; //wait bit to 1, is mean lock ok		
80009ee0:	3c05b800 	lui	a1,0xb800
80009ee4:	34a50020 	ori	a1,a1,0x20
80009ee8:	8ca30000 	lw	v1,0(a1)
80009eec:	30630004 	andi	v1,v1,0x4
80009ef0:	1060fffd 	beqz	v1,80009ee8 <SettingM2xClk+0x7c>
80009ef4:	00041280 	sll	v0,a0,0xa

			//add check transaction dram empty .
		#endif

	
	REG32(SYS_HW_STRAP)= tmp | (clk_sel) <<CK_M2X_FREQ_SEL_OFFSET ;
80009ef8:	240383ff 	li	v1,-31745
80009efc:	00c31824 	and	v1,a2,v1
80009f00:	00431825 	or	v1,v0,v1
80009f04:	3c02b800 	lui	v0,0xb800
80009f08:	34420008 	ori	v0,v0,0x8
80009f0c:	ac430000 	sw	v1,0(v0)
		
		#if 1   //check m2xusable and unlock bus
			while( (REG32(SYS_BIST_DONE)&(1<<18))==0)  ;   //wait to 1, mean m2x is usable
80009f10:	3c06b800 	lui	a2,0xb800
80009f14:	34c60020 	ori	a2,a2,0x20
80009f18:	3c050004 	lui	a1,0x4
80009f1c:	8cc30000 	lw	v1,0(a2)
80009f20:	00651824 	and	v1,v1,a1
80009f24:	1060fffd 	beqz	v1,80009f1c <SettingM2xClk+0xb0>
80009f28:	3c02b800 	lui	v0,0xb800
	
			REG32(SYS_LX_CTRL) &= ~(1<<2);	//unlock
80009f2c:	34420014 	ori	v0,v0,0x14
80009f30:	8c450000 	lw	a1,0(v0)
80009f34:	2403fffb 	li	v1,-5
80009f38:	00a31824 	and	v1,a1,v1
80009f3c:	ac430000 	sw	v1,0(v0)
			while( (REG32(SYS_BIST_DONE)&(1<<0))==(1<<0)) ;  //wait bit to 0  unlock
80009f40:	3c05b800 	lui	a1,0xb800
80009f44:	34a50020 	ori	a1,a1,0x20
80009f48:	8ca30000 	lw	v1,0(a1)
80009f4c:	30630001 	andi	v1,v1,0x1
80009f50:	1460fffd 	bnez	v1,80009f48 <SettingM2xClk+0xdc>
80009f54:	3c02b800 	lui	v0,0xb800

			REG32(SYS_LX_CTRL) &= ~(1<<3);	//unlock
80009f58:	34420014 	ori	v0,v0,0x14
80009f5c:	8c450000 	lw	a1,0(v0)
80009f60:	2403fff7 	li	v1,-9
80009f64:	00a31824 	and	v1,a1,v1
80009f68:	ac430000 	sw	v1,0(v0)
			while( (REG32(SYS_BIST_DONE)&(1<<1))==(1<<1)) ;  //wait bit to 0  unlock
80009f6c:	3c05b800 	lui	a1,0xb800
80009f70:	34a50020 	ori	a1,a1,0x20
80009f74:	8ca30000 	lw	v1,0(a1)
80009f78:	30630002 	andi	v1,v1,0x2
80009f7c:	1460fffd 	bnez	v1,80009f74 <SettingM2xClk+0x108>
80009f80:	3c02b800 	lui	v0,0xb800

			REG32(SYS_LX_CTRL) &= ~(1<<4);	//unlock
80009f84:	34420014 	ori	v0,v0,0x14
80009f88:	8c450000 	lw	a1,0(v0)
80009f8c:	2403ffef 	li	v1,-17
80009f90:	00a31824 	and	v1,a1,v1
80009f94:	ac430000 	sw	v1,0(v0)
			while( (REG32(SYS_BIST_DONE)&(1<<2))==(1<<2)) ;  //wait bit to 0  unlock	
80009f98:	3c05b800 	lui	a1,0xb800
80009f9c:	34a50020 	ori	a1,a1,0x20
80009fa0:	8ca30000 	lw	v1,0(a1)
80009fa4:	30630004 	andi	v1,v1,0x4
80009fa8:	1460fffd 	bnez	v1,80009fa0 <SettingM2xClk+0x134>
80009fac:	3c028001 	lui	v0,0x8001
	{
		console_init(glexra_clock);
		timer_init(glexra_clock);
	}
#endif		
	dprintf("Change M2x clock freq=%d \n", m2x_clksel_table[clk_sel] );
80009fb0:	00042080 	sll	a0,a0,0x2
80009fb4:	244204f0 	addiu	v0,v0,1264
80009fb8:	00821021 	addu	v0,a0,v0
80009fbc:	3c048001 	lui	a0,0x8001
80009fc0:	248456ac 	addiu	a0,a0,22188
80009fc4:	0c002325 	jal	80008c94 <dprintf>
80009fc8:	8c450000 	lw	a1,0(v0)
}
80009fcc:	8fbf0014 	lw	ra,20(sp)
80009fd0:	03e00008 	jr	ra
80009fd4:	27bd0018 	addiu	sp,sp,24

80009fd8 <LetCPUDoSomething>:

struct irqaction irq_SPEED = {SPEED_isr, (unsigned long)NULL, (unsigned long)SPEED_IRQ_NO,"SPEED", (void *)NULL, (struct irqaction *)NULL};   

//---------------------------------------------------------------------------
int LetCPUDoSomething()
{
80009fd8:	27bdfbe8 	addiu	sp,sp,-1048
80009fdc:	afbf0414 	sw	ra,1044(sp)
      	{
		dprintf("FAIL! ,summation 1 to 100=%d \n",sum);
		while(1) {};
	  }

	p=(unsigned int)buf|0xa0000000;
80009fe0:	27a70010 	addiu	a3,sp,16
80009fe4:	3c02a000 	lui	v0,0xa000
80009fe8:	00e23825 	or	a3,a3,v0
80009fec:	00e02821 	move	a1,a3
80009ff0:	00e01821 	move	v1,a3
80009ff4:	00001021 	move	v0,zero
	for(i=0; i<256; i++)
80009ff8:	24040100 	li	a0,256
		p[i]=i;
80009ffc:	ac620000 	sw	v0,0(v1)
		dprintf("FAIL! ,summation 1 to 100=%d \n",sum);
		while(1) {};
	  }

	p=(unsigned int)buf|0xa0000000;
	for(i=0; i<256; i++)
8000a000:	24420001 	addiu	v0,v0,1
8000a004:	1444fffd 	bne	v0,a0,80009ffc <LetCPUDoSomething+0x24>
8000a008:	24630004 	addiu	v1,v1,4
		p[i]=i;

	for(i=0; i<256;i++)
		if(p[i]!=i)
8000a00c:	8ca60000 	lw	a2,0(a1)
8000a010:	24050001 	li	a1,1
8000a014:	10c00003 	beqz	a2,8000a024 <LetCPUDoSomething+0x4c>
8000a018:	24020100 	li	v0,256
8000a01c:	0800280d 	j	8000a034 <LetCPUDoSomething+0x5c>
8000a020:	00002821 	move	a1,zero
8000a024:	8ce60004 	lw	a2,4(a3)
8000a028:	10c50007 	beq	a2,a1,8000a048 <LetCPUDoSomething+0x70>
8000a02c:	24a50001 	addiu	a1,a1,1
8000a030:	24a5ffff 	addiu	a1,a1,-1
		{	dprintf("FAIL! idx=%x val=%x\n",i,p[i]);
8000a034:	3c048001 	lui	a0,0x8001
8000a038:	0c002325 	jal	80008c94 <dprintf>
8000a03c:	248456c8 	addiu	a0,a0,22216
8000a040:	08002810 	j	8000a040 <LetCPUDoSomething+0x68>
8000a044:	00000000 	nop

	p=(unsigned int)buf|0xa0000000;
	for(i=0; i<256; i++)
		p[i]=i;

	for(i=0; i<256;i++)
8000a048:	14a2fff6 	bne	a1,v0,8000a024 <LetCPUDoSomething+0x4c>
8000a04c:	24e70004 	addiu	a3,a3,4
		if(p[i]!=i)
		{	dprintf("FAIL! idx=%x val=%x\n",i,p[i]);
			while(1) {};
		}

}
8000a050:	8fbf0414 	lw	ra,1044(sp)
8000a054:	03e00008 	jr	ra
8000a058:	27bd0418 	addiu	sp,sp,1048

8000a05c <HS0_Control>:
}

//=================================================================================

void HS0_Control(unsigned int ocp, unsigned int lx, unsigned int mx, unsigned int sleep)
{
8000a05c:	27bdffd8 	addiu	sp,sp,-40
8000a060:	afbf0024 	sw	ra,36(sp)
8000a064:	afb40020 	sw	s4,32(sp)
8000a068:	afb3001c 	sw	s3,28(sp)
8000a06c:	afb20018 	sw	s2,24(sp)
8000a070:	afb10014 	sw	s1,20(sp)
8000a074:	afb00010 	sw	s0,16(sp)
8000a078:	00808821 	move	s1,a0
8000a07c:	00c08021 	move	s0,a2
8000a080:	00e09821 	move	s3,a3
	#define GET_BITVAL(v,bitpos,pat) ((v& ((unsigned int)pat<<bitpos))>>bitpos)
	#define RANG5  0x1f
	#define RANG4  0x0f


	if(lx==0)	lx=200;
8000a084:	241400c8 	li	s4,200
	if(mx==0)
8000a088:	14c0000b 	bnez	a2,8000a0b8 <HS0_Control+0x5c>
8000a08c:	00a5a00b 	movn	s4,a1,a1
	{
		unsigned int m2x_freq_sel=GET_BITVAL(REG32(SYS_HW_STRAP), CK_M2X_FREQ_SEL_OFFSET, RANG5);
8000a090:	3c02b800 	lui	v0,0xb800
8000a094:	34420008 	ori	v0,v0,0x8
8000a098:	8c430000 	lw	v1,0(v0)
		mx=(m2x_clksel_table[m2x_freq_sel])/2;
8000a09c:	7c632280 	ext	v1,v1,0xa,0x5
8000a0a0:	00031880 	sll	v1,v1,0x2
8000a0a4:	3c028001 	lui	v0,0x8001
8000a0a8:	244204f0 	addiu	v0,v0,1264
8000a0ac:	00621021 	addu	v0,v1,v0
8000a0b0:	8c500000 	lw	s0,0(v0)
8000a0b4:	00108042 	srl	s0,s0,0x1
	}
 	if(ocp==0)
8000a0b8:	1620000d 	bnez	s1,8000a0f0 <HS0_Control+0x94>
8000a0bc:	0290102b 	sltu	v0,s4,s0
 	{
		unsigned int cpu_freq_sel=GET_BITVAL(REG32(SYS_HW_STRAP), ST_CPU_FREQ_SEL_OFFSET, RANG4);
8000a0c0:	3c02b800 	lui	v0,0xb800
8000a0c4:	34420008 	ori	v0,v0,0x8
8000a0c8:	8c420000 	lw	v0,0(v0)
		ocp=cpu_clksel_table[cpu_freq_sel];
8000a0cc:	3c030007 	lui	v1,0x7
8000a0d0:	34638000 	ori	v1,v1,0x8000
8000a0d4:	00431824 	and	v1,v0,v1
8000a0d8:	00031b42 	srl	v1,v1,0xd
8000a0dc:	3c028001 	lui	v0,0x8001
8000a0e0:	244204b0 	addiu	v0,v0,1200
8000a0e4:	00621021 	addu	v0,v1,v0
8000a0e8:	8c510000 	lw	s1,0(v0)

	
	#define SYS_HS0_CTRL 0xb80000a0
	#define BIT(x)	(1 << x)	
	unsigned int v=0;
	if(lx<mx)		{	v|=BIT(0)| BIT(1) |BIT(2);   	printf("Lx<Mx\n");		}
8000a0ec:	0290102b 	sltu	v0,s4,s0
8000a0f0:	10400005 	beqz	v0,8000a108 <HS0_Control+0xac>
8000a0f4:	00009021 	move	s2,zero
8000a0f8:	3c048001 	lui	a0,0x8001
8000a0fc:	0c002325 	jal	80008c94 <dprintf>
8000a100:	248456e0 	addiu	a0,a0,22240
8000a104:	24120007 	li	s2,7
	if(ocp<mx)		{	v|=BIT(3);					printf("Ocp<Mx\n");	}
8000a108:	0230802b 	sltu	s0,s1,s0
8000a10c:	12000005 	beqz	s0,8000a124 <HS0_Control+0xc8>
8000a110:	00000000 	nop
8000a114:	36520008 	ori	s2,s2,0x8
8000a118:	3c048001 	lui	a0,0x8001
8000a11c:	0c002325 	jal	80008c94 <dprintf>
8000a120:	248456e8 	addiu	a0,a0,22248
	if(ocp<lx)		{	v|=BIT(4);					printf("Ocp<Lx\n");	}
8000a124:	0234882b 	sltu	s1,s1,s4
8000a128:	12200006 	beqz	s1,8000a144 <HS0_Control+0xe8>
8000a12c:	3c02b800 	lui	v0,0xb800
8000a130:	36520010 	ori	s2,s2,0x10
8000a134:	3c048001 	lui	a0,0x8001
8000a138:	0c002325 	jal	80008c94 <dprintf>
8000a13c:	248456f0 	addiu	a0,a0,22256

	
	//REG32(SYS_HS0_CTRL) = v;
	REG32(SYS_HS0_CTRL) |= v;
8000a140:	3c02b800 	lui	v0,0xb800
8000a144:	344200a0 	ori	v0,v0,0xa0
8000a148:	8c430000 	lw	v1,0(v0)
8000a14c:	02439025 	or	s2,s2,v1
8000a150:	ac520000 	sw	s2,0(v0)
	


	if(sleep)
8000a154:	12600012 	beqz	s3,8000a1a0 <HS0_Control+0x144>
8000a158:	3c02b800 	lui	v0,0xb800
	{	
		#if 1			
			//printf("llx0\n");
			REG32(SYS_LX_CTRL) |= (1<<2) ;	  //lock bus arb2
8000a15c:	34420014 	ori	v0,v0,0x14
8000a160:	8c430000 	lw	v1,0(v0)
8000a164:	34630004 	ori	v1,v1,0x4
8000a168:	ac430000 	sw	v1,0(v0)
			while( (REG32(SYS_LX_CTRL)&(1<<12))==0)  {}; //wait bit to 1, is mean lock ok	
8000a16c:	00401821 	move	v1,v0
8000a170:	8c620000 	lw	v0,0(v1)
8000a174:	30421000 	andi	v0,v0,0x1000
8000a178:	1040fffd 	beqz	v0,8000a170 <HS0_Control+0x114>
8000a17c:	00000000 	nop
			//REG32(SYS_BIST_CTRL) |= (1<<4) ;	  //lock bus arb6
			//while( (REG32(SYS_BIST_DONE)&(1<<2))==0)  {}; //wait bit to 1, is mean lock ok				
		#endif
		
		//__asm__ volatile("sleep");	 //need 10 usec to guaretee
		__asm__ volatile("nop");
8000a180:	00000000 	nop


		#if 1
			//printf("ulx0\n");	
			REG32(SYS_LX_CTRL) &= ~(1<<2);	//unlock
8000a184:	3c02b800 	lui	v0,0xb800
8000a188:	34420014 	ori	v0,v0,0x14
8000a18c:	8c440000 	lw	a0,0(v0)
8000a190:	2403fffb 	li	v1,-5
8000a194:	00831824 	and	v1,a0,v1
8000a198:	ac430000 	sw	v1,0(v0)
			while( (REG32(SYS_LX_CTRL)&(1<<12))==(1<<0)) {};  //wait bit to 0  unlock
8000a19c:	8c420000 	lw	v0,0(v0)
			//while( (REG32(SYS_BIST_DONE)&(1<<2))==(1<<2)) {};  //wait bit to 0  unlock				
		#endif
	}
			//printf("done\n");

}
8000a1a0:	8fbf0024 	lw	ra,36(sp)
8000a1a4:	8fb40020 	lw	s4,32(sp)
8000a1a8:	8fb3001c 	lw	s3,28(sp)
8000a1ac:	8fb20018 	lw	s2,24(sp)
8000a1b0:	8fb10014 	lw	s1,20(sp)
8000a1b4:	8fb00010 	lw	s0,16(sp)
8000a1b8:	03e00008 	jr	ra
8000a1bc:	27bd0028 	addiu	sp,sp,40

8000a1c0 <ShowStrapMsg>:
#define printf dprintf


//=================================================================================
void ShowStrapMsg()
{
8000a1c0:	27bdffa0 	addiu	sp,sp,-96
8000a1c4:	afbf005c 	sw	ra,92(sp)
8000a1c8:	afb50058 	sw	s5,88(sp)
8000a1cc:	afb40054 	sw	s4,84(sp)
8000a1d0:	afb30050 	sw	s3,80(sp)
8000a1d4:	afb2004c 	sw	s2,76(sp)
8000a1d8:	afb10048 	sw	s1,72(sp)
8000a1dc:	afb00044 	sw	s0,68(sp)
	const unsigned char *boot_type_tab[]={ {"SPI3B"}, {"SPI4B"}, {"NFBI"}, {"NAND"}, {"ROM01"}, {"ROM02"}, {"ROM03"}, {"auto"} };
8000a1e0:	3c028001 	lui	v0,0x8001
8000a1e4:	244256f8 	addiu	v0,v0,22264
8000a1e8:	afa20018 	sw	v0,24(sp)
8000a1ec:	3c028001 	lui	v0,0x8001
8000a1f0:	24425700 	addiu	v0,v0,22272
8000a1f4:	afa2001c 	sw	v0,28(sp)
8000a1f8:	3c028001 	lui	v0,0x8001
8000a1fc:	24425708 	addiu	v0,v0,22280
8000a200:	afa20020 	sw	v0,32(sp)
8000a204:	3c028001 	lui	v0,0x8001
8000a208:	24425710 	addiu	v0,v0,22288
8000a20c:	afa20024 	sw	v0,36(sp)
8000a210:	3c028001 	lui	v0,0x8001
8000a214:	24425718 	addiu	v0,v0,22296
8000a218:	afa20028 	sw	v0,40(sp)
8000a21c:	3c028001 	lui	v0,0x8001
8000a220:	24425720 	addiu	v0,v0,22304
8000a224:	afa2002c 	sw	v0,44(sp)
8000a228:	3c028001 	lui	v0,0x8001
8000a22c:	24425728 	addiu	v0,v0,22312
8000a230:	afa20030 	sw	v0,48(sp)
8000a234:	3c028001 	lui	v0,0x8001
8000a238:	24425730 	addiu	v0,v0,22320
8000a23c:	afa20034 	sw	v0,52(sp)
	const unsigned char *dram_type_tab[]={  {"DDR2"}, {"DDR3"} };
8000a240:	3c028001 	lui	v0,0x8001
8000a244:	24425738 	addiu	v0,v0,22328
8000a248:	afa20038 	sw	v0,56(sp)
8000a24c:	3c028001 	lui	v0,0x8001
8000a250:	24425740 	addiu	v0,v0,22336
8000a254:	afa2003c 	sw	v0,60(sp)
	#define RANG2 3
	#define RANG3  7
	#define RANG4 0xf	
	#define RANG5 0x1f
	
	unsigned int v=REG32(SYS_HW_STRAP);
8000a258:	3c02b800 	lui	v0,0xb800
8000a25c:	34420008 	ori	v0,v0,0x8
8000a260:	8c500000 	lw	s0,0(v0)

	unsigned int bootsel=GET_BITVAL(v, 0, RANG3);
8000a264:	32110007 	andi	s1,s0,0x7
	unsigned int dramtype=GET_BITVAL(v, 3, RANG1);
8000a268:	7e1200c0 	ext	s2,s0,0x3,0x1
	

	
	unsigned int ck_m2x_freq_sel=GET_BITVAL(v, 10, RANG5);
8000a26c:	7e152280 	ext	s5,s0,0xa,0x5
	unsigned int ck_cpu_freq_sel=GET_BITVAL(v, 15, RANG4);
8000a270:	3c130007 	lui	s3,0x7
8000a274:	36738000 	ori	s3,s3,0x8000
8000a278:	02139824 	and	s3,s0,s3
8000a27c:	00139bc2 	srl	s3,s3,0xf
	unsigned int ck_cpu_div_sel=GET_BITVAL(v, 19, RANG2);
8000a280:	7e140cc0 	ext	s4,s0,0x13,0x2



	
	printf("---------------------\n");
8000a284:	3c048001 	lui	a0,0x8001
8000a288:	0c002325 	jal	80008c94 <dprintf>
8000a28c:	24845748 	addiu	a0,a0,22344
	printf("HW_STRAP_VAL= 0x%08x \n", v);
8000a290:	3c048001 	lui	a0,0x8001
8000a294:	24845760 	addiu	a0,a0,22368
8000a298:	0c002325 	jal	80008c94 <dprintf>
8000a29c:	02002821 	move	a1,s0
	printf("[02:00] ST_BOOTPINSEL= 0x%x  \n", bootsel);		
8000a2a0:	3c048001 	lui	a0,0x8001
8000a2a4:	24845778 	addiu	a0,a0,22392
8000a2a8:	0c002325 	jal	80008c94 <dprintf>
8000a2ac:	02202821 	move	a1,s1
	printf("[03:03] ST_DRAMTYPE= 0x%x      	\n", 	dramtype);	
8000a2b0:	3c048001 	lui	a0,0x8001
8000a2b4:	24845798 	addiu	a0,a0,22424
8000a2b8:	0c002325 	jal	80008c94 <dprintf>
8000a2bc:	02402821 	move	a1,s2

	printf("[04:04] clklx_from_clkm= 0x%x \n",  	GET_BITVAL(v, 4, RANG1)  );	
8000a2c0:	3c048001 	lui	a0,0x8001
8000a2c4:	248457bc 	addiu	a0,a0,22460
8000a2c8:	0c002325 	jal	80008c94 <dprintf>
8000a2cc:	7e050100 	ext	a1,s0,0x4,0x1
	printf("[05:05] disable_ext_reset= 0x%x \n",  	GET_BITVAL(v, 5, RANG1)  );	
8000a2d0:	3c048001 	lui	a0,0x8001
8000a2d4:	248457dc 	addiu	a0,a0,22492
8000a2d8:	0c002325 	jal	80008c94 <dprintf>
8000a2dc:	7e050140 	ext	a1,s0,0x5,0x1
	printf("[06:06] ext_phy_mode= 0x%x \n",  	GET_BITVAL(v, 6, RANG1)  );		
8000a2e0:	3c048001 	lui	a0,0x8001
8000a2e4:	24845800 	addiu	a0,a0,22528
8000a2e8:	0c002325 	jal	80008c94 <dprintf>
8000a2ec:	7e050180 	ext	a1,s0,0x6,0x1


	printf("[14:10] CK_M2X_FREQ_SEL= 0x%x \n", ck_m2x_freq_sel);	
8000a2f0:	3c048001 	lui	a0,0x8001
8000a2f4:	24845820 	addiu	a0,a0,22560
8000a2f8:	0c002325 	jal	80008c94 <dprintf>
8000a2fc:	02a02821 	move	a1,s5
	printf("[18:15] ST_CPU_FREQ_SEL= 0x%x \n", ck_cpu_freq_sel);
8000a300:	3c048001 	lui	a0,0x8001
8000a304:	24845840 	addiu	a0,a0,22592
8000a308:	0c002325 	jal	80008c94 <dprintf>
8000a30c:	02602821 	move	a1,s3
	
	printf("[20:19] ST_CPU_FREQDIV_SEL= 0x%x \n", ck_cpu_div_sel);
8000a310:	3c048001 	lui	a0,0x8001
8000a314:	24845860 	addiu	a0,a0,22624
8000a318:	0c002325 	jal	80008c94 <dprintf>
8000a31c:	02802821 	move	a1,s4

	printf("[21:21] clklx_from_halfoc= 0x%x \n",  	GET_BITVAL(v, 21, RANG1)  );	
8000a320:	3c048001 	lui	a0,0x8001
8000a324:	24845884 	addiu	a0,a0,22660
8000a328:	0c002325 	jal	80008c94 <dprintf>
8000a32c:	7e050540 	ext	a1,s0,0x15,0x1
	
	printf("[22:22] ever_reboot_once= 0x%x \n", 	GET_BITVAL(v, 22, RANG1)  );	
8000a330:	3c048001 	lui	a0,0x8001
8000a334:	248458a8 	addiu	a0,a0,22696
8000a338:	0c002325 	jal	80008c94 <dprintf>
8000a33c:	7e050580 	ext	a1,s0,0x16,0x1
	printf("[23:23] clkoc_from_clkm= 0x%x \n", 	GET_BITVAL(v, 23, RANG1)  );			
8000a340:	3c048001 	lui	a0,0x8001
8000a344:	248458cc 	addiu	a0,a0,22732
8000a348:	0c002325 	jal	80008c94 <dprintf>
8000a34c:	7e0505c0 	ext	a1,s0,0x17,0x1
	printf("[24:24] sel_40m= 0x%x \n", 	GET_BITVAL(v, 24, RANG1)  );		
8000a350:	3c048001 	lui	a0,0x8001
8000a354:	248458ec 	addiu	a0,a0,22764
8000a358:	0c002325 	jal	80008c94 <dprintf>
8000a35c:	7e050600 	ext	a1,s0,0x18,0x1

	printf("\n");
8000a360:	3c048001 	lui	a0,0x8001
8000a364:	0c002325 	jal	80008c94 <dprintf>
8000a368:	248457b8 	addiu	a0,a0,22456
	printf("%s mode, %s Ram,  CPU=%d MHz, Mem2x=%d MHz, \n", 
8000a36c:	00118880 	sll	s1,s1,0x2
8000a370:	27a20018 	addiu	v0,sp,24
8000a374:	00518821 	addu	s1,v0,s1
8000a378:	8e250000 	lw	a1,0(s1)
8000a37c:	00129080 	sll	s2,s2,0x2
8000a380:	00521021 	addu	v0,v0,s2
8000a384:	8c460020 	lw	a2,32(v0)
8000a388:	00139880 	sll	s3,s3,0x2
8000a38c:	3c028001 	lui	v0,0x8001
8000a390:	244204b0 	addiu	v0,v0,1200
8000a394:	02629821 	addu	s3,s3,v0
8000a398:	0014a080 	sll	s4,s4,0x2
8000a39c:	3c028001 	lui	v0,0x8001
8000a3a0:	24427620 	addiu	v0,v0,30240
8000a3a4:	0282a021 	addu	s4,s4,v0
8000a3a8:	8e670000 	lw	a3,0(s3)
8000a3ac:	8e820000 	lw	v0,0(s4)
8000a3b0:	00e2001b 	divu	zero,a3,v0
8000a3b4:	004001f4 	teq	v0,zero,0x7
8000a3b8:	00003812 	mflo	a3
8000a3bc:	0015a880 	sll	s5,s5,0x2
8000a3c0:	3c028001 	lui	v0,0x8001
8000a3c4:	244204f0 	addiu	v0,v0,1264
8000a3c8:	02a2a821 	addu	s5,s5,v0
8000a3cc:	8ea20000 	lw	v0,0(s5)
8000a3d0:	afa20010 	sw	v0,16(sp)
8000a3d4:	3c048001 	lui	a0,0x8001
8000a3d8:	0c002325 	jal	80008c94 <dprintf>
8000a3dc:	24845904 	addiu	a0,a0,22788
						dram_type_tab[dramtype],
						cpu_clksel_table[ck_cpu_freq_sel]/cpu_clkdiv_table[ck_cpu_div_sel] ,
						m2x_clksel_table[ck_m2x_freq_sel]
						);
					
}
8000a3e0:	8fbf005c 	lw	ra,92(sp)
8000a3e4:	8fb50058 	lw	s5,88(sp)
8000a3e8:	8fb40054 	lw	s4,84(sp)
8000a3ec:	8fb30050 	lw	s3,80(sp)
8000a3f0:	8fb2004c 	lw	s2,76(sp)
8000a3f4:	8fb10048 	lw	s1,72(sp)
8000a3f8:	8fb00044 	lw	s0,68(sp)
8000a3fc:	03e00008 	jr	ra
8000a400:	27bd0060 	addiu	sp,sp,96

8000a404 <Cmd_AllBistTest>:
}
		
		
//=============================================================================
int Cmd_AllBistTest(int argc, char* argv[])
{
8000a404:	27bdffd0 	addiu	sp,sp,-48
8000a408:	afbf002c 	sw	ra,44(sp)
8000a40c:	afb60028 	sw	s6,40(sp)
8000a410:	afb50024 	sw	s5,36(sp)
8000a414:	afb40020 	sw	s4,32(sp)
8000a418:	afb3001c 	sw	s3,28(sp)
8000a41c:	afb20018 	sw	s2,24(sp)
8000a420:	afb10014 	sw	s1,20(sp)
8000a424:	afb00010 	sw	s0,16(sp)
	#define HS0_DRF_FAIL4    0xb80002bc
	#define HS0_DRF_FAIL5    0xb80002c0
	#define HS0_DRF_FAIL6    0xb80002c4


	printf( "========================\n");
8000a428:	3c138001 	lui	s3,0x8001
8000a42c:	0c002325 	jal	80008c94 <dprintf>
8000a430:	26645934 	addiu	a0,s3,22836
	printf( "Mode 1 BIST : cpu1 mbr \n");
8000a434:	3c048001 	lui	a0,0x8001
8000a438:	0c002325 	jal	80008c94 <dprintf>
8000a43c:	24845950 	addiu	a0,a0,22864
	REG32(HS0_BIST_CTRL) = 0;
8000a440:	3c10b800 	lui	s0,0xb800
8000a444:	36110208 	ori	s1,s0,0x208
8000a448:	ae200000 	sw	zero,0(s1)
		printf( "W:HS0_BIST_CTRL=%08x \n", REG32(HS0_BIST_CTRL) );
8000a44c:	8e250000 	lw	a1,0(s1)
8000a450:	3c128001 	lui	s2,0x8001
8000a454:	0c002325 	jal	80008c94 <dprintf>
8000a458:	2644596c 	addiu	a0,s2,22892

#if 0		
	REG32(HS0_BIST_CTRL) |=  (0x7f);
#else
	REG32(HS0_BIST_CTRL) |=  (0x7c);  //skip mbr0, mbr1
8000a45c:	8e220000 	lw	v0,0(s1)
8000a460:	3442007c 	ori	v0,v0,0x7c
8000a464:	ae220000 	sw	v0,0(s1)
#endif
		printf( "W:HS0_BIST_CTRL=%08x \n", REG32(HS0_BIST_CTRL) );
8000a468:	8e250000 	lw	a1,0(s1)
8000a46c:	0c002325 	jal	80008c94 <dprintf>
8000a470:	2644596c 	addiu	a0,s2,22892
	
	REG32(HS0_BIST_CTRL2) = 0;
8000a474:	3611020c 	ori	s1,s0,0x20c
8000a478:	ae200000 	sw	zero,0(s1)
		printf( "W:HS0_BIST_CTRL2=%08x \n", REG32(HS0_BIST_CTRL2) );
8000a47c:	8e250000 	lw	a1,0(s1)
8000a480:	3c128001 	lui	s2,0x8001
8000a484:	0c002325 	jal	80008c94 <dprintf>
8000a488:	26445984 	addiu	a0,s2,22916
		
	REG32(HS0_BIST_CTRL2) |=  (0x1e0103ff);
8000a48c:	8e230000 	lw	v1,0(s1)
8000a490:	3c021e01 	lui	v0,0x1e01
8000a494:	344203ff 	ori	v0,v0,0x3ff
8000a498:	00621025 	or	v0,v1,v0
8000a49c:	ae220000 	sw	v0,0(s1)
		printf( "W:HS0_BIST_CTRL2=%08x \n", REG32(HS0_BIST_CTRL2) );
8000a4a0:	8e250000 	lw	a1,0(s1)
8000a4a4:	0c002325 	jal	80008c94 <dprintf>
8000a4a8:	26445984 	addiu	a0,s2,22916
	

	delay_ms(10);
8000a4ac:	0c002219 	jal	80008864 <delay_ms>
8000a4b0:	2404000a 	li	a0,10

	printf( "\n");
8000a4b4:	3c048001 	lui	a0,0x8001
8000a4b8:	0c002325 	jal	80008c94 <dprintf>
8000a4bc:	248457b8 	addiu	a0,a0,22456
	printf( "R:HS0_BIST DONE=%08x \n",  REG32(HS0_BIST_DONE) );
8000a4c0:	36110218 	ori	s1,s0,0x218
8000a4c4:	8e250000 	lw	a1,0(s1)
8000a4c8:	3c048001 	lui	a0,0x8001
8000a4cc:	0c002325 	jal	80008c94 <dprintf>
8000a4d0:	2484599c 	addiu	a0,a0,22940
	printf( "R:HS0_BIST FAIL1=%08x \n", REG32(HS0_BIST_FAIL1) );
8000a4d4:	36020230 	ori	v0,s0,0x230
8000a4d8:	8c450000 	lw	a1,0(v0)
8000a4dc:	3c048001 	lui	a0,0x8001
8000a4e0:	0c002325 	jal	80008c94 <dprintf>
8000a4e4:	248459b4 	addiu	a0,a0,22964
	printf( "R:HS0_BIST FAIL2=%08x \n", REG32(HS0_BIST_FAIL2) );
8000a4e8:	36020234 	ori	v0,s0,0x234
8000a4ec:	8c450000 	lw	a1,0(v0)
8000a4f0:	3c048001 	lui	a0,0x8001
8000a4f4:	0c002325 	jal	80008c94 <dprintf>
8000a4f8:	248459cc 	addiu	a0,a0,22988
	printf( "R:HS0_BIST FAIL3=%08x \n", REG32(HS0_BIST_FAIL3) );
8000a4fc:	36020238 	ori	v0,s0,0x238
8000a500:	8c450000 	lw	a1,0(v0)
8000a504:	3c048001 	lui	a0,0x8001
8000a508:	0c002325 	jal	80008c94 <dprintf>
8000a50c:	248459e4 	addiu	a0,a0,23012
	printf( "R:HS0_BIST FAIL4=%08x \n", REG32(HS0_BIST_FAIL4) );
8000a510:	3602023c 	ori	v0,s0,0x23c
8000a514:	8c450000 	lw	a1,0(v0)
8000a518:	3c048001 	lui	a0,0x8001
8000a51c:	0c002325 	jal	80008c94 <dprintf>
8000a520:	248459fc 	addiu	a0,a0,23036
	printf( "R:HS0_BIST FAIL5=%08x \n", REG32(HS0_BIST_FAIL5) );
8000a524:	36020240 	ori	v0,s0,0x240
8000a528:	8c450000 	lw	a1,0(v0)
8000a52c:	3c048001 	lui	a0,0x8001
8000a530:	0c002325 	jal	80008c94 <dprintf>
8000a534:	24845a14 	addiu	a0,a0,23060
		  (REG32(HS0_BIST_FAIL5)==0)  )
		  { printf( " ==>BIST PASS \n"); }	 
#endif		
	//============================================
	
	printf( "========================\n");
8000a538:	0c002325 	jal	80008c94 <dprintf>
8000a53c:	26645934 	addiu	a0,s3,22836
	printf( "Mode 2 BIST : L2,SRAM,ROM,CPU2 \n");
8000a540:	3c048001 	lui	a0,0x8001
8000a544:	0c002325 	jal	80008c94 <dprintf>
8000a548:	24845a2c 	addiu	a0,a0,23084

	printf( "R:HS0_BIST FAIL6=%08x \n", REG32(HS0_BIST_FAIL6));
8000a54c:	36100244 	ori	s0,s0,0x244
8000a550:	8e050000 	lw	a1,0(s0)
8000a554:	3c048001 	lui	a0,0x8001
8000a558:	0c002325 	jal	80008c94 <dprintf>
8000a55c:	24845a50 	addiu	a0,a0,23120

	if ( (REG32(HS0_BIST_DONE)&(0x79<<10)) != (0x79<<10)) { printf( " ==>DONE FAIL \n"); }	
8000a560:	8e230000 	lw	v1,0(s1)
8000a564:	3c020001 	lui	v0,0x1
8000a568:	3442e400 	ori	v0,v0,0xe400
8000a56c:	00621824 	and	v1,v1,v0
8000a570:	10620005 	beq	v1,v0,8000a588 <Cmd_AllBistTest+0x184>
8000a574:	3c02b800 	lui	v0,0xb800
8000a578:	3c048001 	lui	a0,0x8001
8000a57c:	0c002325 	jal	80008c94 <dprintf>
8000a580:	24845a68 	addiu	a0,a0,23144
	if (  REG32(HS0_BIST_FAIL6) != 0) { printf( " ==>FAIL FAIL \n"); }	
8000a584:	3c02b800 	lui	v0,0xb800
8000a588:	34420244 	ori	v0,v0,0x244
8000a58c:	8c420000 	lw	v0,0(v0)
8000a590:	10400005 	beqz	v0,8000a5a8 <Cmd_AllBistTest+0x1a4>
8000a594:	3c02b800 	lui	v0,0xb800
8000a598:	3c048001 	lui	a0,0x8001
8000a59c:	0c002325 	jal	80008c94 <dprintf>
8000a5a0:	24845a78 	addiu	a0,a0,23160

	if ((( REG32(HS0_BIST_DONE)&(0x79<<10)) == (0x79<<10)) && 
8000a5a4:	3c02b800 	lui	v0,0xb800
8000a5a8:	34420218 	ori	v0,v0,0x218
8000a5ac:	8c430000 	lw	v1,0(v0)
8000a5b0:	3c020001 	lui	v0,0x1
8000a5b4:	3442e400 	ori	v0,v0,0xe400
8000a5b8:	00621824 	and	v1,v1,v0
8000a5bc:	1462000a 	bne	v1,v0,8000a5e8 <Cmd_AllBistTest+0x1e4>
8000a5c0:	3c02b800 	lui	v0,0xb800
		 ( REG32(HS0_BIST_FAIL6) == 0) )
8000a5c4:	34420244 	ori	v0,v0,0x244
8000a5c8:	8c420000 	lw	v0,0(v0)
	printf( "R:HS0_BIST FAIL6=%08x \n", REG32(HS0_BIST_FAIL6));

	if ( (REG32(HS0_BIST_DONE)&(0x79<<10)) != (0x79<<10)) { printf( " ==>DONE FAIL \n"); }	
	if (  REG32(HS0_BIST_FAIL6) != 0) { printf( " ==>FAIL FAIL \n"); }	

	if ((( REG32(HS0_BIST_DONE)&(0x79<<10)) == (0x79<<10)) && 
8000a5cc:	14400006 	bnez	v0,8000a5e8 <Cmd_AllBistTest+0x1e4>
8000a5d0:	00000000 	nop
		 ( REG32(HS0_BIST_FAIL6) == 0) )
	{ printf( " ==>BIST PASS \n"); }
8000a5d4:	3c048001 	lui	a0,0x8001
8000a5d8:	0c002325 	jal	80008c94 <dprintf>
8000a5dc:	24845a88 	addiu	a0,a0,23176
	printf( "R:HS0_BIST FAIL6=%08x \n", REG32(HS0_BIST_FAIL6));

	if ( (REG32(HS0_BIST_DONE)&(0x79<<10)) != (0x79<<10)) { printf( " ==>DONE FAIL \n"); }	
	if (  REG32(HS0_BIST_FAIL6) != 0) { printf( " ==>FAIL FAIL \n"); }	

	if ((( REG32(HS0_BIST_DONE)&(0x79<<10)) == (0x79<<10)) && 
8000a5e0:	0800297e 	j	8000a5f8 <Cmd_AllBistTest+0x1f4>
8000a5e4:	00008821 	move	s1,zero
		 ( REG32(HS0_BIST_FAIL6) == 0) )
	{ printf( " ==>BIST PASS \n"); }
	else
	{ printf( " ==>BIST FAIL \n"); err++; }		
8000a5e8:	3c048001 	lui	a0,0x8001
8000a5ec:	0c002325 	jal	80008c94 <dprintf>
8000a5f0:	24845a98 	addiu	a0,a0,23192
8000a5f4:	24110001 	li	s1,1
	//============================================
	printf( "========================\n");
8000a5f8:	3c048001 	lui	a0,0x8001
8000a5fc:	0c002325 	jal	80008c94 <dprintf>
8000a600:	24845934 	addiu	a0,a0,22836
	printf( "Mode 3 BIST : NAND,FFT,SATA, PCS ROM, PCS RAM, USB3, OTG, PCIE(ep10),VOIP\n");
8000a604:	3c048001 	lui	a0,0x8001
8000a608:	0c002325 	jal	80008c94 <dprintf>
8000a60c:	24845aa8 	addiu	a0,a0,23208
	REG32(BIST_CTRL) = 0;
8000a610:	3c13b800 	lui	s3,0xb800
8000a614:	36700200 	ori	s0,s3,0x200
8000a618:	ae000000 	sw	zero,0(s0)
		printf( "W:BIST_CTRL=%08x \n", REG32(BIST_CTRL));
8000a61c:	8e050000 	lw	a1,0(s0)
8000a620:	3c128001 	lui	s2,0x8001
8000a624:	0c002325 	jal	80008c94 <dprintf>
8000a628:	26445af4 	addiu	a0,s2,23284
			
	REG32(BIST_CTRL) |=  (0x01);
8000a62c:	8e020000 	lw	v0,0(s0)
8000a630:	34420001 	ori	v0,v0,0x1
8000a634:	ae020000 	sw	v0,0(s0)
		printf( "W:BIST_CTRL=%08x \n", REG32(BIST_CTRL));
8000a638:	8e050000 	lw	a1,0(s0)
8000a63c:	0c002325 	jal	80008c94 <dprintf>
8000a640:	26445af4 	addiu	a0,s2,23284

	REG32(BIST_CTRL) |= (0x03ff0001);
8000a644:	8e030000 	lw	v1,0(s0)
8000a648:	3c0203ff 	lui	v0,0x3ff
8000a64c:	34420001 	ori	v0,v0,0x1
8000a650:	00621025 	or	v0,v1,v0
8000a654:	ae020000 	sw	v0,0(s0)
		printf( "W:BIST_CTRL=%08x \n", REG32(BIST_CTRL   )); 
8000a658:	8e050000 	lw	a1,0(s0)
8000a65c:	0c002325 	jal	80008c94 <dprintf>
8000a660:	26445af4 	addiu	a0,s2,23284

	delay_ms(10);
8000a664:	0c002219 	jal	80008864 <delay_ms>
8000a668:	2404000a 	li	a0,10
	printf( "\n");
8000a66c:	3c048001 	lui	a0,0x8001
8000a670:	0c002325 	jal	80008c94 <dprintf>
8000a674:	248457b8 	addiu	a0,a0,22456
	printf( "R:BIST DONE=%08x \n", REG32(BIST_DONE));
8000a678:	36700210 	ori	s0,s3,0x210
8000a67c:	8e050000 	lw	a1,0(s0)
8000a680:	3c048001 	lui	a0,0x8001
8000a684:	0c002325 	jal	80008c94 <dprintf>
8000a688:	24845b08 	addiu	a0,a0,23304
	printf( "R:BIST FAIL=%08x \n", REG32(BIST_FAIL));
8000a68c:	36730220 	ori	s3,s3,0x220
8000a690:	8e650000 	lw	a1,0(s3)
8000a694:	3c048001 	lui	a0,0x8001
8000a698:	0c002325 	jal	80008c94 <dprintf>
8000a69c:	24845b1c 	addiu	a0,a0,23324


	
	if ( (REG32(BIST_DONE) == 0xffff3fff) && 
8000a6a0:	8e030000 	lw	v1,0(s0)
8000a6a4:	3c02ffff 	lui	v0,0xffff
8000a6a8:	34423fff 	ori	v0,v0,0x3fff
8000a6ac:	14620009 	bne	v1,v0,8000a6d4 <Cmd_AllBistTest+0x2d0>
8000a6b0:	00000000 	nop
		( REG32(BIST_FAIL) == 0x00000000)) { printf( " ==>BIST PASS \n"); }	 
8000a6b4:	8e620000 	lw	v0,0(s3)
	printf( "R:BIST DONE=%08x \n", REG32(BIST_DONE));
	printf( "R:BIST FAIL=%08x \n", REG32(BIST_FAIL));


	
	if ( (REG32(BIST_DONE) == 0xffff3fff) && 
8000a6b8:	14400006 	bnez	v0,8000a6d4 <Cmd_AllBistTest+0x2d0>
8000a6bc:	00000000 	nop
		( REG32(BIST_FAIL) == 0x00000000)) { printf( " ==>BIST PASS \n"); }	 
8000a6c0:	3c048001 	lui	a0,0x8001
8000a6c4:	0c002325 	jal	80008c94 <dprintf>
8000a6c8:	24845a88 	addiu	a0,a0,23176
	printf( "R:BIST DONE=%08x \n", REG32(BIST_DONE));
	printf( "R:BIST FAIL=%08x \n", REG32(BIST_FAIL));


	
	if ( (REG32(BIST_DONE) == 0xffff3fff) && 
8000a6cc:	080029cc 	j	8000a730 <Cmd_AllBistTest+0x32c>
8000a6d0:	3c048001 	lui	a0,0x8001
		( REG32(BIST_FAIL) == 0x00000000)) { printf( " ==>BIST PASS \n"); }	 
	else 								   
	{ 	printf( " ==>BIST FAIL \n"); err++;
8000a6d4:	3c048001 	lui	a0,0x8001
8000a6d8:	0c002325 	jal	80008c94 <dprintf>
8000a6dc:	24845a98 	addiu	a0,a0,23192
8000a6e0:	26310001 	addiu	s1,s1,1
		if ( REG32(BIST_DONE) != 0xffff3fff) { printf( " ==>DONE FAIL \n"); }
8000a6e4:	3c02b800 	lui	v0,0xb800
8000a6e8:	34420210 	ori	v0,v0,0x210
8000a6ec:	8c430000 	lw	v1,0(v0)
8000a6f0:	3c02ffff 	lui	v0,0xffff
8000a6f4:	34423fff 	ori	v0,v0,0x3fff
8000a6f8:	10620005 	beq	v1,v0,8000a710 <Cmd_AllBistTest+0x30c>
8000a6fc:	3c02b800 	lui	v0,0xb800
8000a700:	3c048001 	lui	a0,0x8001
8000a704:	0c002325 	jal	80008c94 <dprintf>
8000a708:	24845a68 	addiu	a0,a0,23144
		if ( REG32(BIST_FAIL) != 0x00000000) { printf( " ==>FAIL FAIL \n"); }	
8000a70c:	3c02b800 	lui	v0,0xb800
8000a710:	34420220 	ori	v0,v0,0x220
8000a714:	8c420000 	lw	v0,0(v0)
8000a718:	10400004 	beqz	v0,8000a72c <Cmd_AllBistTest+0x328>
8000a71c:	00000000 	nop
8000a720:	3c048001 	lui	a0,0x8001
8000a724:	0c002325 	jal	80008c94 <dprintf>
8000a728:	24845a78 	addiu	a0,a0,23160
	}	
		
	//============================================
	printf( "============================== \n");
8000a72c:	3c048001 	lui	a0,0x8001
8000a730:	0c002325 	jal	80008c94 <dprintf>
8000a734:	24845b30 	addiu	a0,a0,23344
	printf( "Mode 4 BIST :switch\n");
8000a738:	3c048001 	lui	a0,0x8001
8000a73c:	0c002325 	jal	80008c94 <dprintf>
8000a740:	24845b54 	addiu	a0,a0,23380
	REG32(BIST_CTRL) = 0;
8000a744:	3c13b800 	lui	s3,0xb800
8000a748:	36700200 	ori	s0,s3,0x200
8000a74c:	ae000000 	sw	zero,0(s0)
		printf( "W:BIST_CTRL=%08x \n", REG32(BIST_CTRL) );	
8000a750:	8e050000 	lw	a1,0(s0)
8000a754:	3c128001 	lui	s2,0x8001
8000a758:	0c002325 	jal	80008c94 <dprintf>
8000a75c:	26445af4 	addiu	a0,s2,23284
	REG32(BIST_CTRL) |=  (0x01);
8000a760:	8e020000 	lw	v0,0(s0)
8000a764:	34420001 	ori	v0,v0,0x1
8000a768:	ae020000 	sw	v0,0(s0)
		printf( "W:BIST_CTRL=%08x \n", REG32(BIST_CTRL) );
8000a76c:	8e050000 	lw	a1,0(s0)
8000a770:	0c002325 	jal	80008c94 <dprintf>
8000a774:	26445af4 	addiu	a0,s2,23284
	REG32(BIST_CTRL) |=  (1<<26);
8000a778:	8e030000 	lw	v1,0(s0)
8000a77c:	3c020400 	lui	v0,0x400
8000a780:	00621025 	or	v0,v1,v0
8000a784:	ae020000 	sw	v0,0(s0)
		printf( "W:BIST_CTRL=%08x \n", REG32(BIST_CTRL) );
8000a788:	8e050000 	lw	a1,0(s0)
8000a78c:	0c002325 	jal	80008c94 <dprintf>
8000a790:	26445af4 	addiu	a0,s2,23284
	    
	delay_ms(10);  
8000a794:	0c002219 	jal	80008864 <delay_ms>
8000a798:	2404000a 	li	a0,10
	printf( "\n");
8000a79c:	3c048001 	lui	a0,0x8001
8000a7a0:	0c002325 	jal	80008c94 <dprintf>
8000a7a4:	248457b8 	addiu	a0,a0,22456
	printf( "R:BIST DONE=%08x \n", REG32(BIST_DONE));
8000a7a8:	36700210 	ori	s0,s3,0x210
8000a7ac:	8e050000 	lw	a1,0(s0)
8000a7b0:	3c048001 	lui	a0,0x8001
8000a7b4:	0c002325 	jal	80008c94 <dprintf>
8000a7b8:	24845b08 	addiu	a0,a0,23304
	printf( "R:BIST FAIL=%08x \n", REG32(BIST_FAIL));
8000a7bc:	36730220 	ori	s3,s3,0x220
8000a7c0:	8e650000 	lw	a1,0(s3)
8000a7c4:	3c048001 	lui	a0,0x8001
8000a7c8:	0c002325 	jal	80008c94 <dprintf>
8000a7cc:	24845b1c 	addiu	a0,a0,23324


	
	if ( (REG32(BIST_DONE) == 0xffff4418) && 
8000a7d0:	8e030000 	lw	v1,0(s0)
8000a7d4:	3c02ffff 	lui	v0,0xffff
8000a7d8:	34424418 	ori	v0,v0,0x4418
8000a7dc:	14620009 	bne	v1,v0,8000a804 <Cmd_AllBistTest+0x400>
8000a7e0:	00000000 	nop
		( REG32(BIST_FAIL) == 0x00000000)) { printf( " ==>BIST PASS \n"); }	 
8000a7e4:	8e620000 	lw	v0,0(s3)
	printf( "R:BIST DONE=%08x \n", REG32(BIST_DONE));
	printf( "R:BIST FAIL=%08x \n", REG32(BIST_FAIL));


	
	if ( (REG32(BIST_DONE) == 0xffff4418) && 
8000a7e8:	14400006 	bnez	v0,8000a804 <Cmd_AllBistTest+0x400>
8000a7ec:	00000000 	nop
		( REG32(BIST_FAIL) == 0x00000000)) { printf( " ==>BIST PASS \n"); }	 
8000a7f0:	3c048001 	lui	a0,0x8001
8000a7f4:	0c002325 	jal	80008c94 <dprintf>
8000a7f8:	24845a88 	addiu	a0,a0,23176
	printf( "R:BIST DONE=%08x \n", REG32(BIST_DONE));
	printf( "R:BIST FAIL=%08x \n", REG32(BIST_FAIL));


	
	if ( (REG32(BIST_DONE) == 0xffff4418) && 
8000a7fc:	08002a18 	j	8000a860 <Cmd_AllBistTest+0x45c>
8000a800:	3c048001 	lui	a0,0x8001
		( REG32(BIST_FAIL) == 0x00000000)) { printf( " ==>BIST PASS \n"); }	 
	else								   
	{ 	printf( " ==>BIST FAIL \n"); err++;
8000a804:	3c048001 	lui	a0,0x8001
8000a808:	0c002325 	jal	80008c94 <dprintf>
8000a80c:	24845a98 	addiu	a0,a0,23192
8000a810:	26310001 	addiu	s1,s1,1
		if ( REG32(BIST_DONE) != 0xffff4418) { printf( " ==>DONE FAIL \n"); }
8000a814:	3c02b800 	lui	v0,0xb800
8000a818:	34420210 	ori	v0,v0,0x210
8000a81c:	8c430000 	lw	v1,0(v0)
8000a820:	3c02ffff 	lui	v0,0xffff
8000a824:	34424418 	ori	v0,v0,0x4418
8000a828:	10620005 	beq	v1,v0,8000a840 <Cmd_AllBistTest+0x43c>
8000a82c:	3c02b800 	lui	v0,0xb800
8000a830:	3c048001 	lui	a0,0x8001
8000a834:	0c002325 	jal	80008c94 <dprintf>
8000a838:	24845a68 	addiu	a0,a0,23144
		if ( REG32(BIST_FAIL) != 0x00000000) { printf( " ==>FAIL FAIL \n"); }	
8000a83c:	3c02b800 	lui	v0,0xb800
8000a840:	34420220 	ori	v0,v0,0x220
8000a844:	8c420000 	lw	v0,0(v0)
8000a848:	10400004 	beqz	v0,8000a85c <Cmd_AllBistTest+0x458>
8000a84c:	00000000 	nop
8000a850:	3c048001 	lui	a0,0x8001
8000a854:	0c002325 	jal	80008c94 <dprintf>
8000a858:	24845a78 	addiu	a0,a0,23160
	}	 
	//============================================
	printf( "============================== \n");
8000a85c:	3c048001 	lui	a0,0x8001
8000a860:	0c002325 	jal	80008c94 <dprintf>
8000a864:	24845b30 	addiu	a0,a0,23344
	printf( "Mode 5 BIST :switch bist-r \n");
8000a868:	3c048001 	lui	a0,0x8001
8000a86c:	0c002325 	jal	80008c94 <dprintf>
8000a870:	24845b6c 	addiu	a0,a0,23404
	REG32(BIST_CTRL) = 0;
8000a874:	3c13b800 	lui	s3,0xb800
8000a878:	36700200 	ori	s0,s3,0x200
8000a87c:	ae000000 	sw	zero,0(s0)
		printf( "W:BIST_CTRL=%08x \n", REG32(BIST_CTRL) );		
8000a880:	8e050000 	lw	a1,0(s0)
8000a884:	3c128001 	lui	s2,0x8001
8000a888:	0c002325 	jal	80008c94 <dprintf>
8000a88c:	26445af4 	addiu	a0,s2,23284
	REG32(BIST_CTRL) |=  (0x01);
8000a890:	8e020000 	lw	v0,0(s0)
8000a894:	34420001 	ori	v0,v0,0x1
8000a898:	ae020000 	sw	v0,0(s0)
		printf( "W:BIST_CTRL=%08x \n", REG32(BIST_CTRL) );
8000a89c:	8e050000 	lw	a1,0(s0)
8000a8a0:	0c002325 	jal	80008c94 <dprintf>
8000a8a4:	26445af4 	addiu	a0,s2,23284
	REG32(BIST_CTRL) |= (1<<27);
8000a8a8:	8e030000 	lw	v1,0(s0)
8000a8ac:	3c020800 	lui	v0,0x800
8000a8b0:	00621025 	or	v0,v1,v0
8000a8b4:	ae020000 	sw	v0,0(s0)
		printf( "W:BIST_CTRL=%08x \n", REG32(BIST_CTRL) );
8000a8b8:	8e050000 	lw	a1,0(s0)
8000a8bc:	0c002325 	jal	80008c94 <dprintf>
8000a8c0:	26445af4 	addiu	a0,s2,23284
	    
	delay_ms(10);   
8000a8c4:	0c002219 	jal	80008864 <delay_ms>
8000a8c8:	2404000a 	li	a0,10
	printf( "\n");
8000a8cc:	3c048001 	lui	a0,0x8001
8000a8d0:	0c002325 	jal	80008c94 <dprintf>
8000a8d4:	248457b8 	addiu	a0,a0,22456
	printf( "R:BIST DONE=%08x \n", REG32(BIST_DONE) );
8000a8d8:	36700210 	ori	s0,s3,0x210
8000a8dc:	8e050000 	lw	a1,0(s0)
8000a8e0:	3c048001 	lui	a0,0x8001
8000a8e4:	0c002325 	jal	80008c94 <dprintf>
8000a8e8:	24845b08 	addiu	a0,a0,23304
	printf( "R:BIST FAIL=%08x \n", REG32(BIST_FAIL) );
8000a8ec:	36730220 	ori	s3,s3,0x220
8000a8f0:	8e650000 	lw	a1,0(s3)
8000a8f4:	3c048001 	lui	a0,0x8001
8000a8f8:	0c002325 	jal	80008c94 <dprintf>
8000a8fc:	24845b1c 	addiu	a0,a0,23324


	
	if ( (REG32(BIST_DONE) == 0xffff8418) && ( REG32(BIST_FAIL) == 0x00000000)) { printf( " ==>BIST PASS \n"); }	 
8000a900:	8e030000 	lw	v1,0(s0)
8000a904:	24028418 	li	v0,-31720
8000a908:	14620009 	bne	v1,v0,8000a930 <Cmd_AllBistTest+0x52c>
8000a90c:	00000000 	nop
8000a910:	8e620000 	lw	v0,0(s3)
8000a914:	14400006 	bnez	v0,8000a930 <Cmd_AllBistTest+0x52c>
8000a918:	00000000 	nop
8000a91c:	3c048001 	lui	a0,0x8001
8000a920:	0c002325 	jal	80008c94 <dprintf>
8000a924:	24845a88 	addiu	a0,a0,23176
8000a928:	08002a62 	j	8000a988 <Cmd_AllBistTest+0x584>
8000a92c:	3c048001 	lui	a0,0x8001
	else 							
	{ 	printf( " ==>BIST FAIL \n");  err++;
8000a930:	3c048001 	lui	a0,0x8001
8000a934:	0c002325 	jal	80008c94 <dprintf>
8000a938:	24845a98 	addiu	a0,a0,23192
8000a93c:	26310001 	addiu	s1,s1,1
		if ( REG32(BIST_DONE) != 0xffff8418) { printf( " ==>DONE FAIL \n"); }
8000a940:	3c02b800 	lui	v0,0xb800
8000a944:	34420210 	ori	v0,v0,0x210
8000a948:	8c430000 	lw	v1,0(v0)
8000a94c:	24028418 	li	v0,-31720
8000a950:	10620005 	beq	v1,v0,8000a968 <Cmd_AllBistTest+0x564>
8000a954:	3c02b800 	lui	v0,0xb800
8000a958:	3c048001 	lui	a0,0x8001
8000a95c:	0c002325 	jal	80008c94 <dprintf>
8000a960:	24845a68 	addiu	a0,a0,23144
		if ( REG32(BIST_FAIL) != 0x00000000) { printf( " ==>FAIL FAIL \n"); }	
8000a964:	3c02b800 	lui	v0,0xb800
8000a968:	34420220 	ori	v0,v0,0x220
8000a96c:	8c420000 	lw	v0,0(v0)
8000a970:	10400004 	beqz	v0,8000a984 <Cmd_AllBistTest+0x580>
8000a974:	00000000 	nop
8000a978:	3c048001 	lui	a0,0x8001
8000a97c:	0c002325 	jal	80008c94 <dprintf>
8000a980:	24845a78 	addiu	a0,a0,23160
		{ printf( " ==>DRF PASS \n"); }	 
	printf( "============================== \n");	    
#endif
		
		
	printf( "============================== \n");
8000a984:	3c048001 	lui	a0,0x8001
8000a988:	0c002325 	jal	80008c94 <dprintf>
8000a98c:	24845b30 	addiu	a0,a0,23344
	printf( "Mode x DRF_BIST TEST : IP \n");
8000a990:	3c048001 	lui	a0,0x8001
8000a994:	0c002325 	jal	80008c94 <dprintf>
8000a998:	24845b8c 	addiu	a0,a0,23436
	REG32( 0xb800020c)=0x001e0000;
8000a99c:	3c10b800 	lui	s0,0xb800
8000a9a0:	3602020c 	ori	v0,s0,0x20c
8000a9a4:	3c03001e 	lui	v1,0x1e
8000a9a8:	ac430000 	sw	v1,0(v0)
	REG32( 0xb8000200)=0x00000002;
8000a9ac:	36020200 	ori	v0,s0,0x200
8000a9b0:	24030002 	li	v1,2
8000a9b4:	ac430000 	sw	v1,0(v0)
//	REG32( 0xb8000208)=0x007f007f;   //skip mbr
	//
	REG32( 0xb8000200)=0x0fff0002;
8000a9b8:	3c030fff 	lui	v1,0xfff
8000a9bc:	34630002 	ori	v1,v1,0x2
8000a9c0:	ac430000 	sw	v1,0(v0)


	printf( "4.pause\n");    
8000a9c4:	3c048001 	lui	a0,0x8001
8000a9c8:	0c002325 	jal	80008c94 <dprintf>
8000a9cc:	24845ba8 	addiu	a0,a0,23464
	printf( " R:DRF_PAUSE=%08x \n", REG32(DRF_PAUSE    ));
8000a9d0:	36140270 	ori	s4,s0,0x270
8000a9d4:	8e850000 	lw	a1,0(s4)
8000a9d8:	3c158001 	lui	s5,0x8001
8000a9dc:	0c002325 	jal	80008c94 <dprintf>
8000a9e0:	26a45bb4 	addiu	a0,s5,23476
	if ( REG32(HS0_DRF_PAUSE) == 0xffffffff) { printf( " ==>PAUSE PASS \n"); }
	if ( REG32(HS0_DRF_PAUSE) != 0xffffffff) { printf( " ==>PAUSE FAIL \n"); }
#endif


	printf( "5.resume\n");   
8000a9e4:	3c048001 	lui	a0,0x8001
8000a9e8:	0c002325 	jal	80008c94 <dprintf>
8000a9ec:	24845bc8 	addiu	a0,a0,23496
	REG32(DRF_RESUME) = 0xffffffff;
8000a9f0:	36120280 	ori	s2,s0,0x280
8000a9f4:	2413ffff 	li	s3,-1
8000a9f8:	ae530000 	sw	s3,0(s2)
		printf( " W:DRF_RESUME=%08x \n", REG32(DRF_RESUME) );    
8000a9fc:	8e450000 	lw	a1,0(s2)
8000aa00:	3c168001 	lui	s6,0x8001
8000aa04:	0c002325 	jal	80008c94 <dprintf>
8000aa08:	26c45bd4 	addiu	a0,s6,23508

	printf( "6.two pause\n");      
8000aa0c:	3c048001 	lui	a0,0x8001
8000aa10:	0c002325 	jal	80008c94 <dprintf>
8000aa14:	24845bec 	addiu	a0,a0,23532
	printf( " R:DRF_PAUSE=%08x \n", REG32(DRF_PAUSE) );    
8000aa18:	8e850000 	lw	a1,0(s4)
8000aa1c:	0c002325 	jal	80008c94 <dprintf>
8000aa20:	26a45bb4 	addiu	a0,s5,23476
#if 0 //skip mbr	 
	printf( " R:HS0_DRF_PAUSE=%08x \n", REG32(HS0_DRF_PAUSE ));
	if ( REG32(HS0_DRF_PAUSE) == 0xffffffff) { printf( " ==>PAUSE PASS \n"); }
	if ( REG32(HS0_DRF_PAUSE) != 0xffffffff) { printf( " ==>PAUSE FAIL \n"); }
#endif	    
	printf( "7.two resume\n");    
8000aa24:	3c048001 	lui	a0,0x8001
8000aa28:	0c002325 	jal	80008c94 <dprintf>
8000aa2c:	24845bfc 	addiu	a0,a0,23548
	REG32(DRF_RESUME) = 0xffffffff;
8000aa30:	ae530000 	sw	s3,0(s2)
		printf( " W:DRF_RESUME=%08x \n", REG32(DRF_RESUME ) ); 
8000aa34:	8e450000 	lw	a1,0(s2)
8000aa38:	0c002325 	jal	80008c94 <dprintf>
8000aa3c:	26c45bd4 	addiu	a0,s6,23508
	  
	printf( " R:DRF_DONE=%08x \n", REG32(DRF_DONE) );
8000aa40:	36120290 	ori	s2,s0,0x290
8000aa44:	8e450000 	lw	a1,0(s2)
8000aa48:	3c048001 	lui	a0,0x8001
8000aa4c:	0c002325 	jal	80008c94 <dprintf>
8000aa50:	24845c0c 	addiu	a0,a0,23564
	printf( " R:DRF_FAIL=%08x \n", REG32(DRF_FAIL) );
8000aa54:	361002a0 	ori	s0,s0,0x2a0
8000aa58:	8e050000 	lw	a1,0(s0)
8000aa5c:	3c048001 	lui	a0,0x8001
8000aa60:	0c002325 	jal	80008c94 <dprintf>
8000aa64:	24845c20 	addiu	a0,a0,23584



	if ( (REG32(DRF_DONE)==0xffffffff) &&( REG32(DRF_FAIL)==0) ) 
8000aa68:	8e420000 	lw	v0,0(s2)
8000aa6c:	14530009 	bne	v0,s3,8000aa94 <Cmd_AllBistTest+0x690>
8000aa70:	00000000 	nop
8000aa74:	8e020000 	lw	v0,0(s0)
8000aa78:	14400006 	bnez	v0,8000aa94 <Cmd_AllBistTest+0x690>
8000aa7c:	00000000 	nop
		{ printf( " ==>DRF PASS \n"); }	 
8000aa80:	3c048001 	lui	a0,0x8001
8000aa84:	0c002325 	jal	80008c94 <dprintf>
8000aa88:	24845c34 	addiu	a0,a0,23604
	printf( " R:DRF_DONE=%08x \n", REG32(DRF_DONE) );
	printf( " R:DRF_FAIL=%08x \n", REG32(DRF_FAIL) );



	if ( (REG32(DRF_DONE)==0xffffffff) &&( REG32(DRF_FAIL)==0) ) 
8000aa8c:	08002aba 	j	8000aae8 <Cmd_AllBistTest+0x6e4>
8000aa90:	00000000 	nop
		{ printf( " ==>DRF PASS \n"); }	 
	else	
	{ 
		printf( " ==>DRF FAIL \n");  err++;
8000aa94:	3c048001 	lui	a0,0x8001
8000aa98:	0c002325 	jal	80008c94 <dprintf>
8000aa9c:	24845c44 	addiu	a0,a0,23620
8000aaa0:	26310001 	addiu	s1,s1,1
		if ( REG32(DRF_DONE) != 0xffffffff) { printf( " ==>DRF DONE FAIL \n"); }	    
8000aaa4:	3c02b800 	lui	v0,0xb800
8000aaa8:	34420290 	ori	v0,v0,0x290
8000aaac:	8c430000 	lw	v1,0(v0)
8000aab0:	2402ffff 	li	v0,-1
8000aab4:	10620005 	beq	v1,v0,8000aacc <Cmd_AllBistTest+0x6c8>
8000aab8:	3c02b800 	lui	v0,0xb800
8000aabc:	3c048001 	lui	a0,0x8001
8000aac0:	0c002325 	jal	80008c94 <dprintf>
8000aac4:	24845c54 	addiu	a0,a0,23636
		if ( REG32(DRF_FAIL) != 0) { printf( " ==>FAIL FAIL \n"); }		
8000aac8:	3c02b800 	lui	v0,0xb800
8000aacc:	344202a0 	ori	v0,v0,0x2a0
8000aad0:	8c420000 	lw	v0,0(v0)
8000aad4:	10400004 	beqz	v0,8000aae8 <Cmd_AllBistTest+0x6e4>
8000aad8:	00000000 	nop
8000aadc:	3c048001 	lui	a0,0x8001
8000aae0:	0c002325 	jal	80008c94 <dprintf>
8000aae4:	24845a78 	addiu	a0,a0,23160
	}	


	if(err==0)
8000aae8:	16200005 	bnez	s1,8000ab00 <Cmd_AllBistTest+0x6fc>
8000aaec:	3c048001 	lui	a0,0x8001
		printf("==> IP BIST ALL PASS <== \n");
8000aaf0:	0c002325 	jal	80008c94 <dprintf>
8000aaf4:	24845c68 	addiu	a0,a0,23656
	else
		printf("==> IP BIST FAIL count=%d <== \n", err);		

}
8000aaf8:	08002ac5 	j	8000ab14 <Cmd_AllBistTest+0x710>
8000aafc:	8fbf002c 	lw	ra,44(sp)


	if(err==0)
		printf("==> IP BIST ALL PASS <== \n");
	else
		printf("==> IP BIST FAIL count=%d <== \n", err);		
8000ab00:	3c048001 	lui	a0,0x8001
8000ab04:	24845c84 	addiu	a0,a0,23684
8000ab08:	0c002325 	jal	80008c94 <dprintf>
8000ab0c:	02202821 	move	a1,s1

}
8000ab10:	8fbf002c 	lw	ra,44(sp)
8000ab14:	8fb60028 	lw	s6,40(sp)
8000ab18:	8fb50024 	lw	s5,36(sp)
8000ab1c:	8fb40020 	lw	s4,32(sp)
8000ab20:	8fb3001c 	lw	s3,28(sp)
8000ab24:	8fb20018 	lw	s2,24(sp)
8000ab28:	8fb10014 	lw	s1,20(sp)
8000ab2c:	8fb00010 	lw	s0,16(sp)
8000ab30:	03e00008 	jr	ra
8000ab34:	27bd0030 	addiu	sp,sp,48

8000ab38 <GPHY_DRF_BIST>:
	else
		printf("==> GPHY BIST FAIL count=%d <== \n", err);				
}
//=============================================================================
int GPHY_DRF_BIST(int argc, char* argv[])
{
8000ab38:	27bdffb0 	addiu	sp,sp,-80
8000ab3c:	afbf004c 	sw	ra,76(sp)
8000ab40:	afbe0048 	sw	s8,72(sp)
8000ab44:	afb70044 	sw	s7,68(sp)
8000ab48:	afb60040 	sw	s6,64(sp)
8000ab4c:	afb5003c 	sw	s5,60(sp)
8000ab50:	afb40038 	sw	s4,56(sp)
8000ab54:	afb30034 	sw	s3,52(sp)
8000ab58:	afb20030 	sw	s2,48(sp)
8000ab5c:	afb1002c 	sw	s1,44(sp)
8000ab60:	afb00028 	sw	s0,40(sp)
	volatile unsigned int phyid=4,rdat=0;
8000ab64:	24020004 	li	v0,4
8000ab68:	afa20018 	sw	v0,24(sp)
8000ab6c:	afa0001c 	sw	zero,28(sp)
	int i;
	int err=0;

//	dprintf("Set P0-P4 force mode...... \n");
	REG32(0xbb804104)= 0x427f0038;
8000ab70:	3c02bb80 	lui	v0,0xbb80
8000ab74:	34434104 	ori	v1,v0,0x4104
8000ab78:	3c04427f 	lui	a0,0x427f
8000ab7c:	34840038 	ori	a0,a0,0x38
8000ab80:	ac640000 	sw	a0,0(v1)
	REG32(0xbb804108)= 0x467f0038;
8000ab84:	34434108 	ori	v1,v0,0x4108
8000ab88:	3c04467f 	lui	a0,0x467f
8000ab8c:	34840038 	ori	a0,a0,0x38
8000ab90:	ac640000 	sw	a0,0(v1)
	REG32(0xbb80410c)= 0x4a7f0038;
8000ab94:	3443410c 	ori	v1,v0,0x410c
8000ab98:	3c044a7f 	lui	a0,0x4a7f
8000ab9c:	34840038 	ori	a0,a0,0x38
8000aba0:	ac640000 	sw	a0,0(v1)
	REG32(0xbb804110)= 0x4e7f0038;
8000aba4:	34434110 	ori	v1,v0,0x4110
8000aba8:	3c044e7f 	lui	a0,0x4e7f
8000abac:	34840038 	ori	a0,a0,0x38
8000abb0:	ac640000 	sw	a0,0(v1)
	REG32(0xbb804114)= 0x527f0038;
8000abb4:	34434114 	ori	v1,v0,0x4114
8000abb8:	3c04527f 	lui	a0,0x527f
8000abbc:	34840038 	ori	a0,a0,0x38
8000abc0:	ac640000 	sw	a0,0(v1)
	REG32(0xbb804118)= 0x566f0038;
8000abc4:	34424118 	ori	v0,v0,0x4118
8000abc8:	3c03566f 	lui	v1,0x566f
8000abcc:	34630038 	ori	v1,v1,0x38
8000abd0:	ac430000 	sw	v1,0(v0)
	
//	void Set_GPHYWB(unsigned int phyid, unsigned int page, unsigned int reg, unsigned int mask, unsigned int val)
//	Set_GPHYWB(8, 24, 22, 0, 0x5bd5);
	
		
	Set_GPHYWB(0, 0xc40, 21, 0, 0xc000);
8000abd4:	3410c000 	li	s0,0xc000
8000abd8:	afb00010 	sw	s0,16(sp)
8000abdc:	00002021 	move	a0,zero
8000abe0:	24050c40 	li	a1,3136
8000abe4:	24060015 	li	a2,21
8000abe8:	0c00098a 	jal	80002628 <Set_GPHYWB>
8000abec:	00003821 	move	a3,zero
	Set_GPHYWB(0, 0xa00, 23, 0, 0xc000);
8000abf0:	afb00010 	sw	s0,16(sp)
8000abf4:	00002021 	move	a0,zero
8000abf8:	24050a00 	li	a1,2560
8000abfc:	24060017 	li	a2,23
8000ac00:	0c00098a 	jal	80002628 <Set_GPHYWB>
8000ac04:	00003821 	move	a3,zero

	rtl8651_setAsicEthernetPHYReg(0, 23, 0x0120 );		
8000ac08:	00002021 	move	a0,zero
8000ac0c:	24050017 	li	a1,23
8000ac10:	0c000941 	jal	80002504 <rtl8651_setAsicEthernetPHYReg>
8000ac14:	24060120 	li	a2,288
	
	//
	Set_GPHYWB(0, 0xb81, 18, 0, 0x0000);
8000ac18:	afa00010 	sw	zero,16(sp)
8000ac1c:	00002021 	move	a0,zero
8000ac20:	24050b81 	li	a1,2945
8000ac24:	24060012 	li	a2,18
8000ac28:	0c00098a 	jal	80002628 <Set_GPHYWB>
8000ac2c:	00003821 	move	a3,zero
	rtl8651_setAsicEthernetPHYReg(0, 18, 0x0005 );		
8000ac30:	00002021 	move	a0,zero
8000ac34:	24050012 	li	a1,18
8000ac38:	0c000941 	jal	80002504 <rtl8651_setAsicEthernetPHYReg>
8000ac3c:	24060005 	li	a2,5

	Set_GPHYWB(0, 0xc84, 22, 0, 0x0000);			
8000ac40:	afa00010 	sw	zero,16(sp)
8000ac44:	00002021 	move	a0,zero
8000ac48:	24050c84 	li	a1,3204
8000ac4c:	24060016 	li	a2,22
8000ac50:	0c00098a 	jal	80002628 <Set_GPHYWB>
8000ac54:	00003821 	move	a3,zero
	rtl8651_setAsicEthernetPHYReg(0, 22, 0x0007 );		
8000ac58:	00002021 	move	a0,zero
8000ac5c:	24050016 	li	a1,22
8000ac60:	0c000941 	jal	80002504 <rtl8651_setAsicEthernetPHYReg>
8000ac64:	24060007 	li	a2,7


	delay_ms(1000);
8000ac68:	0c002219 	jal	80008864 <delay_ms>
8000ac6c:	240403e8 	li	a0,1000

	
	//resume
	Set_GPHYWB(0, 0xa00, 23, 0xffff, 0x0040);
8000ac70:	24100040 	li	s0,64
8000ac74:	afb00010 	sw	s0,16(sp)
8000ac78:	00002021 	move	a0,zero
8000ac7c:	24050a00 	li	a1,2560
8000ac80:	24060017 	li	a2,23
8000ac84:	0c00098a 	jal	80002628 <Set_GPHYWB>
8000ac88:	3407ffff 	li	a3,0xffff
	Set_GPHYWB(0, 0xa00, 23, 0xffbf, 0x0000);
8000ac8c:	afa00010 	sw	zero,16(sp)
8000ac90:	00002021 	move	a0,zero
8000ac94:	24050a00 	li	a1,2560
8000ac98:	24060017 	li	a2,23
8000ac9c:	0c00098a 	jal	80002628 <Set_GPHYWB>
8000aca0:	3407ffbf 	li	a3,0xffbf
	Set_GPHYWB(0, 0xb81, 18, 0xffff, 0x0400);
8000aca4:	24110400 	li	s1,1024
8000aca8:	afb10010 	sw	s1,16(sp)
8000acac:	00002021 	move	a0,zero
8000acb0:	24050b81 	li	a1,2945
8000acb4:	24060012 	li	a2,18
8000acb8:	0c00098a 	jal	80002628 <Set_GPHYWB>
8000acbc:	3407ffff 	li	a3,0xffff
	Set_GPHYWB(0, 0xc84, 23, 0xffff, 0x1000);			
8000acc0:	24121000 	li	s2,4096
8000acc4:	afb20010 	sw	s2,16(sp)
8000acc8:	00002021 	move	a0,zero
8000accc:	24050c84 	li	a1,3204
8000acd0:	24060017 	li	a2,23
8000acd4:	0c00098a 	jal	80002628 <Set_GPHYWB>
8000acd8:	3407ffff 	li	a3,0xffff
	
	
	delay_ms(1000);
8000acdc:	0c002219 	jal	80008864 <delay_ms>
8000ace0:	240403e8 	li	a0,1000
	Set_GPHYWB(0, 0xa00, 23, 0xffff, 0x0040);
8000ace4:	afb00010 	sw	s0,16(sp)
8000ace8:	00002021 	move	a0,zero
8000acec:	24050a00 	li	a1,2560
8000acf0:	24060017 	li	a2,23
8000acf4:	0c00098a 	jal	80002628 <Set_GPHYWB>
8000acf8:	3407ffff 	li	a3,0xffff
	Set_GPHYWB(0, 0xa00, 23, 0xffbf, 0x0000);
8000acfc:	afa00010 	sw	zero,16(sp)
8000ad00:	00002021 	move	a0,zero
8000ad04:	24050a00 	li	a1,2560
8000ad08:	24060017 	li	a2,23
8000ad0c:	0c00098a 	jal	80002628 <Set_GPHYWB>
8000ad10:	3407ffbf 	li	a3,0xffbf
	Set_GPHYWB(0, 0xb81, 18, 0xffff, 0x0400);
8000ad14:	afb10010 	sw	s1,16(sp)
8000ad18:	00002021 	move	a0,zero
8000ad1c:	24050b81 	li	a1,2945
8000ad20:	24060012 	li	a2,18
8000ad24:	0c00098a 	jal	80002628 <Set_GPHYWB>
8000ad28:	3407ffff 	li	a3,0xffff
	Set_GPHYWB(0, 0xc84, 23, 0xffff, 0x1000);
8000ad2c:	afb20010 	sw	s2,16(sp)
8000ad30:	00002021 	move	a0,zero
8000ad34:	24050c84 	li	a1,3204
8000ad38:	24060017 	li	a2,23
8000ad3c:	0c00098a 	jal	80002628 <Set_GPHYWB>
8000ad40:	3407ffff 	li	a3,0xffff
	
	delay_ms(1000);
8000ad44:	0c002219 	jal	80008864 <delay_ms>
8000ad48:	240403e8 	li	a0,1000
8000ad4c:	00008821 	move	s1,zero
8000ad50:	00008021 	move	s0,zero
	{	
		if(i==0) phyid=8;
		else phyid=i;
		
		rtl8651_setAsicEthernetPHYReg(phyid, 31,0x0a00 );
		rtl8651_getAsicEthernetPHYReg(phyid, 23, &rdat );	
8000ad54:	27b3001c 	addiu	s3,sp,28
		printf("get data=%x\n", rdat);
8000ad58:	3c128001 	lui	s2,0x8001
8000ad5c:	26525ca4 	addiu	s2,s2,23716
		
		if((rdat&(0xf<<9))== (0x4<<9)) 	printf("Port %d BIST PASS\n",i);
8000ad60:	24150800 	li	s5,2048
		else 			{ printf("Port %d BIST FAIL\n",i);  err++; }
8000ad64:	3c148001 	lui	s4,0x8001
8000ad68:	26945cc8 	addiu	s4,s4,23752
		
		rtl8651_setAsicEthernetPHYReg(phyid, 31,0x0a00 );
		rtl8651_getAsicEthernetPHYReg(phyid, 23, &rdat );	
		printf("get data=%x\n", rdat);
		
		if((rdat&(0xf<<9))== (0x4<<9)) 	printf("Port %d BIST PASS\n",i);
8000ad6c:	3c028001 	lui	v0,0x8001
8000ad70:	24425cb4 	addiu	v0,v0,23732
8000ad74:	afa20020 	sw	v0,32(sp)
		//
		rtl8651_setAsicEthernetPHYReg(phyid, 31,0x0b81 );
		rtl8651_getAsicEthernetPHYReg(phyid, 18, &rdat );	
		printf("get data=%x\n", rdat);
		
		if((rdat&(0xf<<12))== (0x4<<12)) 	printf("Port %d BIST PASS\n",i);
8000ad78:	24164000 	li	s6,16384
		//
		rtl8651_setAsicEthernetPHYReg(phyid, 31,0x0c84 );
		rtl8651_getAsicEthernetPHYReg(phyid, 23, &rdat );	
		printf("get data=%x\n", rdat);
		
		if((rdat&(0x7<<0))== (0x4<<0)) 	printf("Port %d BIST PASS\n",i);
8000ad7c:	24170004 	li	s7,4
	
	delay_ms(1000);
	

	
	for(i=0;i<5;i++)
8000ad80:	241e0005 	li	s8,5
	{	
		if(i==0) phyid=8;
8000ad84:	16000004 	bnez	s0,8000ad98 <GPHY_DRF_BIST+0x260>
8000ad88:	24020008 	li	v0,8
8000ad8c:	afa20018 	sw	v0,24(sp)
8000ad90:	08002b67 	j	8000ad9c <GPHY_DRF_BIST+0x264>
8000ad94:	00000000 	nop
		else phyid=i;
8000ad98:	afb00018 	sw	s0,24(sp)
		
		rtl8651_setAsicEthernetPHYReg(phyid, 31,0x0a00 );
8000ad9c:	8fa40018 	lw	a0,24(sp)
8000ada0:	2405001f 	li	a1,31
8000ada4:	0c000941 	jal	80002504 <rtl8651_setAsicEthernetPHYReg>
8000ada8:	24060a00 	li	a2,2560
		rtl8651_getAsicEthernetPHYReg(phyid, 23, &rdat );	
8000adac:	8fa40018 	lw	a0,24(sp)
8000adb0:	24050017 	li	a1,23
8000adb4:	0c000933 	jal	800024cc <rtl8651_getAsicEthernetPHYReg>
8000adb8:	02603021 	move	a2,s3
		printf("get data=%x\n", rdat);
8000adbc:	8fa5001c 	lw	a1,28(sp)
8000adc0:	0c002325 	jal	80008c94 <dprintf>
8000adc4:	02402021 	move	a0,s2
		
		if((rdat&(0xf<<9))== (0x4<<9)) 	printf("Port %d BIST PASS\n",i);
8000adc8:	8fa2001c 	lw	v0,28(sp)
8000adcc:	30421e00 	andi	v0,v0,0x1e00
8000add0:	14550006 	bne	v0,s5,8000adec <GPHY_DRF_BIST+0x2b4>
8000add4:	00000000 	nop
8000add8:	8fa40020 	lw	a0,32(sp)
8000addc:	0c002325 	jal	80008c94 <dprintf>
8000ade0:	02002821 	move	a1,s0
8000ade4:	08002b7f 	j	8000adfc <GPHY_DRF_BIST+0x2c4>
8000ade8:	00000000 	nop
		else 			{ printf("Port %d BIST FAIL\n",i);  err++; }
8000adec:	02802021 	move	a0,s4
8000adf0:	0c002325 	jal	80008c94 <dprintf>
8000adf4:	02002821 	move	a1,s0
8000adf8:	26310001 	addiu	s1,s1,1
			
			
		//
		rtl8651_setAsicEthernetPHYReg(phyid, 31,0x0b81 );
8000adfc:	8fa40018 	lw	a0,24(sp)
8000ae00:	2405001f 	li	a1,31
8000ae04:	0c000941 	jal	80002504 <rtl8651_setAsicEthernetPHYReg>
8000ae08:	24060b81 	li	a2,2945
		rtl8651_getAsicEthernetPHYReg(phyid, 18, &rdat );	
8000ae0c:	8fa40018 	lw	a0,24(sp)
8000ae10:	24050012 	li	a1,18
8000ae14:	0c000933 	jal	800024cc <rtl8651_getAsicEthernetPHYReg>
8000ae18:	02603021 	move	a2,s3
		printf("get data=%x\n", rdat);
8000ae1c:	8fa5001c 	lw	a1,28(sp)
8000ae20:	0c002325 	jal	80008c94 <dprintf>
8000ae24:	02402021 	move	a0,s2
		
		if((rdat&(0xf<<12))== (0x4<<12)) 	printf("Port %d BIST PASS\n",i);
8000ae28:	8fa2001c 	lw	v0,28(sp)
8000ae2c:	3042f000 	andi	v0,v0,0xf000
8000ae30:	14560006 	bne	v0,s6,8000ae4c <GPHY_DRF_BIST+0x314>
8000ae34:	00000000 	nop
8000ae38:	8fa40020 	lw	a0,32(sp)
8000ae3c:	0c002325 	jal	80008c94 <dprintf>
8000ae40:	02002821 	move	a1,s0
8000ae44:	08002b97 	j	8000ae5c <GPHY_DRF_BIST+0x324>
8000ae48:	00000000 	nop
		else 			{ printf("Port %d BIST FAIL\n",i);	err++; }
8000ae4c:	02802021 	move	a0,s4
8000ae50:	0c002325 	jal	80008c94 <dprintf>
8000ae54:	02002821 	move	a1,s0
8000ae58:	26310001 	addiu	s1,s1,1
			
		//
		rtl8651_setAsicEthernetPHYReg(phyid, 31,0x0c84 );
8000ae5c:	8fa40018 	lw	a0,24(sp)
8000ae60:	2405001f 	li	a1,31
8000ae64:	0c000941 	jal	80002504 <rtl8651_setAsicEthernetPHYReg>
8000ae68:	24060c84 	li	a2,3204
		rtl8651_getAsicEthernetPHYReg(phyid, 23, &rdat );	
8000ae6c:	8fa40018 	lw	a0,24(sp)
8000ae70:	24050017 	li	a1,23
8000ae74:	0c000933 	jal	800024cc <rtl8651_getAsicEthernetPHYReg>
8000ae78:	02603021 	move	a2,s3
		printf("get data=%x\n", rdat);
8000ae7c:	8fa5001c 	lw	a1,28(sp)
8000ae80:	0c002325 	jal	80008c94 <dprintf>
8000ae84:	02402021 	move	a0,s2
		
		if((rdat&(0x7<<0))== (0x4<<0)) 	printf("Port %d BIST PASS\n",i);
8000ae88:	8fa2001c 	lw	v0,28(sp)
8000ae8c:	30420007 	andi	v0,v0,0x7
8000ae90:	14570006 	bne	v0,s7,8000aeac <GPHY_DRF_BIST+0x374>
8000ae94:	02802021 	move	a0,s4
8000ae98:	8fa40020 	lw	a0,32(sp)
8000ae9c:	0c002325 	jal	80008c94 <dprintf>
8000aea0:	02002821 	move	a1,s0
	
	delay_ms(1000);
	

	
	for(i=0;i<5;i++)
8000aea4:	08002baf 	j	8000aebc <GPHY_DRF_BIST+0x384>
8000aea8:	26100001 	addiu	s0,s0,1
		rtl8651_setAsicEthernetPHYReg(phyid, 31,0x0c84 );
		rtl8651_getAsicEthernetPHYReg(phyid, 23, &rdat );	
		printf("get data=%x\n", rdat);
		
		if((rdat&(0x7<<0))== (0x4<<0)) 	printf("Port %d BIST PASS\n",i);
		else 			{ printf("Port %d BIST FAIL\n",i);	err++; }
8000aeac:	0c002325 	jal	80008c94 <dprintf>
8000aeb0:	02002821 	move	a1,s0
8000aeb4:	26310001 	addiu	s1,s1,1
	
	delay_ms(1000);
	

	
	for(i=0;i<5;i++)
8000aeb8:	26100001 	addiu	s0,s0,1
8000aebc:	161effb1 	bne	s0,s8,8000ad84 <GPHY_DRF_BIST+0x24c>
8000aec0:	24050c40 	li	a1,3136
		if((rdat&(0x7<<0))== (0x4<<0)) 	printf("Port %d BIST PASS\n",i);
		else 			{ printf("Port %d BIST FAIL\n",i);	err++; }
		
	}	
	
	Set_GPHYWB(0, 0xc40, 21, 0, 0x0000);
8000aec4:	afa00010 	sw	zero,16(sp)
8000aec8:	00002021 	move	a0,zero
8000aecc:	24060015 	li	a2,21
8000aed0:	0c00098a 	jal	80002628 <Set_GPHYWB>
8000aed4:	00003821 	move	a3,zero

	
	//=================
	if(err==0)
8000aed8:	16200005 	bnez	s1,8000aef0 <GPHY_DRF_BIST+0x3b8>
8000aedc:	3c048001 	lui	a0,0x8001
		printf("==> GPHY BIST ALL PASS <== \n");
8000aee0:	0c002325 	jal	80008c94 <dprintf>
8000aee4:	24845cdc 	addiu	a0,a0,23772
	else
		printf("==> GPHY BIST FAIL count=%d <== \n", err);	
			
}
8000aee8:	08002bc1 	j	8000af04 <GPHY_DRF_BIST+0x3cc>
8000aeec:	8fbf004c 	lw	ra,76(sp)
	
	//=================
	if(err==0)
		printf("==> GPHY BIST ALL PASS <== \n");
	else
		printf("==> GPHY BIST FAIL count=%d <== \n", err);	
8000aef0:	3c048001 	lui	a0,0x8001
8000aef4:	24845cfc 	addiu	a0,a0,23804
8000aef8:	0c002325 	jal	80008c94 <dprintf>
8000aefc:	02202821 	move	a1,s1
			
}
8000af00:	8fbf004c 	lw	ra,76(sp)
8000af04:	8fbe0048 	lw	s8,72(sp)
8000af08:	8fb70044 	lw	s7,68(sp)
8000af0c:	8fb60040 	lw	s6,64(sp)
8000af10:	8fb5003c 	lw	s5,60(sp)
8000af14:	8fb40038 	lw	s4,56(sp)
8000af18:	8fb30034 	lw	s3,52(sp)
8000af1c:	8fb20030 	lw	s2,48(sp)
8000af20:	8fb1002c 	lw	s1,44(sp)
8000af24:	8fb00028 	lw	s0,40(sp)
8000af28:	03e00008 	jr	ra
8000af2c:	27bd0050 	addiu	sp,sp,80

8000af30 <GPHY_BIST>:

//=========================================================

//=========================================================
int GPHY_BIST(int argc, char* argv[])
{
8000af30:	27bdffa8 	addiu	sp,sp,-88
8000af34:	afbf0054 	sw	ra,84(sp)
8000af38:	afbe0050 	sw	s8,80(sp)
8000af3c:	afb7004c 	sw	s7,76(sp)
8000af40:	afb60048 	sw	s6,72(sp)
8000af44:	afb50044 	sw	s5,68(sp)
8000af48:	afb40040 	sw	s4,64(sp)
8000af4c:	afb3003c 	sw	s3,60(sp)
8000af50:	afb20038 	sw	s2,56(sp)
8000af54:	afb10034 	sw	s1,52(sp)
8000af58:	afb00030 	sw	s0,48(sp)
	volatile unsigned int phyid=4,rdat=0;
8000af5c:	24020004 	li	v0,4
8000af60:	afa20018 	sw	v0,24(sp)
8000af64:	afa0001c 	sw	zero,28(sp)
	int i;
	int err=0;

	dprintf("Set P0-P4 force mode...... \n");
8000af68:	3c048001 	lui	a0,0x8001
8000af6c:	0c002325 	jal	80008c94 <dprintf>
8000af70:	24845d20 	addiu	a0,a0,23840
	REG32(0xbb804104)= 0x427f0038;
8000af74:	3c02bb80 	lui	v0,0xbb80
8000af78:	34434104 	ori	v1,v0,0x4104
8000af7c:	3c04427f 	lui	a0,0x427f
8000af80:	34840038 	ori	a0,a0,0x38
8000af84:	ac640000 	sw	a0,0(v1)
	REG32(0xbb804108)= 0x467f0038;
8000af88:	34434108 	ori	v1,v0,0x4108
8000af8c:	3c04467f 	lui	a0,0x467f
8000af90:	34840038 	ori	a0,a0,0x38
8000af94:	ac640000 	sw	a0,0(v1)
	REG32(0xbb80410c)= 0x4a7f0038;
8000af98:	3443410c 	ori	v1,v0,0x410c
8000af9c:	3c044a7f 	lui	a0,0x4a7f
8000afa0:	34840038 	ori	a0,a0,0x38
8000afa4:	ac640000 	sw	a0,0(v1)
	REG32(0xbb804110)= 0x4e7f0038;
8000afa8:	34434110 	ori	v1,v0,0x4110
8000afac:	3c044e7f 	lui	a0,0x4e7f
8000afb0:	34840038 	ori	a0,a0,0x38
8000afb4:	ac640000 	sw	a0,0(v1)
	REG32(0xbb804114)= 0x527f0038;
8000afb8:	34434114 	ori	v1,v0,0x4114
8000afbc:	3c04527f 	lui	a0,0x527f
8000afc0:	34840038 	ori	a0,a0,0x38
8000afc4:	ac640000 	sw	a0,0(v1)
	REG32(0xbb804118)= 0x566f0038;	
8000afc8:	34424118 	ori	v0,v0,0x4118
8000afcc:	3c03566f 	lui	v1,0x566f
8000afd0:	34630038 	ori	v1,v1,0x38
8000afd4:	ac430000 	sw	v1,0(v0)
	
	//
	rtl8651_setAsicEthernetPHYReg(8, 24, 0x2198 );		
8000afd8:	24040008 	li	a0,8
8000afdc:	24050018 	li	a1,24
8000afe0:	0c000941 	jal	80002504 <rtl8651_setAsicEthernetPHYReg>
8000afe4:	24062198 	li	a2,8600
	rtl8651_setAsicEthernetPHYReg(1, 24, 0x2198 );	
8000afe8:	24040001 	li	a0,1
8000afec:	24050018 	li	a1,24
8000aff0:	0c000941 	jal	80002504 <rtl8651_setAsicEthernetPHYReg>
8000aff4:	24062198 	li	a2,8600
	rtl8651_setAsicEthernetPHYReg(2, 24, 0x2198 );	
8000aff8:	24040002 	li	a0,2
8000affc:	24050018 	li	a1,24
8000b000:	0c000941 	jal	80002504 <rtl8651_setAsicEthernetPHYReg>
8000b004:	24062198 	li	a2,8600
	rtl8651_setAsicEthernetPHYReg(3, 24, 0x2198 );
8000b008:	24040003 	li	a0,3
8000b00c:	24050018 	li	a1,24
8000b010:	0c000941 	jal	80002504 <rtl8651_setAsicEthernetPHYReg>
8000b014:	24062198 	li	a2,8600
	rtl8651_setAsicEthernetPHYReg(4, 24, 0x2198 );	
8000b018:	24040004 	li	a0,4
8000b01c:	24050018 	li	a1,24
8000b020:	0c000941 	jal	80002504 <rtl8651_setAsicEthernetPHYReg>
8000b024:	24062198 	li	a2,8600
	
	//
	Set_GPHYWB(0, 0xA40, 0, 0, 0x1140);
8000b028:	24021140 	li	v0,4416
8000b02c:	afa20010 	sw	v0,16(sp)
8000b030:	00002021 	move	a0,zero
8000b034:	24050a40 	li	a1,2624
8000b038:	00003021 	move	a2,zero
8000b03c:	0c00098a 	jal	80002628 <Set_GPHYWB>
8000b040:	00003821 	move	a3,zero
	Set_GPHYWB(0, 0xA46, 20, 0, 0x0003);	
8000b044:	24020003 	li	v0,3
8000b048:	afa20010 	sw	v0,16(sp)
8000b04c:	00002021 	move	a0,zero
8000b050:	24050a46 	li	a1,2630
8000b054:	24060014 	li	a2,20
8000b058:	0c00098a 	jal	80002628 <Set_GPHYWB>
8000b05c:	00003821 	move	a3,zero
//	Set_GPHYWB(0, 0xA4A, 19, 0, 0x001f);	
//	Set_GPHYWB(0, 0xB80, 23, 0, 0x000e);	
	
	//
	rtl8651_setAsicEthernetPHYReg(0, 31,0x0a42 );		
8000b060:	00002021 	move	a0,zero
8000b064:	2405001f 	li	a1,31
8000b068:	0c000941 	jal	80002504 <rtl8651_setAsicEthernetPHYReg>
8000b06c:	24060a42 	li	a2,2626
8000b070:	00008821 	move	s1,zero
8000b074:	00008021 	move	s0,zero
	for(i=0;i<5;i++)
	{
		if(i==0) phyid=8;
8000b078:	24170008 	li	s7,8
		rtl8651_getAsicEthernetPHYReg(phyid, 16, &rdat );
8000b07c:	27b5001c 	addiu	s5,sp,28
		printf("get data=%x\n", rdat);
8000b080:	3c128001 	lui	s2,0x8001
8000b084:	26525ca4 	addiu	s2,s2,23716
		if((rdat&0x7)==	0x3) 	printf("Port %d PCS ready PASS\n",i);
8000b088:	24130003 	li	s3,3
		else 			{ printf("Port %d PCS ready FAIL\n",i); err++; }
8000b08c:	3c168001 	lui	s6,0x8001
8000b090:	26d65d58 	addiu	s6,s6,23896
	for(i=0;i<5;i++)
	{
		if(i==0) phyid=8;
		rtl8651_getAsicEthernetPHYReg(phyid, 16, &rdat );
		printf("get data=%x\n", rdat);
		if((rdat&0x7)==	0x3) 	printf("Port %d PCS ready PASS\n",i);
8000b094:	3c1e8001 	lui	s8,0x8001
8000b098:	27de5d40 	addiu	s8,s8,23872
//	Set_GPHYWB(0, 0xA4A, 19, 0, 0x001f);	
//	Set_GPHYWB(0, 0xB80, 23, 0, 0x000e);	
	
	//
	rtl8651_setAsicEthernetPHYReg(0, 31,0x0a42 );		
	for(i=0;i<5;i++)
8000b09c:	24140005 	li	s4,5
	{
		if(i==0) phyid=8;
8000b0a0:	16000002 	bnez	s0,8000b0ac <GPHY_BIST+0x17c>
8000b0a4:	00000000 	nop
8000b0a8:	afb70018 	sw	s7,24(sp)
		rtl8651_getAsicEthernetPHYReg(phyid, 16, &rdat );
8000b0ac:	8fa40018 	lw	a0,24(sp)
8000b0b0:	24050010 	li	a1,16
8000b0b4:	0c000933 	jal	800024cc <rtl8651_getAsicEthernetPHYReg>
8000b0b8:	02a03021 	move	a2,s5
		printf("get data=%x\n", rdat);
8000b0bc:	8fa5001c 	lw	a1,28(sp)
8000b0c0:	0c002325 	jal	80008c94 <dprintf>
8000b0c4:	02402021 	move	a0,s2
		if((rdat&0x7)==	0x3) 	printf("Port %d PCS ready PASS\n",i);
8000b0c8:	8fa2001c 	lw	v0,28(sp)
8000b0cc:	30420007 	andi	v0,v0,0x7
8000b0d0:	14530006 	bne	v0,s3,8000b0ec <GPHY_BIST+0x1bc>
8000b0d4:	02c02021 	move	a0,s6
8000b0d8:	03c02021 	move	a0,s8
8000b0dc:	0c002325 	jal	80008c94 <dprintf>
8000b0e0:	02002821 	move	a1,s0
//	Set_GPHYWB(0, 0xA4A, 19, 0, 0x001f);	
//	Set_GPHYWB(0, 0xB80, 23, 0, 0x000e);	
	
	//
	rtl8651_setAsicEthernetPHYReg(0, 31,0x0a42 );		
	for(i=0;i<5;i++)
8000b0e4:	08002c3f 	j	8000b0fc <GPHY_BIST+0x1cc>
8000b0e8:	26100001 	addiu	s0,s0,1
	{
		if(i==0) phyid=8;
		rtl8651_getAsicEthernetPHYReg(phyid, 16, &rdat );
		printf("get data=%x\n", rdat);
		if((rdat&0x7)==	0x3) 	printf("Port %d PCS ready PASS\n",i);
		else 			{ printf("Port %d PCS ready FAIL\n",i); err++; }
8000b0ec:	0c002325 	jal	80008c94 <dprintf>
8000b0f0:	02002821 	move	a1,s0
8000b0f4:	26310001 	addiu	s1,s1,1
//	Set_GPHYWB(0, 0xA4A, 19, 0, 0x001f);	
//	Set_GPHYWB(0, 0xB80, 23, 0, 0x000e);	
	
	//
	rtl8651_setAsicEthernetPHYReg(0, 31,0x0a42 );		
	for(i=0;i<5;i++)
8000b0f8:	26100001 	addiu	s0,s0,1
8000b0fc:	1614ffe8 	bne	s0,s4,8000b0a0 <GPHY_BIST+0x170>
8000b100:	3402c000 	li	v0,0xc000
		if((rdat&0x7)==	0x3) 	printf("Port %d PCS ready PASS\n",i);
		else 			{ printf("Port %d PCS ready FAIL\n",i); err++; }
	}
	
	//3. m3 bist
	Set_GPHYWB(0, 0xc40, 21, 0, 0xc000);
8000b104:	afa20010 	sw	v0,16(sp)
8000b108:	00002021 	move	a0,zero
8000b10c:	24050c40 	li	a1,3136
8000b110:	24060015 	li	a2,21
8000b114:	0c00098a 	jal	80002628 <Set_GPHYWB>
8000b118:	00003821 	move	a3,zero
	Set_GPHYWB(0, 0xA00, 20, 0, 0x0000);	
8000b11c:	afa00010 	sw	zero,16(sp)
8000b120:	00002021 	move	a0,zero
8000b124:	24050a00 	li	a1,2560
8000b128:	24060014 	li	a2,20
8000b12c:	0c00098a 	jal	80002628 <Set_GPHYWB>
8000b130:	00003821 	move	a3,zero
	rtl8651_setAsicEthernetPHYReg(0, 20, 0x0060 );			
8000b134:	00002021 	move	a0,zero
8000b138:	24050014 	li	a1,20
8000b13c:	0c000941 	jal	80002504 <rtl8651_setAsicEthernetPHYReg>
8000b140:	24060060 	li	a2,96
	rtl8651_setAsicEthernetPHYReg(0, 23, 0x0000 );	
8000b144:	00002021 	move	a0,zero
8000b148:	24050017 	li	a1,23
8000b14c:	0c000941 	jal	80002504 <rtl8651_setAsicEthernetPHYReg>
8000b150:	00003021 	move	a2,zero
	rtl8651_setAsicEthernetPHYReg(0, 23, 0x00a0 );	
8000b154:	00002021 	move	a0,zero
8000b158:	24050017 	li	a1,23
8000b15c:	0c000941 	jal	80002504 <rtl8651_setAsicEthernetPHYReg>
8000b160:	240600a0 	li	a2,160
	Set_GPHYWB(0, 0xb81, 18, 0, 0x0000);
8000b164:	afa00010 	sw	zero,16(sp)
8000b168:	00002021 	move	a0,zero
8000b16c:	24050b81 	li	a1,2945
8000b170:	24060012 	li	a2,18
8000b174:	0c00098a 	jal	80002628 <Set_GPHYWB>
8000b178:	00003821 	move	a3,zero
	rtl8651_setAsicEthernetPHYReg(0, 18, 0x001b );					
8000b17c:	00002021 	move	a0,zero
8000b180:	24050012 	li	a1,18
8000b184:	0c000941 	jal	80002504 <rtl8651_setAsicEthernetPHYReg>
8000b188:	2406001b 	li	a2,27
	Set_GPHYWB(0, 0xc84, 22, 0, 0x0000);	
8000b18c:	afa00010 	sw	zero,16(sp)
8000b190:	00002021 	move	a0,zero
8000b194:	24050c84 	li	a1,3204
8000b198:	24060016 	li	a2,22
8000b19c:	0c00098a 	jal	80002628 <Set_GPHYWB>
8000b1a0:	00003821 	move	a3,zero
	rtl8651_setAsicEthernetPHYReg(0, 22, 0x0005 );	
8000b1a4:	00002021 	move	a0,zero
8000b1a8:	24050016 	li	a1,22
8000b1ac:	0c000941 	jal	80002504 <rtl8651_setAsicEthernetPHYReg>
8000b1b0:	24060005 	li	a2,5
	
	delay_ms(100);
8000b1b4:	0c002219 	jal	80008864 <delay_ms>
8000b1b8:	24040064 	li	a0,100
	printf("\n");
8000b1bc:	3c048001 	lui	a0,0x8001
8000b1c0:	0c002325 	jal	80008c94 <dprintf>
8000b1c4:	248457b8 	addiu	a0,a0,22456
8000b1c8:	00008021 	move	s0,zero
	{	
		if(i==0) phyid=8;
		else phyid=i;		
		rtl8651_setAsicEthernetPHYReg(phyid, 31,0x0a00 );
		rtl8651_getAsicEthernetPHYReg(phyid, 23, &rdat );	
		printf("get data=%x\n", rdat);
8000b1cc:	3c128001 	lui	s2,0x8001
8000b1d0:	26525ca4 	addiu	s2,s2,23716
		if((rdat&(0xf<<9))== (0x8<<9)) 	printf("Port %d BIST PASS\n",i);
		else 			{ printf("Port %d BIST FAIL\n",i); err++; }
8000b1d4:	3c148001 	lui	s4,0x8001
8000b1d8:	26945cc8 	addiu	s4,s4,23752
		if(i==0) phyid=8;
		else phyid=i;		
		rtl8651_setAsicEthernetPHYReg(phyid, 31,0x0a00 );
		rtl8651_getAsicEthernetPHYReg(phyid, 23, &rdat );	
		printf("get data=%x\n", rdat);
		if((rdat&(0xf<<9))== (0x8<<9)) 	printf("Port %d BIST PASS\n",i);
8000b1dc:	3c028001 	lui	v0,0x8001
8000b1e0:	24425cb4 	addiu	v0,v0,23732
8000b1e4:	afa20020 	sw	v0,32(sp)
			
		//	
		rtl8651_getAsicEthernetPHYReg(phyid, 22, &rdat );	
		printf("get data=%x\n", rdat);
		if(rdat== 0xd279) 	printf("Port %d BIST_ROM [31:16] PASS\n",i);
		else 			{ printf("Port %d BIST_ROM [31:16] FAIL\n",i);	err++; }
8000b1e8:	3c158001 	lui	s5,0x8001
8000b1ec:	26b55d90 	addiu	s5,s5,23952
			
			
		//	
		rtl8651_getAsicEthernetPHYReg(phyid, 22, &rdat );	
		printf("get data=%x\n", rdat);
		if(rdat== 0xd279) 	printf("Port %d BIST_ROM [31:16] PASS\n",i);
8000b1f0:	3c028001 	lui	v0,0x8001
8000b1f4:	24425d70 	addiu	v0,v0,23920
8000b1f8:	afa20024 	sw	v0,36(sp)
			
		//
		rtl8651_getAsicEthernetPHYReg(phyid, 21, &rdat );	
		printf("get data=%x\n", rdat);
		if(rdat== 0xa555) 	printf("Port %d BIST_ROM [15:0] PASS\n",i);
		else 			{ printf("Port %d BIST_ROM [15:0] FAIL\n",i);	err++; }
8000b1fc:	3c168001 	lui	s6,0x8001
8000b200:	26d65dd0 	addiu	s6,s6,24016
		else 			{ printf("Port %d BIST_ROM [31:16] FAIL\n",i);	err++; }
			
		//
		rtl8651_getAsicEthernetPHYReg(phyid, 21, &rdat );	
		printf("get data=%x\n", rdat);
		if(rdat== 0xa555) 	printf("Port %d BIST_ROM [15:0] PASS\n",i);
8000b204:	3c028001 	lui	v0,0x8001
8000b208:	24425db0 	addiu	v0,v0,23984
8000b20c:	afa20028 	sw	v0,40(sp)
		
		rtl8651_setAsicEthernetPHYReg(phyid, 31,0x0b81 );
		rtl8651_getAsicEthernetPHYReg(phyid, 18, &rdat );				
		printf("get data=%x\n", rdat);
		if((rdat&(0xf<<12))== (0x1<<12)) 	printf("Port %d GPHY BIST PASS\n",i);
		else 			{		printf("Port %d GPHY BIST FAIL\n",i);	err++; }
8000b210:	3c138001 	lui	s3,0x8001
8000b214:	26735e08 	addiu	s3,s3,24072
		else 			{ printf("Port %d BIST_ROM [15:0] FAIL\n",i);	err++; }
		
		rtl8651_setAsicEthernetPHYReg(phyid, 31,0x0b81 );
		rtl8651_getAsicEthernetPHYReg(phyid, 18, &rdat );				
		printf("get data=%x\n", rdat);
		if((rdat&(0xf<<12))== (0x1<<12)) 	printf("Port %d GPHY BIST PASS\n",i);
8000b218:	3c1e8001 	lui	s8,0x8001
8000b21c:	27de5df0 	addiu	s8,s8,24048
			
			
		rtl8651_getAsicEthernetPHYReg(phyid, 19, &rdat );				
		printf("get data=%x\n", rdat);
		if(rdat== 0x2c34) 	printf("Port %d GPHY BIST_ROM PASS\n",i);
		else 			{ printf("Port %d GPHY BIST_ROM FAIL\n",i);	err++; }
8000b220:	3c178001 	lui	s7,0x8001
8000b224:	26f75e3c 	addiu	s7,s7,24124
		else 			{		printf("Port %d GPHY BIST FAIL\n",i);	err++; }
			
			
		rtl8651_getAsicEthernetPHYReg(phyid, 19, &rdat );				
		printf("get data=%x\n", rdat);
		if(rdat== 0x2c34) 	printf("Port %d GPHY BIST_ROM PASS\n",i);
8000b228:	3c028001 	lui	v0,0x8001
8000b22c:	24425e20 	addiu	v0,v0,24096
8000b230:	afa2002c 	sw	v0,44(sp)
	delay_ms(100);
	printf("\n");
	
	for(i=0;i<5;i++)
	{	
		if(i==0) phyid=8;
8000b234:	16000004 	bnez	s0,8000b248 <GPHY_BIST+0x318>
8000b238:	24020008 	li	v0,8
8000b23c:	afa20018 	sw	v0,24(sp)
8000b240:	08002c93 	j	8000b24c <GPHY_BIST+0x31c>
8000b244:	00000000 	nop
		else phyid=i;		
8000b248:	afb00018 	sw	s0,24(sp)
		rtl8651_setAsicEthernetPHYReg(phyid, 31,0x0a00 );
8000b24c:	8fa40018 	lw	a0,24(sp)
8000b250:	2405001f 	li	a1,31
8000b254:	0c000941 	jal	80002504 <rtl8651_setAsicEthernetPHYReg>
8000b258:	24060a00 	li	a2,2560
		rtl8651_getAsicEthernetPHYReg(phyid, 23, &rdat );	
8000b25c:	8fa40018 	lw	a0,24(sp)
8000b260:	24050017 	li	a1,23
8000b264:	0c000933 	jal	800024cc <rtl8651_getAsicEthernetPHYReg>
8000b268:	27a6001c 	addiu	a2,sp,28
		printf("get data=%x\n", rdat);
8000b26c:	8fa5001c 	lw	a1,28(sp)
8000b270:	0c002325 	jal	80008c94 <dprintf>
8000b274:	02402021 	move	a0,s2
		if((rdat&(0xf<<9))== (0x8<<9)) 	printf("Port %d BIST PASS\n",i);
8000b278:	8fa3001c 	lw	v1,28(sp)
8000b27c:	30631e00 	andi	v1,v1,0x1e00
8000b280:	24021000 	li	v0,4096
8000b284:	14620006 	bne	v1,v0,8000b2a0 <GPHY_BIST+0x370>
8000b288:	00000000 	nop
8000b28c:	8fa40020 	lw	a0,32(sp)
8000b290:	0c002325 	jal	80008c94 <dprintf>
8000b294:	02002821 	move	a1,s0
8000b298:	08002cac 	j	8000b2b0 <GPHY_BIST+0x380>
8000b29c:	00000000 	nop
		else 			{ printf("Port %d BIST FAIL\n",i); err++; }
8000b2a0:	02802021 	move	a0,s4
8000b2a4:	0c002325 	jal	80008c94 <dprintf>
8000b2a8:	02002821 	move	a1,s0
8000b2ac:	26310001 	addiu	s1,s1,1
			
			
		//	
		rtl8651_getAsicEthernetPHYReg(phyid, 22, &rdat );	
8000b2b0:	8fa40018 	lw	a0,24(sp)
8000b2b4:	24050016 	li	a1,22
8000b2b8:	0c000933 	jal	800024cc <rtl8651_getAsicEthernetPHYReg>
8000b2bc:	27a6001c 	addiu	a2,sp,28
		printf("get data=%x\n", rdat);
8000b2c0:	8fa5001c 	lw	a1,28(sp)
8000b2c4:	0c002325 	jal	80008c94 <dprintf>
8000b2c8:	02402021 	move	a0,s2
		if(rdat== 0xd279) 	printf("Port %d BIST_ROM [31:16] PASS\n",i);
8000b2cc:	8fa3001c 	lw	v1,28(sp)
8000b2d0:	3402d279 	li	v0,0xd279
8000b2d4:	14620006 	bne	v1,v0,8000b2f0 <GPHY_BIST+0x3c0>
8000b2d8:	00000000 	nop
8000b2dc:	8fa40024 	lw	a0,36(sp)
8000b2e0:	0c002325 	jal	80008c94 <dprintf>
8000b2e4:	02002821 	move	a1,s0
8000b2e8:	08002cc0 	j	8000b300 <GPHY_BIST+0x3d0>
8000b2ec:	00000000 	nop
		else 			{ printf("Port %d BIST_ROM [31:16] FAIL\n",i);	err++; }
8000b2f0:	02a02021 	move	a0,s5
8000b2f4:	0c002325 	jal	80008c94 <dprintf>
8000b2f8:	02002821 	move	a1,s0
8000b2fc:	26310001 	addiu	s1,s1,1
			
		//
		rtl8651_getAsicEthernetPHYReg(phyid, 21, &rdat );	
8000b300:	8fa40018 	lw	a0,24(sp)
8000b304:	24050015 	li	a1,21
8000b308:	0c000933 	jal	800024cc <rtl8651_getAsicEthernetPHYReg>
8000b30c:	27a6001c 	addiu	a2,sp,28
		printf("get data=%x\n", rdat);
8000b310:	8fa5001c 	lw	a1,28(sp)
8000b314:	0c002325 	jal	80008c94 <dprintf>
8000b318:	02402021 	move	a0,s2
		if(rdat== 0xa555) 	printf("Port %d BIST_ROM [15:0] PASS\n",i);
8000b31c:	8fa3001c 	lw	v1,28(sp)
8000b320:	3402a555 	li	v0,0xa555
8000b324:	14620006 	bne	v1,v0,8000b340 <GPHY_BIST+0x410>
8000b328:	00000000 	nop
8000b32c:	8fa40028 	lw	a0,40(sp)
8000b330:	0c002325 	jal	80008c94 <dprintf>
8000b334:	02002821 	move	a1,s0
8000b338:	08002cd4 	j	8000b350 <GPHY_BIST+0x420>
8000b33c:	00000000 	nop
		else 			{ printf("Port %d BIST_ROM [15:0] FAIL\n",i);	err++; }
8000b340:	02c02021 	move	a0,s6
8000b344:	0c002325 	jal	80008c94 <dprintf>
8000b348:	02002821 	move	a1,s0
8000b34c:	26310001 	addiu	s1,s1,1
		
		rtl8651_setAsicEthernetPHYReg(phyid, 31,0x0b81 );
8000b350:	8fa40018 	lw	a0,24(sp)
8000b354:	2405001f 	li	a1,31
8000b358:	0c000941 	jal	80002504 <rtl8651_setAsicEthernetPHYReg>
8000b35c:	24060b81 	li	a2,2945
		rtl8651_getAsicEthernetPHYReg(phyid, 18, &rdat );				
8000b360:	8fa40018 	lw	a0,24(sp)
8000b364:	24050012 	li	a1,18
8000b368:	0c000933 	jal	800024cc <rtl8651_getAsicEthernetPHYReg>
8000b36c:	27a6001c 	addiu	a2,sp,28
		printf("get data=%x\n", rdat);
8000b370:	8fa5001c 	lw	a1,28(sp)
8000b374:	0c002325 	jal	80008c94 <dprintf>
8000b378:	02402021 	move	a0,s2
		if((rdat&(0xf<<12))== (0x1<<12)) 	printf("Port %d GPHY BIST PASS\n",i);
8000b37c:	8fa3001c 	lw	v1,28(sp)
8000b380:	3063f000 	andi	v1,v1,0xf000
8000b384:	24021000 	li	v0,4096
8000b388:	14620006 	bne	v1,v0,8000b3a4 <GPHY_BIST+0x474>
8000b38c:	00000000 	nop
8000b390:	03c02021 	move	a0,s8
8000b394:	0c002325 	jal	80008c94 <dprintf>
8000b398:	02002821 	move	a1,s0
8000b39c:	08002ced 	j	8000b3b4 <GPHY_BIST+0x484>
8000b3a0:	00000000 	nop
		else 			{		printf("Port %d GPHY BIST FAIL\n",i);	err++; }
8000b3a4:	02602021 	move	a0,s3
8000b3a8:	0c002325 	jal	80008c94 <dprintf>
8000b3ac:	02002821 	move	a1,s0
8000b3b0:	26310001 	addiu	s1,s1,1
			
			
		rtl8651_getAsicEthernetPHYReg(phyid, 19, &rdat );				
8000b3b4:	8fa40018 	lw	a0,24(sp)
8000b3b8:	24050013 	li	a1,19
8000b3bc:	0c000933 	jal	800024cc <rtl8651_getAsicEthernetPHYReg>
8000b3c0:	27a6001c 	addiu	a2,sp,28
		printf("get data=%x\n", rdat);
8000b3c4:	8fa5001c 	lw	a1,28(sp)
8000b3c8:	0c002325 	jal	80008c94 <dprintf>
8000b3cc:	02402021 	move	a0,s2
		if(rdat== 0x2c34) 	printf("Port %d GPHY BIST_ROM PASS\n",i);
8000b3d0:	8fa3001c 	lw	v1,28(sp)
8000b3d4:	24022c34 	li	v0,11316
8000b3d8:	14620006 	bne	v1,v0,8000b3f4 <GPHY_BIST+0x4c4>
8000b3dc:	00000000 	nop
8000b3e0:	8fa4002c 	lw	a0,44(sp)
8000b3e4:	0c002325 	jal	80008c94 <dprintf>
8000b3e8:	02002821 	move	a1,s0
8000b3ec:	08002d01 	j	8000b404 <GPHY_BIST+0x4d4>
8000b3f0:	00000000 	nop
		else 			{ printf("Port %d GPHY BIST_ROM FAIL\n",i);	err++; }
8000b3f4:	02e02021 	move	a0,s7
8000b3f8:	0c002325 	jal	80008c94 <dprintf>
8000b3fc:	02002821 	move	a1,s0
8000b400:	26310001 	addiu	s1,s1,1
			
		rtl8651_setAsicEthernetPHYReg(phyid, 31,0x0c84 );
8000b404:	8fa40018 	lw	a0,24(sp)
8000b408:	2405001f 	li	a1,31
8000b40c:	0c000941 	jal	80002504 <rtl8651_setAsicEthernetPHYReg>
8000b410:	24060c84 	li	a2,3204
		rtl8651_getAsicEthernetPHYReg(phyid, 23, &rdat );				
8000b414:	8fa40018 	lw	a0,24(sp)
8000b418:	24050017 	li	a1,23
8000b41c:	0c000933 	jal	800024cc <rtl8651_getAsicEthernetPHYReg>
8000b420:	27a6001c 	addiu	a2,sp,28
		printf("get data=%x\n", rdat);
8000b424:	8fa5001c 	lw	a1,28(sp)
8000b428:	0c002325 	jal	80008c94 <dprintf>
8000b42c:	02402021 	move	a0,s2
		if((rdat&(0x7<<0))== (0x4<<0)) 	printf("Port %d GPHY BIST PASS\n",i);
8000b430:	8fa3001c 	lw	v1,28(sp)
8000b434:	30630007 	andi	v1,v1,0x7
8000b438:	24020004 	li	v0,4
8000b43c:	14620006 	bne	v1,v0,8000b458 <GPHY_BIST+0x528>
8000b440:	02602021 	move	a0,s3
8000b444:	03c02021 	move	a0,s8
8000b448:	0c002325 	jal	80008c94 <dprintf>
8000b44c:	02002821 	move	a1,s0
	rtl8651_setAsicEthernetPHYReg(0, 22, 0x0005 );	
	
	delay_ms(100);
	printf("\n");
	
	for(i=0;i<5;i++)
8000b450:	08002d1a 	j	8000b468 <GPHY_BIST+0x538>
8000b454:	26100001 	addiu	s0,s0,1
			
		rtl8651_setAsicEthernetPHYReg(phyid, 31,0x0c84 );
		rtl8651_getAsicEthernetPHYReg(phyid, 23, &rdat );				
		printf("get data=%x\n", rdat);
		if((rdat&(0x7<<0))== (0x4<<0)) 	printf("Port %d GPHY BIST PASS\n",i);
		else 			{	printf("Port %d GPHY BIST FAIL\n",i);	err++; }
8000b458:	0c002325 	jal	80008c94 <dprintf>
8000b45c:	02002821 	move	a1,s0
8000b460:	26310001 	addiu	s1,s1,1
	rtl8651_setAsicEthernetPHYReg(0, 22, 0x0005 );	
	
	delay_ms(100);
	printf("\n");
	
	for(i=0;i<5;i++)
8000b464:	26100001 	addiu	s0,s0,1
8000b468:	24020005 	li	v0,5
8000b46c:	1602ff71 	bne	s0,v0,8000b234 <GPHY_BIST+0x304>
8000b470:	00000000 	nop
		else 			{	printf("Port %d GPHY BIST FAIL\n",i);	err++; }
					
						
	}	
	
	if(err==0)
8000b474:	16200005 	bnez	s1,8000b48c <GPHY_BIST+0x55c>
8000b478:	3c048001 	lui	a0,0x8001
		printf("==> GPHY BIST ALL PASS <== \n");
8000b47c:	0c002325 	jal	80008c94 <dprintf>
8000b480:	24845cdc 	addiu	a0,a0,23772
	else
		printf("==> GPHY BIST FAIL count=%d <== \n", err);				
}
8000b484:	08002d28 	j	8000b4a0 <GPHY_BIST+0x570>
8000b488:	8fbf0054 	lw	ra,84(sp)
	}	
	
	if(err==0)
		printf("==> GPHY BIST ALL PASS <== \n");
	else
		printf("==> GPHY BIST FAIL count=%d <== \n", err);				
8000b48c:	3c048001 	lui	a0,0x8001
8000b490:	24845cfc 	addiu	a0,a0,23804
8000b494:	0c002325 	jal	80008c94 <dprintf>
8000b498:	02202821 	move	a1,s1
}
8000b49c:	8fbf0054 	lw	ra,84(sp)
8000b4a0:	8fbe0050 	lw	s8,80(sp)
8000b4a4:	8fb7004c 	lw	s7,76(sp)
8000b4a8:	8fb60048 	lw	s6,72(sp)
8000b4ac:	8fb50044 	lw	s5,68(sp)
8000b4b0:	8fb40040 	lw	s4,64(sp)
8000b4b4:	8fb3003c 	lw	s3,60(sp)
8000b4b8:	8fb20038 	lw	s2,56(sp)
8000b4bc:	8fb10034 	lw	s1,52(sp)
8000b4c0:	8fb00030 	lw	s0,48(sp)
8000b4c4:	03e00008 	jr	ra
8000b4c8:	27bd0058 	addiu	sp,sp,88

8000b4cc <ExtractACmdLine>:

};  

//return position 
unsigned int ExtractACmdLine(const char *pPattScript,  char *pOneCmdString, int first)
{
8000b4cc:	27bdffe0 	addiu	sp,sp,-32
8000b4d0:	afbf001c 	sw	ra,28(sp)
8000b4d4:	afb20018 	sw	s2,24(sp)
8000b4d8:	afb10014 	sw	s1,20(sp)
8000b4dc:	afb00010 	sw	s0,16(sp)
8000b4e0:	00809021 	move	s2,a0
	//first=1 reset index, to buffer head
	//first=0 continue read a line

	static unsigned int idx=0;
	unsigned char *p=pPattScript+idx;
8000b4e4:	3c028002 	lui	v0,0x8002
8000b4e8:	8c503e20 	lw	s0,15904(v0)
	int push=0;
	
	if(first==1)
8000b4ec:	24020001 	li	v0,1
8000b4f0:	14c20005 	bne	a2,v0,8000b508 <ExtractACmdLine+0x3c>
8000b4f4:	00a08821 	move	s1,a1
	{	idx=0;
8000b4f8:	3c028002 	lui	v0,0x8002
8000b4fc:	ac403e20 	sw	zero,15904(v0)
		return 0;
8000b500:	08002d93 	j	8000b64c <ExtractACmdLine+0x180>
8000b504:	00001021 	move	v0,zero
{
	//first=1 reset index, to buffer head
	//first=0 continue read a line

	static unsigned int idx=0;
	unsigned char *p=pPattScript+idx;
8000b508:	00908021 	addu	s0,a0,s0
	if(first==1)
	{	idx=0;
		return 0;
	}
	
	memset( pOneCmdString, 0, MAX_MONITOR_BUFFER );
8000b50c:	00a02021 	move	a0,a1
8000b510:	00002821 	move	a1,zero
8000b514:	0c00203d 	jal	800080f4 <memset>
8000b518:	24060080 	li	a2,128
8000b51c:	02204821 	move	t1,s1
8000b520:	240a0001 	li	t2,1
8000b524:	00004021 	move	t0,zero
	while( *p )
	{
		if(n==0)
		{
			//skip first return-line
			while( *p && ((*p == 0x0d) ||(*p==0x0a) ||(*p=='\t') ||(*p==' ') ) )
8000b528:	2403000d 	li	v1,13
8000b52c:	2404000a 	li	a0,10
8000b530:	24060009 	li	a2,9
8000b534:	24070020 	li	a3,32
				p++;
		}

		if ((n==0) && (*p =='~') )
8000b538:	240b007e 	li	t3,126


		//end
		if(n!=0)
		{
			if( (*p == 0x0d)  || (*p == 0x0a)  || (*p == '#'))
8000b53c:	240c0023 	li	t4,35
		}
	
		pOneCmdString[n] = *p ;
		n++;		
		p++;	
		if (n == 80) break;
8000b540:	240d0050 	li	t5,80
	
	memset( pOneCmdString, 0, MAX_MONITOR_BUFFER );


	int n=0;
	while( *p )
8000b544:	08002d7a 	j	8000b5e8 <ExtractACmdLine+0x11c>
8000b548:	240e0020 	li	t6,32
	{
		if(n==0)
8000b54c:	10a00007 	beqz	a1,8000b56c <ExtractACmdLine+0xa0>
8000b550:	00000000 	nop
8000b554:	08002d66 	j	8000b598 <ExtractACmdLine+0xcc>
8000b558:	00000000 	nop
		{
			//skip first return-line
			while( *p && ((*p == 0x0d) ||(*p==0x0a) ||(*p=='\t') ||(*p==' ') ) )
				p++;
8000b55c:	26100001 	addiu	s0,s0,1
	while( *p )
	{
		if(n==0)
		{
			//skip first return-line
			while( *p && ((*p == 0x0d) ||(*p==0x0a) ||(*p=='\t') ||(*p==' ') ) )
8000b560:	92020000 	lbu	v0,0(s0)
8000b564:	1040003f 	beqz	v0,8000b664 <ExtractACmdLine+0x198>
8000b568:	00000000 	nop
8000b56c:	1043fffb 	beq	v0,v1,8000b55c <ExtractACmdLine+0x90>
8000b570:	00000000 	nop
8000b574:	1044fff9 	beq	v0,a0,8000b55c <ExtractACmdLine+0x90>
8000b578:	00000000 	nop
8000b57c:	1046fff7 	beq	v0,a2,8000b55c <ExtractACmdLine+0x90>
8000b580:	00000000 	nop
8000b584:	1047fff6 	beq	v0,a3,8000b560 <ExtractACmdLine+0x94>
8000b588:	26100001 	addiu	s0,s0,1
8000b58c:	2610ffff 	addiu	s0,s0,-1
				p++;
		}

		if ((n==0) && (*p =='~') )
8000b590:	08002d99 	j	8000b664 <ExtractACmdLine+0x198>
8000b594:	92020000 	lbu	v0,0(s0)


		//end
		if(n!=0)
		{
			if( (*p == 0x0d)  || (*p == 0x0a)  || (*p == '#'))
8000b598:	10430005 	beq	v0,v1,8000b5b0 <ExtractACmdLine+0xe4>
8000b59c:	00000000 	nop
8000b5a0:	10440003 	beq	v0,a0,8000b5b0 <ExtractACmdLine+0xe4>
8000b5a4:	00000000 	nop
8000b5a8:	144c0004 	bne	v0,t4,8000b5bc <ExtractACmdLine+0xf0>
8000b5ac:	00000000 	nop
			{	pOneCmdString[n] = 0 ;
8000b5b0:	02251021 	addu	v0,s1,a1
				break;
8000b5b4:	08002d7d 	j	8000b5f4 <ExtractACmdLine+0x128>
8000b5b8:	a0400000 	sb	zero,0(v0)
			}
			if(*p==0x09) //TAB->SPACE
8000b5bc:	14460002 	bne	v0,a2,8000b5c8 <ExtractACmdLine+0xfc>
8000b5c0:	00000000 	nop
				*p=' ';
8000b5c4:	a20e0000 	sb	t6,0(s0)
		}
	
		pOneCmdString[n] = *p ;
8000b5c8:	92020000 	lbu	v0,0(s0)
8000b5cc:	a1220000 	sb	v0,0(t1)
8000b5d0:	01402821 	move	a1,t2
		n++;		
		p++;	
		if (n == 80) break;
8000b5d4:	114d002a 	beq	t2,t5,8000b680 <ExtractACmdLine+0x1b4>
8000b5d8:	26100001 	addiu	s0,s0,1
8000b5dc:	25080001 	addiu	t0,t0,1
8000b5e0:	254a0001 	addiu	t2,t2,1
8000b5e4:	25290001 	addiu	t1,t1,1
	
	memset( pOneCmdString, 0, MAX_MONITOR_BUFFER );


	int n=0;
	while( *p )
8000b5e8:	92020000 	lbu	v0,0(s0)
8000b5ec:	1440ffd7 	bnez	v0,8000b54c <ExtractACmdLine+0x80>
8000b5f0:	01002821 	move	a1,t0
		pOneCmdString[n] = *p ;
		n++;		
		p++;	
		if (n == 80) break;
	}
	idx= (int)p-(int)pPattScript+1;
8000b5f4:	02121023 	subu	v0,s0,s2
8000b5f8:	24420001 	addiu	v0,v0,1
8000b5fc:	3c038002 	lui	v1,0x8002
8000b600:	ac623e20 	sw	v0,15904(v1)

	//thrim last space
	for(;n>1;n--)
8000b604:	28a30002 	slti	v1,a1,2
8000b608:	10600021 	beqz	v1,8000b690 <ExtractACmdLine+0x1c4>
8000b60c:	8fbf001c 	lw	ra,28(sp)
		}

	//dprintf("test=> %s \r\n", pOneCmdString);
	return idx;	

}
8000b610:	08002d95 	j	8000b654 <ExtractACmdLine+0x188>
8000b614:	8fb20018 	lw	s2,24(sp)
	}
	idx= (int)p-(int)pPattScript+1;

	//thrim last space
	for(;n>1;n--)
		if( (pOneCmdString[n-1]!=' ')  &&  (pOneCmdString[n-1]!='\t') )
8000b618:	8064ffff 	lb	a0,-1(v1)
8000b61c:	10860007 	beq	a0,a2,8000b63c <ExtractACmdLine+0x170>
8000b620:	00000000 	nop
8000b624:	10880006 	beq	a0,t0,8000b640 <ExtractACmdLine+0x174>
8000b628:	24a5ffff 	addiu	a1,a1,-1
8000b62c:	24a50001 	addiu	a1,a1,1
		{	pOneCmdString[n]=0;
8000b630:	02253821 	addu	a3,s1,a1
			break;
8000b634:	08002d93 	j	8000b64c <ExtractACmdLine+0x180>
8000b638:	a0e00000 	sb	zero,0(a3)
		if (n == 80) break;
	}
	idx= (int)p-(int)pPattScript+1;

	//thrim last space
	for(;n>1;n--)
8000b63c:	24a5ffff 	addiu	a1,a1,-1
8000b640:	28a40002 	slti	a0,a1,2
8000b644:	1080fff4 	beqz	a0,8000b618 <ExtractACmdLine+0x14c>
8000b648:	2463ffff 	addiu	v1,v1,-1
		}

	//dprintf("test=> %s \r\n", pOneCmdString);
	return idx;	

}
8000b64c:	8fbf001c 	lw	ra,28(sp)
8000b650:	8fb20018 	lw	s2,24(sp)
8000b654:	8fb10014 	lw	s1,20(sp)
8000b658:	8fb00010 	lw	s0,16(sp)
8000b65c:	03e00008 	jr	ra
8000b660:	27bd0020 	addiu	sp,sp,32
			//skip first return-line
			while( *p && ((*p == 0x0d) ||(*p==0x0a) ||(*p=='\t') ||(*p==' ') ) )
				p++;
		}

		if ((n==0) && (*p =='~') )
8000b664:	144b0003 	bne	v0,t3,8000b674 <ExtractACmdLine+0x1a8>
8000b668:	00000000 	nop
8000b66c:	08002d93 	j	8000b64c <ExtractACmdLine+0x180>
8000b670:	00001021 	move	v0,zero
			}
			if(*p==0x09) //TAB->SPACE
				*p=' ';
		}
	
		pOneCmdString[n] = *p ;
8000b674:	a1220000 	sb	v0,0(t1)
		n++;		
		p++;	
8000b678:	08002d77 	j	8000b5dc <ExtractACmdLine+0x110>
8000b67c:	26100001 	addiu	s0,s0,1
		if (n == 80) break;
	}
	idx= (int)p-(int)pPattScript+1;
8000b680:	02121023 	subu	v0,s0,s2
8000b684:	24420001 	addiu	v0,v0,1
8000b688:	3c038002 	lui	v1,0x8002
8000b68c:	ac623e20 	sw	v0,15904(v1)
8000b690:	02251821 	addu	v1,s1,a1

	//thrim last space
	for(;n>1;n--)
		if( (pOneCmdString[n-1]!=' ')  &&  (pOneCmdString[n-1]!='\t') )
8000b694:	24060020 	li	a2,32
8000b698:	08002d86 	j	8000b618 <ExtractACmdLine+0x14c>
8000b69c:	24080009 	li	t0,9

8000b6a0 <CmdMEMCLK>:
#endif		
	dprintf("Change M2x clock freq=%d \n", m2x_clksel_table[clk_sel] );
}
//---------------------------------------------------------------------------
int CmdMEMCLK(int argc, char* argv[])
{
8000b6a0:	27bdffd8 	addiu	sp,sp,-40
8000b6a4:	afbf0024 	sw	ra,36(sp)
8000b6a8:	afb30020 	sw	s3,32(sp)
8000b6ac:	afb2001c 	sw	s2,28(sp)
8000b6b0:	afb10018 	sw	s1,24(sp)
8000b6b4:	afb00014 	sw	s0,20(sp)

	int clk_sel=0;
	int tmp;
	if( argc < 1 ) 
8000b6b8:	1c80001f 	bgtz	a0,8000b738 <CmdMEMCLK+0x98>
8000b6bc:	00000000 	nop
	{
		dprintf("Usage: MEMCLK <sel>: 0-7  \n");		
8000b6c0:	3c048001 	lui	a0,0x8001
8000b6c4:	0c002325 	jal	80008c94 <dprintf>
8000b6c8:	24845e58 	addiu	a0,a0,24152
8000b6cc:	3c118001 	lui	s1,0x8001
8000b6d0:	263104f0 	addiu	s1,s1,1264
8000b6d4:	00008021 	move	s0,zero
		int i;
		for(i=0; i<8;i++)
		dprintf(" %d : %d MHz \n", i, m2x_clksel_table[i]);
8000b6d8:	3c128001 	lui	s2,0x8001
8000b6dc:	26525e74 	addiu	s2,s2,24180
	int tmp;
	if( argc < 1 ) 
	{
		dprintf("Usage: MEMCLK <sel>: 0-7  \n");		
		int i;
		for(i=0; i<8;i++)
8000b6e0:	24130008 	li	s3,8
		dprintf(" %d : %d MHz \n", i, m2x_clksel_table[i]);
8000b6e4:	02402021 	move	a0,s2
8000b6e8:	02002821 	move	a1,s0
8000b6ec:	0c002325 	jal	80008c94 <dprintf>
8000b6f0:	8e260000 	lw	a2,0(s1)
	int tmp;
	if( argc < 1 ) 
	{
		dprintf("Usage: MEMCLK <sel>: 0-7  \n");		
		int i;
		for(i=0; i<8;i++)
8000b6f4:	26100001 	addiu	s0,s0,1
8000b6f8:	1613fffa 	bne	s0,s3,8000b6e4 <CmdMEMCLK+0x44>
8000b6fc:	26310004 	addiu	s1,s1,4
		dprintf(" %d : %d MHz \n", i, m2x_clksel_table[i]);
		
		int	m2xsel=(REG32(SYS_HW_STRAP) & (CK_M2X_FREQ_SEL))>>10;
8000b700:	3c02b800 	lui	v0,0xb800
8000b704:	34420008 	ori	v0,v0,0x8
8000b708:	8c450000 	lw	a1,0(v0)
8000b70c:	7ca52280 	ext	a1,a1,0xa,0x5
		dprintf("status: %d = %d Mhz \n",  m2xsel, m2x_clksel_table[m2xsel] );
8000b710:	00051880 	sll	v1,a1,0x2
8000b714:	3c028001 	lui	v0,0x8001
8000b718:	244204f0 	addiu	v0,v0,1264
8000b71c:	00621021 	addu	v0,v1,v0
8000b720:	3c048001 	lui	a0,0x8001
8000b724:	24845e84 	addiu	a0,a0,24196
8000b728:	0c002325 	jal	80008c94 <dprintf>
8000b72c:	8c460000 	lw	a2,0(v0)
		return;	
8000b730:	08002dd5 	j	8000b754 <CmdMEMCLK+0xb4>
8000b734:	8fbf0024 	lw	ra,36(sp)
	}
	

	clk_sel = strtoul((const char*)(argv[0]), (char **)NULL, 16);
8000b738:	8ca40000 	lw	a0,0(a1)
8000b73c:	00002821 	move	a1,zero
8000b740:	0c0020c4 	jal	80008310 <strtoul>
8000b744:	24060010 	li	a2,16
		SettingM2xClk(clk_sel);
8000b748:	0c00279b 	jal	80009e6c <SettingM2xClk>
8000b74c:	00402021 	move	a0,v0


}
8000b750:	8fbf0024 	lw	ra,36(sp)
8000b754:	8fb30020 	lw	s3,32(sp)
8000b758:	8fb2001c 	lw	s2,28(sp)
8000b75c:	8fb10018 	lw	s1,24(sp)
8000b760:	8fb00014 	lw	s0,20(sp)
8000b764:	03e00008 	jr	ra
8000b768:	27bd0028 	addiu	sp,sp,40

8000b76c <TestStrapPin>:
}

//=================================================================================

int TestStrapPin(int argc, char* argv[])
{
8000b76c:	27bdffe0 	addiu	sp,sp,-32
8000b770:	afbf001c 	sw	ra,28(sp)
8000b774:	afb10018 	sw	s1,24(sp)
8000b778:	afb00014 	sw	s0,20(sp)

	if(argc < 2) 
8000b77c:	28840002 	slti	a0,a0,2
8000b780:	10800008 	beqz	a0,8000b7a4 <TestStrapPin+0x38>
8000b784:	00a08021 	move	s0,a1
	{	ShowStrapMsg();
8000b788:	0c002870 	jal	8000a1c0 <ShowStrapMsg>
8000b78c:	00000000 	nop
		dprintf("Usage: strap bit value \n\n");	
8000b790:	3c048001 	lui	a0,0x8001
8000b794:	0c002325 	jal	80008c94 <dprintf>
8000b798:	24845e9c 	addiu	a0,a0,24220
	{
		dprintf("Unsupport value \n");	
	}
	ShowStrapMsg();
	
}
8000b79c:	08002e0d 	j	8000b834 <TestStrapPin+0xc8>
8000b7a0:	24020001 	li	v0,1
	if(argc < 2) 
	{	ShowStrapMsg();
		dprintf("Usage: strap bit value \n\n");	
		return 1;
	}
	unsigned int bit = strtoul((const char*)(argv[0]), (char **)NULL, 10);		
8000b7a4:	8ca40000 	lw	a0,0(a1)
8000b7a8:	00002821 	move	a1,zero
8000b7ac:	0c0020c4 	jal	80008310 <strtoul>
8000b7b0:	2406000a 	li	a2,10
8000b7b4:	00408821 	move	s1,v0
	unsigned int val = strtoul((const char*)(argv[1]), (char **)NULL, 16);		
8000b7b8:	8e040004 	lw	a0,4(s0)
8000b7bc:	00002821 	move	a1,zero
8000b7c0:	0c0020c4 	jal	80008310 <strtoul>
8000b7c4:	24060010 	li	a2,16


	if(val==0)
8000b7c8:	1440000b 	bnez	v0,8000b7f8 <TestStrapPin+0x8c>
8000b7cc:	24030001 	li	v1,1
	{		
		REG32(SYS_HW_STRAP) &= ~(1<<bit);		
8000b7d0:	3c02b800 	lui	v0,0xb800
8000b7d4:	34420008 	ori	v0,v0,0x8
8000b7d8:	8c430000 	lw	v1,0(v0)
8000b7dc:	24040001 	li	a0,1
8000b7e0:	02248804 	sllv	s1,a0,s1
8000b7e4:	00118827 	nor	s1,zero,s1
8000b7e8:	02238824 	and	s1,s1,v1
8000b7ec:	ac510000 	sw	s1,0(v0)
8000b7f0:	08002e0b 	j	8000b82c <TestStrapPin+0xc0>
8000b7f4:	00000000 	nop
	}
	else if(val==1)
8000b7f8:	1443000a 	bne	v0,v1,8000b824 <TestStrapPin+0xb8>
8000b7fc:	3c048001 	lui	a0,0x8001
	{			
		REG32(SYS_HW_STRAP) |= (1<<bit);		
8000b800:	3c02b800 	lui	v0,0xb800
8000b804:	34420008 	ori	v0,v0,0x8
8000b808:	8c430000 	lw	v1,0(v0)
8000b80c:	24040001 	li	a0,1
8000b810:	02248804 	sllv	s1,a0,s1
8000b814:	02238825 	or	s1,s1,v1
8000b818:	ac510000 	sw	s1,0(v0)
8000b81c:	08002e0b 	j	8000b82c <TestStrapPin+0xc0>
8000b820:	00000000 	nop
	}
	else
	{
		dprintf("Unsupport value \n");	
8000b824:	0c002325 	jal	80008c94 <dprintf>
8000b828:	24845eb8 	addiu	a0,a0,24248
	}
	ShowStrapMsg();
8000b82c:	0c002870 	jal	8000a1c0 <ShowStrapMsg>
8000b830:	00000000 	nop
	
}
8000b834:	8fbf001c 	lw	ra,28(sp)
8000b838:	8fb10018 	lw	s1,24(sp)
8000b83c:	8fb00014 	lw	s0,20(sp)
8000b840:	03e00008 	jr	ra
8000b844:	27bd0020 	addiu	sp,sp,32

8000b848 <SettingLxClk>:

}
//---------------------------------------------------------------------------

int SettingLxClk(int clklx_from_clkm)
{	
8000b848:	27bdffc0 	addiu	sp,sp,-64
8000b84c:	afbf003c 	sw	ra,60(sp)
8000b850:	afb20038 	sw	s2,56(sp)
8000b854:	afb10034 	sw	s1,52(sp)
8000b858:	afb00030 	sw	s0,48(sp)
8000b85c:	00808821 	move	s1,a0
	
	int	tmp=REG32(SYS_HW_STRAP) & ~(ST_CLKLX_FROM_HALFOC);
8000b860:	3c02b800 	lui	v0,0xb800
8000b864:	34420008 	ori	v0,v0,0x8
8000b868:	8c450000 	lw	a1,0(v0)
	int strap_newval= tmp | ((clklx_from_clkm&0x01) <<ST_CLKLX_FROM_HALFOC_OFFSET) ;

	//--------------------------------------
	//int lexra_newval;

	if(clklx_from_clkm==0)
8000b86c:	14800006 	bnez	a0,8000b888 <SettingLxClk+0x40>
8000b870:	3c0207d2 	lui	v0,0x7d2
	{	
		glexra_clock=200*1000*1000;
8000b874:	3c030beb 	lui	v1,0xbeb
8000b878:	3463c200 	ori	v1,v1,0xc200
8000b87c:	3c028001 	lui	v0,0x8001
8000b880:	08002e43 	j	8000b90c <SettingLxClk+0xc4>
8000b884:	ac437710 	sw	v1,30480(v0)
	}
	else
	{
		//prepare uart 
		unsigned long mem2x_clksel_table[]={ 131250000, 156250000, 300000000, 250000000,  312500000, 337500000, 475000000, 387500000 	};
8000b888:	3442b750 	ori	v0,v0,0xb750
8000b88c:	afa20010 	sw	v0,16(sp)
8000b890:	3c020950 	lui	v0,0x950
8000b894:	34422f90 	ori	v0,v0,0x2f90
8000b898:	afa20014 	sw	v0,20(sp)
8000b89c:	3c0211e1 	lui	v0,0x11e1
8000b8a0:	3442a300 	ori	v0,v0,0xa300
8000b8a4:	afa20018 	sw	v0,24(sp)
8000b8a8:	3c020ee6 	lui	v0,0xee6
8000b8ac:	3442b280 	ori	v0,v0,0xb280
8000b8b0:	afa2001c 	sw	v0,28(sp)
8000b8b4:	3c0212a0 	lui	v0,0x12a0
8000b8b8:	34425f20 	ori	v0,v0,0x5f20
8000b8bc:	afa20020 	sw	v0,32(sp)
8000b8c0:	3c02141d 	lui	v0,0x141d
8000b8c4:	3442d760 	ori	v0,v0,0xd760
8000b8c8:	afa20024 	sw	v0,36(sp)
8000b8cc:	3c021c4f 	lui	v0,0x1c4f
8000b8d0:	3442ecc0 	ori	v0,v0,0xecc0
8000b8d4:	afa20028 	sw	v0,40(sp)
8000b8d8:	3c021718 	lui	v0,0x1718
8000b8dc:	3442c7e0 	ori	v0,v0,0xc7e0
8000b8e0:	afa2002c 	sw	v0,44(sp)
		int	m2xsel=(REG32(SYS_HW_STRAP) & (CK_M2X_FREQ_SEL))>>CK_M2X_FREQ_SEL_OFFSET;
8000b8e4:	3c02b800 	lui	v0,0xb800
8000b8e8:	34420008 	ori	v0,v0,0x8
8000b8ec:	8c420000 	lw	v0,0(v0)
	       glexra_clock=mem2x_clksel_table[m2xsel] /2;
8000b8f0:	7c422280 	ext	v0,v0,0xa,0x5
8000b8f4:	00021080 	sll	v0,v0,0x2
8000b8f8:	03a21021 	addu	v0,sp,v0
8000b8fc:	8c430010 	lw	v1,16(v0)
8000b900:	00031842 	srl	v1,v1,0x1
8000b904:	3c028001 	lui	v0,0x8001
8000b908:	ac437710 	sw	v1,30480(v0)

	}
	//--------------------------------------
	int gimr_tmp=REG32(GIMR_REG);
8000b90c:	3c02b800 	lui	v0,0xb800
8000b910:	34433000 	ori	v1,v0,0x3000
8000b914:	8c720000 	lw	s2,0(v1)
	REG32(GIMR_REG)=0;
8000b918:	ac600000 	sw	zero,0(v1)
	

		#if 1  //lock bus			
			REG32(SYS_LX_CTRL) |= (1<<2) ;	  //lock bus arb2
8000b91c:	34420014 	ori	v0,v0,0x14
8000b920:	8c430000 	lw	v1,0(v0)
8000b924:	34630004 	ori	v1,v1,0x4
8000b928:	ac430000 	sw	v1,0(v0)
			while( (REG32(SYS_BIST_DONE)&(1<<0))==0)  ; //wait bit to 1, is mean lock ok	
8000b92c:	3c03b800 	lui	v1,0xb800
8000b930:	34630020 	ori	v1,v1,0x20
8000b934:	8c620000 	lw	v0,0(v1)
8000b938:	30420001 	andi	v0,v0,0x1
8000b93c:	1040fffd 	beqz	v0,8000b934 <SettingLxClk+0xec>
8000b940:	3c02b800 	lui	v0,0xb800

			REG32(SYS_LX_CTRL) |= (1<<3) ;	  //lock bus arb4
8000b944:	34420014 	ori	v0,v0,0x14
8000b948:	8c430000 	lw	v1,0(v0)
8000b94c:	34630008 	ori	v1,v1,0x8
8000b950:	ac430000 	sw	v1,0(v0)
			while( (REG32(SYS_BIST_DONE)&(1<<1))==0)  ; //wait bit to 1, is mean lock ok		
8000b954:	3c03b800 	lui	v1,0xb800
8000b958:	34630020 	ori	v1,v1,0x20
8000b95c:	8c620000 	lw	v0,0(v1)
8000b960:	30420002 	andi	v0,v0,0x2
8000b964:	1040fffd 	beqz	v0,8000b95c <SettingLxClk+0x114>
8000b968:	3c02b800 	lui	v0,0xb800

			REG32(SYS_LX_CTRL) |= (1<<4) ;	  //lock bus arb6
8000b96c:	34420014 	ori	v0,v0,0x14
8000b970:	8c430000 	lw	v1,0(v0)
8000b974:	34630010 	ori	v1,v1,0x10
8000b978:	ac430000 	sw	v1,0(v0)
			while( (REG32(SYS_BIST_DONE)&(1<<2))==0)  ; //wait bit to 1, is mean lock ok	
8000b97c:	3c03b800 	lui	v1,0xb800
8000b980:	34630020 	ori	v1,v1,0x20
8000b984:	8c620000 	lw	v0,0(v1)
8000b988:	30420004 	andi	v0,v0,0x4
8000b98c:	1040fffd 	beqz	v0,8000b984 <SettingLxClk+0x13c>
8000b990:	32220001 	andi	v0,s1,0x1
		#endif
	


	//go
	REG32(SYS_HW_STRAP)=strap_newval;    //change lx clk
8000b994:	00021540 	sll	v0,v0,0x15
8000b998:	3c04ffdf 	lui	a0,0xffdf
8000b99c:	3484ffff 	ori	a0,a0,0xffff
8000b9a0:	00a42024 	and	a0,a1,a0
8000b9a4:	00442025 	or	a0,v0,a0
8000b9a8:	3c02b800 	lui	v0,0xb800
8000b9ac:	34430008 	ori	v1,v0,0x8
8000b9b0:	ac640000 	sw	a0,0(v1)


		#if 1   //check m2xusable and unlock bus
			//while( (REG32(SYS_BIST_DONE)&(1<<18))==0)  ;   //wait to 1, mean m2x is usable
	
			REG32(SYS_LX_CTRL) &= ~(1<<2);	//unlock
8000b9b4:	34420014 	ori	v0,v0,0x14
8000b9b8:	8c440000 	lw	a0,0(v0)
8000b9bc:	2403fffb 	li	v1,-5
8000b9c0:	00831824 	and	v1,a0,v1
8000b9c4:	ac430000 	sw	v1,0(v0)
			while( (REG32(SYS_BIST_DONE)&(1<<0))==(1<<0)) ;  //wait bit to 0  unlock
8000b9c8:	3c03b800 	lui	v1,0xb800
8000b9cc:	34630020 	ori	v1,v1,0x20
8000b9d0:	8c620000 	lw	v0,0(v1)
8000b9d4:	30420001 	andi	v0,v0,0x1
8000b9d8:	1440fffd 	bnez	v0,8000b9d0 <SettingLxClk+0x188>
8000b9dc:	3c02b800 	lui	v0,0xb800

			REG32(SYS_LX_CTRL) &= ~(1<<3);	//unlock
8000b9e0:	34420014 	ori	v0,v0,0x14
8000b9e4:	8c440000 	lw	a0,0(v0)
8000b9e8:	2403fff7 	li	v1,-9
8000b9ec:	00831824 	and	v1,a0,v1
8000b9f0:	ac430000 	sw	v1,0(v0)
			while( (REG32(SYS_BIST_DONE)&(1<<1))==(1<<1)) ;  //wait bit to 0  unlock
8000b9f4:	3c03b800 	lui	v1,0xb800
8000b9f8:	34630020 	ori	v1,v1,0x20
8000b9fc:	8c620000 	lw	v0,0(v1)
8000ba00:	30420002 	andi	v0,v0,0x2
8000ba04:	1440fffd 	bnez	v0,8000b9fc <SettingLxClk+0x1b4>
8000ba08:	3c02b800 	lui	v0,0xb800

			REG32(SYS_LX_CTRL) &= ~(1<<4);	//unlock
8000ba0c:	34420014 	ori	v0,v0,0x14
8000ba10:	8c440000 	lw	a0,0(v0)
8000ba14:	2403ffef 	li	v1,-17
8000ba18:	00831824 	and	v1,a0,v1
8000ba1c:	ac430000 	sw	v1,0(v0)
			while( (REG32(SYS_BIST_DONE)&(1<<2))==(1<<2)) ;  //wait bit to 0  unlock	
8000ba20:	3c03b800 	lui	v1,0xb800
8000ba24:	34630020 	ori	v1,v1,0x20
8000ba28:	8c620000 	lw	v0,0(v1)
8000ba2c:	30420004 	andi	v0,v0,0x4
8000ba30:	1440fffd 	bnez	v0,8000ba28 <SettingLxClk+0x1e0>
8000ba34:	3c108001 	lui	s0,0x8001
		#endif

		
	console_init(glexra_clock);
8000ba38:	0c003693 	jal	8000da4c <console_init>
8000ba3c:	8e047710 	lw	a0,30480(s0)
	timer_init(glexra_clock);
8000ba40:	0c0038f4 	jal	8000e3d0 <timer_init>
8000ba44:	8e047710 	lw	a0,30480(s0)

		
	REG32(GIMR_REG)=gimr_tmp;
8000ba48:	3c02b800 	lui	v0,0xb800
8000ba4c:	34423000 	ori	v0,v0,0x3000
8000ba50:	ac520000 	sw	s2,0(v0)



	

	dprintf("clklx_from_clkm=%d \n", clklx_from_clkm );
8000ba54:	3c048001 	lui	a0,0x8001
8000ba58:	24845ecc 	addiu	a0,a0,24268
8000ba5c:	0c002325 	jal	80008c94 <dprintf>
8000ba60:	02202821 	move	a1,s1
	
}
8000ba64:	8fbf003c 	lw	ra,60(sp)
8000ba68:	8fb20038 	lw	s2,56(sp)
8000ba6c:	8fb10034 	lw	s1,52(sp)
8000ba70:	8fb00030 	lw	s0,48(sp)
8000ba74:	03e00008 	jr	ra
8000ba78:	27bd0040 	addiu	sp,sp,64

8000ba7c <CmdLXCLK>:

int CmdLXCLK(int argc, char* argv[])
{
8000ba7c:	27bdffe8 	addiu	sp,sp,-24
8000ba80:	afbf0014 	sw	ra,20(sp)
	if( argc < 1 ) 
8000ba84:	1c80000d 	bgtz	a0,8000babc <CmdLXCLK+0x40>
8000ba88:	00000000 	nop
	{
		dprintf("Usage: LXCLK <sel>: 0-1  \r\n");		
8000ba8c:	3c048001 	lui	a0,0x8001
8000ba90:	0c002325 	jal	80008c94 <dprintf>
8000ba94:	24845ee4 	addiu	a0,a0,24292
		int	lxsel=(REG32(SYS_HW_STRAP) & (ST_CLKLX_FROM_HALFOC))>>ST_CLKLX_FROM_HALFOC_OFFSET;
8000ba98:	3c02b800 	lui	v0,0xb800
8000ba9c:	34420008 	ori	v0,v0,0x8
8000baa0:	8c450000 	lw	a1,0(v0)
		dprintf("status: %d \n", lxsel );		
8000baa4:	3c048001 	lui	a0,0x8001
8000baa8:	24845f00 	addiu	a0,a0,24320
8000baac:	0c002325 	jal	80008c94 <dprintf>
8000bab0:	7ca50540 	ext	a1,a1,0x15,0x1
		return;	
8000bab4:	08002eb6 	j	8000bad8 <CmdLXCLK+0x5c>
8000bab8:	8fbf0014 	lw	ra,20(sp)
	}

	
	int clklx_from_clkm = strtoul((const char*)(argv[0]), (char **)NULL, 16);
8000babc:	8ca40000 	lw	a0,0(a1)
8000bac0:	00002821 	move	a1,zero
8000bac4:	0c0020c4 	jal	80008310 <strtoul>
8000bac8:	24060010 	li	a2,16
	SettingLxClk(clklx_from_clkm);
8000bacc:	0c002e12 	jal	8000b848 <SettingLxClk>
8000bad0:	00402021 	move	a0,v0


	//--------------------------------------


};  
8000bad4:	8fbf0014 	lw	ra,20(sp)
8000bad8:	03e00008 	jr	ra
8000badc:	27bd0018 	addiu	sp,sp,24

8000bae0 <SettingCPUClk>:
#endif
}
//---------------------------------------------------------------------------

int SettingCPUClk(int clk_sel, int clk_div)
{
8000bae0:	27bdffe0 	addiu	sp,sp,-32
8000bae4:	afbf001c 	sw	ra,28(sp)
8000bae8:	afb20018 	sw	s2,24(sp)
8000baec:	afb10014 	sw	s1,20(sp)
8000baf0:	afb00010 	sw	s0,16(sp)
8000baf4:	00808021 	move	s0,a0
8000baf8:	00a08821 	move	s1,a1
	int clk_curr, clk_exp;	
	unsigned int old_clk_sel;
	unsigned int mask;
	unsigned int sysreg;

	REG32(SYS_INT_STATUS)=(1<<1);  //clear cpu wakeup.
8000bafc:	3c02b800 	lui	v0,0xb800
8000bb00:	34430004 	ori	v1,v0,0x4
8000bb04:	24040002 	li	a0,2
8000bb08:	ac640000 	sw	a0,0(v1)

#if 1  //check core 1 exist
		#define POLLING_REG 0xb800006c
  		#define PATT_SLEEP  0x3333		
  		#define PATT_READY  0x5555
	if(REG32(POLLING_REG)!=PATT_SLEEP)
8000bb0c:	3442006c 	ori	v0,v0,0x6c
8000bb10:	8c440000 	lw	a0,0(v0)
8000bb14:	24033333 	li	v1,13107
8000bb18:	14830074 	bne	a0,v1,8000bcec <SettingCPUClk+0x20c>
8000bb1c:	00001021 	move	v0,zero
	}


#endif
	
	clk_curr = check_cpu_speed();
8000bb20:	0c003f06 	jal	8000fc18 <check_cpu_speed>
8000bb24:	3c12b800 	lui	s2,0xb800
#ifdef _verbose
	dprintf("Now CPU Speed=%d \n",clk_curr);	
#endif
	//----------------------------
	REG32(SYS_INT_STATUS)=(1<<1);  //enable cpu wakeup interrupt mask
8000bb28:	36420004 	ori	v0,s2,0x4
8000bb2c:	24030002 	li	v1,2
8000bb30:	ac430000 	sw	v1,0(v0)

	request_IRQ(SPEED_IRQ_NO, &irq_SPEED, NULL); 	
8000bb34:	2404002b 	li	a0,43
8000bb38:	3c058001 	lui	a1,0x8001
8000bb3c:	24a57630 	addiu	a1,a1,30256
8000bb40:	0c000274 	jal	800009d0 <request_IRQ>
8000bb44:	00003021 	move	a2,zero

	//-------------
	sysreg=REG32(SYS_HW_STRAP);
8000bb48:	36520008 	ori	s2,s2,0x8
8000bb4c:	8e430000 	lw	v1,0(s2)
	//dprintf("Read  SYS_HW_STRAP=%08x\r\n", sysreg);	
	old_clk_sel=(sysreg & ST_CPU_FREQ_SEL) >>ST_CPU_FREQ_SEL_OFFSET;

	sysreg&= ~(ST_FW_CPU_FREQDIV_SEL);
	sysreg&= ~(ST_CK_CPU_FREQDIV_SEL);	
	sysreg&= ~(ST_CPU_FREQ_SEL);
8000bb50:	3c02ffe0 	lui	v0,0xffe0
8000bb54:	34427fff 	ori	v0,v0,0x7fff
8000bb58:	00621024 	and	v0,v1,v0

	sysreg|=  (clk_div & 0x03) <<ST_CPU_FREQDIV_SEL_OFFSET ;
8000bb5c:	3205000f 	andi	a1,s0,0xf
8000bb60:	00052bc0 	sll	a1,a1,0xf
8000bb64:	00a22825 	or	a1,a1,v0
	sysreg|=	 (clk_sel&0x0f)<<ST_CPU_FREQ_SEL_OFFSET ;
8000bb68:	32220003 	andi	v0,s1,0x3
8000bb6c:	000214c0 	sll	v0,v0,0x13
8000bb70:	00a22825 	or	a1,a1,v0
	//-------------------------

	clk_exp=cpu_clksel_table[clk_sel] / cpu_clkdiv_table[clk_div];
8000bb74:	00102080 	sll	a0,s0,0x2
8000bb78:	3c028001 	lui	v0,0x8001
8000bb7c:	244204b0 	addiu	v0,v0,1200
8000bb80:	00821021 	addu	v0,a0,v0
8000bb84:	8c440000 	lw	a0,0(v0)
8000bb88:	00118880 	sll	s1,s1,0x2
8000bb8c:	3c028001 	lui	v0,0x8001
8000bb90:	24427620 	addiu	v0,v0,30240
8000bb94:	02228821 	addu	s1,s1,v0
8000bb98:	8e220000 	lw	v0,0(s1)
	
#ifdef _verbose
	dprintf("Write SYS_HW_STRAP=%08x \n", sysreg);
#endif	

	REG32(SYS_HW_STRAP)=sysreg  ;
8000bb9c:	ae450000 	sw	a1,0(s2)
	//dprintf("Read  SYS_HW_STRAP=%08x \n", REG32(SYS_HW_STRAP));
	
	//--------------
	if(old_clk_sel != clk_sel)
8000bba0:	3c050007 	lui	a1,0x7
8000bba4:	34a58000 	ori	a1,a1,0x8000
8000bba8:	00651824 	and	v1,v1,a1
8000bbac:	00031bc2 	srl	v1,v1,0xf
8000bbb0:	1203004a 	beq	s0,v1,8000bcdc <SettingCPUClk+0x1fc>
8000bbb4:	00002821 	move	a1,zero
	{
#if 1
	HS0_Control(clk_exp, 0, 0, 0);
8000bbb8:	0082001b 	divu	zero,a0,v0
8000bbbc:	004001f4 	teq	v0,zero,0x7
8000bbc0:	00002012 	mflo	a0
8000bbc4:	00003021 	move	a2,zero
8000bbc8:	0c002817 	jal	8000a05c <HS0_Control>
8000bbcc:	00003821 	move	a3,zero
#endif	
		REG32(GISR_REG)=0xffffffff;	
8000bbd0:	3c02b800 	lui	v0,0xb800
8000bbd4:	34433004 	ori	v1,v0,0x3004
8000bbd8:	2404ffff 	li	a0,-1
8000bbdc:	ac640000 	sw	a0,0(v1)
		//dprintf("before sleep, Read  SYS_HW_STRAP=%08x \n", REG32(SYS_HW_STRAP));	
		//dprintf("GISR=%08x \n",REG32(GISR_REG));
		//dprintf("GIMR=%08x \n",REG32(GIMR_REG));	

		#if 1	
			REG32(SYS_CLKMANAGE) |= (1<<12)|(1<<13)|(1<<19)|(1<<20);  //active lx1 lx2
8000bbe0:	34430010 	ori	v1,v0,0x10
8000bbe4:	8c650000 	lw	a1,0(v1)
8000bbe8:	3c040018 	lui	a0,0x18
8000bbec:	34843000 	ori	a0,a0,0x3000
8000bbf0:	00a42025 	or	a0,a1,a0
8000bbf4:	ac640000 	sw	a0,0(v1)
		
			REG32(SYS_LX_CTRL) |= (1<<2) ;	  //lock bus arb2
8000bbf8:	34420014 	ori	v0,v0,0x14
8000bbfc:	8c430000 	lw	v1,0(v0)
8000bc00:	34630004 	ori	v1,v1,0x4
8000bc04:	ac430000 	sw	v1,0(v0)
			while( (REG32(SYS_LX_CTRL)&(1<<12))==0)  ; //wait bit to 1, is mean lock ok	
8000bc08:	00401821 	move	v1,v0
8000bc0c:	8c620000 	lw	v0,0(v1)
8000bc10:	30421000 	andi	v0,v0,0x1000
8000bc14:	1040fffd 	beqz	v0,8000bc0c <SettingCPUClk+0x12c>
8000bc18:	3c02b800 	lui	v0,0xb800

			REG32(SYS_LX_CTRL) |= (1<<3) ;	  //lock bus arb4
8000bc1c:	34420014 	ori	v0,v0,0x14
8000bc20:	8c430000 	lw	v1,0(v0)
8000bc24:	34630008 	ori	v1,v1,0x8
8000bc28:	ac430000 	sw	v1,0(v0)
			while( (REG32(SYS_LX_CTRL)&(1<<13))==0)  ; //wait bit to 1, is mean lock ok		
8000bc2c:	00401821 	move	v1,v0
8000bc30:	8c620000 	lw	v0,0(v1)
8000bc34:	30422000 	andi	v0,v0,0x2000
8000bc38:	1040fffd 	beqz	v0,8000bc30 <SettingCPUClk+0x150>
8000bc3c:	3c02b800 	lui	v0,0xb800

			REG32(SYS_LX_CTRL) |= (1<<4) ;	  //lock bus arb6
8000bc40:	34420014 	ori	v0,v0,0x14
8000bc44:	8c430000 	lw	v1,0(v0)
8000bc48:	34630010 	ori	v1,v1,0x10
8000bc4c:	ac430000 	sw	v1,0(v0)
			while( (REG32(SYS_LX_CTRL)&(1<<14))==0)  ; //wait bit to 1, is mean lock ok				
8000bc50:	00401821 	move	v1,v0
8000bc54:	8c620000 	lw	v0,0(v1)
8000bc58:	30424000 	andi	v0,v0,0x4000
8000bc5c:	1040fffd 	beqz	v0,8000bc54 <SettingCPUClk+0x174>
8000bc60:	00000000 	nop
	...
		
		__asm__ volatile("nop");
		__asm__ volatile("nop");
		__asm__ volatile("nop");
		__asm__ volatile("nop");
		__asm__ volatile("wait");	
8000bc74:	42000020 	wait
	...
		__asm__ volatile("nop");
		__asm__ volatile("nop");
		__asm__ volatile("nop");

		#if 1
			REG32(SYS_LX_CTRL) &= ~(1<<2);	//unlock
8000bc90:	3c03b800 	lui	v1,0xb800
8000bc94:	34620014 	ori	v0,v1,0x14
8000bc98:	8c450000 	lw	a1,0(v0)
8000bc9c:	2404fffb 	li	a0,-5
8000bca0:	00a42024 	and	a0,a1,a0
8000bca4:	ac440000 	sw	a0,0(v0)
			while( (REG32(SYS_LX_CTRL)&(1<<12))==(1<<0)) ;  //wait bit to 0  unlock
8000bca8:	8c440000 	lw	a0,0(v0)

			REG32(SYS_LX_CTRL) &= ~(1<<3);	//unlock
8000bcac:	8c450000 	lw	a1,0(v0)
8000bcb0:	2404fff7 	li	a0,-9
8000bcb4:	00a42024 	and	a0,a1,a0
8000bcb8:	ac440000 	sw	a0,0(v0)
			while( (REG32(SYS_LX_CTRL)&(1<<13))==(1<<1)) ;  //wait bit to 0  unlock
8000bcbc:	8c440000 	lw	a0,0(v0)

			REG32(SYS_LX_CTRL) &= ~(1<<4);	//unlock
8000bcc0:	8c450000 	lw	a1,0(v0)
8000bcc4:	2404ffef 	li	a0,-17
8000bcc8:	00a42024 	and	a0,a1,a0
8000bccc:	ac440000 	sw	a0,0(v0)
			while( (REG32(SYS_LX_CTRL)&(1<<14))==(1<<2)) ;  //wait bit to 0  unlock				
8000bcd0:	8c420000 	lw	v0,0(v0)
		#endif

		int strap_new=REG32(SYS_HW_STRAP) ;
8000bcd4:	34630008 	ori	v1,v1,0x8
8000bcd8:	8c620000 	lw	v0,0(v1)

	}
	
	//-----------------------
	//test cpu can work
	LetCPUDoSomething();
8000bcdc:	0c0027f6 	jal	80009fd8 <LetCPUDoSomething>
8000bce0:	00000000 	nop

	//-----------------------
	clk_curr = check_cpu_speed();
8000bce4:	0c003f06 	jal	8000fc18 <check_cpu_speed>
8000bce8:	00000000 	nop
	{	dprintf("Test FAIL! Curr_speed=%d but Exp_speed=%d \n", clk_curr, clk_exp);
		//while(1) ;
	}
#endif

}
8000bcec:	8fbf001c 	lw	ra,28(sp)
8000bcf0:	8fb20018 	lw	s2,24(sp)
8000bcf4:	8fb10014 	lw	s1,20(sp)
8000bcf8:	8fb00010 	lw	s0,16(sp)
8000bcfc:	03e00008 	jr	ra
8000bd00:	27bd0020 	addiu	sp,sp,32

8000bd04 <CmdCPUCLK>:
//---------------------------------------------------------------------------
int CmdCPUCLK(int argc, char* argv[])
{
8000bd04:	27bdffd0 	addiu	sp,sp,-48
8000bd08:	afbf002c 	sw	ra,44(sp)
8000bd0c:	afb50028 	sw	s5,40(sp)
8000bd10:	afb40024 	sw	s4,36(sp)
8000bd14:	afb30020 	sw	s3,32(sp)
8000bd18:	afb2001c 	sw	s2,28(sp)
8000bd1c:	afb10018 	sw	s1,24(sp)
8000bd20:	afb00014 	sw	s0,20(sp)
	int clk_curr;	


	
	int i;
	if( argc <1 )	//read
8000bd24:	1c80002b 	bgtz	a0,8000bdd4 <CmdCPUCLK+0xd0>
8000bd28:	00a08021 	move	s0,a1
	{
		clk_curr = check_cpu_speed();
8000bd2c:	0c003f06 	jal	8000fc18 <check_cpu_speed>
8000bd30:	3c118001 	lui	s1,0x8001
		dprintf("Now CPU Speed=%d \n",clk_curr);			
8000bd34:	3c048001 	lui	a0,0x8001
8000bd38:	24845f10 	addiu	a0,a0,24336
8000bd3c:	0c002325 	jal	80008c94 <dprintf>
8000bd40:	00402821 	move	a1,v0
		ShowStrapMsg();	
8000bd44:	0c002870 	jal	8000a1c0 <ShowStrapMsg>
8000bd48:	263104b4 	addiu	s1,s1,1204
		dprintf("Usage: CPUCLK clk_sel div_value : 0-f, 0-3  \n");	
8000bd4c:	3c048001 	lui	a0,0x8001
8000bd50:	0c002325 	jal	80008c94 <dprintf>
8000bd54:	24845f24 	addiu	a0,a0,24356
		dprintf("Usage: CPUCLK 999 999: test all freq  \n");		
8000bd58:	3c048001 	lui	a0,0x8001
8000bd5c:	0c002325 	jal	80008c94 <dprintf>
8000bd60:	24845f54 	addiu	a0,a0,24404


		int i;
		for(i=0; i<16;i++)
		{ dprintf(" %x : %d MHz,  ", i, cpu_clksel_table[i]);
8000bd64:	3c048001 	lui	a0,0x8001
8000bd68:	24845f7c 	addiu	a0,a0,24444
8000bd6c:	00002821 	move	a1,zero
8000bd70:	0c002325 	jal	80008c94 <dprintf>
8000bd74:	240601c2 	li	a2,450
8000bd78:	00008021 	move	s0,zero
		dprintf("Usage: CPUCLK clk_sel div_value : 0-f, 0-3  \n");	
		dprintf("Usage: CPUCLK 999 999: test all freq  \n");		


		int i;
		for(i=0; i<16;i++)
8000bd7c:	24120010 	li	s2,16
		{ dprintf(" %x : %d MHz,  ", i, cpu_clksel_table[i]);
8000bd80:	3c138001 	lui	s3,0x8001
8000bd84:	26735f7c 	addiu	s3,s3,24444
		  if( (i&0x3) ==0x3) dprintf("\n");
8000bd88:	24140003 	li	s4,3
8000bd8c:	3c158001 	lui	s5,0x8001
8000bd90:	08002f70 	j	8000bdc0 <CmdCPUCLK+0xbc>
8000bd94:	26b557b8 	addiu	s5,s5,22456
		dprintf("Usage: CPUCLK 999 999: test all freq  \n");		


		int i;
		for(i=0; i<16;i++)
		{ dprintf(" %x : %d MHz,  ", i, cpu_clksel_table[i]);
8000bd98:	02602021 	move	a0,s3
8000bd9c:	02002821 	move	a1,s0
8000bda0:	0c002325 	jal	80008c94 <dprintf>
8000bda4:	8e260000 	lw	a2,0(s1)
		  if( (i&0x3) ==0x3) dprintf("\n");
8000bda8:	32020003 	andi	v0,s0,0x3
8000bdac:	14540003 	bne	v0,s4,8000bdbc <CmdCPUCLK+0xb8>
8000bdb0:	00000000 	nop
8000bdb4:	0c002325 	jal	80008c94 <dprintf>
8000bdb8:	02a02021 	move	a0,s5
8000bdbc:	26310004 	addiu	s1,s1,4
		dprintf("Usage: CPUCLK clk_sel div_value : 0-f, 0-3  \n");	
		dprintf("Usage: CPUCLK 999 999: test all freq  \n");		


		int i;
		for(i=0; i<16;i++)
8000bdc0:	26100001 	addiu	s0,s0,1
8000bdc4:	1612fff4 	bne	s0,s2,8000bd98 <CmdCPUCLK+0x94>
8000bdc8:	8fbf002c 	lw	ra,44(sp)
			
	}
	else
		SettingCPUClk(clk_sel, clk_div);

}
8000bdcc:	08002fae 	j	8000beb8 <CmdCPUCLK+0x1b4>
8000bdd0:	8fb50028 	lw	s5,40(sp)
		return;	
	}


	
	if(argv[0])	clk_sel = strtoul((const char*)(argv[0]), (char **)NULL, 16);
8000bdd4:	8ca40000 	lw	a0,0(a1)
8000bdd8:	10800005 	beqz	a0,8000bdf0 <CmdCPUCLK+0xec>
8000bddc:	00009021 	move	s2,zero
8000bde0:	00002821 	move	a1,zero
8000bde4:	0c0020c4 	jal	80008310 <strtoul>
8000bde8:	24060010 	li	a2,16
8000bdec:	00409021 	move	s2,v0
	if(argv[1])	clk_div = strtoul((const char*)(argv[1]), (char **)NULL, 16);
8000bdf0:	8e040004 	lw	a0,4(s0)
8000bdf4:	10800005 	beqz	a0,8000be0c <CmdCPUCLK+0x108>
8000bdf8:	00008821 	move	s1,zero
8000bdfc:	00002821 	move	a1,zero
8000be00:	0c0020c4 	jal	80008310 <strtoul>
8000be04:	24060010 	li	a2,16
8000be08:	00408821 	move	s1,v0
//	if(argv[2])	sync_oc = strtoul((const char*)(argv[2]), (char **)NULL, 16);


	if(clk_sel==0x999)
8000be0c:	24020999 	li	v0,2457
8000be10:	16420025 	bne	s2,v0,8000bea8 <CmdCPUCLK+0x1a4>
8000be14:	02402021 	move	a0,s2
				SettingCPUClk(clk_sel, 3);

			for(clk_sel=0; clk_sel<=0x0f; clk_sel++)
				SettingCPUClk(clk_sel, 2);
			
			for(clk_sel=0; clk_sel<=0x0f; clk_sel++)
8000be18:	00008021 	move	s0,zero
//	if(argv[2])	sync_oc = strtoul((const char*)(argv[2]), (char **)NULL, 16);


	if(clk_sel==0x999)
	{
		if(clk_div==0x999)
8000be1c:	1622001a 	bne	s1,v0,8000be88 <CmdCPUCLK+0x184>
8000be20:	24120010 	li	s2,16
		{
			for(clk_sel=0; clk_sel<=0x0f; clk_sel++)
8000be24:	24110010 	li	s1,16
				SettingCPUClk(clk_sel, 3);
8000be28:	02002021 	move	a0,s0
8000be2c:	0c002eb8 	jal	8000bae0 <SettingCPUClk>
8000be30:	24050003 	li	a1,3

	if(clk_sel==0x999)
	{
		if(clk_div==0x999)
		{
			for(clk_sel=0; clk_sel<=0x0f; clk_sel++)
8000be34:	26100001 	addiu	s0,s0,1
8000be38:	1611fffc 	bne	s0,s1,8000be2c <CmdCPUCLK+0x128>
8000be3c:	02002021 	move	a0,s0
8000be40:	00008021 	move	s0,zero
				SettingCPUClk(clk_sel, 3);

			for(clk_sel=0; clk_sel<=0x0f; clk_sel++)
8000be44:	24110010 	li	s1,16
				SettingCPUClk(clk_sel, 2);
8000be48:	02002021 	move	a0,s0
8000be4c:	0c002eb8 	jal	8000bae0 <SettingCPUClk>
8000be50:	24050002 	li	a1,2
		if(clk_div==0x999)
		{
			for(clk_sel=0; clk_sel<=0x0f; clk_sel++)
				SettingCPUClk(clk_sel, 3);

			for(clk_sel=0; clk_sel<=0x0f; clk_sel++)
8000be54:	26100001 	addiu	s0,s0,1
8000be58:	1611fffc 	bne	s0,s1,8000be4c <CmdCPUCLK+0x148>
8000be5c:	02002021 	move	a0,s0
8000be60:	00008021 	move	s0,zero
				SettingCPUClk(clk_sel, 2);
			
			for(clk_sel=0; clk_sel<=0x0f; clk_sel++)
8000be64:	24110010 	li	s1,16
				SettingCPUClk(clk_sel, 0);
8000be68:	02002021 	move	a0,s0
8000be6c:	0c002eb8 	jal	8000bae0 <SettingCPUClk>
8000be70:	00002821 	move	a1,zero
				SettingCPUClk(clk_sel, 3);

			for(clk_sel=0; clk_sel<=0x0f; clk_sel++)
				SettingCPUClk(clk_sel, 2);
			
			for(clk_sel=0; clk_sel<=0x0f; clk_sel++)
8000be74:	26100001 	addiu	s0,s0,1
8000be78:	1611fffc 	bne	s0,s1,8000be6c <CmdCPUCLK+0x168>
8000be7c:	02002021 	move	a0,s0
			
	}
	else
		SettingCPUClk(clk_sel, clk_div);

}
8000be80:	08002fad 	j	8000beb4 <CmdCPUCLK+0x1b0>
8000be84:	8fbf002c 	lw	ra,44(sp)
				SettingCPUClk(clk_sel, 0);
		}
		else
		{
			for(clk_sel=0; clk_sel<=0x0f; clk_sel++)
				SettingCPUClk(clk_sel, clk_div);
8000be88:	02002021 	move	a0,s0
8000be8c:	0c002eb8 	jal	8000bae0 <SettingCPUClk>
8000be90:	02202821 	move	a1,s1
			for(clk_sel=0; clk_sel<=0x0f; clk_sel++)
				SettingCPUClk(clk_sel, 0);
		}
		else
		{
			for(clk_sel=0; clk_sel<=0x0f; clk_sel++)
8000be94:	26100001 	addiu	s0,s0,1
8000be98:	1612fffc 	bne	s0,s2,8000be8c <CmdCPUCLK+0x188>
8000be9c:	02002021 	move	a0,s0
			
	}
	else
		SettingCPUClk(clk_sel, clk_div);

}
8000bea0:	08002fad 	j	8000beb4 <CmdCPUCLK+0x1b0>
8000bea4:	8fbf002c 	lw	ra,44(sp)
		}

			
	}
	else
		SettingCPUClk(clk_sel, clk_div);
8000bea8:	0c002eb8 	jal	8000bae0 <SettingCPUClk>
8000beac:	02202821 	move	a1,s1

}
8000beb0:	8fbf002c 	lw	ra,44(sp)
8000beb4:	8fb50028 	lw	s5,40(sp)
8000beb8:	8fb40024 	lw	s4,36(sp)
8000bebc:	8fb30020 	lw	s3,32(sp)
8000bec0:	8fb2001c 	lw	s2,28(sp)
8000bec4:	8fb10018 	lw	s1,24(sp)
8000bec8:	8fb00014 	lw	s0,20(sp)
8000becc:	03e00008 	jr	ra
8000bed0:	27bd0030 	addiu	sp,sp,48

8000bed4 <CPUWAKEUP>:

}

//------------------------------------------------------------------------------
void CPUWAKEUP(void)
{
8000bed4:	27bdffe8 	addiu	sp,sp,-24
8000bed8:	afbf0014 	sw	ra,20(sp)
	request_IRQ(SPEED_IRQ_NO, &irq_SPEED, NULL); 
8000bedc:	2404002b 	li	a0,43
8000bee0:	3c058001 	lui	a1,0x8001
8000bee4:	24a57630 	addiu	a1,a1,30256
8000bee8:	0c000274 	jal	800009d0 <request_IRQ>
8000beec:	00003021 	move	a2,zero
}
8000bef0:	8fbf0014 	lw	ra,20(sp)
8000bef4:	03e00008 	jr	ra
8000bef8:	27bd0018 	addiu	sp,sp,24
8000befc:	00000000 	nop

8000bf00 <Enable_SRAM>:

//------------------------------------------------------------------------
void Enable_SRAM(unsigned int paddr)
{
	//unmap
	REG32(0xb8001304)=0x5;   //unmap seg len=4K
8000bf00:	3c02b800 	lui	v0,0xb800
8000bf04:	34451304 	ori	a1,v0,0x1304
8000bf08:	24030005 	li	v1,5
8000bf0c:	aca30000 	sw	v1,0(a1)
	REG32(0xb8001300)=(unsigned int)paddr |1;   //unmap seg addr
8000bf10:	34840001 	ori	a0,a0,0x1
8000bf14:	34451300 	ori	a1,v0,0x1300
8000bf18:	aca40000 	sw	a0,0(a1)

	//enable sram
	REG32(0xb8004004)=0x05;   //sram seg len=4K		
8000bf1c:	34454004 	ori	a1,v0,0x4004
8000bf20:	aca30000 	sw	v1,0(a1)
	REG32(0xb8004000)=(unsigned int)paddr |1;   //sram seg addr
8000bf24:	34424000 	ori	v0,v0,0x4000
8000bf28:	ac440000 	sw	a0,0(v0)
}
8000bf2c:	03e00008 	jr	ra
8000bf30:	00000000 	nop

8000bf34 <Disable_SRAM>:

void Disable_SRAM()
{
	//unmap
	REG32(0xb8001300)=0;   //unmap seg addr
8000bf34:	3c02b800 	lui	v0,0xb800
8000bf38:	34431300 	ori	v1,v0,0x1300
8000bf3c:	ac600000 	sw	zero,0(v1)
	//enable sram
	REG32(0xb8004000)=0;   //sram seg addr
8000bf40:	34424000 	ori	v0,v0,0x4000
8000bf44:	ac400000 	sw	zero,0(v0)
}
8000bf48:	03e00008 	jr	ra
8000bf4c:	00000000 	nop

8000bf50 <PCIE_MDIO_Reset>:
        #define SYS_PCIE_PHY0   (0xb8000000 +0x50)
        #define SYS_PCIE_PHY1   (0xb8000000 +0x54)	
	 
	unsigned int sys_pcie_phy;

	if(portnum==0)	sys_pcie_phy=SYS_PCIE_PHY0;
8000bf50:	14800003 	bnez	a0,8000bf60 <PCIE_MDIO_Reset+0x10>
8000bf54:	3c02b800 	lui	v0,0xb800
8000bf58:	08002fdc 	j	8000bf70 <PCIE_MDIO_Reset+0x20>
8000bf5c:	34420050 	ori	v0,v0,0x50
	else if(portnum==1)	sys_pcie_phy=SYS_PCIE_PHY1;
8000bf60:	24020001 	li	v0,1
8000bf64:	14820008 	bne	a0,v0,8000bf88 <PCIE_MDIO_Reset+0x38>
8000bf68:	3c02b800 	lui	v0,0xb800
8000bf6c:	34420054 	ori	v0,v0,0x54
	else return;
		
       // 3.MDIO Reset
 	   REG32(sys_pcie_phy) = (1<<3) |(0<<1) | (0<<0);     //mdio reset=0,     	    //0x088
8000bf70:	24030008 	li	v1,8
8000bf74:	ac430000 	sw	v1,0(v0)
 	   REG32(sys_pcie_phy) = (1<<3) |(0<<1) | (1<<0);     //mdio reset=1,           //0x09
8000bf78:	24030009 	li	v1,9
8000bf7c:	ac430000 	sw	v1,0(v0)
 	   REG32(sys_pcie_phy) = (1<<3) |(1<<1) | (1<<0);     //bit1 load_done=1       //0x0b
8000bf80:	2403000b 	li	v1,11
8000bf84:	ac430000 	sw	v1,0(v0)
8000bf88:	03e00008 	jr	ra
8000bf8c:	00000000 	nop

8000bf90 <PCIE_PHY_Reset>:
	 #define PCIE_PHY0 	0xb8b01008
	 #define PCIE_PHY1 	0xb8b21008
	 
	unsigned int pcie_phy;

	if(portnum==0)	pcie_phy=PCIE_PHY0;
8000bf90:	14800003 	bnez	a0,8000bfa0 <PCIE_PHY_Reset+0x10>
8000bf94:	3c02b8b0 	lui	v0,0xb8b0
8000bf98:	08002fec 	j	8000bfb0 <PCIE_PHY_Reset+0x20>
8000bf9c:	34421008 	ori	v0,v0,0x1008
	else if(portnum==1)	pcie_phy=PCIE_PHY1;
8000bfa0:	24020001 	li	v0,1
8000bfa4:	14820006 	bne	a0,v0,8000bfc0 <PCIE_PHY_Reset+0x30>
8000bfa8:	3c02b8b2 	lui	v0,0xb8b2
8000bfac:	34421008 	ori	v0,v0,0x1008
	else return;

        //4. PCIE PHY Reset       
	REG32(pcie_phy) = 0x01;	//bit7:PHY reset=0   bit0: Enable LTSSM=1
8000bfb0:	24030001 	li	v1,1
8000bfb4:	ac430000 	sw	v1,0(v0)
	REG32(pcie_phy) = 0x81;   //bit7: PHY reset=1   bit0: Enable LTSSM=1
8000bfb8:	24030081 	li	v1,129
8000bfbc:	ac430000 	sw	v1,0(v0)
8000bfc0:	03e00008 	jr	ra
8000bfc4:	00000000 	nop

8000bfc8 <HostPCIe_SetPhyMdioRead>:
//------------------------------------------------------------------------
unsigned int HostPCIe_SetPhyMdioRead(unsigned int portnum, unsigned int regaddr)
{
	unsigned int mdioaddr;

	if(portnum==0)		mdioaddr=PCIE0_MDIO;	
8000bfc8:	14800004 	bnez	a0,8000bfdc <HostPCIe_SetPhyMdioRead+0x14>
8000bfcc:	27bdfff8 	addiu	sp,sp,-8
8000bfd0:	3c03b8b0 	lui	v1,0xb8b0
8000bfd4:	08003001 	j	8000c004 <HostPCIe_SetPhyMdioRead+0x3c>
8000bfd8:	34631000 	ori	v1,v1,0x1000
	else if(portnum==1)	mdioaddr=PCIE1_MDIO;
8000bfdc:	24020001 	li	v0,1
8000bfe0:	14820003 	bne	a0,v0,8000bff0 <HostPCIe_SetPhyMdioRead+0x28>
8000bfe4:	3c03b8b2 	lui	v1,0xb8b2
8000bfe8:	08003001 	j	8000c004 <HostPCIe_SetPhyMdioRead+0x3c>
8000bfec:	34631000 	ori	v1,v1,0x1000
	else if(portnum==2)	mdioaddr=0xb8b410c0;	  //EP MDIO
8000bff0:	24030002 	li	v1,2
8000bff4:	14830014 	bne	a0,v1,8000c048 <HostPCIe_SetPhyMdioRead+0x80>
8000bff8:	00001021 	move	v0,zero
8000bffc:	3c03b8b4 	lui	v1,0xb8b4
8000c000:	346310c0 	ori	v1,v1,0x10c0
	else return 0;
	
	REG32(mdioaddr)= ((regaddr&0x1f)<<PCIE_MDIO_REG_OFFSET)  | (0<<PCIE_MDIO_RDWR_OFFSET); 
8000c004:	30a5001f 	andi	a1,a1,0x1f
8000c008:	00052a00 	sll	a1,a1,0x8
8000c00c:	ac650000 	sw	a1,0(v1)
	//delay 
	volatile int i;
	for(i=0;i<5555;i++)  ;
8000c010:	afa00000 	sw	zero,0(sp)
8000c014:	8fa20000 	lw	v0,0(sp)
8000c018:	284215b3 	slti	v0,v0,5555
8000c01c:	10400008 	beqz	v0,8000c040 <HostPCIe_SetPhyMdioRead+0x78>
8000c020:	00000000 	nop
8000c024:	8fa20000 	lw	v0,0(sp)
8000c028:	24420001 	addiu	v0,v0,1
8000c02c:	afa20000 	sw	v0,0(sp)
8000c030:	8fa20000 	lw	v0,0(sp)
8000c034:	284215b3 	slti	v0,v0,5555
8000c038:	1440fffa 	bnez	v0,8000c024 <HostPCIe_SetPhyMdioRead+0x5c>
8000c03c:	00000000 	nop

	int val;
	val=REG32(mdioaddr)&  (0xffff <<PCIE_MDIO_DATA_OFFSET) ;
8000c040:	8c620000 	lw	v0,0(v1)
	return ((val>>PCIE_MDIO_DATA_OFFSET)&0xffff);
8000c044:	00021402 	srl	v0,v0,0x10
	
}
8000c048:	27bd0008 	addiu	sp,sp,8
8000c04c:	03e00008 	jr	ra
8000c050:	00000000 	nop

8000c054 <HostPCIe_SetPhyMdioWrite>:


void HostPCIe_SetPhyMdioWrite(unsigned int portnum, unsigned int regaddr, unsigned short val)
{
8000c054:	27bdfff8 	addiu	sp,sp,-8
	unsigned int mdioaddr;

	if(portnum==0)		mdioaddr=PCIE0_MDIO;	
8000c058:	14800004 	bnez	a0,8000c06c <HostPCIe_SetPhyMdioWrite+0x18>
8000c05c:	30c6ffff 	andi	a2,a2,0xffff
8000c060:	3c02b8b0 	lui	v0,0xb8b0
8000c064:	08003024 	j	8000c090 <HostPCIe_SetPhyMdioWrite+0x3c>
8000c068:	34421000 	ori	v0,v0,0x1000
	else if(portnum==1)	mdioaddr=PCIE1_MDIO;
8000c06c:	24020001 	li	v0,1
8000c070:	14820003 	bne	a0,v0,8000c080 <HostPCIe_SetPhyMdioWrite+0x2c>
8000c074:	3c02b8b2 	lui	v0,0xb8b2
8000c078:	08003024 	j	8000c090 <HostPCIe_SetPhyMdioWrite+0x3c>
8000c07c:	34421000 	ori	v0,v0,0x1000
	else if(portnum==2)	mdioaddr=0xb8b410c0;	  //EP MDIO	
8000c080:	24020002 	li	v0,2
8000c084:	14820014 	bne	a0,v0,8000c0d8 <HostPCIe_SetPhyMdioWrite+0x84>
8000c088:	3c02b8b4 	lui	v0,0xb8b4
8000c08c:	344210c0 	ori	v0,v0,0x10c0
	else return 0;
	
	REG32(mdioaddr)= ( (regaddr&0x1f)<<PCIE_MDIO_REG_OFFSET) | ((val&0xffff)<<PCIE_MDIO_DATA_OFFSET)  | (1<<PCIE_MDIO_RDWR_OFFSET) ; 
8000c090:	30a5001f 	andi	a1,a1,0x1f
8000c094:	00052a00 	sll	a1,a1,0x8
8000c098:	34a50001 	ori	a1,a1,0x1
8000c09c:	00063400 	sll	a2,a2,0x10
8000c0a0:	00a63025 	or	a2,a1,a2
8000c0a4:	ac460000 	sw	a2,0(v0)
	//delay 
	volatile int i;
	for(i=0;i<5555;i++)  ;
8000c0a8:	afa00000 	sw	zero,0(sp)
8000c0ac:	8fa20000 	lw	v0,0(sp)
8000c0b0:	284215b3 	slti	v0,v0,5555
8000c0b4:	10400008 	beqz	v0,8000c0d8 <HostPCIe_SetPhyMdioWrite+0x84>
8000c0b8:	00000000 	nop
8000c0bc:	8fa20000 	lw	v0,0(sp)
8000c0c0:	24420001 	addiu	v0,v0,1
8000c0c4:	afa20000 	sw	v0,0(sp)
8000c0c8:	8fa20000 	lw	v0,0(sp)
8000c0cc:	284215b3 	slti	v0,v0,5555
8000c0d0:	1440fffa 	bnez	v0,8000c0bc <HostPCIe_SetPhyMdioWrite+0x68>
8000c0d4:	00000000 	nop
}
8000c0d8:	27bd0008 	addiu	sp,sp,8
8000c0dc:	03e00008 	jr	ra
8000c0e0:	00000000 	nop

8000c0e4 <HostPCIe_TestINT>:

}; 

//---------------------------------------------------------------------------
int  HostPCIe_TestINT(int argc, char* argv[])
{
8000c0e4:	27bdffc8 	addiu	sp,sp,-56
8000c0e8:	afbf0034 	sw	ra,52(sp)
8000c0ec:	afbe0030 	sw	s8,48(sp)
8000c0f0:	afb7002c 	sw	s7,44(sp)
8000c0f4:	afb60028 	sw	s6,40(sp)
8000c0f8:	afb50024 	sw	s5,36(sp)
8000c0fc:	afb40020 	sw	s4,32(sp)
8000c100:	afb3001c 	sw	s3,28(sp)
8000c104:	afb20018 	sw	s2,24(sp)
8000c108:	afb10014 	sw	s1,20(sp)
8000c10c:	afb00010 	sw	s0,16(sp)
	if( argc < 2 ) 
8000c110:	28820002 	slti	v0,a0,2
8000c114:	10400006 	beqz	v0,8000c130 <HostPCIe_TestINT+0x4c>
8000c118:	00a08021 	move	s0,a1
	{
		dprintf("eint <portnum> <loops>.\n");	
8000c11c:	3c048001 	lui	a0,0x8001
8000c120:	0c002325 	jal	80008c94 <dprintf>
8000c124:	24845f94 	addiu	a0,a0,24468
8000c128:	080030a5 	j	8000c294 <HostPCIe_TestINT+0x1b0>
8000c12c:	00001021 	move	v0,zero
	
		return 0;
	}
	unsigned int portnum=0, loops=10;
	if(argc>=1)	portnum = strtoul((const char*)(argv[0]), (char **)NULL, 16);
8000c130:	18800052 	blez	a0,8000c27c <HostPCIe_TestINT+0x198>
8000c134:	00000000 	nop
8000c138:	8ca40000 	lw	a0,0(a1)
8000c13c:	00002821 	move	a1,zero
8000c140:	0c0020c4 	jal	80008310 <strtoul>
8000c144:	24060010 	li	a2,16
8000c148:	00408821 	move	s1,v0
	if(argc>=2)   loops = strtoul((const char*)(argv[1]), (char **)NULL, 16);
8000c14c:	8e040004 	lw	a0,4(s0)
8000c150:	00002821 	move	a1,zero
8000c154:	0c0020c4 	jal	80008310 <strtoul>
8000c158:	24060010 	li	a2,16

	int rc_cfg, cfgaddr;
	int iomapaddr;
	int memmapaddr;
	
	if(portnum==0)
8000c15c:	1620003e 	bnez	s1,8000c258 <HostPCIe_TestINT+0x174>
8000c160:	0040b821 	move	s7,v0
		cfgaddr=PCIE1_EP_CFG_BASE;
		iomapaddr=PCIE1_MAP_IO_BASE;
		memmapaddr=PCIE1_MAP_MEM_BASE;	
	}

	REG32(memmapaddr + 0x3c) |= (1<<8);  //swint mask
8000c164:	3c10b900 	lui	s0,0xb900
8000c168:	3610003c 	ori	s0,s0,0x3c
8000c16c:	8e020000 	lw	v0,0(s0)
8000c170:	34420100 	ori	v0,v0,0x100
8000c174:	ae020000 	sw	v0,0(s0)
8000c178:	0200b021 	move	s6,s0
8000c17c:	3c15b900 	lui	s5,0xb900
8000c180:	3c130020 	lui	s3,0x20

	
	#define GISR (0xb8003004)
	
	int i;
	for(i=0; i<loops; i++)
8000c184:	12e00032 	beqz	s7,8000c250 <HostPCIe_TestINT+0x16c>
8000c188:	0000a021 	move	s4,zero
	{

		REG32(memmapaddr + 0x38) |= (1<<0);  //kick swint
8000c18c:	26b50038 	addiu	s5,s5,56
		
		while(1) 
		{
			if( REG32(memmapaddr + 0x3c) & SWINT)   //check interrupt status swINT=1
8000c190:	3c120100 	lui	s2,0x100
				break;
		}

		dprintf("Got   SWINT %x=%x \n",memmapaddr + 0x3c, REG32(memmapaddr + 0x3c) );
8000c194:	3c1e8001 	lui	s8,0x8001
8000c198:	27de5fb0 	addiu	s8,s8,24496

		
		while(1) 
		{
			if( REG32(GISR) & PCIEISR )  //check pcie port 0
8000c19c:	3c11b800 	lui	s1,0xb800
8000c1a0:	36313004 	ori	s1,s1,0x3004
	
	int i;
	for(i=0; i<loops; i++)
	{

		REG32(memmapaddr + 0x38) |= (1<<0);  //kick swint
8000c1a4:	8ea20000 	lw	v0,0(s5)
8000c1a8:	34420001 	ori	v0,v0,0x1
8000c1ac:	aea20000 	sw	v0,0(s5)
		
		while(1) 
		{
			if( REG32(memmapaddr + 0x3c) & SWINT)   //check interrupt status swINT=1
8000c1b0:	8e020000 	lw	v0,0(s0)
8000c1b4:	00521024 	and	v0,v0,s2
8000c1b8:	1040fffd 	beqz	v0,8000c1b0 <HostPCIe_TestINT+0xcc>
8000c1bc:	00000000 	nop
				break;
		}

		dprintf("Got   SWINT %x=%x \n",memmapaddr + 0x3c, REG32(memmapaddr + 0x3c) );
8000c1c0:	8e060000 	lw	a2,0(s0)
8000c1c4:	03c02021 	move	a0,s8
8000c1c8:	0c002325 	jal	80008c94 <dprintf>
8000c1cc:	02c02821 	move	a1,s6

		
		while(1) 
		{
			if( REG32(GISR) & PCIEISR )  //check pcie port 0
8000c1d0:	8e220000 	lw	v0,0(s1)
8000c1d4:	02621024 	and	v0,s3,v0
8000c1d8:	1040fffd 	beqz	v0,8000c1d0 <HostPCIe_TestINT+0xec>
8000c1dc:	00000000 	nop
				break;
		}
		dprintf("Got   GISR=%x \n", REG32(0xb8003004) );
8000c1e0:	8e250000 	lw	a1,0(s1)
8000c1e4:	3c048001 	lui	a0,0x8001
8000c1e8:	0c002325 	jal	80008c94 <dprintf>
8000c1ec:	24845fc4 	addiu	a0,a0,24516


		//-----------------
		REG32(memmapaddr + 0x3c) |= SWINT;  //write to clear
8000c1f0:	8e020000 	lw	v0,0(s0)
8000c1f4:	00521025 	or	v0,v0,s2
8000c1f8:	ae020000 	sw	v0,0(s0)



		while(1) 
		{
			if( (REG32(memmapaddr + 0x3c) & SWINT) ==0)  //check interrupt status swINT=1
8000c1fc:	8e020000 	lw	v0,0(s0)
8000c200:	00521024 	and	v0,v0,s2
8000c204:	1440fffd 	bnez	v0,8000c1fc <HostPCIe_TestINT+0x118>
8000c208:	00000000 	nop
				break;
		}

		dprintf("Clear SWINT %x=%x \n",memmapaddr + 0x3c, REG32(memmapaddr + 0x3c) );
8000c20c:	8e060000 	lw	a2,0(s0)
8000c210:	3c048001 	lui	a0,0x8001
8000c214:	24845fd4 	addiu	a0,a0,24532
8000c218:	0c002325 	jal	80008c94 <dprintf>
8000c21c:	02c02821 	move	a1,s6

		
		while(1) 
		{
			if( (REG32(GISR) & PCIEISR )==0)  //check pcie port 0
8000c220:	8e220000 	lw	v0,0(s1)
8000c224:	02621024 	and	v0,s3,v0
8000c228:	1440fffd 	bnez	v0,8000c220 <HostPCIe_TestINT+0x13c>
8000c22c:	00000000 	nop
				break;
		}
		dprintf("Clear GISR=%x \n", REG32(0xb8003004) );
8000c230:	8e250000 	lw	a1,0(s1)
8000c234:	3c048001 	lui	a0,0x8001
8000c238:	0c002325 	jal	80008c94 <dprintf>
8000c23c:	24845fe8 	addiu	a0,a0,24552

	
	#define GISR (0xb8003004)
	
	int i;
	for(i=0; i<loops; i++)
8000c240:	26940001 	addiu	s4,s4,1
8000c244:	0297102b 	sltu	v0,s4,s7
8000c248:	1440ffd6 	bnez	v0,8000c1a4 <HostPCIe_TestINT+0xc0>
8000c24c:	00000000 	nop
		}
		dprintf("Clear GISR=%x \n", REG32(0xb8003004) );
	}
	

}
8000c250:	080030a6 	j	8000c298 <HostPCIe_TestINT+0x1b4>
8000c254:	8fbf0034 	lw	ra,52(sp)
		cfgaddr=PCIE1_EP_CFG_BASE;
		iomapaddr=PCIE1_MAP_IO_BASE;
		memmapaddr=PCIE1_MAP_MEM_BASE;	
	}

	REG32(memmapaddr + 0x3c) |= (1<<8);  //swint mask
8000c258:	3c10ba00 	lui	s0,0xba00
8000c25c:	3610003c 	ori	s0,s0,0x3c
8000c260:	8e020000 	lw	v0,0(s0)
8000c264:	34420100 	ori	v0,v0,0x100
8000c268:	ae020000 	sw	v0,0(s0)
8000c26c:	0200b021 	move	s6,s0
8000c270:	3c15ba00 	lui	s5,0xba00
8000c274:	08003061 	j	8000c184 <HostPCIe_TestINT+0xa0>
8000c278:	3c130040 	lui	s3,0x40
	
		return 0;
	}
	unsigned int portnum=0, loops=10;
	if(argc>=1)	portnum = strtoul((const char*)(argv[0]), (char **)NULL, 16);
	if(argc>=2)   loops = strtoul((const char*)(argv[1]), (char **)NULL, 16);
8000c27c:	8ca40004 	lw	a0,4(a1)
8000c280:	00002821 	move	a1,zero
8000c284:	0c0020c4 	jal	80008310 <strtoul>
8000c288:	24060010 	li	a2,16
8000c28c:	08003059 	j	8000c164 <HostPCIe_TestINT+0x80>
8000c290:	0040b821 	move	s7,v0
		}
		dprintf("Clear GISR=%x \n", REG32(0xb8003004) );
	}
	

}
8000c294:	8fbf0034 	lw	ra,52(sp)
8000c298:	8fbe0030 	lw	s8,48(sp)
8000c29c:	8fb7002c 	lw	s7,44(sp)
8000c2a0:	8fb60028 	lw	s6,40(sp)
8000c2a4:	8fb50024 	lw	s5,36(sp)
8000c2a8:	8fb40020 	lw	s4,32(sp)
8000c2ac:	8fb3001c 	lw	s3,28(sp)
8000c2b0:	8fb20018 	lw	s2,24(sp)
8000c2b4:	8fb10014 	lw	s1,20(sp)
8000c2b8:	8fb00010 	lw	s0,16(sp)
8000c2bc:	03e00008 	jr	ra
8000c2c0:	27bd0038 	addiu	sp,sp,56

8000c2c4 <HostPCIe_MDIOWrite>:


}; 
//----------------------------------------------------------------------------
int HostPCIe_MDIOWrite(int argc, char* argv[])
{
8000c2c4:	27bdffe0 	addiu	sp,sp,-32
8000c2c8:	afbf001c 	sw	ra,28(sp)
8000c2cc:	afb20018 	sw	s2,24(sp)
8000c2d0:	afb10014 	sw	s1,20(sp)
8000c2d4:	afb00010 	sw	s0,16(sp)

	if(argc<3)
8000c2d8:	28840003 	slti	a0,a0,3
8000c2dc:	10800009 	beqz	a0,8000c304 <HostPCIe_MDIOWrite+0x40>
8000c2e0:	00a08021 	move	s0,a1
	{	 
		dprintf("mdiow <portnum> <addr> <val> \n");		
8000c2e4:	3c048001 	lui	a0,0x8001
8000c2e8:	0c002325 	jal	80008c94 <dprintf>
8000c2ec:	24845ff8 	addiu	a0,a0,24568
		dprintf("ex: mdiow 0 00  ffff \n");			
8000c2f0:	3c048001 	lui	a0,0x8001
8000c2f4:	0c002325 	jal	80008c94 <dprintf>
8000c2f8:	24846018 	addiu	a0,a0,24600
		return;	
8000c2fc:	080030d4 	j	8000c350 <HostPCIe_MDIOWrite+0x8c>
8000c300:	8fbf001c 	lw	ra,28(sp)
	}

	unsigned int portnum = strtoul((const char*)(argv[0]), (char **)NULL, 16);	
8000c304:	8ca40000 	lw	a0,0(a1)
8000c308:	00002821 	move	a1,zero
8000c30c:	0c0020c4 	jal	80008310 <strtoul>
8000c310:	24060010 	li	a2,16
8000c314:	00408821 	move	s1,v0
	unsigned int addr = strtoul((const char*)(argv[1]), (char **)NULL, 16);	
8000c318:	8e040004 	lw	a0,4(s0)
8000c31c:	00002821 	move	a1,zero
8000c320:	0c0020c4 	jal	80008310 <strtoul>
8000c324:	24060010 	li	a2,16
8000c328:	00409021 	move	s2,v0
	unsigned int val = strtoul((const char*)(argv[2]), (char **)NULL, 16);	
8000c32c:	8e040008 	lw	a0,8(s0)
8000c330:	00002821 	move	a1,zero
8000c334:	0c0020c4 	jal	80008310 <strtoul>
8000c338:	24060010 	li	a2,16
/*
	REG32(PCIE0_MDIO)= (addr<<PCIE_MDIO_REG_OFFSET) | (val<<PCIE_MDIO_DATA_OFFSET)  | (1<<PCIE_MDIO_RDWR_OFFSET) ;   ;   
*/
	HostPCIe_SetPhyMdioWrite(portnum, addr, val);
8000c33c:	02202021 	move	a0,s1
8000c340:	02402821 	move	a1,s2
8000c344:	0c003015 	jal	8000c054 <HostPCIe_SetPhyMdioWrite>
8000c348:	3046ffff 	andi	a2,v0,0xffff

}; 
8000c34c:	8fbf001c 	lw	ra,28(sp)
8000c350:	8fb20018 	lw	s2,24(sp)
8000c354:	8fb10014 	lw	s1,20(sp)
8000c358:	8fb00010 	lw	s0,16(sp)
8000c35c:	03e00008 	jr	ra
8000c360:	27bd0020 	addiu	sp,sp,32

8000c364 <HostPCIe_MDIORead>:
}


//----------------------------------------------------------------------------
int HostPCIe_MDIORead(int argc, char* argv[])
{
8000c364:	27bdffd8 	addiu	sp,sp,-40
8000c368:	afbf0024 	sw	ra,36(sp)
8000c36c:	afb30020 	sw	s3,32(sp)
8000c370:	afb2001c 	sw	s2,28(sp)
8000c374:	afb10018 	sw	s1,24(sp)
8000c378:	afb00014 	sw	s0,20(sp)
		return;
	}
*/	
	unsigned int portnum=0;
	
	if(argc>=1)
8000c37c:	18800006 	blez	a0,8000c398 <HostPCIe_MDIORead+0x34>
8000c380:	00008821 	move	s1,zero
		portnum	= strtoul((const char*)(argv[0]), (char **)NULL, 16);		
8000c384:	8ca40000 	lw	a0,0(a1)
8000c388:	00002821 	move	a1,zero
8000c38c:	0c0020c4 	jal	80008310 <strtoul>
8000c390:	24060010 	li	a2,16
8000c394:	00408821 	move	s1,v0
8000c398:	00008021 	move	s0,zero
		for(j=0;j<0x5555;j++) ;
		val=REG32(PCIE0_MDIO);
		val=( val& PCIE_MDIO_DATA_MASK ) >> PCIE_MDIO_DATA_OFFSET;		
	*/
		val=HostPCIe_SetPhyMdioRead(portnum, i);
		dprintf("MDIO Reg %x=%x \n", i,val);
8000c39c:	3c128001 	lui	s2,0x8001
8000c3a0:	26526030 	addiu	s2,s2,24624
	unsigned int portnum=0;
	
	if(argc>=1)
		portnum	= strtoul((const char*)(argv[0]), (char **)NULL, 16);		
	
	for(i=0; i<=0x1f; i++)
8000c3a4:	24130020 	li	s3,32
		REG32(PCIE0_MDIO)= (i<<PCIE_MDIO_REG_OFFSET) | (0<<PCIE_MDIO_RDWR_OFFSET) ;   
		for(j=0;j<0x5555;j++) ;
		val=REG32(PCIE0_MDIO);
		val=( val& PCIE_MDIO_DATA_MASK ) >> PCIE_MDIO_DATA_OFFSET;		
	*/
		val=HostPCIe_SetPhyMdioRead(portnum, i);
8000c3a8:	02202021 	move	a0,s1
8000c3ac:	0c002ff2 	jal	8000bfc8 <HostPCIe_SetPhyMdioRead>
8000c3b0:	02002821 	move	a1,s0
		dprintf("MDIO Reg %x=%x \n", i,val);
8000c3b4:	02402021 	move	a0,s2
8000c3b8:	02002821 	move	a1,s0
8000c3bc:	0c002325 	jal	80008c94 <dprintf>
8000c3c0:	00403021 	move	a2,v0
	unsigned int portnum=0;
	
	if(argc>=1)
		portnum	= strtoul((const char*)(argv[0]), (char **)NULL, 16);		
	
	for(i=0; i<=0x1f; i++)
8000c3c4:	26100001 	addiu	s0,s0,1
8000c3c8:	1613fff8 	bne	s0,s3,8000c3ac <HostPCIe_MDIORead+0x48>
8000c3cc:	02202021 	move	a0,s1

	}



}; 
8000c3d0:	8fbf0024 	lw	ra,36(sp)
8000c3d4:	8fb30020 	lw	s3,32(sp)
8000c3d8:	8fb2001c 	lw	s2,28(sp)
8000c3dc:	8fb10018 	lw	s1,24(sp)
8000c3e0:	8fb00014 	lw	s0,20(sp)
8000c3e4:	03e00008 	jr	ra
8000c3e8:	27bd0028 	addiu	sp,sp,40

8000c3ec <PCIE_Host_Init>:
}; 


//--------------------------------------------------------------------------
int PCIE_Host_Init(int argc, char* argv[])
{
8000c3ec:	27bdffe0 	addiu	sp,sp,-32
8000c3f0:	afbf001c 	sw	ra,28(sp)
8000c3f4:	afb10018 	sw	s1,24(sp)
8000c3f8:	afb00014 	sw	s0,20(sp)
	int portnum=0;
	if(argc >= 1) 
8000c3fc:	18800010 	blez	a0,8000c440 <PCIE_Host_Init+0x54>
8000c400:	3c04b900 	lui	a0,0xb900
	{	portnum= strtoul((const char*)(argv[0]), (char **)NULL, 16);	
8000c404:	8ca40000 	lw	a0,0(a1)
8000c408:	00002821 	move	a1,zero
8000c40c:	0c0020c4 	jal	80008310 <strtoul>
8000c410:	24060010 	li	a2,16

	int rc_cfg, cfgaddr;
	int iomapaddr;
	int memmapaddr;

	if(portnum==0)
8000c414:	10400009 	beqz	v0,8000c43c <PCIE_Host_Init+0x50>
8000c418:	00401821 	move	v1,v0
	{	rc_cfg=PCIE0_RC_CFG_BASE;
		cfgaddr=PCIE0_EP_CFG_BASE;
		iomapaddr=PCIE0_MAP_IO_BASE;
		memmapaddr=PCIE0_MAP_MEM_BASE;
	}
	else if(portnum==1)
8000c41c:	24040001 	li	a0,1
8000c420:	1464004b 	bne	v1,a0,8000c550 <PCIE_Host_Init+0x164>
8000c424:	00001021 	move	v0,zero
8000c428:	3c04ba00 	lui	a0,0xba00
8000c42c:	3c07b8e0 	lui	a3,0xb8e0
8000c430:	3c03b8b3 	lui	v1,0xb8b3
8000c434:	08003113 	j	8000c44c <PCIE_Host_Init+0x60>
8000c438:	3c10b8b2 	lui	s0,0xb8b2
8000c43c:	3c04b900 	lui	a0,0xb900
8000c440:	3c07b8c0 	lui	a3,0xb8c0
8000c444:	3c03b8b1 	lui	v1,0xb8b1
8000c448:	3c10b8b0 	lui	s0,0xb8b0
	}
	else 
	{	return 0;
	}
	
	int t=REG32(rc_cfg);
8000c44c:	8e060000 	lw	a2,0(s0)
	unsigned int vid=t&0x0000ffff;   //0x819810EC
8000c450:	30c5ffff 	andi	a1,a2,0xffff
	unsigned int pid=(t&0xffff0000) >>16;
	
	if( (vid!= 0x10ec) || (pid!=0x8198))
8000c454:	240210ec 	li	v0,4332
8000c458:	14a20004 	bne	a1,v0,8000c46c <PCIE_Host_Init+0x80>
8000c45c:	00063402 	srl	a2,a2,0x10
8000c460:	34028198 	li	v0,0x8198
8000c464:	10c20009 	beq	a2,v0,8000c48c <PCIE_Host_Init+0xa0>
8000c468:	00000000 	nop
	{	DBG_PRINT("VID=%x, PID=%x \n", vid, pid );
8000c46c:	3c048001 	lui	a0,0x8001
8000c470:	0c002325 	jal	80008c94 <dprintf>
8000c474:	24846044 	addiu	a0,a0,24644
		DBG_PRINT(" !!!  Read VID PID fail !!! \n");
8000c478:	3c048001 	lui	a0,0x8001
8000c47c:	0c002325 	jal	80008c94 <dprintf>
8000c480:	24846058 	addiu	a0,a0,24664
		//at_errcnt++;
		return;
8000c484:	08003155 	j	8000c554 <PCIE_Host_Init+0x168>
8000c488:	8fbf001c 	lw	ra,28(sp)
	//CMD
	//bit 2: Enable Bys master, 
	//bit 1: enable memmap, 
	//bit 0: enable iomap

	REG32(rc_cfg + 0x04)= 0x00100007;   
8000c48c:	26050004 	addiu	a1,s0,4
8000c490:	3c020010 	lui	v0,0x10
8000c494:	34420007 	ori	v0,v0,0x7
8000c498:	aca20000 	sw	v0,0(a1)

	//Device Control Register 
	//bit [7-5]  payload size
	REG32(rc_cfg + 0x78)= (REG32(rc_cfg + 0x78 ) & (~0xE0)) | MAX_PAYLOAD_SIZE_128B;  // Set MAX_PAYLOAD_SIZE to 128B,default
8000c49c:	26060078 	addiu	a2,s0,120
8000c4a0:	8cc80000 	lw	t0,0(a2)
8000c4a4:	2405ff1f 	li	a1,-225
8000c4a8:	01054024 	and	t0,t0,a1
8000c4ac:	acc80000 	sw	t0,0(a2)
	  
      REG32(cfgaddr + 0x04)= 0x00100007;    //0x00180007
8000c4b0:	24660004 	addiu	a2,v1,4
8000c4b4:	acc20000 	sw	v0,0(a2)

	//bit 0: 0:memory, 1 io indicate
      REG32(cfgaddr + 0x10)= (iomapaddr | 0x00000001) & 0x1FFFFFFF;  // Set BAR0
8000c4b8:	24620010 	addiu	v0,v1,16
8000c4bc:	3c061fff 	lui	a2,0x1fff
8000c4c0:	34c8fffe 	ori	t0,a2,0xfffe
8000c4c4:	00e83824 	and	a3,a3,t0
8000c4c8:	34e70001 	ori	a3,a3,0x1
8000c4cc:	ac470000 	sw	a3,0(v0)

	//bit 3: prefetch
	//bit [2:1] 00:32bit, 01:reserved, 10:64bit 11:reserved
      REG32(cfgaddr + 0x18)= (memmapaddr | 0x00000004) & 0x1FFFFFFF;  // Set BAR1  
8000c4d0:	24710018 	addiu	s1,v1,24
8000c4d4:	34c6fffb 	ori	a2,a2,0xfffb
8000c4d8:	00862024 	and	a0,a0,a2
8000c4dc:	34840004 	ori	a0,a0,0x4
8000c4e0:	ae240000 	sw	a0,0(s1)


	//offset 0x78 [7:5]
      REG32(cfgaddr + 0x78) = (REG32(cfgaddr + 0x78) & (~0xE0)) | (MAX_PAYLOAD_SIZE_128B);  // Set MAX_PAYLOAD_SIZE to 128B
8000c4e4:	24630078 	addiu	v1,v1,120
8000c4e8:	8c640000 	lw	a0,0(v1)
8000c4ec:	00852824 	and	a1,a0,a1
8000c4f0:	ac650000 	sw	a1,0(v1)

	//offset 0x79: [6:4] 
      REG32(cfgaddr + 0x78) = (REG32(cfgaddr + 0x78) & (~0x7000)) | (MAX_READ_REQSIZE_256B<<8);  // Set MAX_REQ_SIZE to 256B,default
8000c4f4:	8c650000 	lw	a1,0(v1)
8000c4f8:	24048fff 	li	a0,-28673
8000c4fc:	00a42024 	and	a0,a1,a0
8000c500:	34841000 	ori	a0,a0,0x1000
8000c504:	ac640000 	sw	a0,0(v1)

	  
	//check
//      if(REG32(cfgaddr + 0x10) != ((iomapaddr | 0x00000001) & 0x1FFFFFFF))
      {	//at_errcnt++;
      		DBG_PRINT("Read Bar0=%x \n", REG32(cfgaddr + 0x10)); //for test
8000c508:	8c450000 	lw	a1,0(v0)
8000c50c:	3c048001 	lui	a0,0x8001
8000c510:	0c002325 	jal	80008c94 <dprintf>
8000c514:	24846078 	addiu	a0,a0,24696
      	}
	  

//	if(REG32(cfgaddr + 0x18)!=((memmapaddr| 0x00000004) & 0x1FFFFFFF))
	{	//at_errcnt++;
      		DBG_PRINT("Read Bar1=%x \n", REG32(cfgaddr + 0x18));      //for test
8000c518:	8e250000 	lw	a1,0(s1)
8000c51c:	3c048001 	lui	a0,0x8001
8000c520:	0c002325 	jal	80008c94 <dprintf>
8000c524:	24846088 	addiu	a0,a0,24712
	}
	DBG_PRINT("Set BAR finish \n");
8000c528:	3c048001 	lui	a0,0x8001
8000c52c:	0c002325 	jal	80008c94 <dprintf>
8000c530:	24846098 	addiu	a0,a0,24728


	//io and mem limit, setting to no litmit
	REG32(rc_cfg+ 0x1c) = (2<<4) | (0<<12);   //  [7:4]=base  [15:12]=limit
8000c534:	2603001c 	addiu	v1,s0,28
8000c538:	24020020 	li	v0,32
8000c53c:	ac620000 	sw	v0,0(v1)
	REG32(rc_cfg+ 0x20) = (2<<4) | (0<<20);   //  [15:4]=base  [31:20]=limit	
8000c540:	26030020 	addiu	v1,s0,32
8000c544:	ac620000 	sw	v0,0(v1)
	REG32(rc_cfg+ 0x24) = (2<<4) | (0<<20);   //  [15:4]=base  [31:20]=limit		
8000c548:	26100024 	addiu	s0,s0,36
8000c54c:	ae020000 	sw	v0,0(s0)

}
8000c550:	8fbf001c 	lw	ra,28(sp)
8000c554:	8fb10018 	lw	s1,24(sp)
8000c558:	8fb00014 	lw	s0,20(sp)
8000c55c:	03e00008 	jr	ra
8000c560:	27bd0020 	addiu	sp,sp,32

8000c564 <PCIE_PHYLoop>:
		
};

//---------------------------------------------------------------------------
int PCIE_PHYLoop(int argc, char* argv[])
{
8000c564:	27bdffd8 	addiu	sp,sp,-40
8000c568:	afbf0024 	sw	ra,36(sp)
8000c56c:	afb30020 	sw	s3,32(sp)
8000c570:	afb2001c 	sw	s2,28(sp)
8000c574:	afb10018 	sw	s1,24(sp)
8000c578:	afb00014 	sw	s0,20(sp)
	int portnum=0;
	int mode=1; 
	if( argc < 2 ) 
8000c57c:	28820002 	slti	v0,a0,2
8000c580:	10400006 	beqz	v0,8000c59c <PCIE_PHYLoop+0x38>
8000c584:	00a08021 	move	s0,a1
	{
		dprintf("epdn <portnum> <stop/start>.\n");	
8000c588:	3c048001 	lui	a0,0x8001
8000c58c:	0c002325 	jal	80008c94 <dprintf>
8000c590:	248460ac 	addiu	a0,a0,24748
		dprintf("ERR=%x\n",v);
	}
	


}; 
8000c594:	080031b6 	j	8000c6d8 <PCIE_PHYLoop+0x174>
8000c598:	00001021 	move	v0,zero
	if( argc < 2 ) 
	{
		dprintf("epdn <portnum> <stop/start>.\n");	
		return 0;
	}
	if(argc>=1)	portnum = strtoul((const char*)(argv[0]), (char **)NULL, 16);
8000c59c:	18800006 	blez	a0,8000c5b8 <PCIE_PHYLoop+0x54>
8000c5a0:	00008821 	move	s1,zero
8000c5a4:	8ca40000 	lw	a0,0(a1)
8000c5a8:	00002821 	move	a1,zero
8000c5ac:	0c0020c4 	jal	80008310 <strtoul>
8000c5b0:	24060010 	li	a2,16
8000c5b4:	00408821 	move	s1,v0
	if(argc>=2)   mode = strtoul((const char*)(argv[1]), (char **)NULL, 16);	
8000c5b8:	8e040004 	lw	a0,4(s0)
8000c5bc:	00002821 	move	a1,zero
8000c5c0:	0c0020c4 	jal	80008310 <strtoul>
8000c5c4:	24060010 	li	a2,16
8000c5c8:	00409021 	move	s2,v0




	unsigned int v;
	v=HostPCIe_SetPhyMdioRead(portnum, 0);  
8000c5cc:	02208021 	move	s0,s1
8000c5d0:	02202021 	move	a0,s1
8000c5d4:	0c002ff2 	jal	8000bfc8 <HostPCIe_SetPhyMdioRead>
8000c5d8:	00002821 	move	a1,zero
8000c5dc:	00409821 	move	s3,v0


	if(mode==1)
8000c5e0:	24020001 	li	v0,1
8000c5e4:	16420023 	bne	s2,v0,8000c674 <PCIE_PHYLoop+0x110>
8000c5e8:	3c048001 	lui	a0,0x8001
	{	
		dprintf("Start... port=%d   ", portnum);
8000c5ec:	248460cc 	addiu	a0,a0,24780
8000c5f0:	0c002325 	jal	80008c94 <dprintf>
8000c5f4:	02202821 	move	a1,s1

		v=v|(1<<8);  //bit 8
		HostPCIe_SetPhyMdioWrite(portnum, 0x00, v);  
8000c5f8:	36660100 	ori	a2,s3,0x100
8000c5fc:	02202021 	move	a0,s1
8000c600:	00002821 	move	a1,zero
8000c604:	0c003015 	jal	8000c054 <HostPCIe_SetPhyMdioWrite>
8000c608:	30c6ffff 	andi	a2,a2,0xffff
		
		// start bist
		HostPCIe_SetPhyMdioWrite(portnum, 0x13, 0x8497);  
8000c60c:	02202021 	move	a0,s1
8000c610:	24050013 	li	a1,19
8000c614:	0c003015 	jal	8000c054 <HostPCIe_SetPhyMdioWrite>
8000c618:	34068497 	li	a2,0x8497
		delay_ms(100);
8000c61c:	0c002219 	jal	80008864 <delay_ms>
8000c620:	24040064 	li	a0,100
		HostPCIe_SetPhyMdioWrite(portnum, 0x14, 0xde01);  
8000c624:	02202021 	move	a0,s1
8000c628:	24050014 	li	a1,20
8000c62c:	0c003015 	jal	8000c054 <HostPCIe_SetPhyMdioWrite>
8000c630:	3406de01 	li	a2,0xde01
		delay_ms(100);		
8000c634:	0c002219 	jal	80008864 <delay_ms>
8000c638:	24040064 	li	a0,100
		HostPCIe_SetPhyMdioWrite(portnum, 0x13, 0x8c97);  
8000c63c:	02202021 	move	a0,s1
8000c640:	24050013 	li	a1,19
8000c644:	0c003015 	jal	8000c054 <HostPCIe_SetPhyMdioWrite>
8000c648:	34068c97 	li	a2,0x8c97
		delay_ms(100);		
8000c64c:	0c002219 	jal	80008864 <delay_ms>
8000c650:	24040064 	li	a0,100
		HostPCIe_SetPhyMdioWrite(portnum, 0x13, 0xcc97);  	
8000c654:	02202021 	move	a0,s1
8000c658:	24050013 	li	a1,19
8000c65c:	0c003015 	jal	8000c054 <HostPCIe_SetPhyMdioWrite>
8000c660:	3406cc97 	li	a2,0xcc97
		delay_ms(100);		
8000c664:	0c002219 	jal	80008864 <delay_ms>
8000c668:	24040064 	li	a0,100
8000c66c:	080031a6 	j	8000c698 <PCIE_PHYLoop+0x134>
8000c670:	00000000 	nop
		//end bist


	
	}
	else if(mode==0)
8000c674:	16400008 	bnez	s2,8000c698 <PCIE_PHYLoop+0x134>
8000c678:	3c048001 	lui	a0,0x8001
	{	
		dprintf("Stop...  port=%d  ", portnum);	
8000c67c:	248460e0 	addiu	a0,a0,24800
8000c680:	0c002325 	jal	80008c94 <dprintf>
8000c684:	02202821 	move	a1,s1
		v=v&0xffffffff-(1<<8);
		HostPCIe_SetPhyMdioWrite(portnum, 0, v);  	
8000c688:	02202021 	move	a0,s1
8000c68c:	00002821 	move	a1,zero
8000c690:	0c003015 	jal	8000c054 <HostPCIe_SetPhyMdioWrite>
8000c694:	3266feff 	andi	a2,s3,0xfeff
	}


	//if(mode==1)
	{
		delay_ms(500);
8000c698:	0c002219 	jal	80008864 <delay_ms>
8000c69c:	240401f4 	li	a0,500
		
		v=HostPCIe_SetPhyMdioRead(portnum, 0x17);	
8000c6a0:	02002021 	move	a0,s0
8000c6a4:	0c002ff2 	jal	8000bfc8 <HostPCIe_SetPhyMdioRead>
8000c6a8:	24050017 	li	a1,23
		dprintf("LOOP CNT=%x ",v);		
8000c6ac:	3c048001 	lui	a0,0x8001
8000c6b0:	248460f4 	addiu	a0,a0,24820
8000c6b4:	0c002325 	jal	80008c94 <dprintf>
8000c6b8:	00402821 	move	a1,v0
		v=HostPCIe_SetPhyMdioRead(portnum, 0x18);
8000c6bc:	02002021 	move	a0,s0
8000c6c0:	0c002ff2 	jal	8000bfc8 <HostPCIe_SetPhyMdioRead>
8000c6c4:	24050018 	li	a1,24
		v=(v &  (0xff<<4)) >>4;  //bit [11:04]
		dprintf("ERR=%x\n",v);
8000c6c8:	3c048001 	lui	a0,0x8001
8000c6cc:	24846104 	addiu	a0,a0,24836
8000c6d0:	0c002325 	jal	80008c94 <dprintf>
8000c6d4:	7c453900 	ext	a1,v0,0x4,0x8
	}
	


}; 
8000c6d8:	8fbf0024 	lw	ra,36(sp)
8000c6dc:	8fb30020 	lw	s3,32(sp)
8000c6e0:	8fb2001c 	lw	s2,28(sp)
8000c6e4:	8fb10018 	lw	s1,24(sp)
8000c6e8:	8fb00014 	lw	s0,20(sp)
8000c6ec:	03e00008 	jr	ra
8000c6f0:	27bd0028 	addiu	sp,sp,40

8000c6f4 <PCIE_PowerDown>:

}; 
//---------------------------------------------------------------------------

int  PCIE_PowerDown(int argc, char* argv[])
{
8000c6f4:	27bdffd8 	addiu	sp,sp,-40
8000c6f8:	afbf0024 	sw	ra,36(sp)
8000c6fc:	afb40020 	sw	s4,32(sp)
8000c700:	afb3001c 	sw	s3,28(sp)
8000c704:	afb20018 	sw	s2,24(sp)
8000c708:	afb10014 	sw	s1,20(sp)
8000c70c:	afb00010 	sw	s0,16(sp)
	 
	 int portnum=0;
	 int mode=0;
	int baseaddr=0xb8b00000;
	 
	if( argc < 2 ) 
8000c710:	28820002 	slti	v0,a0,2
8000c714:	1040002c 	beqz	v0,8000c7c8 <PCIE_PowerDown+0xd4>
8000c718:	00a08021 	move	s0,a1
	{
		dprintf("epdn <portnum> <mode>.\n");	
8000c71c:	3c048001 	lui	a0,0x8001
8000c720:	0c002325 	jal	80008c94 <dprintf>
8000c724:	2484610c 	addiu	a0,a0,24844
		dprintf("epdn 0: D0 ->L0 \n");			
8000c728:	3c048001 	lui	a0,0x8001
8000c72c:	0c002325 	jal	80008c94 <dprintf>
8000c730:	24846124 	addiu	a0,a0,24868
		dprintf("epdn 3: D3hot ->L1 \n");
8000c734:	3c048001 	lui	a0,0x8001
8000c738:	0c002325 	jal	80008c94 <dprintf>
8000c73c:	24846138 	addiu	a0,a0,24888
		dprintf("epdn 4: board cast PME_TurnOff \n");	
8000c740:	3c048001 	lui	a0,0x8001
8000c744:	0c002325 	jal	80008c94 <dprintf>
8000c748:	24846150 	addiu	a0,a0,24912
		
		dprintf("epdn 7: enable aspm and L0s entry \n");	
8000c74c:	3c048001 	lui	a0,0x8001
8000c750:	0c002325 	jal	80008c94 <dprintf>
8000c754:	24846174 	addiu	a0,a0,24948
		dprintf("epdn 8: enable aspm and L1 entry \n");	
8000c758:	3c048001 	lui	a0,0x8001
8000c75c:	0c002325 	jal	80008c94 <dprintf>
8000c760:	24846198 	addiu	a0,a0,24984
		dprintf("epdn 9: diable  aspm \n");	
8000c764:	3c048001 	lui	a0,0x8001
8000c768:	0c002325 	jal	80008c94 <dprintf>
8000c76c:	248461bc 	addiu	a0,a0,25020

		dprintf("epdn 010: measure L0->L1->L0 \n");		
8000c770:	3c048001 	lui	a0,0x8001
8000c774:	0c002325 	jal	80008c94 <dprintf>
8000c778:	248461d4 	addiu	a0,a0,25044
		dprintf("epdn 020: measure L0->L2->L0 \n");			
8000c77c:	3c048001 	lui	a0,0x8001
8000c780:	0c002325 	jal	80008c94 <dprintf>
8000c784:	248461f4 	addiu	a0,a0,25076
		dprintf("P0 Link status=%x \n", REG32(0xb8b00728)&0x1f );		
8000c788:	3c02b8b0 	lui	v0,0xb8b0
8000c78c:	34420728 	ori	v0,v0,0x728
8000c790:	8c450000 	lw	a1,0(v0)
8000c794:	3c048001 	lui	a0,0x8001
8000c798:	24846214 	addiu	a0,a0,25108
8000c79c:	0c002325 	jal	80008c94 <dprintf>
8000c7a0:	30a5001f 	andi	a1,a1,0x1f
		dprintf("P1 Link status=%x \n", REG32(0xb8b20728)&0x1f );		
8000c7a4:	3c02b8b2 	lui	v0,0xb8b2
8000c7a8:	34420728 	ori	v0,v0,0x728
8000c7ac:	8c450000 	lw	a1,0(v0)
8000c7b0:	3c048001 	lui	a0,0x8001
8000c7b4:	24846228 	addiu	a0,a0,25128
8000c7b8:	0c002325 	jal	80008c94 <dprintf>
8000c7bc:	30a5001f 	andi	a1,a1,0x1f
		return 0;
8000c7c0:	080032dd 	j	8000cb74 <PCIE_PowerDown+0x480>
8000c7c4:	00001021 	move	v0,zero
	}
	if(argc>=1)	portnum = strtoul((const char*)(argv[0]), (char **)NULL, 16);
8000c7c8:	188000e2 	blez	a0,8000cb54 <PCIE_PowerDown+0x460>
8000c7cc:	00000000 	nop
8000c7d0:	8ca40000 	lw	a0,0(a1)
8000c7d4:	00002821 	move	a1,zero
8000c7d8:	0c0020c4 	jal	80008310 <strtoul>
8000c7dc:	24060010 	li	a2,16
8000c7e0:	00409021 	move	s2,v0
	if(argc>=2)   mode = strtoul((const char*)(argv[1]), (char **)NULL, 16);	
8000c7e4:	8e040004 	lw	a0,4(s0)
8000c7e8:	00002821 	move	a1,zero
8000c7ec:	0c0020c4 	jal	80008310 <strtoul>
8000c7f0:	24060010 	li	a2,16
	int tmp;

	if(portnum==0) baseaddr=PCIE0_RC_CFG_BASE;
8000c7f4:	12400009 	beqz	s2,8000c81c <PCIE_PowerDown+0x128>
8000c7f8:	00408021 	move	s0,v0
	else if(portnum==1) baseaddr=PCIE1_RC_CFG_BASE;
8000c7fc:	24020001 	li	v0,1
8000c800:	12420007 	beq	s2,v0,8000c820 <PCIE_PowerDown+0x12c>
8000c804:	3c11b8b2 	lui	s1,0xb8b2
	else { dprintf("Only support P0 and P1 \n"); return 0; }
8000c808:	3c048001 	lui	a0,0x8001
8000c80c:	0c002325 	jal	80008c94 <dprintf>
8000c810:	2484623c 	addiu	a0,a0,25148
8000c814:	080032d3 	j	8000cb4c <PCIE_PowerDown+0x458>
8000c818:	00001021 	move	v0,zero
8000c81c:	3c11b8b0 	lui	s1,0xb8b0


	if(mode==0)
8000c820:	1600000c 	bnez	s0,8000c854 <PCIE_PowerDown+0x160>
8000c824:	3c020001 	lui	v0,0x1

		#if 0 //saving more power, leave L1 write
		HostPCIe_SetPhyMdioWrite(portnum, 0xf, 0x0f0f);
		#endif	
		
		tmp = REG32(baseaddr+DEVICE_OFFSET+0x44) &( ~(3));  //D0
8000c828:	34420044 	ori	v0,v0,0x44
8000c82c:	02221021 	addu	v0,s1,v0
8000c830:	8c440000 	lw	a0,0(v0)
		REG32(baseaddr+DEVICE_OFFSET+0x44) = tmp|  (0);  //D0	
8000c834:	2403fffc 	li	v1,-4
8000c838:	00831824 	and	v1,a0,v1
8000c83c:	ac430000 	sw	v1,0(v0)
		dprintf("D0 \n");
8000c840:	3c048001 	lui	a0,0x8001
8000c844:	0c002325 	jal	80008c94 <dprintf>
8000c848:	24846258 	addiu	a0,a0,25176
		#endif	
	
		REG32(baseaddr+0x1008) |= (0x200);  		
		dprintf("Host boardcase PME_TurnOff \n");		
	}
	if(mode==7)
8000c84c:	08003233 	j	8000c8cc <PCIE_PowerDown+0x1d8>
8000c850:	24020007 	li	v0,7
		dprintf("D0 \n");
	
	}

	
	if(mode==3)
8000c854:	24020003 	li	v0,3
8000c858:	16020010 	bne	s0,v0,8000c89c <PCIE_PowerDown+0x1a8>
8000c85c:	3c020001 	lui	v0,0x1
	{

		#if 1 //saving more power
		REG32(baseaddr+DEVICE_OFFSET+0x80)|= (0x100);  //enable clock PM
8000c860:	34430080 	ori	v1,v0,0x80
8000c864:	02231821 	addu	v1,s1,v1
8000c868:	8c640000 	lw	a0,0(v1)
8000c86c:	34840100 	ori	a0,a0,0x100
8000c870:	ac640000 	sw	a0,0(v1)
		#endif
		
		tmp = REG32(baseaddr+DEVICE_OFFSET+0x44) &( ~(3));  //D0
8000c874:	34420044 	ori	v0,v0,0x44
8000c878:	02221021 	addu	v0,s1,v0
8000c87c:	8c430000 	lw	v1,0(v0)
		REG32(baseaddr+DEVICE_OFFSET+0x44) = tmp|  (3);  //D3	
8000c880:	34630003 	ori	v1,v1,0x3
8000c884:	ac430000 	sw	v1,0(v0)
		//HostPCIe_SetPhyMdioWrite(0xd, 0x15a6);
		dprintf("D3 hot \n");		
8000c888:	3c048001 	lui	a0,0x8001
8000c88c:	0c002325 	jal	80008c94 <dprintf>
8000c890:	24846260 	addiu	a0,a0,25184

	}



	if(mode==8)
8000c894:	08003253 	j	8000c94c <PCIE_PowerDown+0x258>
8000c898:	24020008 	li	v0,8
		#if 0 //saving more power		
		HostPCIe_SetPhyMdioWrite(portnum, 0xf, 0x0708);
		#endif
	}

	if(mode==4)
8000c89c:	24020004 	li	v0,4
8000c8a0:	16020009 	bne	s0,v0,8000c8c8 <PCIE_PowerDown+0x1d4>
8000c8a4:	26221008 	addiu	v0,s1,4104
	{	
		#if 0 //saving more power   leave L1 write
		HostPCIe_SetPhyMdioWrite(portnum, 0xf, 0x0f0f);
		#endif	
	
		REG32(baseaddr+0x1008) |= (0x200);  		
8000c8a8:	8c430000 	lw	v1,0(v0)
8000c8ac:	34630200 	ori	v1,v1,0x200
8000c8b0:	ac430000 	sw	v1,0(v0)
		dprintf("Host boardcase PME_TurnOff \n");		
8000c8b4:	3c048001 	lui	a0,0x8001
8000c8b8:	0c002325 	jal	80008c94 <dprintf>
8000c8bc:	2484626c 	addiu	a0,a0,25196
		REG32(baseaddr+0x80) |= 3;   //L1
		REG32(baseaddr+DEVICE_OFFSET+0x80) |= 3;	//L1			

	}

	if(mode==9)
8000c8c0:	08003273 	j	8000c9cc <PCIE_PowerDown+0x2d8>
8000c8c4:	24020009 	li	v0,9
		#endif	
	
		REG32(baseaddr+0x1008) |= (0x200);  		
		dprintf("Host boardcase PME_TurnOff \n");		
	}
	if(mode==7)
8000c8c8:	24020007 	li	v0,7
8000c8cc:	1602001e 	bne	s0,v0,8000c948 <PCIE_PowerDown+0x254>
8000c8d0:	3c020001 	lui	v0,0x1
	{
		REG32(baseaddr+DEVICE_OFFSET+0x070c) &= ~  ((0x7 <<27)|(0x7<<24));
8000c8d4:	3443070c 	ori	v1,v0,0x70c
8000c8d8:	02231821 	addu	v1,s1,v1
8000c8dc:	8c650000 	lw	a1,0(v1)
8000c8e0:	3c04c0ff 	lui	a0,0xc0ff
8000c8e4:	3484ffff 	ori	a0,a0,0xffff
8000c8e8:	00a42024 	and	a0,a1,a0
8000c8ec:	ac640000 	sw	a0,0(v1)
		REG32(baseaddr+DEVICE_OFFSET+0x070c) |=  ((3)<<27) | ((1)<<24);   //L1=3us, L0s=1us
8000c8f0:	8c650000 	lw	a1,0(v1)
8000c8f4:	3c041900 	lui	a0,0x1900
8000c8f8:	00a42025 	or	a0,a1,a0
8000c8fc:	ac640000 	sw	a0,0(v1)

		REG32(baseaddr+0x80) &= ~(0x3);
8000c900:	26230080 	addiu	v1,s1,128
8000c904:	8c650000 	lw	a1,0(v1)
8000c908:	2404fffc 	li	a0,-4
8000c90c:	00a42824 	and	a1,a1,a0
8000c910:	ac650000 	sw	a1,0(v1)
		REG32(baseaddr+DEVICE_OFFSET+0x80) &= ~(0x3);		
8000c914:	34420080 	ori	v0,v0,0x80
8000c918:	02221021 	addu	v0,s1,v0
8000c91c:	8c450000 	lw	a1,0(v0)
8000c920:	00a42024 	and	a0,a1,a0
8000c924:	ac440000 	sw	a0,0(v0)

		REG32(baseaddr+0x80) |= 1;   //L0s
8000c928:	8c640000 	lw	a0,0(v1)
8000c92c:	34840001 	ori	a0,a0,0x1
8000c930:	ac640000 	sw	a0,0(v1)
		REG32(baseaddr+DEVICE_OFFSET+0x80) |= 1;				
8000c934:	8c430000 	lw	v1,0(v0)
8000c938:	34630001 	ori	v1,v1,0x1
8000c93c:	ac430000 	sw	v1,0(v0)
		dprintf("status=%x \n", REG32(0xb8b00728) );		
	}
#endif

       //-------------------------------------------------------------	
	if(mode==0x010)
8000c940:	08003282 	j	8000ca08 <PCIE_PowerDown+0x314>
8000c944:	24020010 	li	v0,16

	}



	if(mode==8)
8000c948:	24020008 	li	v0,8
8000c94c:	1602001e 	bne	s0,v0,8000c9c8 <PCIE_PowerDown+0x2d4>
8000c950:	3c020001 	lui	v0,0x1
	{
		REG32(baseaddr+DEVICE_OFFSET+0x070c) &= ~  ((0x7 <<27)|(0x7<<24));
8000c954:	3443070c 	ori	v1,v0,0x70c
8000c958:	02231821 	addu	v1,s1,v1
8000c95c:	8c650000 	lw	a1,0(v1)
8000c960:	3c04c0ff 	lui	a0,0xc0ff
8000c964:	3484ffff 	ori	a0,a0,0xffff
8000c968:	00a42024 	and	a0,a1,a0
8000c96c:	ac640000 	sw	a0,0(v1)
		REG32(baseaddr+DEVICE_OFFSET+0x070c) |=  ((1)<<27) | ((3)<<24);   //L1=1us, L0s=3us
8000c970:	8c650000 	lw	a1,0(v1)
8000c974:	3c040b00 	lui	a0,0xb00
8000c978:	00a42025 	or	a0,a1,a0
8000c97c:	ac640000 	sw	a0,0(v1)

		REG32(baseaddr+0x80) &= ~(0x3);
8000c980:	26230080 	addiu	v1,s1,128
8000c984:	8c650000 	lw	a1,0(v1)
8000c988:	2404fffc 	li	a0,-4
8000c98c:	00a42824 	and	a1,a1,a0
8000c990:	ac650000 	sw	a1,0(v1)
		REG32(baseaddr+DEVICE_OFFSET+0x80) &= ~(0x3);		
8000c994:	34420080 	ori	v0,v0,0x80
8000c998:	02221021 	addu	v0,s1,v0
8000c99c:	8c450000 	lw	a1,0(v0)
8000c9a0:	00a42024 	and	a0,a1,a0
8000c9a4:	ac440000 	sw	a0,0(v0)

		REG32(baseaddr+0x80) |= 3;   //L1
8000c9a8:	8c640000 	lw	a0,0(v1)
8000c9ac:	34840003 	ori	a0,a0,0x3
8000c9b0:	ac640000 	sw	a0,0(v1)
		REG32(baseaddr+DEVICE_OFFSET+0x80) |= 3;	//L1			
8000c9b4:	8c430000 	lw	v1,0(v0)
8000c9b8:	34630003 	ori	v1,v1,0x3
8000c9bc:	ac430000 	sw	v1,0(v0)
		
		//delay_ms(100);
		dprintf("DID/VID=%x\n", REG32(0xb8b10000));
	}
	//-------------------------------------------------------------	
	if(mode==0x020)
8000c9c0:	0800329b 	j	8000ca6c <PCIE_PowerDown+0x378>
8000c9c4:	24020020 	li	v0,32
		REG32(baseaddr+0x80) |= 3;   //L1
		REG32(baseaddr+DEVICE_OFFSET+0x80) |= 3;	//L1			

	}

	if(mode==9)
8000c9c8:	24020009 	li	v0,9
8000c9cc:	1602000d 	bne	s0,v0,8000ca04 <PCIE_PowerDown+0x310>
8000c9d0:	26220080 	addiu	v0,s1,128
	{
		REG32(baseaddr+0x80) &= ~(0x3);
8000c9d4:	8c440000 	lw	a0,0(v0)
8000c9d8:	2403fffc 	li	v1,-4
8000c9dc:	00832024 	and	a0,a0,v1
8000c9e0:	ac440000 	sw	a0,0(v0)
		REG32(baseaddr+DEVICE_OFFSET+0x80) &= ~(0x3);
8000c9e4:	3c020001 	lui	v0,0x1
8000c9e8:	34420080 	ori	v0,v0,0x80
8000c9ec:	02221021 	addu	v0,s1,v0
8000c9f0:	8c440000 	lw	a0,0(v0)
8000c9f4:	00831824 	and	v1,a0,v1
8000c9f8:	ac430000 	sw	v1,0(v0)





		dprintf("Port%d Link status=%x \n", portnum, REG32(baseaddr+0x728)&0x1f );			
8000c9fc:	080032cb 	j	8000cb2c <PCIE_PowerDown+0x438>
8000ca00:	26310728 	addiu	s1,s1,1832
		dprintf("status=%x \n", REG32(0xb8b00728) );		
	}
#endif

       //-------------------------------------------------------------	
	if(mode==0x010)
8000ca04:	24020010 	li	v0,16
8000ca08:	16020018 	bne	s0,v0,8000ca6c <PCIE_PowerDown+0x378>
8000ca0c:	24020020 	li	v0,32
	{
             //L0->L1->L0
		tmp = REG32(0xb8b10044) &( ~(3));  //D0
8000ca10:	3c10b8b1 	lui	s0,0xb8b1
8000ca14:	36100044 	ori	s0,s0,0x44
8000ca18:	8e130000 	lw	s3,0(s0)
8000ca1c:	2402fffc 	li	v0,-4
8000ca20:	02629824 	and	s3,s3,v0
		{	if((REG32(0xb8b00728)&0x1f)==0x11)   //wait to L0
			break;
		}	
	
       */
		REG32(0xb8b10044) = tmp|  (3);  //D3	
8000ca24:	36620003 	ori	v0,s3,0x3
8000ca28:	ae020000 	sw	v0,0(s0)
		while(1)
		{	if((REG32(0xb8b00728)&0x1f)==0x14)   //wait to L1
			break;
		}	
		*/
		delay_ms(100);
8000ca2c:	0c002219 	jal	80008864 <delay_ms>
8000ca30:	24040064 	li	a0,100
		//REG32(0xb8b10000);
		REG32(0xb8b10044) = tmp|  (0);  //D0, wakeup
8000ca34:	ae130000 	sw	s3,0(s0)
		
		while(1)
		{	if((REG32(0xb8b00728)&0x1f)==0x11)   //wait to L0
8000ca38:	3c04b8b0 	lui	a0,0xb8b0
8000ca3c:	34840728 	ori	a0,a0,0x728
8000ca40:	24030011 	li	v1,17
8000ca44:	8c820000 	lw	v0,0(a0)
8000ca48:	3042001f 	andi	v0,v0,0x1f
8000ca4c:	1443fffd 	bne	v0,v1,8000ca44 <PCIE_PowerDown+0x350>
8000ca50:	3c02b8b1 	lui	v0,0xb8b1
			break;
		}	
		
		//delay_ms(100);
		dprintf("DID/VID=%x\n", REG32(0xb8b10000));
8000ca54:	8c450000 	lw	a1,0(v0)
8000ca58:	3c048001 	lui	a0,0x8001
8000ca5c:	0c002325 	jal	80008c94 <dprintf>
8000ca60:	2484628c 	addiu	a0,a0,25228





		dprintf("Port%d Link status=%x \n", portnum, REG32(baseaddr+0x728)&0x1f );			
8000ca64:	080032cb 	j	8000cb2c <PCIE_PowerDown+0x438>
8000ca68:	26310728 	addiu	s1,s1,1832
		
		//delay_ms(100);
		dprintf("DID/VID=%x\n", REG32(0xb8b10000));
	}
	//-------------------------------------------------------------	
	if(mode==0x020)
8000ca6c:	1602002e 	bne	s0,v0,8000cb28 <PCIE_PowerDown+0x434>
8000ca70:	00000000 	nop
	{
             //L0->L2->L0
		tmp = REG32(0xb8b10044) &( ~(3));  //D0
8000ca74:	3c02b8b1 	lui	v0,0xb8b1
8000ca78:	34420044 	ori	v0,v0,0x44
8000ca7c:	8c430000 	lw	v1,0(v0)

		REG32(0xb8b10044) = tmp|  (3);  //D3	
8000ca80:	34630003 	ori	v1,v1,0x3
8000ca84:	ac430000 	sw	v1,0(v0)
		delay_ms(100);
8000ca88:	0c002219 	jal	80008864 <delay_ms>
8000ca8c:	24040064 	li	a0,100

		REG32(0xb8b01008) |= (0x200);  
8000ca90:	3c14b8b0 	lui	s4,0xb8b0
8000ca94:	36941008 	ori	s4,s4,0x1008
8000ca98:	8e820000 	lw	v0,0(s4)
8000ca9c:	34420200 	ori	v0,v0,0x200
8000caa0:	ae820000 	sw	v0,0(s4)
        __delay(100000);  		
8000caa4:	3c100001 	lui	s0,0x1
8000caa8:	0c0038e0 	jal	8000e380 <__delay>
8000caac:	360486a0 	ori	a0,s0,0x86a0
		//dprintf("Host boardcase PME_TurnOff \n");	
		//delay_ms(100);

	//wakeup
     REG32(SYS_CLKMANAGE) &= ~(1<<12);    //perst=0 off.
8000cab0:	3c13b800 	lui	s3,0xb800
8000cab4:	36730010 	ori	s3,s3,0x10
8000cab8:	8e630000 	lw	v1,0(s3)
8000cabc:	2402efff 	li	v0,-4097
8000cac0:	00621024 	and	v0,v1,v0
8000cac4:	ae620000 	sw	v0,0(s3)
            //dprintf("CLK_MANAGE=%x \n",  REG32(CLK_MANAGE));
        __delay(100000);   
8000cac8:	0c0038e0 	jal	8000e380 <__delay>
8000cacc:	360486a0 	ori	a0,s0,0x86a0
        __delay(100000);   
8000cad0:	0c0038e0 	jal	8000e380 <__delay>
8000cad4:	360486a0 	ori	a0,s0,0x86a0
        __delay(100000);   
8000cad8:	0c0038e0 	jal	8000e380 <__delay>
8000cadc:	360486a0 	ori	a0,s0,0x86a0
		
    REG32(SYS_CLKMANAGE) |=  (1<<12);   //PERST=1
8000cae0:	8e620000 	lw	v0,0(s3)
8000cae4:	34421000 	ori	v0,v0,0x1000
8000cae8:	ae620000 	sw	v0,0(s3)
    //prom_printf("\nCLK_MANAGE(0x%x)=0x%x\n\n",CLK_MANAGE,READ_MEM32(CLK_MANAGE));

	
        //4. PCIE PHY Reset       
    REG32(PCIE_PHY0) = 0x01;	//bit7 PHY reset=0   bit0 Enable LTSSM=1
8000caec:	24020001 	li	v0,1
8000caf0:	ae820000 	sw	v0,0(s4)
    REG32(PCIE_PHY0) = 0x81;   //bit7 PHY reset=1   bit0 Enable LTSSM=1
8000caf4:	24020081 	li	v0,129
8000caf8:	ae820000 	sw	v0,0(s4)
	}
#else

	while(1)
	{
		if( (REG32(0xb8b00728)&0x1f)==0x11)
8000cafc:	3c04b8b0 	lui	a0,0xb8b0
8000cb00:	34840728 	ori	a0,a0,0x728
8000cb04:	24030011 	li	v1,17
8000cb08:	8c820000 	lw	v0,0(a0)
8000cb0c:	3042001f 	andi	v0,v0,0x1f
8000cb10:	1443fffd 	bne	v0,v1,8000cb08 <PCIE_PowerDown+0x414>
8000cb14:	3c02b8b1 	lui	v0,0xb8b1
	}
#endif



		dprintf("DID/VID=%x\n", REG32(0xb8b10000));
8000cb18:	8c450000 	lw	a1,0(v0)
8000cb1c:	3c048001 	lui	a0,0x8001
8000cb20:	0c002325 	jal	80008c94 <dprintf>
8000cb24:	2484628c 	addiu	a0,a0,25228





		dprintf("Port%d Link status=%x \n", portnum, REG32(baseaddr+0x728)&0x1f );			
8000cb28:	26310728 	addiu	s1,s1,1832
8000cb2c:	8e260000 	lw	a2,0(s1)
8000cb30:	3c048001 	lui	a0,0x8001
8000cb34:	24846298 	addiu	a0,a0,25240
8000cb38:	02402821 	move	a1,s2
8000cb3c:	0c002325 	jal	80008c94 <dprintf>
8000cb40:	30c6001f 	andi	a2,a2,0x1f
		
};
8000cb44:	080032de 	j	8000cb78 <PCIE_PowerDown+0x484>
8000cb48:	8fbf0024 	lw	ra,36(sp)
8000cb4c:	080032de 	j	8000cb78 <PCIE_PowerDown+0x484>
8000cb50:	8fbf0024 	lw	ra,36(sp)
		dprintf("P0 Link status=%x \n", REG32(0xb8b00728)&0x1f );		
		dprintf("P1 Link status=%x \n", REG32(0xb8b20728)&0x1f );		
		return 0;
	}
	if(argc>=1)	portnum = strtoul((const char*)(argv[0]), (char **)NULL, 16);
	if(argc>=2)   mode = strtoul((const char*)(argv[1]), (char **)NULL, 16);	
8000cb54:	8ca40004 	lw	a0,4(a1)
8000cb58:	00002821 	move	a1,zero
8000cb5c:	0c0020c4 	jal	80008310 <strtoul>
8000cb60:	24060010 	li	a2,16
8000cb64:	00408021 	move	s0,v0
8000cb68:	00009021 	move	s2,zero
8000cb6c:	08003208 	j	8000c820 <PCIE_PowerDown+0x12c>
8000cb70:	3c11b8b0 	lui	s1,0xb8b0



		dprintf("Port%d Link status=%x \n", portnum, REG32(baseaddr+0x728)&0x1f );			
		
};
8000cb74:	8fbf0024 	lw	ra,36(sp)
8000cb78:	8fb40020 	lw	s4,32(sp)
8000cb7c:	8fb3001c 	lw	s3,28(sp)
8000cb80:	8fb20018 	lw	s2,24(sp)
8000cb84:	8fb10014 	lw	s1,20(sp)
8000cb88:	8fb00010 	lw	s0,16(sp)
8000cb8c:	03e00008 	jr	ra
8000cb90:	27bd0028 	addiu	sp,sp,40

8000cb94 <PCIE_Device_PERST>:

//===========================================================

//------------------------------------------------------------------------
void PCIE_Device_PERST(void)
{
8000cb94:	27bdffe0 	addiu	sp,sp,-32
8000cb98:	afbf001c 	sw	ra,28(sp)
8000cb9c:	afb10018 	sw	s1,24(sp)
8000cba0:	afb00014 	sw	s0,20(sp)
	 #define CLK_MANAGE 	0xb8000010
        // 6. PCIE Device Reset       
     REG32(CLK_MANAGE) &= ~(1<<26);    //perst=0 off.    
8000cba4:	3c11b800 	lui	s1,0xb800
8000cba8:	36310010 	ori	s1,s1,0x10
8000cbac:	8e230000 	lw	v1,0(s1)
8000cbb0:	3c02fbff 	lui	v0,0xfbff
8000cbb4:	3442ffff 	ori	v0,v0,0xffff
8000cbb8:	00621024 	and	v0,v1,v0
8000cbbc:	ae220000 	sw	v0,0(s1)
        __delay(100000);   //PCIE standadrd: poweron: 100us, after poweron: 100ms
8000cbc0:	3c100001 	lui	s0,0x1
8000cbc4:	0c0038e0 	jal	8000e380 <__delay>
8000cbc8:	360486a0 	ori	a0,s0,0x86a0
        __delay(100000);   
8000cbcc:	0c0038e0 	jal	8000e380 <__delay>
8000cbd0:	360486a0 	ori	a0,s0,0x86a0
        __delay(100000);   		
8000cbd4:	0c0038e0 	jal	8000e380 <__delay>
8000cbd8:	360486a0 	ori	a0,s0,0x86a0
    REG32(CLK_MANAGE) |=  (1<<26);   //PERST=1
8000cbdc:	8e230000 	lw	v1,0(s1)
8000cbe0:	3c020400 	lui	v0,0x400
8000cbe4:	00621025 	or	v0,v1,v0
8000cbe8:	ae220000 	sw	v0,0(s1)

}
8000cbec:	8fbf001c 	lw	ra,28(sp)
8000cbf0:	8fb10018 	lw	s1,24(sp)
8000cbf4:	8fb00014 	lw	s0,20(sp)
8000cbf8:	03e00008 	jr	ra
8000cbfc:	27bd0020 	addiu	sp,sp,32

8000cc00 <Test_HostPCIE_DataLoopback>:
}


//------------------------------------------------------------------------
int Test_HostPCIE_DataLoopback(int argc, char* argv[])
{
8000cc00:	27bdffd0 	addiu	sp,sp,-48
8000cc04:	afbf002c 	sw	ra,44(sp)
8000cc08:	afb50028 	sw	s5,40(sp)
8000cc0c:	afb40024 	sw	s4,36(sp)
8000cc10:	afb30020 	sw	s3,32(sp)
8000cc14:	afb2001c 	sw	s2,28(sp)
8000cc18:	afb10018 	sw	s1,24(sp)
8000cc1c:	afb00014 	sw	s0,20(sp)
8000cc20:	00808821 	move	s1,a0
8000cc24:	00a09021 	move	s2,a1

//    PCIE_reset_procedure(0,0,1);
	unsigned int portnum=0;
	unsigned int test_packet_num=1;
	
	if(argc >= 1) 
8000cc28:	18800006 	blez	a0,8000cc44 <Test_HostPCIE_DataLoopback+0x44>
8000cc2c:	00008021 	move	s0,zero
	{	portnum= strtoul((const char*)(argv[0]), (char **)NULL, 16);
8000cc30:	8ca40000 	lw	a0,0(a1)
8000cc34:	00002821 	move	a1,zero
8000cc38:	0c0020c4 	jal	80008310 <strtoul>
8000cc3c:	24060010 	li	a2,16
8000cc40:	00408021 	move	s0,v0
	}

	if(argc >= 2) 
8000cc44:	2a220002 	slti	v0,s1,2
8000cc48:	14400007 	bnez	v0,8000cc68 <Test_HostPCIE_DataLoopback+0x68>
8000cc4c:	24110001 	li	s1,1
	{	test_packet_num= strtoul((const char*)(argv[1]), (char **)NULL, 16);
8000cc50:	8e440004 	lw	a0,4(s2)
8000cc54:	00002821 	move	a1,zero
8000cc58:	0c0020c4 	jal	80008310 <strtoul>
8000cc5c:	24060010 	li	a2,16
    unsigned int cnt;

    unsigned int PCIE_Test_cnt;
	unsigned int pcie_err=0;
	
	if(test_packet_num==0)
8000cc60:	10400006 	beqz	v0,8000cc7c <Test_HostPCIE_DataLoopback+0x7c>
8000cc64:	00408821 	move	s1,v0
8000cc68:	00009021 	move	s2,zero
8000cc6c:	24130001 	li	s3,1
#if DBG
        prom_printf("\n==================(Start)======================\n");
        prom_printf("\nPCIE_Test_cnt:%d\n",PCIE_Test_cnt);
#endif        

        if(example(portnum, at2_mode)==0)   //0: mean fail
8000cc70:	3c158002 	lui	s5,0x8002

	{		at2_errcnt++;
8000cc74:	08003333 	j	8000cccc <Test_HostPCIE_DataLoopback+0xcc>
8000cc78:	3c148002 	lui	s4,0x8002
	unsigned int pcie_err=0;
	
	if(test_packet_num==0)
	{
		while(1)
       	 if(example(portnum, at2_mode)==0)   //0: mean fail
8000cc7c:	3c118002 	lui	s1,0x8002
       	 {
				//printf("FAIL, and hang!\n");
				printf("FAIL!\n");
8000cc80:	3c128001 	lui	s2,0x8001
8000cc84:	265262b0 	addiu	s2,s2,25264
	unsigned int pcie_err=0;
	
	if(test_packet_num==0)
	{
		while(1)
       	 if(example(portnum, at2_mode)==0)   //0: mean fail
8000cc88:	02002021 	move	a0,s0
8000cc8c:	0c002671 	jal	800099c4 <example>
8000cc90:	8e253e34 	lw	a1,15924(s1)
8000cc94:	1440fffc 	bnez	v0,8000cc88 <Test_HostPCIE_DataLoopback+0x88>
8000cc98:	00000000 	nop
       	 {
				//printf("FAIL, and hang!\n");
				printf("FAIL!\n");
8000cc9c:	0c002325 	jal	80008c94 <dprintf>
8000cca0:	02402021 	move	a0,s2
	unsigned int pcie_err=0;
	
	if(test_packet_num==0)
	{
		while(1)
       	 if(example(portnum, at2_mode)==0)   //0: mean fail
8000cca4:	08003323 	j	8000cc8c <Test_HostPCIE_DataLoopback+0x8c>
8000cca8:	02002021 	move	a0,s0
#if DBG
        prom_printf("\n==================(Start)======================\n");
        prom_printf("\nPCIE_Test_cnt:%d\n",PCIE_Test_cnt);
#endif        

        if(example(portnum, at2_mode)==0)   //0: mean fail
8000ccac:	0c002671 	jal	800099c4 <example>
8000ccb0:	8ea53e34 	lw	a1,15924(s5)
8000ccb4:	14400004 	bnez	v0,8000ccc8 <Test_HostPCIE_DataLoopback+0xc8>
8000ccb8:	8e823e30 	lw	v0,15920(s4)

	{		at2_errcnt++;
8000ccbc:	24420001 	addiu	v0,v0,1
8000ccc0:	ae823e30 	sw	v0,15920(s4)
		pcie_err++;
8000ccc4:	26520001 	addiu	s2,s2,1
				printf("FAIL!\n");
				//while(1)  {};
		 }
	}
	
    for (PCIE_Test_cnt=1; PCIE_Test_cnt<=test_packet_num; PCIE_Test_cnt++)
8000ccc8:	26730001 	addiu	s3,s3,1
8000cccc:	0233102b 	sltu	v0,s1,s3
8000ccd0:	1040fff6 	beqz	v0,8000ccac <Test_HostPCIE_DataLoopback+0xac>
8000ccd4:	02002021 	move	a0,s0
			return;
	}
#endif
		
    }
	printf("====> Total test cnt=%d, test fail=%d\n", test_packet_num,  pcie_err);
8000ccd8:	3c048001 	lui	a0,0x8001
8000ccdc:	248462b8 	addiu	a0,a0,25272
8000cce0:	02202821 	move	a1,s1
8000cce4:	0c002325 	jal	80008c94 <dprintf>
8000cce8:	02403021 	move	a2,s2
	
}; 
8000ccec:	8fbf002c 	lw	ra,44(sp)
8000ccf0:	8fb50028 	lw	s5,40(sp)
8000ccf4:	8fb40024 	lw	s4,36(sp)
8000ccf8:	8fb30020 	lw	s3,32(sp)
8000ccfc:	8fb2001c 	lw	s2,28(sp)
8000cd00:	8fb10018 	lw	s1,24(sp)
8000cd04:	8fb00014 	lw	s0,20(sp)
8000cd08:	03e00008 	jr	ra
8000cd0c:	27bd0030 	addiu	sp,sp,48

8000cd10 <PCIE_Check_Link>:
	REG32(pcie_phy) = 0x81;   //bit7: PHY reset=1   bit0: Enable LTSSM=1
	
}
//------------------------------------------------------------------------
int PCIE_Check_Link(unsigned int portnum)
{
8000cd10:	27bdffd0 	addiu	sp,sp,-48
8000cd14:	afbf002c 	sw	ra,44(sp)
8000cd18:	afb30028 	sw	s3,40(sp)
8000cd1c:	afb20024 	sw	s2,36(sp)
8000cd20:	afb10020 	sw	s1,32(sp)
8000cd24:	afb0001c 	sw	s0,28(sp)
	unsigned int dbgaddr;
	unsigned int cfgaddr;
	
	if(portnum==0)	dbgaddr=0xb8b00728;
8000cd28:	14800004 	bnez	a0,8000cd3c <PCIE_Check_Link+0x2c>
8000cd2c:	00808021 	move	s0,a0
8000cd30:	3c11b8b0 	lui	s1,0xb8b0
8000cd34:	08003359 	j	8000cd64 <PCIE_Check_Link+0x54>
8000cd38:	36310728 	ori	s1,s1,0x728
	else if(portnum==1)	dbgaddr=0xb8b20728;
8000cd3c:	24020001 	li	v0,1
8000cd40:	14820004 	bne	a0,v0,8000cd54 <PCIE_Check_Link+0x44>
8000cd44:	24020002 	li	v0,2
8000cd48:	3c11b8b2 	lui	s1,0xb8b2
8000cd4c:	08003359 	j	8000cd64 <PCIE_Check_Link+0x54>
8000cd50:	36310728 	ori	s1,s1,0x728
	else if(portnum==2)	dbgaddr=0xb8b40728;	
8000cd54:	14820033 	bne	a0,v0,8000ce24 <PCIE_Check_Link+0x114>
8000cd58:	8fbf002c 	lw	ra,44(sp)
8000cd5c:	3c11b8b4 	lui	s1,0xb8b4
8000cd60:	36310728 	ori	s1,s1,0x728
	else return;	

  //wait for LinkUP
      delay_ms(10);
8000cd64:	0c002219 	jal	80008864 <delay_ms>
8000cd68:	2404000a 	li	a0,10
	volatile int i=5;
8000cd6c:	24020005 	li	v0,5
8000cd70:	afa20010 	sw	v0,16(sp)
	while(--i)
8000cd74:	08003365 	j	8000cd94 <PCIE_Check_Link+0x84>
8000cd78:	24120011 	li	s2,17
	{
		 delay_ms(10);	  
8000cd7c:	0c002219 	jal	80008864 <delay_ms>
8000cd80:	2404000a 	li	a0,10
	      if( (REG32(dbgaddr)&0x1f)==0x11)
8000cd84:	8e220000 	lw	v0,0(s1)
8000cd88:	3042001f 	andi	v0,v0,0x1f
8000cd8c:	10520007 	beq	v0,s2,8000cdac <PCIE_Check_Link+0x9c>
8000cd90:	00000000 	nop
	else return;	

  //wait for LinkUP
      delay_ms(10);
	volatile int i=5;
	while(--i)
8000cd94:	8fa20010 	lw	v0,16(sp)
8000cd98:	2442ffff 	addiu	v0,v0,-1
8000cd9c:	afa20010 	sw	v0,16(sp)
8000cda0:	8fa20010 	lw	v0,16(sp)
8000cda4:	1440fff5 	bnez	v0,8000cd7c <PCIE_Check_Link+0x6c>
8000cda8:	00000000 	nop
		 delay_ms(10);	  
	      if( (REG32(dbgaddr)&0x1f)==0x11)
		  	break;

	}
	if(i==0)
8000cdac:	8fa20010 	lw	v0,16(sp)
8000cdb0:	14400006 	bnez	v0,8000cdcc <PCIE_Check_Link+0xbc>
8000cdb4:	3c048001 	lui	a0,0x8001
	{	//if(at2_mode==0)  //not auto test, show message
		prom_printf("PCIE_P%d ->  Cannot LinkUP\n",portnum);
8000cdb8:	248462e0 	addiu	a0,a0,25312
8000cdbc:	0c0023a7 	jal	80008e9c <prom_printf>
8000cdc0:	02002821 	move	a1,s0
		return 0;
8000cdc4:	08003388 	j	8000ce20 <PCIE_Check_Link+0x110>
8000cdc8:	00001021 	move	v0,zero
	}
	else  //already  linkup
	{
		if(portnum==0)	      REG32(PCIE0_RC_CFG_BASE + 0x04)= 0x00100007;
8000cdcc:	16000007 	bnez	s0,8000cdec <PCIE_Check_Link+0xdc>
8000cdd0:	3c030010 	lui	v1,0x10
8000cdd4:	34630007 	ori	v1,v1,0x7
8000cdd8:	3c02b8b0 	lui	v0,0xb8b0
8000cddc:	34420004 	ori	v0,v0,0x4
8000cde0:	ac430000 	sw	v1,0(v0)
8000cde4:	08003382 	j	8000ce08 <PCIE_Check_Link+0xf8>
8000cde8:	3c13b8b1 	lui	s3,0xb8b1
		else if(portnum==1) REG32(PCIE1_RC_CFG_BASE + 0x04)= 0x00100007;
8000cdec:	24020001 	li	v0,1
8000cdf0:	16020005 	bne	s0,v0,8000ce08 <PCIE_Check_Link+0xf8>
8000cdf4:	34630007 	ori	v1,v1,0x7
8000cdf8:	3c02b8b2 	lui	v0,0xb8b2
8000cdfc:	34420004 	ori	v0,v0,0x4
8000ce00:	ac430000 	sw	v1,0(v0)
8000ce04:	3c13b8b3 	lui	s3,0xb8b3
		  
		if(portnum==0) cfgaddr=0xb8b10000;
		else if(portnum==1) cfgaddr=0xb8b30000;

		//if(at2_mode==0)
		dprintf("Find Port=%x Device:Vender ID=%x\n", portnum, REG32(cfgaddr) );
8000ce08:	8e660000 	lw	a2,0(s3)
8000ce0c:	3c048001 	lui	a0,0x8001
8000ce10:	248462fc 	addiu	a0,a0,25340
8000ce14:	0c002325 	jal	80008c94 <dprintf>
8000ce18:	02002821 	move	a1,s0
8000ce1c:	24020001 	li	v0,1
	}
	return 1;
}
8000ce20:	8fbf002c 	lw	ra,44(sp)
8000ce24:	8fb30028 	lw	s3,40(sp)
8000ce28:	8fb20024 	lw	s2,36(sp)
8000ce2c:	8fb10020 	lw	s1,32(sp)
8000ce30:	8fb0001c 	lw	s0,28(sp)
8000ce34:	03e00008 	jr	ra
8000ce38:	27bd0030 	addiu	sp,sp,48

8000ce3c <PCIE_reset_procedure>:
//#else  //25MHz
//#define PHY_EAT_40MHZ 0
//#endif

void PCIE_reset_procedure(int portnum, int Use_External_PCIE_CLK, int mdio_reset)
{
8000ce3c:	27bdffe0 	addiu	sp,sp,-32
8000ce40:	afbf001c 	sw	ra,28(sp)
8000ce44:	afb10018 	sw	s1,24(sp)
8000ce48:	afb00014 	sw	s0,20(sp)
8000ce4c:	00808021 	move	s0,a0
8000ce50:	00c08821 	move	s1,a2
 	//dprintf("port=%x, mdio_rst=%x \n", portnum, mdio_reset);

	
 #if 1
	#define SYS_HW_STRAP   (0xb8000000 +0x08)
	unsigned int v=REG32(SYS_HW_STRAP);
8000ce54:	3c03b800 	lui	v1,0xb800
8000ce58:	34620008 	ori	v0,v1,0x8
8000ce5c:	8c420000 	lw	v0,0(v0)
	//unsigned char sel40m=GET_BITVAL(v, 25, RANG1);
	unsigned char sel40m=GET_BITVAL(v, 24, RANG1);
#endif

	//for RTL8198c pin_mux2 (0xb8000104) [21:20]=01
	REG32(0xb8000104)&=~(3<<20);
8000ce60:	34620104 	ori	v0,v1,0x104
8000ce64:	8c450000 	lw	a1,0(v0)
8000ce68:	3c04ffcf 	lui	a0,0xffcf
8000ce6c:	3484ffff 	ori	a0,a0,0xffff
8000ce70:	00a42024 	and	a0,a1,a0
8000ce74:	ac440000 	sw	a0,0(v0)
	REG32(0xb8000104)|=(1<<20);
8000ce78:	8c450000 	lw	a1,0(v0)
8000ce7c:	3c040010 	lui	a0,0x10
8000ce80:	00a42025 	or	a0,a1,a0
8000ce84:	ac440000 	sw	a0,0(v0)



 	//first, Turn On PCIE IP
	 #define CLK_MANAGE 	0xb8000010
	REG32(CLK_MANAGE) |= (1<<12) | (1<<13) | (1<<18);
8000ce88:	34630010 	ori	v1,v1,0x10
8000ce8c:	8c640000 	lw	a0,0(v1)
8000ce90:	3c020004 	lui	v0,0x4
8000ce94:	34423000 	ori	v0,v0,0x3000
8000ce98:	00821025 	or	v0,a0,v0
8000ce9c:	ac620000 	sw	v0,0(v1)
	 
	if(portnum==0)		    REG32(CLK_MANAGE) |=  (1<<14);        //enable active_pcie0
8000cea0:	1600000d 	bnez	s0,8000ced8 <PCIE_reset_procedure+0x9c>
8000cea4:	24020001 	li	v0,1
8000cea8:	00601021 	move	v0,v1
8000ceac:	8c630000 	lw	v1,0(v1)
8000ceb0:	34634000 	ori	v1,v1,0x4000
8000ceb4:	ac430000 	sw	v1,0(v0)
	else return;
		    

			
      // __delay(1000*1000*1);
       delay_ms(10);
8000ceb8:	0c002219 	jal	80008864 <delay_ms>
8000cebc:	2404000a 	li	a0,10

        //add compatible, slove sata pcie card.
	if(portnum==0)	  REG32(0xb8b0100c)=(1<<3);  //set target Device Num=1;
8000cec0:	24030008 	li	v1,8
8000cec4:	3c02b8b0 	lui	v0,0xb8b0
8000cec8:	3442100c 	ori	v0,v0,0x100c
8000cecc:	ac430000 	sw	v1,0(v0)
8000ced0:	080033c4 	j	8000cf10 <PCIE_reset_procedure+0xd4>
8000ced4:	00000000 	nop
 	//first, Turn On PCIE IP
	 #define CLK_MANAGE 	0xb8000010
	REG32(CLK_MANAGE) |= (1<<12) | (1<<13) | (1<<18);
	 
	if(portnum==0)		    REG32(CLK_MANAGE) |=  (1<<14);        //enable active_pcie0
	else if(portnum==1)	    REG32(CLK_MANAGE) |=  (1<<16);        //enable active_pcie1	
8000ced8:	16020069 	bne	s0,v0,8000d080 <PCIE_reset_procedure+0x244>
8000cedc:	8fbf001c 	lw	ra,28(sp)
8000cee0:	3c02b800 	lui	v0,0xb800
8000cee4:	34420010 	ori	v0,v0,0x10
8000cee8:	8c440000 	lw	a0,0(v0)
8000ceec:	3c030001 	lui	v1,0x1
8000cef0:	00831825 	or	v1,a0,v1
8000cef4:	ac430000 	sw	v1,0(v0)
	else return;
		    

			
      // __delay(1000*1000*1);
       delay_ms(10);
8000cef8:	0c002219 	jal	80008864 <delay_ms>
8000cefc:	2404000a 	li	a0,10

        //add compatible, slove sata pcie card.
	if(portnum==0)	  REG32(0xb8b0100c)=(1<<3);  //set target Device Num=1;
	if(portnum==1)	  REG32(0xb8b2100c)=(2<<3);  //set target Device Num=1;
8000cf00:	24030010 	li	v1,16
8000cf04:	3c02b8b2 	lui	v0,0xb8b2
8000cf08:	3442100c 	ori	v0,v0,0x100c
8000cf0c:	ac430000 	sw	v1,0(v0)

 	//REG32(SYS_PCIE_ANA)=0x3f39;   //PCIE_ANA  bokai tell me to do this.

	if(mdio_reset)
8000cf10:	12200019 	beqz	s1,8000cf78 <PCIE_reset_procedure+0x13c>
8000cf14:	3c028002 	lui	v0,0x8002
	{
		if(at2_mode==0)  //no auto test, show message
8000cf18:	8c423e34 	lw	v0,15924(v0)
8000cf1c:	14400003 	bnez	v0,8000cf2c <PCIE_reset_procedure+0xf0>
8000cf20:	3c048001 	lui	a0,0x8001
			dprintf("Do MDIO_RESET\n");
8000cf24:	0c002325 	jal	80008c94 <dprintf>
8000cf28:	24846320 	addiu	a0,a0,25376
		
		 delay_ms(10);
8000cf2c:	0c002219 	jal	80008864 <delay_ms>
8000cf30:	2404000a 	li	a0,10
       	// 3.MDIO Reset
		PCIE_MDIO_Reset(portnum);
8000cf34:	02008821 	move	s1,s0
8000cf38:	0c002fd4 	jal	8000bf50 <PCIE_MDIO_Reset>
8000cf3c:	02002021 	move	a0,s0
	}  
	
	  delay_ms(10);
8000cf40:	0c002219 	jal	80008864 <delay_ms>
8000cf44:	2404000a 	li	a0,10
 	PCIE_PHY_Reset(portnum);	
8000cf48:	0c002fe4 	jal	8000bf90 <PCIE_PHY_Reset>
8000cf4c:	02002021 	move	a0,s0
	
       // __delay(1000*1000);
        delay_ms(10);
8000cf50:	0c002219 	jal	80008864 <delay_ms>
8000cf54:	2404000a 	li	a0,10
#endif
#if 1  //v6 FPGA 98C PCIE PHY 40MHZ
		{
		int phy40M=0;
		
		 phy40M=(REG32(0xb8000008)&(1<<24))>>24;
8000cf58:	3c02b800 	lui	v0,0xb800
8000cf5c:	34420008 	ori	v0,v0,0x8
8000cf60:	8c420000 	lw	v0,0(v0)
		if(phy40M)
8000cf64:	7c420600 	ext	v0,v0,0x18,0x1
8000cf68:	1440000c 	bnez	v0,8000cf9c <PCIE_reset_procedure+0x160>
8000cf6c:	00000000 	nop
		HostPCIe_SetPhyMdioWrite(portnum, 0x19, 0xFC70); 
		// HostPCIe_SetPhyMdioWrite(portnum, 0x13, 0x026c);
		}
		else
		{
			dprintf("PCIE PHY=25MHZ,portnum=%d\n",portnum);
8000cf70:	080033f9 	j	8000cfe4 <PCIE_reset_procedure+0x1a8>
8000cf74:	3c048001 	lui	a0,0x8001
		 delay_ms(10);
       	// 3.MDIO Reset
		PCIE_MDIO_Reset(portnum);
	}  
	
	  delay_ms(10);
8000cf78:	0c002219 	jal	80008864 <delay_ms>
8000cf7c:	2404000a 	li	a0,10
 	PCIE_PHY_Reset(portnum);	
8000cf80:	02008821 	move	s1,s0
8000cf84:	0c002fe4 	jal	8000bf90 <PCIE_PHY_Reset>
8000cf88:	02002021 	move	a0,s0
	
       // __delay(1000*1000);
        delay_ms(10);
8000cf8c:	0c002219 	jal	80008864 <delay_ms>
8000cf90:	2404000a 	li	a0,10
8000cf94:	0800340c 	j	8000d030 <PCIE_reset_procedure+0x1f4>
8000cf98:	00000000 	nop
		int phy40M=0;
		
		 phy40M=(REG32(0xb8000008)&(1<<24))>>24;
		if(phy40M)
		{
		dprintf("PCIE PHY=40MHZ,portnum=%d\n",portnum);
8000cf9c:	3c048001 	lui	a0,0x8001
8000cfa0:	24846330 	addiu	a0,a0,25392
8000cfa4:	0c002325 	jal	80008c94 <dprintf>
8000cfa8:	02002821 	move	a1,s0
		HostPCIe_SetPhyMdioWrite(portnum, 0x3, 0x7b01);
8000cfac:	02002021 	move	a0,s0
8000cfb0:	24050003 	li	a1,3
8000cfb4:	0c003015 	jal	8000c054 <HostPCIe_SetPhyMdioWrite>
8000cfb8:	24067b01 	li	a2,31489
		HostPCIe_SetPhyMdioWrite(portnum, 0x6, 0x0268);
8000cfbc:	02002021 	move	a0,s0
8000cfc0:	24050006 	li	a1,6
8000cfc4:	0c003015 	jal	8000c054 <HostPCIe_SetPhyMdioWrite>
8000cfc8:	24060268 	li	a2,616
		//f26c
		
		HostPCIe_SetPhyMdioWrite(portnum, 0x19, 0xFC70); 
8000cfcc:	02002021 	move	a0,s0
8000cfd0:	24050019 	li	a1,25
8000cfd4:	0c003015 	jal	8000c054 <HostPCIe_SetPhyMdioWrite>
8000cfd8:	3406fc70 	li	a2,0xfc70
8000cfdc:	0800340c 	j	8000d030 <PCIE_reset_procedure+0x1f4>
8000cfe0:	00000000 	nop
		// HostPCIe_SetPhyMdioWrite(portnum, 0x13, 0x026c);
		}
		else
		{
			dprintf("PCIE PHY=25MHZ,portnum=%d\n",portnum);
8000cfe4:	2484634c 	addiu	a0,a0,25420
8000cfe8:	0c002325 	jal	80008c94 <dprintf>
8000cfec:	02002821 	move	a1,s0
			HostPCIe_SetPhyMdioWrite(portnum, 0x3, 0x3001);
8000cff0:	02002021 	move	a0,s0
8000cff4:	24050003 	li	a1,3
8000cff8:	0c003015 	jal	8000c054 <HostPCIe_SetPhyMdioWrite>
8000cffc:	24063001 	li	a2,12289
        		HostPCIe_SetPhyMdioWrite(portnum, 0x6, 0xe0b8); //Hannah
8000d000:	02002021 	move	a0,s0
8000d004:	24050006 	li	a1,6
8000d008:	0c003015 	jal	8000c054 <HostPCIe_SetPhyMdioWrite>
8000d00c:	3406e0b8 	li	a2,0xe0b8

        		HostPCIe_SetPhyMdioWrite(portnum, 0xF, 0x400F);
8000d010:	02002021 	move	a0,s0
8000d014:	2405000f 	li	a1,15
8000d018:	0c003015 	jal	8000c054 <HostPCIe_SetPhyMdioWrite>
8000d01c:	2406400f 	li	a2,16399
        		HostPCIe_SetPhyMdioWrite(portnum, 0x19, 0xFC70);	
8000d020:	02002021 	move	a0,s0
8000d024:	24050019 	li	a1,25
8000d028:	0c003015 	jal	8000c054 <HostPCIe_SetPhyMdioWrite>
8000d02c:	3406fc70 	li	a2,0xfc70
#endif
	  	}
 
	//---------------------------------------
         // 6. PCIE Device Reset
       delay_ms(10);
8000d030:	0c002219 	jal	80008864 <delay_ms>
8000d034:	2404000a 	li	a0,10
	PCIE_PHY_Reset(portnum);
8000d038:	0c002fe4 	jal	8000bf90 <PCIE_PHY_Reset>
8000d03c:	02202021 	move	a0,s1
       REG32(CLK_MANAGE) &= ~(1<<26);    //perst=0 off.
8000d040:	3c10b800 	lui	s0,0xb800
8000d044:	36100010 	ori	s0,s0,0x10
8000d048:	8e030000 	lw	v1,0(s0)
8000d04c:	3c02fbff 	lui	v0,0xfbff
8000d050:	3442ffff 	ori	v0,v0,0xffff
8000d054:	00621024 	and	v0,v1,v0
8000d058:	ae020000 	sw	v0,0(s0)
     	delay_ms(300);
8000d05c:	0c002219 	jal	80008864 <delay_ms>
8000d060:	2404012c 	li	a0,300
       REG32(CLK_MANAGE) |=  (1<<26);   //PERST=1 
8000d064:	8e030000 	lw	v1,0(s0)
8000d068:	3c020400 	lui	v0,0x400
8000d06c:	00621025 	or	v0,v1,v0
8000d070:	ae020000 	sw	v0,0(s0)
	//---------------------------------------	  
	PCIE_Check_Link(portnum);
8000d074:	0c003344 	jal	8000cd10 <PCIE_Check_Link>
8000d078:	02202021 	move	a0,s1

}
8000d07c:	8fbf001c 	lw	ra,28(sp)
8000d080:	8fb10018 	lw	s1,24(sp)
8000d084:	8fb00014 	lw	s0,20(sp)
8000d088:	03e00008 	jr	ra
8000d08c:	27bd0020 	addiu	sp,sp,32

8000d090 <PCIE_Host_RESET>:
	printf("====> Total test cnt=%d, test fail=%d\n", test_packet_num,  pcie_err);
	
}; 
//------------------------------------------------------------------------
int PCIE_Host_RESET(int argc, char* argv[])
{
8000d090:	27bdffe0 	addiu	sp,sp,-32
8000d094:	afbf001c 	sw	ra,28(sp)
8000d098:	afb10018 	sw	s1,24(sp)
8000d09c:	afb00014 	sw	s0,20(sp)
	int  portnum= 0;  //0: one port, 1: two port
	int Use_External_PCIE_CLK=0;
	int mdio_reset=0;
	if(argc<2)
8000d0a0:	28820002 	slti	v0,a0,2
8000d0a4:	10400009 	beqz	v0,8000d0cc <PCIE_Host_RESET+0x3c>
8000d0a8:	00a08021 	move	s0,a1
	{//dump all	
	       dprintf("\n"); 		   
8000d0ac:	3c048001 	lui	a0,0x8001
8000d0b0:	0c002325 	jal	80008c94 <dprintf>
8000d0b4:	248457b8 	addiu	a0,a0,22456
		dprintf("hrst <portnum> <mdio_reset>\n");
8000d0b8:	3c048001 	lui	a0,0x8001
8000d0bc:	0c002325 	jal	80008c94 <dprintf>
8000d0c0:	24846368 	addiu	a0,a0,25448
		return;
8000d0c4:	08003450 	j	8000d140 <PCIE_Host_RESET+0xb0>
8000d0c8:	8fbf001c 	lw	ra,28(sp)
	}
	
	if(argc >= 1) 
8000d0cc:	18800020 	blez	a0,8000d150 <PCIE_Host_RESET+0xc0>
8000d0d0:	00000000 	nop
	{	portnum= strtoul((const char*)(argv[0]), (char **)NULL, 16);	
8000d0d4:	8ca40000 	lw	a0,0(a1)
8000d0d8:	00002821 	move	a1,zero
8000d0dc:	0c0020c4 	jal	80008310 <strtoul>
8000d0e0:	24060010 	li	a2,16
8000d0e4:	00408821 	move	s1,v0
	}
	if(argc >= 2) 
	{	mdio_reset= strtoul((const char*)(argv[1]), (char **)NULL, 16);	
8000d0e8:	8e040004 	lw	a0,4(s0)
8000d0ec:	00002821 	move	a1,zero
8000d0f0:	0c0020c4 	jal	80008310 <strtoul>
8000d0f4:	24060010 	li	a2,16
8000d0f8:	00408021 	move	s0,v0
	}

	if(portnum==2)
8000d0fc:	24020002 	li	v0,2
8000d100:	1622000a 	bne	s1,v0,8000d12c <PCIE_Host_RESET+0x9c>
8000d104:	00002021 	move	a0,zero
	{
		PCIE_reset_procedure(0, Use_External_PCIE_CLK, mdio_reset);
8000d108:	00002821 	move	a1,zero
8000d10c:	0c00338f 	jal	8000ce3c <PCIE_reset_procedure>
8000d110:	02003021 	move	a2,s0
		PCIE_reset_procedure(1, Use_External_PCIE_CLK, mdio_reset);
8000d114:	24040001 	li	a0,1
8000d118:	00002821 	move	a1,zero
8000d11c:	0c00338f 	jal	8000ce3c <PCIE_reset_procedure>
8000d120:	02003021 	move	a2,s0
		//PCIE_reset_procedure(portnum, 1, mdio_reset);		
	}		
	else
		PCIE_reset_procedure(portnum, Use_External_PCIE_CLK, mdio_reset);

}; 
8000d124:	08003450 	j	8000d140 <PCIE_Host_RESET+0xb0>
8000d128:	8fbf001c 	lw	ra,28(sp)
		PCIE_reset_procedure(0, Use_External_PCIE_CLK, mdio_reset);
		PCIE_reset_procedure(1, Use_External_PCIE_CLK, mdio_reset);
		//PCIE_reset_procedure(portnum, 1, mdio_reset);		
	}		
	else
		PCIE_reset_procedure(portnum, Use_External_PCIE_CLK, mdio_reset);
8000d12c:	02202021 	move	a0,s1
8000d130:	00002821 	move	a1,zero
8000d134:	0c00338f 	jal	8000ce3c <PCIE_reset_procedure>
8000d138:	02003021 	move	a2,s0

}; 
8000d13c:	8fbf001c 	lw	ra,28(sp)
8000d140:	8fb10018 	lw	s1,24(sp)
8000d144:	8fb00014 	lw	s0,20(sp)
8000d148:	03e00008 	jr	ra
8000d14c:	27bd0020 	addiu	sp,sp,32
	
	if(argc >= 1) 
	{	portnum= strtoul((const char*)(argv[0]), (char **)NULL, 16);	
	}
	if(argc >= 2) 
	{	mdio_reset= strtoul((const char*)(argv[1]), (char **)NULL, 16);	
8000d150:	8ca40004 	lw	a0,4(a1)
8000d154:	00002821 	move	a1,zero
8000d158:	0c0020c4 	jal	80008310 <strtoul>
8000d15c:	24060010 	li	a2,16
8000d160:	00408021 	move	s0,v0
8000d164:	0800344b 	j	8000d12c <PCIE_Host_RESET+0x9c>
8000d168:	00008821 	move	s1,zero

8000d16c <CmdTestSRAM>:
	REG32(0xb8004000)=0;   //sram seg addr
}


int CmdTestSRAM(int argc, char* argv[])
{
8000d16c:	27bdff98 	addiu	sp,sp,-104
8000d170:	afbf0064 	sw	ra,100(sp)
8000d174:	afbe0060 	sw	s8,96(sp)
8000d178:	afb7005c 	sw	s7,92(sp)
8000d17c:	afb60058 	sw	s6,88(sp)
8000d180:	afb50054 	sw	s5,84(sp)
8000d184:	afb40050 	sw	s4,80(sp)
8000d188:	afb3004c 	sw	s3,76(sp)
8000d18c:	afb20048 	sw	s2,72(sp)
8000d190:	afb10044 	sw	s1,68(sp)
8000d194:	afb00040 	sw	s0,64(sp)

	unsigned char *addr;
	unsigned int len=(1<<12);  //SRAM size=4K
	unsigned int i;
	
	if( argc < 1 ) 
8000d198:	1c800006 	bgtz	a0,8000d1b4 <CmdTestSRAM+0x48>
8000d19c:	00000000 	nop
	{
		dprintf("Usage: sram <map addr> \n");		
8000d1a0:	3c048001 	lui	a0,0x8001
8000d1a4:	0c002325 	jal	80008c94 <dprintf>
8000d1a8:	24846388 	addiu	a0,a0,25480
		return;	
8000d1ac:	08003589 	j	8000d624 <CmdTestSRAM+0x4b8>
8000d1b0:	8fbf0064 	lw	ra,100(sp)
	}
	addr = strtoul((const char*)(argv[0]), (char **)NULL, 16);	
8000d1b4:	8ca40000 	lw	a0,0(a1)
8000d1b8:	00002821 	move	a1,zero
8000d1bc:	0c0020c4 	jal	80008310 <strtoul>
8000d1c0:	24060010 	li	a2,16

	unsigned char *paddr=VIR2PHY(addr);
8000d1c4:	3c031fff 	lui	v1,0x1fff
8000d1c8:	3463ffff 	ori	v1,v1,0xffff
8000d1cc:	00431824 	and	v1,v0,v1
8000d1d0:	afa30038 	sw	v1,56(sp)
	unsigned char  *n8addr=VIR2NOC(addr);
8000d1d4:	3c13a000 	lui	s3,0xa000
8000d1d8:	00539825 	or	s3,v0,s3
8000d1dc:	afb3002c 	sw	s3,44(sp)
	unsigned short *n16addr=VIR2NOC(addr);		
	unsigned int     *n32addr=VIR2NOC(addr);	
	
	//===============================================
	//stage 1: r/w
	memset(n8addr, 0xff, len);
8000d1e0:	02602021 	move	a0,s3
8000d1e4:	240500ff 	li	a1,255
8000d1e8:	0c00203d 	jal	800080f4 <memset>
8000d1ec:	24061000 	li	a2,4096
#if 1
	Enable_SRAM(paddr);
8000d1f0:	0c002fc0 	jal	8000bf00 <Enable_SRAM>
8000d1f4:	8fa40038 	lw	a0,56(sp)
#endif
	//-----------------------------------------------------
	//test fix pattern
	unsigned int patt_array[]={ 0x00000000, 0x55555555, 0xaaaaaaaa, 0xffffffff, 0x1234567, 0xa5a55a5a  };
8000d1f8:	afa00010 	sw	zero,16(sp)
8000d1fc:	3c025555 	lui	v0,0x5555
8000d200:	34425555 	ori	v0,v0,0x5555
8000d204:	afa20014 	sw	v0,20(sp)
8000d208:	3c02aaaa 	lui	v0,0xaaaa
8000d20c:	3442aaaa 	ori	v0,v0,0xaaaa
8000d210:	afa20018 	sw	v0,24(sp)
8000d214:	2402ffff 	li	v0,-1
8000d218:	afa2001c 	sw	v0,28(sp)
8000d21c:	3c020123 	lui	v0,0x123
8000d220:	34424567 	ori	v0,v0,0x4567
8000d224:	afa20020 	sw	v0,32(sp)
8000d228:	3c02a5a5 	lui	v0,0xa5a5
8000d22c:	34425a5a 	ori	v0,v0,0x5a5a
8000d230:	afa20024 	sw	v0,36(sp)
8000d234:	0000b821 	move	s7,zero
	//enable sram
	REG32(0xb8004000)=0;   //sram seg addr
}


int CmdTestSRAM(int argc, char* argv[])
8000d238:	27be0028 	addiu	s8,sp,40
			}
		}
		else if(accmode==ACC32)   //pattern fix value, 32 bit access
		{			
			unsigned int patt=patt_array[patt_idx];
			printf("Test Patt %08x, int w/r \n", patt);	
8000d23c:	3c028001 	lui	v0,0x8001
8000d240:	244263f8 	addiu	v0,v0,25592
8000d244:	afa2003c 	sw	v0,60(sp)
	//enable sram
	REG32(0xb8004000)=0;   //sram seg addr
}


int CmdTestSRAM(int argc, char* argv[])
8000d248:	26711000 	addiu	s1,s3,4096
			}
		}
		else if(accmode==ACC16)			//pattern fix value, 16 bit access
		{
			unsigned short patt=patt_array[patt_idx];
			printf("Test Patt %04x, short w/r \n", patt);	
8000d24c:	3c028001 	lui	v0,0x8001
8000d250:	244263dc 	addiu	v0,v0,25564
8000d254:	afa20034 	sw	v0,52(sp)
	for(patt_idx=0; patt_idx< sizeof(patt_array)/sizeof(patt_array[0]) ; patt_idx++)
	{
		if(accmode==ACC8)  //pattern fix value, 8 bit access
		{			
			unsigned char patt=patt_array[patt_idx];
			printf("Test Patt %02x, byte w/r \n", patt);	
8000d258:	3c028001 	lui	v0,0x8001
8000d25c:	244263a4 	addiu	v0,v0,25508
8000d260:	afa20030 	sw	v0,48(sp)
	//enable sram
	REG32(0xb8004000)=0;   //sram seg addr
}


int CmdTestSRAM(int argc, char* argv[])
8000d264:	afb30028 	sw	s3,40(sp)
				REG32(n8addr+i)= patt;	

			for(i=0; i<len; i+=4)
			{
				if(REG32(n8addr+i) != patt)
					printf("%x err, exp=%x, read=%x\n", n8addr+i, patt, REG32(n8addr+i));
8000d268:	3c148001 	lui	s4,0x8001
8000d26c:	080034fc 	j	8000d3f0 <CmdTestSRAM+0x284>
8000d270:	269463c0 	addiu	s4,s4,25536
	for(accmode=ACC8; accmode<ACCEND; accmode++)  // 8 bit, 16bit, 32bit
	{
	
	for(patt_idx=0; patt_idx< sizeof(patt_array)/sizeof(patt_array[0]) ; patt_idx++)
	{
		if(accmode==ACC8)  //pattern fix value, 8 bit access
8000d274:	16e0001a 	bnez	s7,8000d2e0 <CmdTestSRAM+0x174>
8000d278:	24020001 	li	v0,1
		{			
			unsigned char patt=patt_array[patt_idx];
8000d27c:	92d20003 	lbu	s2,3(s6)
			printf("Test Patt %02x, byte w/r \n", patt);	
8000d280:	0240a821 	move	s5,s2
8000d284:	8fa40030 	lw	a0,48(sp)
8000d288:	0c002325 	jal	80008c94 <dprintf>
8000d28c:	02402821 	move	a1,s2
			memset(n8addr, patt, len);	
8000d290:	8fa4002c 	lw	a0,44(sp)
8000d294:	02402821 	move	a1,s2
8000d298:	0c00203d 	jal	800080f4 <memset>
8000d29c:	24061000 	li	a2,4096
	//enable sram
	REG32(0xb8004000)=0;   //sram seg addr
}


int CmdTestSRAM(int argc, char* argv[])
8000d2a0:	8fb00028 	lw	s0,40(sp)
			unsigned char patt=patt_array[patt_idx];
			printf("Test Patt %02x, byte w/r \n", patt);	
			memset(n8addr, patt, len);	
			for(i=0; i<len; i++)
			{
				if(REG8(n8addr+i) != patt)
8000d2a4:	92020000 	lbu	v0,0(s0)
8000d2a8:	304200ff 	andi	v0,v0,0xff
8000d2ac:	10520007 	beq	v0,s2,8000d2cc <CmdTestSRAM+0x160>
8000d2b0:	00000000 	nop
					printf("%x err, exp=%x, read=%x\n", n8addr+i, patt, REG8(n8addr+i));
8000d2b4:	92070000 	lbu	a3,0(s0)
8000d2b8:	02802021 	move	a0,s4
8000d2bc:	02002821 	move	a1,s0
8000d2c0:	02a03021 	move	a2,s5
8000d2c4:	0c002325 	jal	80008c94 <dprintf>
8000d2c8:	30e700ff 	andi	a3,a3,0xff
8000d2cc:	26100001 	addiu	s0,s0,1
		if(accmode==ACC8)  //pattern fix value, 8 bit access
		{			
			unsigned char patt=patt_array[patt_idx];
			printf("Test Patt %02x, byte w/r \n", patt);	
			memset(n8addr, patt, len);	
			for(i=0; i<len; i++)
8000d2d0:	1611fff4 	bne	s0,s1,8000d2a4 <CmdTestSRAM+0x138>
8000d2d4:	00000000 	nop
			printf("Test Patt %08x, int w/r \n", patt);	

			for(i=0; i<len; i+=4)			
				REG32(n8addr+i)= patt;	

			for(i=0; i<len; i+=4)
8000d2d8:	080034e9 	j	8000d3a4 <CmdTestSRAM+0x238>
8000d2dc:	26d60004 	addiu	s6,s6,4
			{
				if(REG8(n8addr+i) != patt)
					printf("%x err, exp=%x, read=%x\n", n8addr+i, patt, REG8(n8addr+i));
			}
		}
		else if(accmode==ACC16)			//pattern fix value, 16 bit access
8000d2e0:	16e2001a 	bne	s7,v0,8000d34c <CmdTestSRAM+0x1e0>
8000d2e4:	24020002 	li	v0,2
		{
			unsigned short patt=patt_array[patt_idx];
8000d2e8:	96d20002 	lhu	s2,2(s6)
			printf("Test Patt %04x, short w/r \n", patt);	
8000d2ec:	0240a821 	move	s5,s2
8000d2f0:	8fa40034 	lw	a0,52(sp)
8000d2f4:	0c002325 	jal	80008c94 <dprintf>
8000d2f8:	02402821 	move	a1,s2
	//enable sram
	REG32(0xb8004000)=0;   //sram seg addr
}


int CmdTestSRAM(int argc, char* argv[])
8000d2fc:	8fa20028 	lw	v0,40(sp)
		{
			unsigned short patt=patt_array[patt_idx];
			printf("Test Patt %04x, short w/r \n", patt);	

			for(i=0; i<len; i+=2)			
				REG16(n8addr+i)= patt;	
8000d300:	a4520000 	sh	s2,0(v0)
8000d304:	24420002 	addiu	v0,v0,2
		else if(accmode==ACC16)			//pattern fix value, 16 bit access
		{
			unsigned short patt=patt_array[patt_idx];
			printf("Test Patt %04x, short w/r \n", patt);	

			for(i=0; i<len; i+=2)			
8000d308:	1451fffd 	bne	v0,s1,8000d300 <CmdTestSRAM+0x194>
8000d30c:	8fb00028 	lw	s0,40(sp)
				REG16(n8addr+i)= patt;	
			
			for(i=0; i<len; i+=2)
			{
				if(REG16(n8addr+i) != patt)
8000d310:	96020000 	lhu	v0,0(s0)
8000d314:	3042ffff 	andi	v0,v0,0xffff
8000d318:	10520007 	beq	v0,s2,8000d338 <CmdTestSRAM+0x1cc>
8000d31c:	00000000 	nop
					printf("%x err, exp=%x, read=%x\n", n8addr+i, patt, REG16(n8addr+i));
8000d320:	96070000 	lhu	a3,0(s0)
8000d324:	02802021 	move	a0,s4
8000d328:	02002821 	move	a1,s0
8000d32c:	02a03021 	move	a2,s5
8000d330:	0c002325 	jal	80008c94 <dprintf>
8000d334:	30e7ffff 	andi	a3,a3,0xffff
8000d338:	26100002 	addiu	s0,s0,2
			printf("Test Patt %04x, short w/r \n", patt);	

			for(i=0; i<len; i+=2)			
				REG16(n8addr+i)= patt;	
			
			for(i=0; i<len; i+=2)
8000d33c:	1630fff4 	bne	s1,s0,8000d310 <CmdTestSRAM+0x1a4>
8000d340:	00000000 	nop
			printf("Test Patt %08x, int w/r \n", patt);	

			for(i=0; i<len; i+=4)			
				REG32(n8addr+i)= patt;	

			for(i=0; i<len; i+=4)
8000d344:	080034e9 	j	8000d3a4 <CmdTestSRAM+0x238>
8000d348:	26d60004 	addiu	s6,s6,4
			{
				if(REG16(n8addr+i) != patt)
					printf("%x err, exp=%x, read=%x\n", n8addr+i, patt, REG16(n8addr+i));
			}
		}
		else if(accmode==ACC32)   //pattern fix value, 32 bit access
8000d34c:	16e20014 	bne	s7,v0,8000d3a0 <CmdTestSRAM+0x234>
8000d350:	8fa4003c 	lw	a0,60(sp)
		{			
			unsigned int patt=patt_array[patt_idx];
8000d354:	8ed20000 	lw	s2,0(s6)
			printf("Test Patt %08x, int w/r \n", patt);	
8000d358:	0c002325 	jal	80008c94 <dprintf>
8000d35c:	02402821 	move	a1,s2
	//enable sram
	REG32(0xb8004000)=0;   //sram seg addr
}


int CmdTestSRAM(int argc, char* argv[])
8000d360:	8fa20028 	lw	v0,40(sp)
		{			
			unsigned int patt=patt_array[patt_idx];
			printf("Test Patt %08x, int w/r \n", patt);	

			for(i=0; i<len; i+=4)			
				REG32(n8addr+i)= patt;	
8000d364:	ac520000 	sw	s2,0(v0)
8000d368:	24420004 	addiu	v0,v0,4
		else if(accmode==ACC32)   //pattern fix value, 32 bit access
		{			
			unsigned int patt=patt_array[patt_idx];
			printf("Test Patt %08x, int w/r \n", patt);	

			for(i=0; i<len; i+=4)			
8000d36c:	1451fffd 	bne	v0,s1,8000d364 <CmdTestSRAM+0x1f8>
8000d370:	8fb00028 	lw	s0,40(sp)
				REG32(n8addr+i)= patt;	

			for(i=0; i<len; i+=4)
			{
				if(REG32(n8addr+i) != patt)
8000d374:	8e020000 	lw	v0,0(s0)
8000d378:	10520006 	beq	v0,s2,8000d394 <CmdTestSRAM+0x228>
8000d37c:	00000000 	nop
					printf("%x err, exp=%x, read=%x\n", n8addr+i, patt, REG32(n8addr+i));
8000d380:	8e070000 	lw	a3,0(s0)
8000d384:	02802021 	move	a0,s4
8000d388:	02002821 	move	a1,s0
8000d38c:	0c002325 	jal	80008c94 <dprintf>
8000d390:	02403021 	move	a2,s2
8000d394:	26100004 	addiu	s0,s0,4
			printf("Test Patt %08x, int w/r \n", patt);	

			for(i=0; i<len; i+=4)			
				REG32(n8addr+i)= patt;	

			for(i=0; i<len; i+=4)
8000d398:	1630fff6 	bne	s1,s0,8000d374 <CmdTestSRAM+0x208>
8000d39c:	00000000 	nop
8000d3a0:	26d60004 	addiu	s6,s6,4
	unsigned int accmode;
	
	for(accmode=ACC8; accmode<ACCEND; accmode++)  // 8 bit, 16bit, 32bit
	{
	
	for(patt_idx=0; patt_idx< sizeof(patt_array)/sizeof(patt_array[0]) ; patt_idx++)
8000d3a4:	16deffb3 	bne	s6,s8,8000d274 <CmdTestSRAM+0x108>
8000d3a8:	24020003 	li	v0,3
	#define ACC16 1
	#define ACC32 2
	#define ACCEND 3
	unsigned int accmode;
	
	for(accmode=ACC8; accmode<ACCEND; accmode++)  // 8 bit, 16bit, 32bit
8000d3ac:	26f70001 	addiu	s7,s7,1
8000d3b0:	16e2000f 	bne	s7,v0,8000d3f0 <CmdTestSRAM+0x284>
8000d3b4:	3c028001 	lui	v0,0x8001
8000d3b8:	24170001 	li	s7,1
8000d3bc:	0000b021 	move	s6,zero
			{
				if(REG8(n8addr+i) != (i&0xff) )
					printf("%x err, exp=%x, read=%x\n", n8addr+i, (i&0xff), REG8(n8addr+i));
			}
		}
		else if(accmode==ACC16)			//pattern fix value, 16 bit access
8000d3c0:	241e0001 	li	s8,1
		{
			printf("Test inc Patt, short w/r \n");	
8000d3c4:	24426430 	addiu	v0,v0,25648
8000d3c8:	afa20030 	sw	v0,48(sp)
8000d3cc:	afb30028 	sw	s3,40(sp)

			for(i=0; i<len/2; i++)			
8000d3d0:	24150800 	li	s5,2048
				REG16(n16addr+i)= i;	
			
			for(i=0; i<len/2; i++)
			{
				if(REG16(n16addr+i) != (i&0xffff) )
					printf("%x err, exp=%x, read=%x\n", n16addr+i, (i&0xffff), REG16(n16addr+i));
8000d3d4:	3c148001 	lui	s4,0x8001
8000d3d8:	269463c0 	addiu	s4,s4,25536
	//test inc patt
	for(accmode=ACC8; accmode<ACCEND; accmode++)  // 8 bit, 16bit, 32bit
	{
		if(accmode==ACC8)  //pattern fix value, 8 bit access
		{			
			printf("Test inc Patt, byte w/r \n");	
8000d3dc:	3c028001 	lui	v0,0x8001
8000d3e0:	24426414 	addiu	v0,v0,25620
8000d3e4:	afa20034 	sw	v0,52(sp)
			for(i=0; i<len; i++)		
8000d3e8:	08003500 	j	8000d400 <CmdTestSRAM+0x294>
8000d3ec:	24121000 	li	s2,4096
	#define ACC16 1
	#define ACC32 2
	#define ACCEND 3
	unsigned int accmode;
	
	for(accmode=ACC8; accmode<ACCEND; accmode++)  // 8 bit, 16bit, 32bit
8000d3f0:	0800349d 	j	8000d274 <CmdTestSRAM+0x108>
8000d3f4:	27b60010 	addiu	s6,sp,16
	//enable sram
	REG32(0xb8004000)=0;   //sram seg addr
}


int CmdTestSRAM(int argc, char* argv[])
8000d3f8:	26d60001 	addiu	s6,s6,1
8000d3fc:	26f70001 	addiu	s7,s7,1
	}
	//-----------------------------------------------------	
	//test inc patt
	for(accmode=ACC8; accmode<ACCEND; accmode++)  // 8 bit, 16bit, 32bit
	{
		if(accmode==ACC8)  //pattern fix value, 8 bit access
8000d400:	16c0001b 	bnez	s6,8000d470 <CmdTestSRAM+0x304>
8000d404:	00000000 	nop
		{			
			printf("Test inc Patt, byte w/r \n");	
8000d408:	0c002325 	jal	80008c94 <dprintf>
8000d40c:	8fa40034 	lw	a0,52(sp)
8000d410:	00001021 	move	v0,zero
8000d414:	00531821 	addu	v1,v0,s3
8000d418:	304400ff 	andi	a0,v0,0xff
			for(i=0; i<len; i++)		
				REG8(n8addr+i)=i;
8000d41c:	a0640000 	sb	a0,0(v1)
	for(accmode=ACC8; accmode<ACCEND; accmode++)  // 8 bit, 16bit, 32bit
	{
		if(accmode==ACC8)  //pattern fix value, 8 bit access
		{			
			printf("Test inc Patt, byte w/r \n");	
			for(i=0; i<len; i++)		
8000d420:	24420001 	addiu	v0,v0,1
8000d424:	1452fffc 	bne	v0,s2,8000d418 <CmdTestSRAM+0x2ac>
8000d428:	00531821 	addu	v1,v0,s3
8000d42c:	8fb00028 	lw	s0,40(sp)
8000d430:	00008821 	move	s1,zero
				REG8(n8addr+i)=i;
			
			for(i=0; i<len; i++)
			{
				if(REG8(n8addr+i) != (i&0xff) )
8000d434:	92020000 	lbu	v0,0(s0)
8000d438:	304200ff 	andi	v0,v0,0xff
8000d43c:	322600ff 	andi	a2,s1,0xff
8000d440:	10460006 	beq	v0,a2,8000d45c <CmdTestSRAM+0x2f0>
8000d444:	00000000 	nop
					printf("%x err, exp=%x, read=%x\n", n8addr+i, (i&0xff), REG8(n8addr+i));
8000d448:	92070000 	lbu	a3,0(s0)
8000d44c:	02802021 	move	a0,s4
8000d450:	02002821 	move	a1,s0
8000d454:	0c002325 	jal	80008c94 <dprintf>
8000d458:	30e700ff 	andi	a3,a3,0xff
		{			
			printf("Test inc Patt, byte w/r \n");	
			for(i=0; i<len; i++)		
				REG8(n8addr+i)=i;
			
			for(i=0; i<len; i++)
8000d45c:	26310001 	addiu	s1,s1,1
8000d460:	1632fff4 	bne	s1,s2,8000d434 <CmdTestSRAM+0x2c8>
8000d464:	26100001 	addiu	s0,s0,1
	//enable sram
	REG32(0xb8004000)=0;   //sram seg addr
}


int CmdTestSRAM(int argc, char* argv[])
8000d468:	080034ff 	j	8000d3fc <CmdTestSRAM+0x290>
8000d46c:	26d60001 	addiu	s6,s6,1
			{
				if(REG8(n8addr+i) != (i&0xff) )
					printf("%x err, exp=%x, read=%x\n", n8addr+i, (i&0xff), REG8(n8addr+i));
			}
		}
		else if(accmode==ACC16)			//pattern fix value, 16 bit access
8000d470:	16de001b 	bne	s6,s8,8000d4e0 <CmdTestSRAM+0x374>
8000d474:	24020002 	li	v0,2
		{
			printf("Test inc Patt, short w/r \n");	
8000d478:	0c002325 	jal	80008c94 <dprintf>
8000d47c:	8fa40030 	lw	a0,48(sp)
8000d480:	8fa30028 	lw	v1,40(sp)
8000d484:	00001021 	move	v0,zero
8000d488:	3044ffff 	andi	a0,v0,0xffff

			for(i=0; i<len/2; i++)			
				REG16(n16addr+i)= i;	
8000d48c:	a4640000 	sh	a0,0(v1)
		}
		else if(accmode==ACC16)			//pattern fix value, 16 bit access
		{
			printf("Test inc Patt, short w/r \n");	

			for(i=0; i<len/2; i++)			
8000d490:	24420001 	addiu	v0,v0,1
8000d494:	1455fffc 	bne	v0,s5,8000d488 <CmdTestSRAM+0x31c>
8000d498:	24630002 	addiu	v1,v1,2
8000d49c:	8fb00028 	lw	s0,40(sp)
8000d4a0:	00008821 	move	s1,zero
				REG16(n16addr+i)= i;	
			
			for(i=0; i<len/2; i++)
			{
				if(REG16(n16addr+i) != (i&0xffff) )
8000d4a4:	96020000 	lhu	v0,0(s0)
8000d4a8:	3042ffff 	andi	v0,v0,0xffff
8000d4ac:	3226ffff 	andi	a2,s1,0xffff
8000d4b0:	10460006 	beq	v0,a2,8000d4cc <CmdTestSRAM+0x360>
8000d4b4:	00000000 	nop
					printf("%x err, exp=%x, read=%x\n", n16addr+i, (i&0xffff), REG16(n16addr+i));
8000d4b8:	96070000 	lhu	a3,0(s0)
8000d4bc:	02802021 	move	a0,s4
8000d4c0:	02002821 	move	a1,s0
8000d4c4:	0c002325 	jal	80008c94 <dprintf>
8000d4c8:	30e7ffff 	andi	a3,a3,0xffff
			printf("Test inc Patt, short w/r \n");	

			for(i=0; i<len/2; i++)			
				REG16(n16addr+i)= i;	
			
			for(i=0; i<len/2; i++)
8000d4cc:	26310001 	addiu	s1,s1,1
8000d4d0:	1635fff4 	bne	s1,s5,8000d4a4 <CmdTestSRAM+0x338>
8000d4d4:	26100002 	addiu	s0,s0,2
	//enable sram
	REG32(0xb8004000)=0;   //sram seg addr
}


int CmdTestSRAM(int argc, char* argv[])
8000d4d8:	080034ff 	j	8000d3fc <CmdTestSRAM+0x290>
8000d4dc:	26d60001 	addiu	s6,s6,1
			{
				if(REG16(n16addr+i) != (i&0xffff) )
					printf("%x err, exp=%x, read=%x\n", n16addr+i, (i&0xffff), REG16(n16addr+i));
			}
		}
		else if(accmode==ACC32)   //pattern fix value, 32 bit access
8000d4e0:	16c2001d 	bne	s6,v0,8000d558 <CmdTestSRAM+0x3ec>
8000d4e4:	2ee20003 	sltiu	v0,s7,3
		{			
			printf("Test inc Patt, int w/r \n");	
8000d4e8:	3c048001 	lui	a0,0x8001
8000d4ec:	0c002325 	jal	80008c94 <dprintf>
8000d4f0:	2484644c 	addiu	a0,a0,25676
8000d4f4:	02601821 	move	v1,s3
8000d4f8:	00001021 	move	v0,zero

			for(i=0; i<len/4; i++)			
8000d4fc:	24040400 	li	a0,1024
				REG32(n32addr+i)= i;	
8000d500:	ac620000 	sw	v0,0(v1)
		}
		else if(accmode==ACC32)   //pattern fix value, 32 bit access
		{			
			printf("Test inc Patt, int w/r \n");	

			for(i=0; i<len/4; i++)			
8000d504:	24420001 	addiu	v0,v0,1
8000d508:	1444fffd 	bne	v0,a0,8000d500 <CmdTestSRAM+0x394>
8000d50c:	24630004 	addiu	v1,v1,4
8000d510:	02608021 	move	s0,s3
8000d514:	00008821 	move	s1,zero
				REG32(n32addr+i)= i;	

			for(i=0; i<len/4; i++)
			{
				if(REG32(n32addr+i) != i)
					printf("%x err, exp=%x, read=%x\n", n32addr+i, i, REG32(n32addr+i));
8000d518:	3c148001 	lui	s4,0x8001
8000d51c:	269463c0 	addiu	s4,s4,25536
			printf("Test inc Patt, int w/r \n");	

			for(i=0; i<len/4; i++)			
				REG32(n32addr+i)= i;	

			for(i=0; i<len/4; i++)
8000d520:	24120400 	li	s2,1024
			{
				if(REG32(n32addr+i) != i)
8000d524:	8e020000 	lw	v0,0(s0)
8000d528:	10510006 	beq	v0,s1,8000d544 <CmdTestSRAM+0x3d8>
8000d52c:	00000000 	nop
					printf("%x err, exp=%x, read=%x\n", n32addr+i, i, REG32(n32addr+i));
8000d530:	8e070000 	lw	a3,0(s0)
8000d534:	02802021 	move	a0,s4
8000d538:	02002821 	move	a1,s0
8000d53c:	0c002325 	jal	80008c94 <dprintf>
8000d540:	02203021 	move	a2,s1
			printf("Test inc Patt, int w/r \n");	

			for(i=0; i<len/4; i++)			
				REG32(n32addr+i)= i;	

			for(i=0; i<len/4; i++)
8000d544:	26310001 	addiu	s1,s1,1
8000d548:	1632fff6 	bne	s1,s2,8000d524 <CmdTestSRAM+0x3b8>
8000d54c:	26100004 	addiu	s0,s0,4
		if(n32addr[i] !=data)
			printf("%x err, exp=%x, read=%x\n", n8addr+i, data, n8addr[i]);
	}
#endif
	//-----------------------------------------------------
	memset(n8addr,0xaa,len);
8000d550:	08003558 	j	8000d560 <CmdTestSRAM+0x3f4>
8000d554:	8fa4002c 	lw	a0,44(sp)
		}		
	}
	}
	//-----------------------------------------------------	
	//test inc patt
	for(accmode=ACC8; accmode<ACCEND; accmode++)  // 8 bit, 16bit, 32bit
8000d558:	1440ffa7 	bnez	v0,8000d3f8 <CmdTestSRAM+0x28c>
8000d55c:	8fa4002c 	lw	a0,44(sp)
		if(n32addr[i] !=data)
			printf("%x err, exp=%x, read=%x\n", n8addr+i, data, n8addr[i]);
	}
#endif
	//-----------------------------------------------------
	memset(n8addr,0xaa,len);
8000d560:	240500aa 	li	a1,170
8000d564:	0c00203d 	jal	800080f4 <memset>
8000d568:	24061000 	li	a2,4096
	Disable_SRAM();
8000d56c:	0c002fcd 	jal	8000bf34 <Disable_SRAM>
8000d570:	26711000 	addiu	s1,s3,4096


	//===========================================
	//stage 2: test on/off
	printf("Test Pattern 0x55 in DRAM, 0xaa in SRAM \n");
8000d574:	3c048001 	lui	a0,0x8001
8000d578:	0c002325 	jal	80008c94 <dprintf>
8000d57c:	24846468 	addiu	a0,a0,25704
	
	memset(n8addr,0x55,len);
8000d580:	8fa4002c 	lw	a0,44(sp)
8000d584:	24050055 	li	a1,85
8000d588:	0c00203d 	jal	800080f4 <memset>
8000d58c:	24061000 	li	a2,4096
	
#if 1
	printf("Enable SRAM, do compare\n");
8000d590:	3c048001 	lui	a0,0x8001
8000d594:	0c002325 	jal	80008c94 <dprintf>
8000d598:	24846494 	addiu	a0,a0,25748
	Enable_SRAM(paddr);
8000d59c:	0c002fc0 	jal	8000bf00 <Enable_SRAM>
8000d5a0:	8fa40038 	lw	a0,56(sp)
	//enable sram
	REG32(0xb8004000)=0;   //sram seg addr
}


int CmdTestSRAM(int argc, char* argv[])
8000d5a4:	02608021 	move	s0,s3

	
	//compare the original sdram
	for(i=0; i<len; i++)
	{
		if(n8addr[i] != 0xaa)
8000d5a8:	241200aa 	li	s2,170
			printf("%x err, exp=%x, read=%x\n", n8addr+i, 0xaa, n8addr[i]);
8000d5ac:	3c148001 	lui	s4,0x8001
8000d5b0:	269463c0 	addiu	s4,s4,25536

	
	//compare the original sdram
	for(i=0; i<len; i++)
	{
		if(n8addr[i] != 0xaa)
8000d5b4:	92070000 	lbu	a3,0(s0)
8000d5b8:	10f20004 	beq	a3,s2,8000d5cc <CmdTestSRAM+0x460>
8000d5bc:	02002821 	move	a1,s0
			printf("%x err, exp=%x, read=%x\n", n8addr+i, 0xaa, n8addr[i]);
8000d5c0:	02802021 	move	a0,s4
8000d5c4:	0c002325 	jal	80008c94 <dprintf>
8000d5c8:	02403021 	move	a2,s2
8000d5cc:	26100001 	addiu	s0,s0,1
	Enable_SRAM(paddr);
#endif

	
	//compare the original sdram
	for(i=0; i<len; i++)
8000d5d0:	1611fff8 	bne	s0,s1,8000d5b4 <CmdTestSRAM+0x448>
8000d5d4:	00000000 	nop
	{
		if(n8addr[i] != 0xaa)
			printf("%x err, exp=%x, read=%x\n", n8addr+i, 0xaa, n8addr[i]);
	}
	
	printf("Disable SRAM, do compare\n");
8000d5d8:	3c048001 	lui	a0,0x8001
8000d5dc:	0c002325 	jal	80008c94 <dprintf>
8000d5e0:	248464b0 	addiu	a0,a0,25776
	Disable_SRAM();
8000d5e4:	0c002fcd 	jal	8000bf34 <Disable_SRAM>
8000d5e8:	24100055 	li	s0,85
	
	for(i=0; i<len; i++)
	{
		if(n8addr[i] != 0x55)
			printf("%x err, exp=%x, read=%x\n", n8addr+i, 0x55, n8addr[i]);
8000d5ec:	3c128001 	lui	s2,0x8001
8000d5f0:	265263c0 	addiu	s2,s2,25536
	printf("Disable SRAM, do compare\n");
	Disable_SRAM();
	
	for(i=0; i<len; i++)
	{
		if(n8addr[i] != 0x55)
8000d5f4:	92670000 	lbu	a3,0(s3)
8000d5f8:	10f00004 	beq	a3,s0,8000d60c <CmdTestSRAM+0x4a0>
8000d5fc:	02602821 	move	a1,s3
			printf("%x err, exp=%x, read=%x\n", n8addr+i, 0x55, n8addr[i]);
8000d600:	02402021 	move	a0,s2
8000d604:	0c002325 	jal	80008c94 <dprintf>
8000d608:	02003021 	move	a2,s0
8000d60c:	26730001 	addiu	s3,s3,1
	}
	
	printf("Disable SRAM, do compare\n");
	Disable_SRAM();
	
	for(i=0; i<len; i++)
8000d610:	1671fff8 	bne	s3,s1,8000d5f4 <CmdTestSRAM+0x488>
8000d614:	3c048001 	lui	a0,0x8001
	}

	//-----------------------------------------------------

	
	printf("No error is pass\n");
8000d618:	0c002325 	jal	80008c94 <dprintf>
8000d61c:	248464cc 	addiu	a0,a0,25804
}
8000d620:	8fbf0064 	lw	ra,100(sp)
8000d624:	8fbe0060 	lw	s8,96(sp)
8000d628:	8fb7005c 	lw	s7,92(sp)
8000d62c:	8fb60058 	lw	s6,88(sp)
8000d630:	8fb50054 	lw	s5,84(sp)
8000d634:	8fb40050 	lw	s4,80(sp)
8000d638:	8fb3004c 	lw	s3,76(sp)
8000d63c:	8fb20048 	lw	s2,72(sp)
8000d640:	8fb10044 	lw	s1,68(sp)
8000d644:	8fb00040 	lw	s0,64(sp)
8000d648:	03e00008 	jr	ra
8000d64c:	27bd0068 	addiu	sp,sp,104

8000d650 <Check_UartRxDataRdy>:



unsigned int Check_UartRxDataRdy()
{
	if 	(REG32(UART_LSR) & (1<<24) )
8000d650:	3c02b800 	lui	v0,0xb800
8000d654:	34422014 	ori	v0,v0,0x2014
8000d658:	8c420000 	lw	v0,0(v0)
		return 1;
	else
		return 0;
}
8000d65c:	03e00008 	jr	ra
8000d660:	7c420600 	ext	v0,v0,0x18,0x1

8000d664 <Get_UartData>:

unsigned char Get_UartData()
{	return REG32(UART_RBR)>>24;
8000d664:	3c02b800 	lui	v0,0xb800
8000d668:	34422000 	ori	v0,v0,0x2000
8000d66c:	8c420000 	lw	v0,0(v0)
}
8000d670:	03e00008 	jr	ra
8000d674:	00021602 	srl	v0,v0,0x18

8000d678 <Get_UartData_timeout>:

int Get_UartData_timeout(unsigned char *c, unsigned int  timeout)
{	
8000d678:	27bdffe0 	addiu	sp,sp,-32
8000d67c:	afbf001c 	sw	ra,28(sp)
8000d680:	afb10018 	sw	s1,24(sp)
8000d684:	afb00014 	sw	s0,20(sp)
8000d688:	00808821 	move	s1,a0
	unsigned int t=timeout;

	while(t--)
8000d68c:	080035ae 	j	8000d6b8 <Get_UartData_timeout+0x40>
8000d690:	00a08021 	move	s0,a1
	{
		if(Check_UartRxDataRdy())
8000d694:	0c003594 	jal	8000d650 <Check_UartRxDataRdy>
8000d698:	2610ffff 	addiu	s0,s0,-1
8000d69c:	10400006 	beqz	v0,8000d6b8 <Get_UartData_timeout+0x40>
8000d6a0:	00000000 	nop
		{	*c=Get_UartData();
8000d6a4:	0c003599 	jal	8000d664 <Get_UartData>
8000d6a8:	00000000 	nop
8000d6ac:	a2220000 	sb	v0,0(s1)
			return 1;
8000d6b0:	080035b0 	j	8000d6c0 <Get_UartData_timeout+0x48>
8000d6b4:	24020001 	li	v0,1

int Get_UartData_timeout(unsigned char *c, unsigned int  timeout)
{	
	unsigned int t=timeout;

	while(t--)
8000d6b8:	1600fff6 	bnez	s0,8000d694 <Get_UartData_timeout+0x1c>
8000d6bc:	00001021 	move	v0,zero
			return 1;
		}

	}
	return 0;
}
8000d6c0:	8fbf001c 	lw	ra,28(sp)
8000d6c4:	8fb10018 	lw	s1,24(sp)
8000d6c8:	8fb00014 	lw	s0,20(sp)
8000d6cc:	03e00008 	jr	ra
8000d6d0:	27bd0020 	addiu	sp,sp,32

8000d6d4 <xmodem_receive>:




int xmodem_receive(unsigned char  * buf)
{
8000d6d4:	27bdffa8 	addiu	sp,sp,-88
8000d6d8:	afbf0054 	sw	ra,84(sp)
8000d6dc:	afbe0050 	sw	s8,80(sp)
8000d6e0:	afb7004c 	sw	s7,76(sp)
8000d6e4:	afb60048 	sw	s6,72(sp)
8000d6e8:	afb50044 	sw	s5,68(sp)
8000d6ec:	afb40040 	sw	s4,64(sp)
8000d6f0:	afb3003c 	sw	s3,60(sp)
8000d6f4:	afb20038 	sw	s2,56(sp)
8000d6f8:	afb10034 	sw	s1,52(sp)
8000d6fc:	afb00030 	sw	s0,48(sp)
8000d700:	afa40018 	sw	a0,24(sp)
8000d704:	24110014 	li	s1,20
8000d708:	00009821 	move	s3,zero
8000d70c:	00008021 	move	s0,zero
8000d710:	24020001 	li	v0,1
8000d714:	afa2001c 	sw	v0,28(sp)
	/* received buffer size to zero */
	int size = 0;
	
	while(retry > 0)
	{
		switch(state)
8000d718:	3c148001 	lui	s4,0x8001
8000d71c:	26940570 	addiu	s4,s4,1392
					retry--;
				}
				break;
				
			case XMODEM_RX_PACKET:
				if(getc_with_timeout(&c, timeout))
8000d720:	27b50010 	addiu	s5,sp,16
8000d724:	3c120001 	lui	s2,0x1
8000d728:	365286a0 	ori	s2,s2,0x86a0
				{	head1=c;
				}
				else goto fail;
				
				if(getc_with_timeout(&c, timeout))
				{	head2=c;				
8000d72c:	0000f021 	move	s8,zero
						 continue;
					}
				}
				
				retry--;
				putc(NAK);
8000d730:	24160001 	li	s6,1
					}
				
					else if(c == CAN)
					{	state = XMODEM_CANCEL;
					}
					else if(c == EOT)
8000d734:	24170004 	li	s7,4
	/* received buffer size to zero */
	int size = 0;
	
	while(retry > 0)
	{
		switch(state)
8000d738:	2e020005 	sltiu	v0,s0,5
8000d73c:	1040ffff 	beqz	v0,8000d73c <xmodem_receive+0x68>
8000d740:	00000000 	nop
8000d744:	00101080 	sll	v0,s0,0x2
8000d748:	02821021 	addu	v0,s4,v0
8000d74c:	8c420000 	lw	v0,0(v0)
8000d750:	00400008 	jr	v0
8000d754:	00000000 	nop
		{
			case XMODEM_RX_READY:
				
				putc(NAK);			
8000d758:	0c001fe0 	jal	80007f80 <serial_outc>
8000d75c:	24040015 	li	a0,21
				if(getc_with_timeout(&c, timeout))
8000d760:	02a02021 	move	a0,s5
8000d764:	0c00359e 	jal	8000d678 <Get_UartData_timeout>
8000d768:	02402821 	move	a1,s2
8000d76c:	10400078 	beqz	v0,8000d950 <xmodem_receive+0x27c>
8000d770:	93a20010 	lbu	v0,16(sp)
				{
					if(c == SOH)
8000d774:	10560075 	beq	v0,s6,8000d94c <xmodem_receive+0x278>
8000d778:	24030003 	li	v1,3
					{
						packet_size = 128;						
						state = XMODEM_RX_PACKET;
					}			
					else if(c == 3)  //Ctrl+C
8000d77c:	14430074 	bne	v0,v1,8000d950 <xmodem_receive+0x27c>
8000d780:	00000000 	nop
					{
						putc(CAN);	putc(CAN);
8000d784:	0c001fe0 	jal	80007f80 <serial_outc>
8000d788:	24040018 	li	a0,24
8000d78c:	0c001fe0 	jal	80007f80 <serial_outc>
8000d790:	24040018 	li	a0,24
						putc(CAN);	putc(CAN);
8000d794:	0c001fe0 	jal	80007f80 <serial_outc>
8000d798:	24040018 	li	a0,24
8000d79c:	0c001fe0 	jal	80007f80 <serial_outc>
8000d7a0:	24040018 	li	a0,24
						size = 0;
						return false;
8000d7a4:	0800365f 	j	8000d97c <xmodem_receive+0x2a8>
8000d7a8:	00009821 	move	s3,zero
					}
				}	
				break;
				
			case XMODEM_WAIT_HEADER:
				if(getc_with_timeout(&c, timeout))
8000d7ac:	02a02021 	move	a0,s5
8000d7b0:	0c00359e 	jal	8000d678 <Get_UartData_timeout>
8000d7b4:	02402821 	move	a1,s2
8000d7b8:	10400009 	beqz	v0,8000d7e0 <xmodem_receive+0x10c>
8000d7bc:	93a20010 	lbu	v0,16(sp)
				{
					if(c == SOH)
8000d7c0:	10560062 	beq	v0,s6,8000d94c <xmodem_receive+0x278>
8000d7c4:	24040018 	li	a0,24
					{
						packet_size = 128;						
						state = XMODEM_RX_PACKET;
					}
				
					else if(c == CAN)
8000d7c8:	14440003 	bne	v0,a0,8000d7d8 <xmodem_receive+0x104>
8000d7cc:	00571026 	xor	v0,v0,s7
8000d7d0:	08003654 	j	8000d950 <xmodem_receive+0x27c>
8000d7d4:	24100003 	li	s0,3
					{	state = XMODEM_CANCEL;
					}
					else if(c == EOT)
8000d7d8:	08003654 	j	8000d950 <xmodem_receive+0x27c>
8000d7dc:	02e2800a 	movz	s0,s7,v0
					}
				}
				else
				{
					/* timed out, try again */
					retry--;
8000d7e0:	08003654 	j	8000d950 <xmodem_receive+0x27c>
8000d7e4:	2631ffff 	addiu	s1,s1,-1
				}
				break;
				
			case XMODEM_RX_PACKET:
				if(getc_with_timeout(&c, timeout))
8000d7e8:	02a02021 	move	a0,s5
8000d7ec:	0c00359e 	jal	8000d678 <Get_UartData_timeout>
8000d7f0:	02402821 	move	a1,s2
8000d7f4:	10400024 	beqz	v0,8000d888 <xmodem_receive+0x1b4>
8000d7f8:	93a50010 	lbu	a1,16(sp)
				{	head1=c;
8000d7fc:	afa50028 	sw	a1,40(sp)
				}
				else goto fail;
				
				if(getc_with_timeout(&c, timeout))
8000d800:	02a02021 	move	a0,s5
8000d804:	0c00359e 	jal	8000d678 <Get_UartData_timeout>
8000d808:	02402821 	move	a1,s2
8000d80c:	1040001e 	beqz	v0,8000d888 <xmodem_receive+0x1b4>
8000d810:	93a20010 	lbu	v0,16(sp)
				{	head2=c;				
8000d814:	afa2002c 	sw	v0,44(sp)
8000d818:	afbe0024 	sw	s8,36(sp)
8000d81c:	afbe0020 	sw	s8,32(sp)
				else goto fail;

				csum=0;
				for(i = 0; i < packet_size  ; i++)
				{
					if(getc_with_timeout(&c, timeout))
8000d820:	02a02021 	move	a0,s5
8000d824:	0c00359e 	jal	8000d678 <Get_UartData_timeout>
8000d828:	02402821 	move	a1,s2
8000d82c:	10400016 	beqz	v0,8000d888 <xmodem_receive+0x1b4>
8000d830:	8fa40018 	lw	a0,24(sp)
					{	ptr[i] = c;
8000d834:	8fa50020 	lw	a1,32(sp)
8000d838:	00851821 	addu	v1,a0,a1
8000d83c:	93a20010 	lbu	v0,16(sp)
8000d840:	a0620000 	sb	v0,0(v1)
						csum+=c;
8000d844:	8fa30024 	lw	v1,36(sp)
8000d848:	00621021 	addu	v0,v1,v0
8000d84c:	304200ff 	andi	v0,v0,0xff
8000d850:	afa20024 	sw	v0,36(sp)
				{	head2=c;				
				}
				else goto fail;

				csum=0;
				for(i = 0; i < packet_size  ; i++)
8000d854:	24a50001 	addiu	a1,a1,1
8000d858:	24040080 	li	a0,128
8000d85c:	14a4fff0 	bne	a1,a0,8000d820 <xmodem_receive+0x14c>
8000d860:	afa50020 	sw	a1,32(sp)
					}
					else
						goto fail;
				}

				if(getc_with_timeout(&c, timeout))
8000d864:	02a02021 	move	a0,s5
8000d868:	0c00359e 	jal	8000d678 <Get_UartData_timeout>
8000d86c:	02402821 	move	a1,s2
8000d870:	10400005 	beqz	v0,8000d888 <xmodem_receive+0x1b4>
8000d874:	8fa50020 	lw	a1,32(sp)

				
				state = XMODEM_WAIT_HEADER;
				
				/* packet was too small, retry */
				if(i < (packet_size))
8000d878:	2ca30080 	sltiu	v1,a1,128
8000d87c:	10600007 	beqz	v1,8000d89c <xmodem_receive+0x1c8>
8000d880:	93a20010 	lbu	v0,16(sp)
8000d884:	02c08021 	move	s0,s6
				{
fail:				
					retry--;
8000d888:	2631ffff 	addiu	s1,s1,-1
					putc(NAK);
8000d88c:	0c001fe0 	jal	80007f80 <serial_outc>
8000d890:	24040015 	li	a0,21
					continue;
8000d894:	08003654 	j	8000d950 <xmodem_receive+0x27c>
8000d898:	00000000 	nop
				}
				
				/* check validity of packet */
				if( (head1 == 255-head2) && (head_csum==csum) )
8000d89c:	240400ff 	li	a0,255
8000d8a0:	8fa5002c 	lw	a1,44(sp)
8000d8a4:	00851823 	subu	v1,a0,a1
8000d8a8:	8fa40028 	lw	a0,40(sp)
8000d8ac:	1483001a 	bne	a0,v1,8000d918 <xmodem_receive+0x244>
8000d8b0:	8fa50024 	lw	a1,36(sp)
8000d8b4:	14450018 	bne	v0,a1,8000d918 <xmodem_receive+0x244>
8000d8b8:	8fa2001c 	lw	v0,28(sp)
				{
					/* is this the packet we were waiting for? */
					if(head1== block_index)
8000d8bc:	1444000d 	bne	v0,a0,8000d8f4 <xmodem_receive+0x220>
8000d8c0:	8fa4001c 	lw	a0,28(sp)
					{
						ptr+=packet_size;
8000d8c4:	8fa30018 	lw	v1,24(sp)
8000d8c8:	24630080 	addiu	v1,v1,128
8000d8cc:	afa30018 	sw	v1,24(sp)
						size += packet_size;						
8000d8d0:	26730080 	addiu	s3,s3,128
						block_index++;
8000d8d4:	24420001 	addiu	v0,v0,1
8000d8d8:	304200ff 	andi	v0,v0,0xff
8000d8dc:	afa2001c 	sw	v0,28(sp)
						retry = RETRY;
						putc(ACK);
8000d8e0:	0c001fe0 	jal	80007f80 <serial_outc>
8000d8e4:	24040006 	li	a0,6
8000d8e8:	24110014 	li	s1,20
8000d8ec:	080035ce 	j	8000d738 <xmodem_receive+0x64>
8000d8f0:	02c08021 	move	s0,s6
						continue;
					}
					else if(head1 == (unsigned char )(block_index-1))
8000d8f4:	2482ffff 	addiu	v0,a0,-1
8000d8f8:	304200ff 	andi	v0,v0,0xff
8000d8fc:	8fa50028 	lw	a1,40(sp)
8000d900:	14450005 	bne	v0,a1,8000d918 <xmodem_receive+0x244>
8000d904:	00000000 	nop
					{
						/* this is a retransmission of the last packet */
						putc(ACK);
8000d908:	0c001fe0 	jal	80007f80 <serial_outc>
8000d90c:	24040006 	li	a0,6
						 continue;
8000d910:	08003654 	j	8000d950 <xmodem_receive+0x27c>
8000d914:	02c08021 	move	s0,s6
					}
				}
				
				retry--;
8000d918:	2631ffff 	addiu	s1,s1,-1
				putc(NAK);
8000d91c:	0c001fe0 	jal	80007f80 <serial_outc>
8000d920:	24040015 	li	a0,21
				break;
8000d924:	08003654 	j	8000d950 <xmodem_receive+0x27c>
8000d928:	02c08021 	move	s0,s6
				
			case XMODEM_CANCEL:
				putc(ACK);
8000d92c:	0c001fe0 	jal	80007f80 <serial_outc>
8000d930:	24040006 	li	a0,6
				
				return false;
8000d934:	0800365f 	j	8000d97c <xmodem_receive+0x2a8>
8000d938:	00009821 	move	s3,zero
				
			case XMODEM_EOT:
				putc(ACK);
8000d93c:	0c001fe0 	jal	80007f80 <serial_outc>
8000d940:	24040006 	li	a0,6
				//mdelay(100);				
				return size;
8000d944:	08003660 	j	8000d980 <xmodem_receive+0x2ac>
8000d948:	02601021 	move	v0,s3
8000d94c:	24100002 	li	s0,2

	
	/* received buffer size to zero */
	int size = 0;
	
	while(retry > 0)
8000d950:	1620ff7a 	bnez	s1,8000d73c <xmodem_receive+0x68>
8000d954:	2e020005 	sltiu	v0,s0,5
				break;
		}
	}
	
	/* retry too much, fail */
	putc(CAN);	putc(CAN);
8000d958:	0c001fe0 	jal	80007f80 <serial_outc>
8000d95c:	24040018 	li	a0,24
8000d960:	0c001fe0 	jal	80007f80 <serial_outc>
8000d964:	24040018 	li	a0,24
	putc(CAN);	putc(CAN);
8000d968:	0c001fe0 	jal	80007f80 <serial_outc>
8000d96c:	24040018 	li	a0,24
8000d970:	0c001fe0 	jal	80007f80 <serial_outc>
8000d974:	24040018 	li	a0,24
8000d978:	00009821 	move	s3,zero
	
	
	return false;
}
8000d97c:	02601021 	move	v0,s3
8000d980:	8fbf0054 	lw	ra,84(sp)
8000d984:	8fbe0050 	lw	s8,80(sp)
8000d988:	8fb7004c 	lw	s7,76(sp)
8000d98c:	8fb60048 	lw	s6,72(sp)
8000d990:	8fb50044 	lw	s5,68(sp)
8000d994:	8fb40040 	lw	s4,64(sp)
8000d998:	8fb3003c 	lw	s3,60(sp)
8000d99c:	8fb20038 	lw	s2,56(sp)
8000d9a0:	8fb10034 	lw	s1,52(sp)
8000d9a4:	8fb00030 	lw	s0,48(sp)
8000d9a8:	03e00008 	jr	ra
8000d9ac:	27bd0058 	addiu	sp,sp,88

8000d9b0 <pollingDownModeKeyword>:
{
	int i;
                 #if CONFIG_ESD_SUPPORT//patch for ESD
                  	 REG32(0xb800311c)|= (1<<23);
                  #endif
	if  (Check_UART_DataReady() )
8000d9b0:	3c02b800 	lui	v0,0xb800
8000d9b4:	34422014 	ori	v0,v0,0x2014
8000d9b8:	8c420000 	lw	v0,0(v0)
8000d9bc:	7c420600 	ext	v0,v0,0x18,0x1
8000d9c0:	1040000c 	beqz	v0,8000d9f4 <pollingDownModeKeyword+0x44>
8000d9c4:	00000000 	nop
	{
		i=Get_UART_Data();
8000d9c8:	3c02b800 	lui	v0,0xb800
8000d9cc:	34422000 	ori	v0,v0,0x2000
8000d9d0:	8c430000 	lw	v1,0(v0)
		Get_UART_Data();
8000d9d4:	8c420000 	lw	v0,0(v0)
		if( i == key )
8000d9d8:	00031602 	srl	v0,v1,0x18
8000d9dc:	14440005 	bne	v0,a0,8000d9f4 <pollingDownModeKeyword+0x44>
8000d9e0:	24030001 	li	v1,1
		{ 	
#if defined(UTILITY_DEBUG)		
			dprintf("User Press ESC Break Key\r\n");
#endif			
			gCHKKEY_HIT=1;
8000d9e4:	3c028002 	lui	v0,0x8002
8000d9e8:	ac433e50 	sw	v1,15952(v0)
			return 1;
8000d9ec:	03e00008 	jr	ra
8000d9f0:	24020001 	li	v0,1
		}
	}
	return 0;
}
8000d9f4:	03e00008 	jr	ra
8000d9f8:	00001021 	move	v0,zero

8000d9fc <pollingPressedButton>:
int pollingPressedButton(int pressedFlag)
{
#ifndef CONFIG_NFBI
#ifndef CONFIG_FPGA_PLATFORM
		// polling if button is pressed --------------------------------------
    		if (pressedFlag == -1 ||  pressedFlag == 1) 
8000d9fc:	2403ffff 	li	v1,-1
8000da00:	10830004 	beq	a0,v1,8000da14 <pollingPressedButton+0x18>
8000da04:	00801021 	move	v0,a0
8000da08:	24030001 	li	v1,1
8000da0c:	1483000b 	bne	a0,v1,8000da3c <pollingPressedButton+0x40>
8000da10:	00000000 	nop
	//		REG32(RTL_GPIO_MUX) =  0x0c0f;
	//		REG32(PEFGHCNR_REG) = REG32(PEFGHCNR_REG)& (~(1<<25) ); //set byte F GPIO7 = gpio
        //     		REG32(PEFGHDIR_REG) = REG32(PEFGHDIR_REG) & (~(1<<25) );  //0 input, 1 out
#endif
		
			if ( Get_GPIO_SW_IN() )			
8000da14:	3c02b800 	lui	v0,0xb800
8000da18:	34423528 	ori	v0,v0,0x3528
8000da1c:	8c430000 	lw	v1,0(v0)
8000da20:	7c630740 	ext	v1,v1,0x1d,0x1
8000da24:	14600005 	bnez	v1,8000da3c <pollingPressedButton+0x40>
8000da28:	00001021 	move	v0,zero
				if (pressedFlag == -1) 
				{
					//SET_TIMER(1*CPU_CLOCK); // wait 1 sec
				}
				pressedFlag = 1;
				gCHKKEY_HIT=1;
8000da2c:	24030001 	li	v1,1
8000da30:	3c028002 	lui	v0,0x8002
8000da34:	ac433e50 	sw	v1,15952(v0)
8000da38:	24020001 	li	v0,1
#endif
#endif
#endif //CONFIG_NFBI

	return pressedFlag;
}
8000da3c:	03e00008 	jr	ra
8000da40:	00000000 	nop

8000da44 <Init_GPIO>:
	REG32(PEFGHDIR_REG) = REG32(PEFGHDIR_REG) & (~(1<<25) );  //0 input, 1 output, set F bit 7 input
#endif	
#endif
#endif
#endif
}
8000da44:	03e00008 	jr	ra
8000da48:	00000000 	nop

8000da4c <console_init>:
	unsigned long dl;
	unsigned long dll;     
	unsigned long dlm;       


  	REG32(UART_LCR_REG)=0x03000000;		//Line Control Register  8,n,1
8000da4c:	3c02b800 	lui	v0,0xb800
8000da50:	3443200c 	ori	v1,v0,0x200c
8000da54:	3c050300 	lui	a1,0x300
8000da58:	ac650000 	sw	a1,0(v1)
  			
  	REG32( UART_FCR_REG)=0xc7000000;		//FIFO Ccontrol Register
8000da5c:	34462008 	ori	a2,v0,0x2008
8000da60:	3c07c700 	lui	a3,0xc700
8000da64:	acc70000 	sw	a3,0(a2)
  	REG32( UART_IER_REG)=0x00000000;
8000da68:	34462004 	ori	a2,v0,0x2004
8000da6c:	acc00000 	sw	zero,0(a2)
  	dl = (lexea_clock /16)/BAUD_RATE-1;
8000da70:	3c071b4e 	lui	a3,0x1b4e
8000da74:	34e781b5 	ori	a3,a3,0x81b5
8000da78:	00870019 	multu	a0,a3
8000da7c:	00002010 	mfhi	a0
8000da80:	00042402 	srl	a0,a0,0x10
8000da84:	2484ffff 	addiu	a0,a0,-1
  	//*(volatile unsigned long *)(0xa1000000) = dl ; 
  	dll = dl & 0xff;
  	dlm = dl / 0x100;
  	REG32( UART_LCR_REG)=0x83000000;		//Divisor latch access bit=1
8000da88:	3c078300 	lui	a3,0x8300
8000da8c:	ac670000 	sw	a3,0(v1)
  	REG32( UART_DLL_REG)=dll*0x1000000;
8000da90:	00043e00 	sll	a3,a0,0x18
8000da94:	34422000 	ori	v0,v0,0x2000
8000da98:	ac470000 	sw	a3,0(v0)
   	REG32( UART_DLM_REG)=dlm*0x1000000; 
8000da9c:	00042202 	srl	a0,a0,0x8
8000daa0:	00042600 	sll	a0,a0,0x18
8000daa4:	acc40000 	sw	a0,0(a2)
    	REG32( UART_LCR_REG)=0x83000000& 0x7fffffff;	//Divisor latch access bit=0
8000daa8:	ac650000 	sw	a1,0(v1)
   	//rtl_outl( UART_THR,0x41000000);	

	//dprintf("\n\n-------------------------------------------");
	//dprintf("\nUART1 output test ok\n");
}
8000daac:	03e00008 	jr	ra
8000dab0:	00000000 	nop

8000dab4 <setClkInitConsole>:
}
#endif
//-------------------------------------------------------
//set clk and init console	
void setClkInitConsole(void)
{
8000dab4:	27bdffe8 	addiu	sp,sp,-24
8000dab8:	afbf0014 	sw	ra,20(sp)
	console_init( glexra_clock);
8000dabc:	3c028001 	lui	v0,0x8001
8000dac0:	0c003693 	jal	8000da4c <console_init>
8000dac4:	8c447710 	lw	a0,30480(v0)
//	printf("\n=>init console ok\n");
}
8000dac8:	8fbf0014 	lw	ra,20(sp)
8000dacc:	03e00008 	jr	ra
8000dad0:	27bd0018 	addiu	sp,sp,24

8000dad4 <initFlash>:
//-------------------------------------------------------

//-------------------------------------------------------
// init flash 
void initFlash(void)
{
8000dad4:	27bdffe8 	addiu	sp,sp,-24
8000dad8:	afbf0014 	sw	ra,20(sp)
#if defined(CONFIG_SPI_FLASH)
   	spi_probe();                                  
#endif  

#if defined CONFIG_NAND_FLASH_BOOTING ||defined(CONFIG_NAND_FLASH)
		rtk_nand_probe ();
8000dadc:	0c0019cd 	jal	80006734 <rtk_nand_probe>
8000dae0:	00000000 	nop

#ifdef CONFIG_RTK_NAND_BBT	
		//dprintf("[%s:] %d NAND_ADDR_CYCLE = %d\n",__func__,__LINE__,NAND_ADDR_CYCLE);
		rtk_scan_v2r_bbt();
8000dae4:	0c0017c5 	jal	80005f14 <rtk_scan_v2r_bbt>
8000dae8:	00000000 	nop
		rtk_nand_scan_bbt();
8000daec:	0c0015e8 	jal	800057a0 <rtk_nand_scan_bbt>
8000daf0:	00000000 	nop
#endif

#endif
}
8000daf4:	8fbf0014 	lw	ra,20(sp)
8000daf8:	03e00008 	jr	ra
8000dafc:	27bd0018 	addiu	sp,sp,24

8000db00 <initHeap>:
//	printf("\n=>init console ok\n");
}
//-------------------------------------------------------
//init heap	
void initHeap(void)
{
8000db00:	27bdffe8 	addiu	sp,sp,-24
8000db04:	afbf0014 	sw	ra,20(sp)
#if defined(RTL8198)
	/* Initialize malloc mechanism */
	UINT32 heap_addr=((UINT32)dl_heap&(~7))+8 ;
8000db08:	2403fff8 	li	v1,-8
8000db0c:	3c028002 	lui	v0,0x8002
8000db10:	24425fa8 	addiu	v0,v0,24488
8000db14:	00431024 	and	v0,v0,v1
8000db18:	24420008 	addiu	v0,v0,8
	UINT32 heap_end=heap_addr+sizeof(dl_heap)-8;
  	i_alloc((void *)heap_addr, heap_end);
8000db1c:	00402021 	move	a0,v0
8000db20:	3c050003 	lui	a1,0x3
8000db24:	34a5fff8 	ori	a1,a1,0xfff8
8000db28:	0c001f4c 	jal	80007d30 <i_alloc>
8000db2c:	00452821 	addu	a1,v0,a1
8000db30:	40016000 	mfc0	at,c0_status
8000db34:	34210001 	ori	at,at,0x1
8000db38:	38210001 	xori	at,at,0x1
8000db3c:	40816000 	mtc0	at,c0_status
8000db40:	000000c0 	ehb
	...
#endif
	cli();  	
	flush_cache(); // david
8000db50:	0c001eae 	jal	80007ab8 <flush_cache>
8000db54:	00000000 	nop
}
8000db58:	8fbf0014 	lw	ra,20(sp)
8000db5c:	03e00008 	jr	ra
8000db60:	27bd0018 	addiu	sp,sp,24

8000db64 <CmdEthStartup>:
	//dprintf("\nUART1 output test ok\n");
}
//-------------------------------------------------------

void CmdEthStartup(int argc, char* argv[])
{
8000db64:	27bdffe8 	addiu	sp,sp,-24
8000db68:	afbf0014 	sw	ra,20(sp)
	eth_startup(0);	
8000db6c:	0c0008ab 	jal	800022ac <eth_startup>
8000db70:	00002021 	move	a0,zero

	dprintf("\n---Ethernet init Okay!\n");
8000db74:	3c048001 	lui	a0,0x8001
8000db78:	0c002325 	jal	80008c94 <dprintf>
8000db7c:	248466e8 	addiu	a0,a0,26344


extern __inline__ void
__sti(void)
{
	__asm__ __volatile__(
8000db80:	40016000 	mfc0	at,c0_status
8000db84:	34210001 	ori	at,at,0x1
8000db88:	40816000 	mtc0	at,c0_status
8000db8c:	000000c0 	ehb
	sti();

#ifdef SUPPORT_TFTP_CLIENT	
	tftpd_entry(0);		
#else
	tftpd_entry();		
8000db90:	0c000376 	jal	80000dd8 <tftpd_entry>
8000db94:	00000000 	nop
#endif
	return ;		
}
8000db98:	8fbf0014 	lw	ra,20(sp)
8000db9c:	03e00008 	jr	ra
8000dba0:	27bd0018 	addiu	sp,sp,24

8000dba4 <goToDownMode>:

void goToDownMode()
{
8000dba4:	27bdffe8 	addiu	sp,sp,-24
8000dba8:	afbf0014 	sw	ra,20(sp)
#ifndef CONFIG_SW_NONE

	if(pollingDownModeKeyword('m')==0)
8000dbac:	0c00366c 	jal	8000d9b0 <pollingDownModeKeyword>
8000dbb0:	2404006d 	li	a0,109
8000dbb4:	1440000c 	bnez	v0,8000dbe8 <goToDownMode+0x44>
8000dbb8:	00000000 	nop
	{
		eth_startup(0);	
8000dbbc:	0c0008ab 	jal	800022ac <eth_startup>
8000dbc0:	00002021 	move	a0,zero

		dprintf("\n---Ethernet init Okay!\n");
8000dbc4:	3c048001 	lui	a0,0x8001
8000dbc8:	0c002325 	jal	80008c94 <dprintf>
8000dbcc:	248466e8 	addiu	a0,a0,26344
8000dbd0:	40016000 	mfc0	at,c0_status
8000dbd4:	34210001 	ori	at,at,0x1
8000dbd8:	40816000 	mtc0	at,c0_status
8000dbdc:	000000c0 	ehb
		sti();

#ifdef SUPPORT_TFTP_CLIENT	
		tftpd_entry(0);
#else
		tftpd_entry();		
8000dbe0:	0c000376 	jal	80000dd8 <tftpd_entry>
8000dbe4:	00000000 	nop
		httpd_entry();
#endif

	}
#endif
	monitor();
8000dbe8:	0c003c03 	jal	8000f00c <monitor>
8000dbec:	00000000 	nop
	return ;
}
8000dbf0:	8fbf0014 	lw	ra,20(sp)
8000dbf4:	03e00008 	jr	ra
8000dbf8:	27bd0018 	addiu	sp,sp,24

8000dbfc <user_interrupt>:
#endif
//------------------------------------------------------------------------------------------

//return 0: do nothing; 1: jump to down load mode; 3 jump to debug down load mode
int user_interrupt(unsigned long time)
{
8000dbfc:	27bdffe8 	addiu	sp,sp,-24
8000dc00:	afbf0014 	sw	ra,20(sp)
	
#ifdef CONFIG_BOOT_RESET_ENABLE
	int button_press_detected=-1;
#endif
	
	tickStart=get_timer_jiffies();
8000dc04:	0c0038f0 	jal	8000e3c0 <get_timer_jiffies>
8000dc08:	00000000 	nop
#ifdef  SUPPORT_TFTP_CLIENT
	do 
#endif
    {
		ret=pollingDownModeKeyword(ESC);
8000dc0c:	0c00366c 	jal	8000d9b0 <pollingDownModeKeyword>
8000dc10:	2404001b 	li	a0,27
		if(ret == 1) return 1;
8000dc14:	24030001 	li	v1,1
8000dc18:	10430006 	beq	v0,v1,8000dc34 <user_interrupt+0x38>
8000dc1c:	8fbf0014 	lw	ra,20(sp)
#ifdef CONFIG_BOOT_RESET_ENABLE		
		ret=pollingPressedButton(button_press_detected);
8000dc20:	0c00367f 	jal	8000d9fc <pollingPressedButton>
8000dc24:	2404ffff 	li	a0,-1
8000dc28:	28430000 	slti	v1,v0,0
8000dc2c:	0003100b 	movn	v0,zero,v1
		gCHKKEY_HIT=1;    
		return 1;
	}
#endif	
	return 0;
}
8000dc30:	8fbf0014 	lw	ra,20(sp)
8000dc34:	03e00008 	jr	ra
8000dc38:	27bd0018 	addiu	sp,sp,24

8000dc3c <goToLocalStartMode>:
#endif		
//-------------------------------------------------------

#if !defined(CONFIG_NONE_FLASH)
void goToLocalStartMode(unsigned long addr,IMG_HEADER_Tp pheader)
{
8000dc3c:	27bdffe0 	addiu	sp,sp,-32
8000dc40:	afbf001c 	sw	ra,28(sp)
8000dc44:	afb10018 	sw	s1,24(sp)
8000dc48:	afb00014 	sw	s0,20(sp)
8000dc4c:	00a08021 	move	s0,a1
	// move image to SDRAM
#if !defined(CONFIG_NONE_FLASH)	
	flashread( pheader->startAddr|0x20000000,	(unsigned int)(addr-FLASH_BASE+sizeof(IMG_HEADER_T)), 	pheader->len-2);
#endif		
#endif
	if ( !user_interrupt(0) )  // See if user escape during copy image
8000dc50:	0c0036ff 	jal	8000dbfc <user_interrupt>
8000dc54:	00002021 	move	a0,zero
8000dc58:	14400028 	bnez	v0,8000dcfc <goToLocalStartMode+0xc0>
8000dc5c:	8fbf001c 	lw	ra,28(sp)
8000dc60:	3c03b800 	lui	v1,0xb800
8000dc64:	ac623000 	sw	v0,12288(v1)
	{
		outl(0,GIMR0); // mask all interrupt
#if defined(CONFIG_BOOT_RESET_ENABLE)
		Set_GPIO_LED_OFF();
8000dc68:	3c11b800 	lui	s1,0xb800
8000dc6c:	36223528 	ori	v0,s1,0x3528
8000dc70:	8c440000 	lw	a0,0(v0)
8000dc74:	3c030100 	lui	v1,0x100
8000dc78:	00831825 	or	v1,a0,v1
8000dc7c:	ac430000 	sw	v1,0(v0)
#endif

		prom_printf("Jump to image start=0x%x...\n", pheader->startAddr);
8000dc80:	3c048001 	lui	a0,0x8001
8000dc84:	24846704 	addiu	a0,a0,26372
8000dc88:	0c0023a7 	jal	80008e9c <prom_printf>
8000dc8c:	8e050004 	lw	a1,4(s0)
		set_bankinfo_register();
#endif
#ifdef CONFIG_RTK_BOOTINFO_SUPPORT
		rtk_inc_bootcnt();
#endif
		jump = (void *)(pheader->startAddr);
8000dc90:	8e100004 	lw	s0,4(s0)

		 REG32(0xb8003114)=0;
8000dc94:	36223114 	ori	v0,s1,0x3114
8000dc98:	ac400000 	sw	zero,0(v0)
  		REG32(0xb8000010)&=~(1<<11);
8000dc9c:	36310010 	ori	s1,s1,0x10
8000dca0:	8e230000 	lw	v1,0(s1)
8000dca4:	2402f7ff 	li	v0,-2049
8000dca8:	00621024 	and	v0,v1,v0
8000dcac:	ae220000 	sw	v0,0(s1)
  		REG32(0xbbdc0300)=0xffffffff;
8000dcb0:	3c03bbdc 	lui	v1,0xbbdc
8000dcb4:	34640300 	ori	a0,v1,0x300
8000dcb8:	2402ffff 	li	v0,-1
8000dcbc:	ac820000 	sw	v0,0(a0)
  		REG32(0xbbdc0304)=0xffffffff;
8000dcc0:	34630304 	ori	v1,v1,0x304
8000dcc4:	ac620000 	sw	v0,0(v1)
 * no nops at all.
 */
extern __inline__ void
__cli(void)
{
	__asm__ __volatile__(
8000dcc8:	40016000 	mfc0	at,c0_status
8000dccc:	34210001 	ori	at,at,0x1
8000dcd0:	38210001 	xori	at,at,0x1
8000dcd4:	40816000 	mtc0	at,c0_status
8000dcd8:	000000c0 	ehb
	...
		cli();
		flush_cache(); 
8000dce8:	0c001eae 	jal	80007ab8 <flush_cache>
8000dcec:	00000000 	nop
		jump();				 // jump to start
8000dcf0:	0200f809 	jalr	s0
8000dcf4:	00000000 	nop
		return ;
	}
	return;
}
8000dcf8:	8fbf001c 	lw	ra,28(sp)
8000dcfc:	8fb10018 	lw	s1,24(sp)
8000dd00:	8fb00014 	lw	s0,20(sp)
8000dd04:	03e00008 	jr	ra
8000dd08:	27bd0020 	addiu	sp,sp,32

8000dd0c <doBooting>:
#define RTL_8198CS 0x80
#define RTL_8954ES 0x83


void doBooting(int flag, unsigned long addr, IMG_HEADER_Tp pheader)
{
8000dd0c:	27bdffe0 	addiu	sp,sp,-32
8000dd10:	afbf001c 	sw	ra,28(sp)
8000dd14:	afb20018 	sw	s2,24(sp)
8000dd18:	afb10014 	sw	s1,20(sp)
8000dd1c:	afb00010 	sw	s0,16(sp)
8000dd20:	00a08021 	move	s0,a1
8000dd24:	00c08821 	move	s1,a2
	unsigned int id = REG32(0xb800000c) & 0xff;
8000dd28:	3c02b800 	lui	v0,0xb800
8000dd2c:	3442000c 	ori	v0,v0,0xc
8000dd30:	8c520000 	lw	s2,0(v0)
#ifdef SUPPORT_TFTP_CLIENT	
	extern int check_tftp_client_state();

	if(flag || check_tftp_client_state() >= 0)
#else
	if(flag)
8000dd34:	10800031 	beqz	a0,8000ddfc <doBooting+0xf0>
8000dd38:	3c043b02 	lui	a0,0x3b02
#endif
	{
		switch(user_interrupt(WAIT_TIME_USER_INTERRUPT))
8000dd3c:	0c0036ff 	jal	8000dbfc <user_interrupt>
8000dd40:	34843380 	ori	a0,a0,0x3380
8000dd44:	24030001 	li	v1,1
8000dd48:	1043001f 	beq	v0,v1,8000ddc8 <doBooting+0xbc>
8000dd4c:	325200ff 	andi	s2,s2,0xff
		{
		case LOCALSTART_MODE:
		default:
			if ((id==RTL_8198C)||(id==RTL_8198CS||(id==RTL_8954E)||(id==RTL_8954ES)))
8000dd50:	12400007 	beqz	s2,8000dd70 <doBooting+0x64>
8000dd54:	24020080 	li	v0,128
8000dd58:	12420005 	beq	s2,v0,8000dd70 <doBooting+0x64>
8000dd5c:	24020003 	li	v0,3
8000dd60:	12420003 	beq	s2,v0,8000dd70 <doBooting+0x64>
8000dd64:	24020083 	li	v0,131
8000dd68:	16420006 	bne	s2,v0,8000dd84 <doBooting+0x78>
8000dd6c:	24020002 	li	v0,2
			{
				SettingCPUClk(0xb,0);      //chg f1000MHz
8000dd70:	2404000b 	li	a0,11
8000dd74:	0c002eb8 	jal	8000bae0 <SettingCPUClk>
8000dd78:	00002821 	move	a1,zero
	{
		switch(user_interrupt(WAIT_TIME_USER_INTERRUPT))
		{
		case LOCALSTART_MODE:
		default:
			if ((id==RTL_8198C)||(id==RTL_8198CS||(id==RTL_8954E)||(id==RTL_8954ES)))
8000dd7c:	0800376b 	j	8000ddac <doBooting+0xa0>
8000dd80:	00002021 	move	a0,zero
			{
				SettingCPUClk(0xb,0);      //chg f1000MHz
			}
			else if (id==RTL_8198CD)
8000dd84:	16420005 	bne	s2,v0,8000dd9c <doBooting+0x90>
8000dd88:	24040003 	li	a0,3
			{
				SettingCPUClk(3,0);      //chg f600MHz	
8000dd8c:	0c002eb8 	jal	8000bae0 <SettingCPUClk>
8000dd90:	00002821 	move	a1,zero
			}
			else
			{
				SettingCPUClk(0x7,0);      //chg f800MHz			
			}
			CmdCore1Wakeup(0,NULL);		
8000dd94:	0800376b 	j	8000ddac <doBooting+0xa0>
8000dd98:	00002021 	move	a0,zero
			{
				SettingCPUClk(3,0);      //chg f600MHz	
			}
			else
			{
				SettingCPUClk(0x7,0);      //chg f800MHz			
8000dd9c:	24040007 	li	a0,7
8000dda0:	0c002eb8 	jal	8000bae0 <SettingCPUClk>
8000dda4:	00002821 	move	a1,zero
			}
			CmdCore1Wakeup(0,NULL);		
8000dda8:	00002021 	move	a0,zero
8000ddac:	0c002758 	jal	80009d60 <CmdCore1Wakeup>
8000ddb0:	00002821 	move	a1,zero
			if (!flag) {
				REG32(GIMR_REG)=0x0;   //add by jiawenjian
				goToDownMode(); 	
			}	
#endif			
			goToLocalStartMode(addr,pheader);
8000ddb4:	02002021 	move	a0,s0
8000ddb8:	0c00370f 	jal	8000dc3c <goToLocalStartMode>
8000ddbc:	02202821 	move	a1,s1
			break;
8000ddc0:	0800378a 	j	8000de28 <doBooting+0x11c>
8000ddc4:	8fbf001c 	lw	ra,28(sp)
			
		case DOWN_MODE:
		 	CmdCore1Wakeup(0,NULL);	
8000ddc8:	00002021 	move	a0,zero
8000ddcc:	0c002758 	jal	80009d60 <CmdCore1Wakeup>
8000ddd0:	00002821 	move	a1,zero
			dprintf("\n---Escape booting by user\n");	
8000ddd4:	3c048001 	lui	a0,0x8001
8000ddd8:	0c002325 	jal	80008c94 <dprintf>
8000dddc:	24846724 	addiu	a0,a0,26404
			//REG32(GIMR_REG)=0x0;   //add by jiawenjian
			 #if CONFIG_ESD_SUPPORT//patch for ESD
                         REG32(0xb800311c)=0xa5000000 ;
        		 #endif
			#ifdef CONFIG_NAND_FLASH
			REG32(0xb8019004) = 0;
8000dde0:	3c02b801 	lui	v0,0xb801
8000dde4:	34429004 	ori	v0,v0,0x9004
8000dde8:	ac400000 	sw	zero,0(v0)
			#endif
			goToDownMode();	
8000ddec:	0c0036e9 	jal	8000dba4 <goToDownMode>
8000ddf0:	00000000 	nop
		REG32(0xb8019004) = 0;
		#endif
		goToDownMode();		
	}
	return;
}
8000ddf4:	0800378a 	j	8000de28 <doBooting+0x11c>
8000ddf8:	8fbf001c 	lw	ra,28(sp)
		}/*switch case */
	}/*if image correct*/
	else
#endif //CONFIG_NFBI
	{
		CmdCore1Wakeup(0,NULL);		
8000ddfc:	00002021 	move	a0,zero
8000de00:	0c002758 	jal	80009d60 <CmdCore1Wakeup>
8000de04:	00002821 	move	a1,zero
		flush_cache();
8000de08:	0c001eae 	jal	80007ab8 <flush_cache>
8000de0c:	00000000 	nop
		 #if CONFIG_ESD_SUPPORT//patch for ESD
                       REG32(0xb800311c)=0xa5000000 ;
                 #endif	
		//REG32(GIMR_REG)=0x0;   //add by jiawenjian
		#ifdef CONFIG_NAND_FLASH
		REG32(0xb8019004) = 0;
8000de10:	3c02b801 	lui	v0,0xb801
8000de14:	34429004 	ori	v0,v0,0x9004
8000de18:	ac400000 	sw	zero,0(v0)
		#endif
		goToDownMode();		
8000de1c:	0c0036e9 	jal	8000dba4 <goToDownMode>
8000de20:	00000000 	nop
	}
	return;
}
8000de24:	8fbf001c 	lw	ra,28(sp)
8000de28:	8fb20018 	lw	s2,24(sp)
8000de2c:	8fb10014 	lw	s1,20(sp)
8000de30:	8fb00010 	lw	s0,16(sp)
8000de34:	03e00008 	jr	ra
8000de38:	27bd0020 	addiu	sp,sp,32

8000de3c <check_rootfs_image>:
	return (ret);
}
//------------------------------------------------------------------------------------------

int check_rootfs_image(unsigned long addr)
{
8000de3c:	27bdffb8 	addiu	sp,sp,-72
8000de40:	afbf0044 	sw	ra,68(sp)
8000de44:	afbe0040 	sw	s8,64(sp)
8000de48:	afb7003c 	sw	s7,60(sp)
8000de4c:	afb60038 	sw	s6,56(sp)
8000de50:	afb50034 	sw	s5,52(sp)
8000de54:	afb40030 	sw	s4,48(sp)
8000de58:	afb3002c 	sw	s3,44(sp)
8000de5c:	afb20028 	sw	s2,40(sp)
8000de60:	afb10024 	sw	s1,36(sp)
8000de64:	afb00020 	sw	s0,32(sp)
	unsigned char __attribute__ ((aligned(64))) oob_buf[64];
	unsigned char *data_buf = (unsigned char *)(DRAM_DIMAGE_ADDR);
	int jump_to_backup=0;
#endif
	
	if(gCHKKEY_HIT==1)
8000de68:	3c028002 	lui	v0,0x8002
8000de6c:	8c433e50 	lw	v1,15952(v0)
8000de70:	24020001 	li	v0,1
8000de74:	10620042 	beq	v1,v0,8000df80 <check_rootfs_image+0x144>
8000de78:	0080f021 	move	s8,a0
		return 0;
	
	word_ptr = (unsigned short *)tmpbuf;
8000de7c:	27a20010 	addiu	v0,sp,16
8000de80:	3c14b800 	lui	s4,0xb800
8000de84:	0094a021 	addu	s4,a0,s4

	return (ret);
}
//------------------------------------------------------------------------------------------

int check_rootfs_image(unsigned long addr)
8000de88:	27a50020 	addiu	a1,sp,32
8000de8c:	02801821 	move	v1,s4
	if(gCHKKEY_HIT==1)
		return 0;
	
	word_ptr = (unsigned short *)tmpbuf;
	for (i=0; i<16; i+=2, word_ptr++)
		*word_ptr = rtl_inw(addr + i);
8000de90:	94640000 	lhu	a0,0(v1)
8000de94:	a4440000 	sh	a0,0(v0)
	
	if(gCHKKEY_HIT==1)
		return 0;
	
	word_ptr = (unsigned short *)tmpbuf;
	for (i=0; i<16; i+=2, word_ptr++)
8000de98:	24420002 	addiu	v0,v0,2
8000de9c:	1445fffc 	bne	v0,a1,8000de90 <check_rootfs_image+0x54>
8000dea0:	24630002 	addiu	v1,v1,2
		*word_ptr = rtl_inw(addr + i);

	if ( memcmp(tmpbuf, SQSH_SIGNATURE, SIG_LEN) && memcmp(tmpbuf, SQSH_SIGNATURE_LE, SIG_LEN)) {
8000dea4:	27a40010 	addiu	a0,sp,16
8000dea8:	3c058001 	lui	a1,0x8001
8000deac:	24a54178 	addiu	a1,a1,16760
8000deb0:	0c002051 	jal	80008144 <memcmp>
8000deb4:	24060004 	li	a2,4
8000deb8:	1040000e 	beqz	v0,8000def4 <check_rootfs_image+0xb8>
8000debc:	8fb50018 	lw	s5,24(sp)
8000dec0:	27a40010 	addiu	a0,sp,16
8000dec4:	3c058001 	lui	a1,0x8001
8000dec8:	24a56740 	addiu	a1,a1,26432
8000decc:	0c002051 	jal	80008144 <memcmp>
8000ded0:	24060004 	li	a2,4
8000ded4:	10400007 	beqz	v0,8000def4 <check_rootfs_image+0xb8>
8000ded8:	8fb50018 	lw	s5,24(sp)
		prom_printf("no rootfs signature at %X!\n",addr-FLASH_BASE);
8000dedc:	3c048001 	lui	a0,0x8001
8000dee0:	24846748 	addiu	a0,a0,26440
8000dee4:	0c0023a7 	jal	80008e9c <prom_printf>
8000dee8:	03c02821 	move	a1,s8
		return 0;
8000deec:	080037e3 	j	8000df8c <check_rootfs_image+0x150>
8000def0:	00001021 	move	v0,zero
	}

#if CHECK_BURN_SERIAL
	board_rootfs_length =
#endif
	length = *(((unsigned long *)tmpbuf) + OFFSET_OF_LEN) + SIZE_OF_SQFS_SUPER_BLOCK + SIZE_OF_CHECKSUM;
8000def4:	26b50282 	addiu	s5,s5,642
}

SKIP_CHECK_BURN_SERIAL:
#endif

	for (i=0; i<length; i+=2) {
8000def8:	12a00023 	beqz	s5,8000df88 <check_rootfs_image+0x14c>
8000defc:	00009821 	move	s3,zero
8000df00:	00009021 	move	s2,zero
8000df04:	00008021 	move	s0,zero
#if 1  //slowly
                 #if CONFIG_ESD_SUPPORT//patch for ESD
                  	 REG32(0xb800311c)|= (1<<23);
                  #endif
			gCHKKEY_CNT++;
8000df08:	3c118002 	lui	s1,0x8002
			if( gCHKKEY_CNT>ACCCNT_TOCHKKEY)
8000df0c:	3c160002 	lui	s6,0x2
8000df10:	36d60001 	ori	s6,s6,0x1
			{	gCHKKEY_CNT=0;
				if ( user_interrupt(0)==1 )  //return 1: got ESC Key
8000df14:	24170001 	li	s7,1
	for (i=0; i<length; i+=2) {
#if 1  //slowly
                 #if CONFIG_ESD_SUPPORT//patch for ESD
                  	 REG32(0xb800311c)|= (1<<23);
                  #endif
			gCHKKEY_CNT++;
8000df18:	8e223e54 	lw	v0,15956(s1)
8000df1c:	24420001 	addiu	v0,v0,1
8000df20:	ae223e54 	sw	v0,15956(s1)
			if( gCHKKEY_CNT>ACCCNT_TOCHKKEY)
8000df24:	0056102b 	sltu	v0,v0,s6
8000df28:	14400006 	bnez	v0,8000df44 <check_rootfs_image+0x108>
8000df2c:	00000000 	nop
			{	gCHKKEY_CNT=0;
8000df30:	ae203e54 	sw	zero,15956(s1)
				if ( user_interrupt(0)==1 )  //return 1: got ESC Key
8000df34:	0c0036ff 	jal	8000dbfc <user_interrupt>
8000df38:	00002021 	move	a0,zero
8000df3c:	10570013 	beq	v0,s7,8000df8c <check_rootfs_image+0x150>
8000df40:	00001021 	move	v0,zero
			{	gCHKKEY_HIT=1; 
				return 0;
			}
#endif			
#if defined(NEED_CHKSUM)	
		sum += rtl_inw(addr + i);
8000df44:	02939821 	addu	s3,s4,s3
8000df48:	96620000 	lhu	v0,0(s3)
8000df4c:	02429021 	addu	s2,s2,v0
8000df50:	3252ffff 	andi	s2,s2,0xffff
}

SKIP_CHECK_BURN_SERIAL:
#endif

	for (i=0; i<length; i+=2) {
8000df54:	26100002 	addiu	s0,s0,2
8000df58:	0215102b 	sltu	v0,s0,s5
8000df5c:	1440ffee 	bnez	v0,8000df18 <check_rootfs_image+0xdc>
8000df60:	02009821 	move	s3,s0
		sum += rtl_inw(addr + i);
#endif
	}

#if defined(NEED_CHKSUM)		
	if ( sum ) {
8000df64:	12400008 	beqz	s2,8000df88 <check_rootfs_image+0x14c>
8000df68:	3c048001 	lui	a0,0x8001
		prom_printf("rootfs checksum error at %X!\n",addr-FLASH_BASE);
8000df6c:	24846764 	addiu	a0,a0,26468
8000df70:	0c0023a7 	jal	80008e9c <prom_printf>
8000df74:	03c02821 	move	a1,s8
		return 0;
8000df78:	080037e3 	j	8000df8c <check_rootfs_image+0x150>
8000df7c:	00001021 	move	v0,zero
8000df80:	080037e3 	j	8000df8c <check_rootfs_image+0x150>
8000df84:	00001021 	move	v0,zero
8000df88:	24020001 	li	v0,1
	}	
#endif	
	return 1;
#endif //CONFIG_RTK_VOIP
}
8000df8c:	8fbf0044 	lw	ra,68(sp)
8000df90:	8fbe0040 	lw	s8,64(sp)
8000df94:	8fb7003c 	lw	s7,60(sp)
8000df98:	8fb60038 	lw	s6,56(sp)
8000df9c:	8fb50034 	lw	s5,52(sp)
8000dfa0:	8fb40030 	lw	s4,48(sp)
8000dfa4:	8fb3002c 	lw	s3,44(sp)
8000dfa8:	8fb20028 	lw	s2,40(sp)
8000dfac:	8fb10024 	lw	s1,36(sp)
8000dfb0:	8fb00020 	lw	s0,32(sp)
8000dfb4:	03e00008 	jr	ra
8000dfb8:	27bd0048 	addiu	sp,sp,72

8000dfbc <check_system_image>:
	return ret;
}
#endif
// return,  0: not found, 1: linux found, 2:linux with root found
int check_system_image(unsigned long addr,IMG_HEADER_Tp pHeader,SETTING_HEADER_Tp setting_header)
{
8000dfbc:	27bdffb8 	addiu	sp,sp,-72
8000dfc0:	afbf0044 	sw	ra,68(sp)
8000dfc4:	afbe0040 	sw	s8,64(sp)
8000dfc8:	afb7003c 	sw	s7,60(sp)
8000dfcc:	afb60038 	sw	s6,56(sp)
8000dfd0:	afb50034 	sw	s5,52(sp)
8000dfd4:	afb40030 	sw	s4,48(sp)
8000dfd8:	afb3002c 	sw	s3,44(sp)
8000dfdc:	afb20028 	sw	s2,40(sp)
8000dfe0:	afb10024 	sw	s1,36(sp)
8000dfe4:	afb00020 	sw	s0,32(sp)
8000dfe8:	0080b821 	move	s7,a0
	int i, ret=0;
	unsigned short sum=0, *word_ptr;
	unsigned short length=0;
	unsigned short temp16=0;
	char image_sig_check[1]={0};
	char image_sig[4]={0};
8000dfec:	afa00010 	sw	zero,16(sp)
	char image_sig_root[4]={0};
8000dff0:	afa00014 	sw	zero,20(sp)
	unsigned char __attribute__ ((aligned(64))) oob_buf[64];
	unsigned char *data_buf = (unsigned char *)(DRAM_DIMAGE_ADDR);
	int jump_to_backup=0;
	#endif

	if(gCHKKEY_HIT==1)
8000dff4:	3c028002 	lui	v0,0x8002
8000dff8:	8c433e50 	lw	v1,15952(v0)
8000dffc:	24020001 	li	v0,1
8000e000:	10620095 	beq	v1,v0,8000e258 <check_system_image+0x29c>
8000e004:	00a08821 	move	s1,a1
		    //dprintf("[%s]:%d\n",__func__,__LINE__);
			word_ptr = (unsigned short *)pHeader;
			start_page = ((addr)/page_size)-ppb;			
			start_position = addr;
			#ifdef CONFIG_RTK_NAND_BBT			
						start_block = (addr >> block_shift);//virtual block index
8000e008:	3c028002 	lui	v0,0x8002
8000e00c:	8c563d70 	lw	s6,15728(v0)
8000e010:	02c4b006 	srlv	s6,a0,s6
		}
			#ifdef CONFIG_RTK_NAND_BBT
			//printf("start blockv %x addr %x page_size:%x ppb:%x ptr_data:%x\n\r",start_block,addr,page_size,ppb,ptr_data);
		    //dprintf("[%s]:%d block_shift = %d\n",__func__,__LINE__,block_shift );
			count=0;
			 for(i=start_block;i< start_block+1;i++){ //caculate how many block.
8000e014:	02c08021 	move	s0,s6
8000e018:	26d30001 	addiu	s3,s6,1
8000e01c:	02d3102b 	sltu	v0,s6,s3
8000e020:	1040000f 	beqz	v0,8000e060 <check_system_image+0xa4>
8000e024:	00009021 	move	s2,zero
				addr_bt = (i << block_shift);//real block index, addr.
		       //printf("blockv:%x addrv:%x addr_bt:%x\n\r",i,addr,addr_bt);
			   //while(1); //debug cl for safe sake //read a block here
				if(nand_read_ecc_ob(addr_bt, block_size, ptr_data+(count*block_size), ptr_oob)){
8000e028:	3c148001 	lui	s4,0x8001
8000e02c:	3c158002 	lui	s5,0x8002
8000e030:	3c1ea0a0 	lui	s8,0xa0a0
8000e034:	8e8675c4 	lw	a2,30148(s4)
8000e038:	8ea43d70 	lw	a0,15728(s5)
8000e03c:	00902004 	sllv	a0,s0,a0
8000e040:	00c02821 	move	a1,a2
8000e044:	72461002 	mul	v0,s2,a2
8000e048:	005e3021 	addu	a2,v0,s8
8000e04c:	0c001be3 	jal	80006f8c <nand_read_ecc_ob>
8000e050:	3c07a100 	lui	a3,0xa100
8000e054:	10400007 	beqz	v0,8000e074 <check_system_image+0xb8>
8000e058:	26100001 	addiu	s0,s0,1
8000e05c:	2610ffff 	addiu	s0,s0,-1
8000e060:	00001821 	move	v1,zero
8000e064:	00001021 	move	v0,zero
			
		    //dprintf("[%s]:%d read signature block ok, print header data:...\n",__func__,__LINE__);
			 //printf("FF size:%x  ptr:%x \r\n",sizeof(IMG_HEADER_T),word_ptr);
			for (i=0; i<sizeof(IMG_HEADER_T); i+=2, word_ptr++)
			{
				*word_ptr = ((*(ptr_data+1+i))|*(ptr_data+i)<<8)&0xffff;
8000e068:	3c08a0a0 	lui	t0,0xa0a0
				count++;
			 }
			
		    //dprintf("[%s]:%d read signature block ok, print header data:...\n",__func__,__LINE__);
			 //printf("FF size:%x  ptr:%x \r\n",sizeof(IMG_HEADER_T),word_ptr);
			for (i=0; i<sizeof(IMG_HEADER_T); i+=2, word_ptr++)
8000e06c:	08003822 	j	8000e088 <check_system_image+0xcc>
8000e070:	24070010 	li	a3,16
		}
			#ifdef CONFIG_RTK_NAND_BBT
			//printf("start blockv %x addr %x page_size:%x ppb:%x ptr_data:%x\n\r",start_block,addr,page_size,ppb,ptr_data);
		    //dprintf("[%s]:%d block_shift = %d\n",__func__,__LINE__,block_shift );
			count=0;
			 for(i=start_block;i< start_block+1;i++){ //caculate how many block.
8000e074:	0213102b 	sltu	v0,s0,s3
8000e078:	1440ffee 	bnez	v0,8000e034 <check_system_image+0x78>
8000e07c:	26520001 	addiu	s2,s2,1
				addr_bt = (i << block_shift);//real block index, addr.
		       //printf("blockv:%x addrv:%x addr_bt:%x\n\r",i,addr,addr_bt);
			   //while(1); //debug cl for safe sake //read a block here
				if(nand_read_ecc_ob(addr_bt, block_size, ptr_data+(count*block_size), ptr_oob)){
8000e080:	08003819 	j	8000e064 <check_system_image+0xa8>
8000e084:	00001821 	move	v1,zero
			
		    //dprintf("[%s]:%d read signature block ok, print header data:...\n",__func__,__LINE__);
			 //printf("FF size:%x  ptr:%x \r\n",sizeof(IMG_HEADER_T),word_ptr);
			for (i=0; i<sizeof(IMG_HEADER_T); i+=2, word_ptr++)
			{
				*word_ptr = ((*(ptr_data+1+i))|*(ptr_data+i)<<8)&0xffff;
8000e088:	02222021 	addu	a0,s1,v0
8000e08c:	01031821 	addu	v1,t0,v1
8000e090:	90660000 	lbu	a2,0(v1)
8000e094:	90650001 	lbu	a1,1(v1)
8000e098:	00061a00 	sll	v1,a2,0x8
8000e09c:	00651825 	or	v1,v1,a1
8000e0a0:	a4830000 	sh	v1,0(a0)
				count++;
			 }
			
		    //dprintf("[%s]:%d read signature block ok, print header data:...\n",__func__,__LINE__);
			 //printf("FF size:%x  ptr:%x \r\n",sizeof(IMG_HEADER_T),word_ptr);
			for (i=0; i<sizeof(IMG_HEADER_T); i+=2, word_ptr++)
8000e0a4:	24420002 	addiu	v0,v0,2
8000e0a8:	1447fff7 	bne	v0,a3,8000e088 <check_system_image+0xcc>
8000e0ac:	00401821 	move	v1,v0
	word_ptr = (unsigned short *)pHeader;
	for (i=0; i<sizeof(IMG_HEADER_T); i+=2, word_ptr++)
		*word_ptr = rtl_inw(addr + i);	
#endif

	memcpy(image_sig, FW_SIGNATURE, SIG_LEN);
8000e0b0:	3c028001 	lui	v0,0x8001
8000e0b4:	8c424334 	lw	v0,17204(v0)
8000e0b8:	afa20010 	sw	v0,16(sp)
	memcpy(image_sig_root, FW_SIGNATURE_WITH_ROOT, SIG_LEN);
8000e0bc:	3c028001 	lui	v0,0x8001
8000e0c0:	8c42434c 	lw	v0,17228(v0)
8000e0c4:	afa20014 	sw	v0,20(sp)

	if (!memcmp(pHeader->signature, image_sig, SIG_LEN))
8000e0c8:	02202021 	move	a0,s1
8000e0cc:	27a50010 	addiu	a1,sp,16
8000e0d0:	0c002051 	jal	80008144 <memcmp>
8000e0d4:	24060004 	li	a2,4
		ret=1;
	else if  (!memcmp(pHeader->signature, image_sig_root, SIG_LEN))
		ret=2;
	else{
		prom_printf("no sys signature at %X!\n",addr-FLASH_BASE);
8000e0d8:	24030001 	li	v1,1
#endif

	memcpy(image_sig, FW_SIGNATURE, SIG_LEN);
	memcpy(image_sig_root, FW_SIGNATURE_WITH_ROOT, SIG_LEN);

	if (!memcmp(pHeader->signature, image_sig, SIG_LEN))
8000e0dc:	1040000e 	beqz	v0,8000e118 <check_system_image+0x15c>
8000e0e0:	afa3001c 	sw	v1,28(sp)
		ret=1;
	else if  (!memcmp(pHeader->signature, image_sig_root, SIG_LEN))
8000e0e4:	02202021 	move	a0,s1
8000e0e8:	27a50014 	addiu	a1,sp,20
8000e0ec:	0c002051 	jal	80008144 <memcmp>
8000e0f0:	24060004 	li	a2,4
8000e0f4:	24030002 	li	v1,2
8000e0f8:	10400007 	beqz	v0,8000e118 <check_system_image+0x15c>
8000e0fc:	afa3001c 	sw	v1,28(sp)
		ret=2;
	else{
		prom_printf("no sys signature at %X!\n",addr-FLASH_BASE);
8000e100:	3c048001 	lui	a0,0x8001
8000e104:	24846784 	addiu	a0,a0,26500
8000e108:	0c0023a7 	jal	80008e9c <prom_printf>
8000e10c:	02e02821 	move	a1,s7
8000e110:	08003897 	j	8000e25c <check_system_image+0x2a0>
8000e114:	afa0001c 	sw	zero,28(sp)
	
	if (ret) {

#ifdef CONFIG_NAND_FLASH_BOOTING
		#ifdef CONFIG_RTK_NAND_BBT
		for(i=(start_block+1);i< (pHeader->len/block_size)+start_block+1;i++){ //caculate how many block.
8000e118:	02608021 	move	s0,s3
8000e11c:	3c028001 	lui	v0,0x8001
8000e120:	8c4675c4 	lw	a2,30148(v0)
8000e124:	8e22000c 	lw	v0,12(s1)
8000e128:	0046001b 	divu	zero,v0,a2
8000e12c:	00c001f4 	teq	a2,zero,0x7
8000e130:	00001812 	mflo	v1
8000e134:	24620001 	addiu	v0,v1,1
8000e138:	00561021 	addu	v0,v0,s6
8000e13c:	0262102b 	sltu	v0,s3,v0
8000e140:	1040002c 	beqz	v0,8000e1f4 <check_system_image+0x238>
8000e144:	0260a021 	move	s4,s3
			addr_bt = (i << block_shift);//real block index, addr.
		       //printf("blockv:%x addrv:%x\n\r",i,addr_bt);
				if(nand_read_ecc_ob(addr_bt, block_size, ptr_data+(count*block_size), ptr_oob)){
8000e148:	3c138002 	lui	s3,0x8002
8000e14c:	3c17a0a0 	lui	s7,0xa0a0
		                    break;
				}
				count++;
				//Enhance the user interrupt latency
				if((i%0x10000) == 0){
					gCHKKEY_CNT++;
8000e150:	3c158002 	lui	s5,0x8002
					if( gCHKKEY_CNT>ACCCNT_TOCHKKEY)
8000e154:	3c020002 	lui	v0,0x2
8000e158:	34420001 	ori	v0,v0,0x1
8000e15c:	afa20018 	sw	v0,24(sp)
	
	if (ret) {

#ifdef CONFIG_NAND_FLASH_BOOTING
		#ifdef CONFIG_RTK_NAND_BBT
		for(i=(start_block+1);i< (pHeader->len/block_size)+start_block+1;i++){ //caculate how many block.
8000e160:	3c1e8001 	lui	s8,0x8001
			addr_bt = (i << block_shift);//real block index, addr.
		       //printf("blockv:%x addrv:%x\n\r",i,addr_bt);
				if(nand_read_ecc_ob(addr_bt, block_size, ptr_data+(count*block_size), ptr_oob)){
8000e164:	8e643d70 	lw	a0,15728(s3)
8000e168:	00902004 	sllv	a0,s0,a0
8000e16c:	00c02821 	move	a1,a2
8000e170:	70d21002 	mul	v0,a2,s2
8000e174:	00573021 	addu	a2,v0,s7
8000e178:	0c001be3 	jal	80006f8c <nand_read_ecc_ob>
8000e17c:	3c07a100 	lui	a3,0xa100
8000e180:	1440001c 	bnez	v0,8000e1f4 <check_system_image+0x238>
8000e184:	3294ffff 	andi	s4,s4,0xffff
							//while(1); //debug cl for safe sake
		                    break;
				}
				count++;
				//Enhance the user interrupt latency
				if((i%0x10000) == 0){
8000e188:	1680000d 	bnez	s4,8000e1c0 <check_system_image+0x204>
8000e18c:	8ea23e54 	lw	v0,15956(s5)
					gCHKKEY_CNT++;
8000e190:	24420001 	addiu	v0,v0,1
8000e194:	aea23e54 	sw	v0,15956(s5)
					if( gCHKKEY_CNT>ACCCNT_TOCHKKEY)
8000e198:	8fa30018 	lw	v1,24(sp)
8000e19c:	0043102b 	sltu	v0,v0,v1
8000e1a0:	14400007 	bnez	v0,8000e1c0 <check_system_image+0x204>
8000e1a4:	00000000 	nop
					{	gCHKKEY_CNT=0;
8000e1a8:	aea03e54 	sw	zero,15956(s5)
						if ( user_interrupt(0)==1 )  //return 1: got ESC Key
8000e1ac:	0c0036ff 	jal	8000dbfc <user_interrupt>
8000e1b0:	00002021 	move	a0,zero
8000e1b4:	24030001 	li	v1,1
8000e1b8:	10430027 	beq	v0,v1,8000e258 <check_system_image+0x29c>
8000e1bc:	00000000 	nop
	
	if (ret) {

#ifdef CONFIG_NAND_FLASH_BOOTING
		#ifdef CONFIG_RTK_NAND_BBT
		for(i=(start_block+1);i< (pHeader->len/block_size)+start_block+1;i++){ //caculate how many block.
8000e1c0:	26100001 	addiu	s0,s0,1
8000e1c4:	8fc675c4 	lw	a2,30148(s8)
8000e1c8:	8e22000c 	lw	v0,12(s1)
8000e1cc:	0046001b 	divu	zero,v0,a2
8000e1d0:	00c001f4 	teq	a2,zero,0x7
8000e1d4:	00001812 	mflo	v1
8000e1d8:	24620001 	addiu	v0,v1,1
8000e1dc:	00561021 	addu	v0,v0,s6
8000e1e0:	0202102b 	sltu	v0,s0,v0
8000e1e4:	10400003 	beqz	v0,8000e1f4 <check_system_image+0x238>
8000e1e8:	0200a021 	move	s4,s0
				if(nand_read_ecc_ob(addr_bt, block_size, ptr_data+(count*block_size), ptr_oob)){
		                    //printf("%s: nand_read_ecc addrv :%x error\n",__FUNCTION__, addr_bt);
							//while(1); //debug cl for safe sake
		                    break;
				}
				count++;
8000e1ec:	08003859 	j	8000e164 <check_system_image+0x1a8>
8000e1f0:	26520001 	addiu	s2,s2,1
						}
					}
				}
		}
		
		for (i=0; i<pHeader->len; i+=2){
8000e1f4:	8e26000c 	lw	a2,12(s1)
8000e1f8:	10c00011 	beqz	a2,8000e240 <check_system_image+0x284>
8000e1fc:	00001821 	move	v1,zero
8000e200:	00002021 	move	a0,zero
8000e204:	00001021 	move	v0,zero
                 #if CONFIG_ESD_SUPPORT//patch for ESD
                  	 REG32(0xb800311c)|= (1<<23);
                  #endif
			
			#if defined(NEED_CHKSUM)	
			sum +=(unsigned short)(((*(ptr_data+1+i+ sizeof(IMG_HEADER_T)))|(*(ptr_data+i+ sizeof(IMG_HEADER_T)))<<8)&0xffff);
8000e208:	3c08a0a0 	lui	t0,0xa0a0
8000e20c:	01031821 	addu	v1,t0,v1
8000e210:	90670010 	lbu	a3,16(v1)
8000e214:	90650011 	lbu	a1,17(v1)
8000e218:	00071a00 	sll	v1,a3,0x8
8000e21c:	00651825 	or	v1,v1,a1
8000e220:	00832021 	addu	a0,a0,v1
8000e224:	3084ffff 	andi	a0,a0,0xffff
						}
					}
				}
		}
		
		for (i=0; i<pHeader->len; i+=2){
8000e228:	24420002 	addiu	v0,v0,2
8000e22c:	0046282b 	sltu	a1,v0,a2
8000e230:	14a0fff6 	bnez	a1,8000e20c <check_system_image+0x250>
8000e234:	00401821 	move	v1,v0
#endif
		}	
#endif

#if defined(NEED_CHKSUM)			
		if ( sum ) {
8000e238:	14800007 	bnez	a0,8000e258 <check_system_image+0x29c>
8000e23c:	00000000 	nop
		{
		    //dprintf("[%s]:%d\n",__func__,__LINE__);
			unsigned char* target_add;
			target_add=pHeader->startAddr;
			//target_add= ((pHeader->startAddr)|0x20000000);
			memcpy(target_add,ptr_data+sizeof(IMG_HEADER_T),pHeader->len);		
8000e240:	8e240004 	lw	a0,4(s1)
8000e244:	3c05a0a0 	lui	a1,0xa0a0
8000e248:	0c002046 	jal	80008118 <memcpy>
8000e24c:	34a50010 	ori	a1,a1,0x10
#endif		
	}
	//prom_printf("ret=%d  sys signature at %X!\n",ret,addr-FLASH_BASE);

	return (ret);
}
8000e250:	08003898 	j	8000e260 <check_system_image+0x2a4>
8000e254:	8fa2001c 	lw	v0,28(sp)
		{
		    //dprintf("[%s]:%d\n",__func__,__LINE__);
			unsigned char* target_add;
			target_add=pHeader->startAddr;
			//target_add= ((pHeader->startAddr)|0x20000000);
			memcpy(target_add,ptr_data+sizeof(IMG_HEADER_T),pHeader->len);		
8000e258:	afa0001c 	sw	zero,28(sp)
#endif		
	}
	//prom_printf("ret=%d  sys signature at %X!\n",ret,addr-FLASH_BASE);

	return (ret);
}
8000e25c:	8fa2001c 	lw	v0,28(sp)
8000e260:	8fbf0044 	lw	ra,68(sp)
8000e264:	8fbe0040 	lw	s8,64(sp)
8000e268:	8fb7003c 	lw	s7,60(sp)
8000e26c:	8fb60038 	lw	s6,56(sp)
8000e270:	8fb50034 	lw	s5,52(sp)
8000e274:	8fb40030 	lw	s4,48(sp)
8000e278:	8fb3002c 	lw	s3,44(sp)
8000e27c:	8fb20028 	lw	s2,40(sp)
8000e280:	8fb10024 	lw	s1,36(sp)
8000e284:	8fb00020 	lw	s0,32(sp)
8000e288:	03e00008 	jr	ra
8000e28c:	27bd0048 	addiu	sp,sp,72

8000e290 <check_image>:
#endif

//------------------------------------------------------------------------------------------

int check_image(IMG_HEADER_Tp pHeader,SETTING_HEADER_Tp psetting_header)
{
8000e290:	27bdffc8 	addiu	sp,sp,-56
8000e294:	afbf0034 	sw	ra,52(sp)
8000e298:	afbe0030 	sw	s8,48(sp)
8000e29c:	afb7002c 	sw	s7,44(sp)
8000e2a0:	afb60028 	sw	s6,40(sp)
8000e2a4:	afb50024 	sw	s5,36(sp)
8000e2a8:	afb40020 	sw	s4,32(sp)
8000e2ac:	afb3001c 	sw	s3,28(sp)
8000e2b0:	afb20018 	sw	s2,24(sp)
8000e2b4:	afb10014 	sw	s1,20(sp)
8000e2b8:	afb00010 	sw	s0,16(sp)
8000e2bc:	0080b821 	move	s7,a0
8000e2c0:	00a0f021 	move	s8,a1
8000e2c4:	3c100080 	lui	s0,0x80

#ifdef CONFIG_RTL_FLASH_MAPPING_ENABLE	
	i=CONFIG_LINUX_IMAGE_OFFSET_START;	
	while(i<=CONFIG_LINUX_IMAGE_OFFSET_END && (0==ret))
	{
		return_addr=(unsigned long)FLASH_BASE+i+bank_offset; 
8000e2c8:	3c128002 	lui	s2,0x8002
		if(CODE_IMAGE_OFFSET == i || CODE_IMAGE_OFFSET2 == i || CODE_IMAGE_OFFSET3 == i){
8000e2cc:	3c130001 	lui	s3,0x1
			i += CONFIG_LINUX_IMAGE_OFFSET_STEP; 
			continue;
		}
		ret = check_system_image((unsigned long)FLASH_BASE+i+bank_offset, pHeader, psetting_header);
8000e2d0:	0000a821 	move	s5,zero
#ifdef CONFIG_RTL_FLASH_MAPPING_ENABLE	
	i=CONFIG_LINUX_IMAGE_OFFSET_START;	
	while(i<=CONFIG_LINUX_IMAGE_OFFSET_END && (0==ret))
	{
		return_addr=(unsigned long)FLASH_BASE+i+bank_offset; 
		if(CODE_IMAGE_OFFSET == i || CODE_IMAGE_OFFSET2 == i || CODE_IMAGE_OFFSET3 == i){
8000e2d4:	3c110002 	lui	s1,0x2
8000e2d8:	3c160003 	lui	s6,0x3
	}			
#endif

#ifdef CONFIG_RTL_FLASH_MAPPING_ENABLE	
	i=CONFIG_LINUX_IMAGE_OFFSET_START;	
	while(i<=CONFIG_LINUX_IMAGE_OFFSET_END && (0==ret))
8000e2dc:	3c140090 	lui	s4,0x90
	{
		return_addr=(unsigned long)FLASH_BASE+i+bank_offset; 
		if(CODE_IMAGE_OFFSET == i || CODE_IMAGE_OFFSET2 == i || CODE_IMAGE_OFFSET3 == i){
8000e2e0:	1213000a 	beq	s0,s3,8000e30c <check_image+0x7c>
8000e2e4:	ae502e7c 	sw	s0,11900(s2)
8000e2e8:	12110009 	beq	s0,s1,8000e310 <check_image+0x80>
8000e2ec:	02a01021 	move	v0,s5
8000e2f0:	12160007 	beq	s0,s6,8000e310 <check_image+0x80>
8000e2f4:	02002021 	move	a0,s0
			i += CONFIG_LINUX_IMAGE_OFFSET_STEP; 
			continue;
		}
		ret = check_system_image((unsigned long)FLASH_BASE+i+bank_offset, pHeader, psetting_header);
8000e2f8:	02e02821 	move	a1,s7
8000e2fc:	0c0037ef 	jal	8000dfbc <check_system_image>
8000e300:	03c03021 	move	a2,s8
8000e304:	080038c4 	j	8000e310 <check_image+0x80>
8000e308:	00000000 	nop
8000e30c:	02a01021 	move	v0,s5
	}			
#endif

#ifdef CONFIG_RTL_FLASH_MAPPING_ENABLE	
	i=CONFIG_LINUX_IMAGE_OFFSET_START;	
	while(i<=CONFIG_LINUX_IMAGE_OFFSET_END && (0==ret))
8000e310:	12140004 	beq	s0,s4,8000e324 <check_image+0x94>
8000e314:	24030002 	li	v1,2
8000e318:	1040fff1 	beqz	v0,8000e2e0 <check_image+0x50>
8000e31c:	02118021 	addu	s0,s0,s1
		ret = check_system_image((unsigned long)FLASH_BASE+i+bank_offset, pHeader, psetting_header);
		i += CONFIG_LINUX_IMAGE_OFFSET_STEP; 
	}
#endif

	if(ret==2)
8000e320:	24030002 	li	v1,2
8000e324:	14430006 	bne	v0,v1,8000e340 <check_image+0xb0>
8000e328:	8fbf0034 	lw	ra,52(sp)
                	ret=check_rootfs_image((unsigned long)FLASH_BASE+ROOT_FS_OFFSET+ROOT_FS_OFFSET_OP1+ROOT_FS_OFFSET_OP2+bank_offset);
#endif

#ifdef CONFIG_RTL_FLASH_MAPPING_ENABLE
		i = CONFIG_ROOT_IMAGE_OFFSET_START;
		while((i <= CONFIG_ROOT_IMAGE_OFFSET_END) && (0==ret))
8000e32c:	14400005 	bnez	v0,8000e344 <check_image+0xb4>
8000e330:	8fbe0030 	lw	s8,48(sp)
			    (ROOT_FS_OFFSET + ROOT_FS_OFFSET_OP1) == i ||
		            (ROOT_FS_OFFSET + ROOT_FS_OFFSET_OP1 + ROOT_FS_OFFSET_OP2) == i){
				i += CONFIG_ROOT_IMAGE_OFFSET_STEP;
				continue;
			}
			ret = check_rootfs_image((unsigned long)FLASH_BASE+i+bank_offset);
8000e334:	0c00378f 	jal	8000de3c <check_rootfs_image>
8000e338:	3c0400e0 	lui	a0,0xe0
 	#else
       	ret = check_dualbank_setting(IN_BOOTING_MODE);
	#endif
#endif //end of NFBI else
	return ret;
}
8000e33c:	8fbf0034 	lw	ra,52(sp)
8000e340:	8fbe0030 	lw	s8,48(sp)
8000e344:	8fb7002c 	lw	s7,44(sp)
8000e348:	8fb60028 	lw	s6,40(sp)
8000e34c:	8fb50024 	lw	s5,36(sp)
8000e350:	8fb40020 	lw	s4,32(sp)
8000e354:	8fb3001c 	lw	s3,28(sp)
8000e358:	8fb20018 	lw	s2,24(sp)
8000e35c:	8fb10014 	lw	s1,20(sp)
8000e360:	8fb00010 	lw	s0,16(sp)
8000e364:	03e00008 	jr	ra
8000e368:	27bd0038 	addiu	sp,sp,56
8000e36c:	00000000 	nop

8000e370 <bootimg>:
void bootimg()
{
}
8000e370:	03e00008 	jr	ra
8000e374:	00000000 	nop
	...

8000e380 <__delay>:
//------------------------------------------------------------------------------

__inline__ void
__delay(unsigned long loops)
{
	__asm__ __volatile__ (
8000e380:	1480ffff 	bnez	a0,8000e380 <__delay>
8000e384:	2484ffff 	addiu	a0,a0,-1
		"1:\tbnez\t%0,1b\n\t"
		"subu\t%0,1\n\t"
		".set\treorder"
		:"=r" (loops)
		:"0" (loops));
}
8000e388:	03e00008 	jr	ra
8000e38c:	00000000 	nop

8000e390 <timer_interrupt>:
static void timer_interrupt(int num, void *ptr, struct pt_regs * reg)
{
	//dprintf("jiff=%x\r\n",jiffies);
	//flush_WBcache();
	//rtl_outl(TCIR,rtl_inl(TCIR));
	REG32(TCIR_REG)|=(1<<29);
8000e390:	3c02b800 	lui	v0,0xb800
8000e394:	34423114 	ori	v0,v0,0x3114
8000e398:	8c440000 	lw	a0,0(v0)
8000e39c:	3c032000 	lui	v1,0x2000
8000e3a0:	00831825 	or	v1,a0,v1
8000e3a4:	ac430000 	sw	v1,0(v0)

	//if(jiffies==0x80)
	//REG32(GIMR_REG)&= ~(1<<8);
	
	jiffies++;
8000e3a8:	3c028002 	lui	v0,0x8002
8000e3ac:	8c433e60 	lw	v1,15968(v0)
8000e3b0:	24630001 	addiu	v1,v1,1
8000e3b4:	ac433e60 	sw	v1,15968(v0)


}
8000e3b8:	03e00008 	jr	ra
8000e3bc:	00000000 	nop

8000e3c0 <get_timer_jiffies>:
volatile unsigned int get_timer_jiffies(void)
{

	return jiffies;
8000e3c0:	3c028002 	lui	v0,0x8002
8000e3c4:	8c423e60 	lw	v0,15968(v0)
};
8000e3c8:	03e00008 	jr	ra
8000e3cc:	00000000 	nop

8000e3d0 <timer_init>:

//------------------------------------------------------------------------------
void timer_init(unsigned long lexra_clock)
{
    /* Set timer mode and Enable timer */
    REG32(TCCNR_REG) = (0<<31) | (0<<30);	//using time0
8000e3d0:	3c02b800 	lui	v0,0xb800
8000e3d4:	34433110 	ori	v1,v0,0x3110
8000e3d8:	ac600000 	sw	zero,0(v1)
    //REG32(TCCNR_REG) = (1<<31) | (0<<30);	//using counter0

	#define DIVISOR     0xE
	#define DIVF_OFFSET                         16		
    REG32(CDBR_REG) = (DIVISOR) << DIVF_OFFSET;
8000e3dc:	34453118 	ori	a1,v0,0x3118
8000e3e0:	3c06000e 	lui	a2,0xe
8000e3e4:	aca60000 	sw	a2,0(a1)
	#define TICK_10MS_FREQ  100  /* 100 Hz */
	#define TICK_1MS_FREQ   1000 /* 1K Hz */
	
	#define TICK_FREQ       TICK_10MS_FREQ	
   
      REG32(TC0DATA_REG) = (((SysClkRate / DIVISOR) / TICK_FREQ) + 1) <<4;
8000e3e8:	3c055d9f 	lui	a1,0x5d9f
8000e3ec:	34a57391 	ori	a1,a1,0x7391
8000e3f0:	00850018 	mult	a0,a1
8000e3f4:	00002810 	mfhi	a1
8000e3f8:	00052a43 	sra	a1,a1,0x9
8000e3fc:	000427c3 	sra	a0,a0,0x1f
8000e400:	00a42823 	subu	a1,a1,a0
8000e404:	24a50001 	addiu	a1,a1,1
8000e408:	00052900 	sll	a1,a1,0x4
8000e40c:	34443100 	ori	a0,v0,0x3100
8000e410:	ac850000 	sw	a1,0(a0)

         
    /* Set timer mode and Enable timer */
    REG32(TCCNR_REG) = (1<<31) | (1<<30);	//using time0
8000e414:	3c04c000 	lui	a0,0xc000
8000e418:	ac640000 	sw	a0,0(v1)
    //REG32(GIMR_REG) |= (1<<8);	//request_irq() will set 

    /* Set interrupt routing register */
  // RTL8198
    //REG32(IRR1_REG) = 0x00050004;  //uart:IRQ5,  time0:IRQ4
    REG32(IRR1_REG) = 0x02;  
8000e41c:	3443300c 	ori	v1,v0,0x300c
8000e420:	24040002 	li	a0,2
8000e424:	ac640000 	sw	a0,0(v1)
   
    
    /* Enable timer interrupt */
    REG32(TCIR_REG) = (1<<31);
8000e428:	34423114 	ori	v0,v0,0x3114
8000e42c:	3c038000 	lui	v1,0x8000
8000e430:	ac430000 	sw	v1,0(v0)
}
8000e434:	03e00008 	jr	ra
8000e438:	00000000 	nop

8000e43c <rand2>:
    static unsigned int z = 521288629;
    static unsigned int c = 7654321;

    unsigned long long t, a= 698769069;

    x = 69069 * x + 12345;
8000e43c:	3c048001 	lui	a0,0x8001
8000e440:	8c8279e8 	lw	v0,31208(a0)
8000e444:	00022880 	sll	a1,v0,0x2
8000e448:	00021900 	sll	v1,v0,0x4
8000e44c:	00a31821 	addu	v1,a1,v1
8000e450:	00032900 	sll	a1,v1,0x4
8000e454:	00a31823 	subu	v1,a1,v1
8000e458:	00621023 	subu	v0,v1,v0
8000e45c:	000218c0 	sll	v1,v0,0x3
8000e460:	00621023 	subu	v0,v1,v0
8000e464:	00021940 	sll	v1,v0,0x5
8000e468:	00431021 	addu	v0,v0,v1
8000e46c:	24423039 	addiu	v0,v0,12345
8000e470:	ac8279e8 	sw	v0,31208(a0)
    y ^= (y << 13); y ^= (y >> 17); y ^= (y << 5);
8000e474:	3c038001 	lui	v1,0x8001
8000e478:	8c6479e4 	lw	a0,31204(v1)
8000e47c:	00043340 	sll	a2,a0,0xd
8000e480:	00c43026 	xor	a2,a2,a0
8000e484:	00062442 	srl	a0,a2,0x11
8000e488:	00863026 	xor	a2,a0,a2
8000e48c:	00062140 	sll	a0,a2,0x5
8000e490:	00863026 	xor	a2,a0,a2
8000e494:	ac6679e4 	sw	a2,31204(v1)
    t = a * z + c; c = (t >> 32); z = t;
8000e498:	3c078001 	lui	a3,0x8001
8000e49c:	8ce379e0 	lw	v1,31200(a3)
8000e4a0:	3c0429a6 	lui	a0,0x29a6
8000e4a4:	34845ead 	ori	a0,a0,0x5ead
8000e4a8:	00640019 	multu	v1,a0
8000e4ac:	00002812 	mflo	a1
8000e4b0:	00002010 	mfhi	a0
8000e4b4:	3c088001 	lui	t0,0x8001
8000e4b8:	8d0379dc 	lw	v1,31196(t0)
8000e4bc:	00a31821 	addu	v1,a1,v1
8000e4c0:	0065482b 	sltu	t1,v1,a1
8000e4c4:	01242021 	addu	a0,t1,a0
8000e4c8:	ad0479dc 	sw	a0,31196(t0)
8000e4cc:	ace379e0 	sw	v1,31200(a3)
8000e4d0:	00621021 	addu	v0,v1,v0

    return x + y + z;
}
8000e4d4:	03e00008 	jr	ra
8000e4d8:	00461021 	addu	v0,v0,a2

8000e4dc <CmdWriteByte>:
	
}
#endif
//---------------------------------------------------------------------------
int CmdWriteByte( int argc, char* argv[] )
{
8000e4dc:	27bdffd8 	addiu	sp,sp,-40
8000e4e0:	afbf0024 	sw	ra,36(sp)
8000e4e4:	afb30020 	sw	s3,32(sp)
8000e4e8:	afb2001c 	sw	s2,28(sp)
8000e4ec:	afb10018 	sw	s1,24(sp)
8000e4f0:	afb00014 	sw	s0,20(sp)
8000e4f4:	00809821 	move	s3,a0
8000e4f8:	00a09021 	move	s2,a1
	
	unsigned long src;
	unsigned char value,i;
	
	src = strtoul((const char*)(argv[0]), (char **)NULL, 16);		
8000e4fc:	8ca40000 	lw	a0,0(a1)
8000e500:	00002821 	move	a1,zero
8000e504:	0c0020c4 	jal	80008310 <strtoul>
8000e508:	24060010 	li	a2,16


	for(i=0;i<argc-1;i++,src++)
8000e50c:	2673ffff 	addiu	s3,s3,-1
8000e510:	1a60000f 	blez	s3,8000e550 <CmdWriteByte+0x74>
8000e514:	00408021 	move	s0,v0
{
	
	unsigned long src;
	unsigned char value,i;
	
	src = strtoul((const char*)(argv[0]), (char **)NULL, 16);		
8000e518:	00008821 	move	s1,zero


	for(i=0;i<argc-1;i++,src++)
	{
		value= strtoul((const char*)(argv[i+1]), (char **)NULL, 16);	
8000e51c:	26310001 	addiu	s1,s1,1
8000e520:	00111080 	sll	v0,s1,0x2
8000e524:	02421021 	addu	v0,s2,v0
8000e528:	8c440000 	lw	a0,0(v0)
8000e52c:	00002821 	move	a1,zero
8000e530:	0c0020c4 	jal	80008310 <strtoul>
8000e534:	24060010 	li	a2,16
8000e538:	304200ff 	andi	v0,v0,0xff
		*(volatile unsigned char *)(src) = value;
8000e53c:	a2020000 	sb	v0,0(s0)
	unsigned char value,i;
	
	src = strtoul((const char*)(argv[0]), (char **)NULL, 16);		


	for(i=0;i<argc-1;i++,src++)
8000e540:	323100ff 	andi	s1,s1,0xff
8000e544:	0233102a 	slt	v0,s1,s3
8000e548:	1440fff4 	bnez	v0,8000e51c <CmdWriteByte+0x40>
8000e54c:	26100001 	addiu	s0,s0,1
	{
		value= strtoul((const char*)(argv[i+1]), (char **)NULL, 16);	
		*(volatile unsigned char *)(src) = value;
	}
	
}
8000e550:	8fbf0024 	lw	ra,36(sp)
8000e554:	8fb30020 	lw	s3,32(sp)
8000e558:	8fb2001c 	lw	s2,28(sp)
8000e55c:	8fb10018 	lw	s1,24(sp)
8000e560:	8fb00014 	lw	s0,20(sp)
8000e564:	03e00008 	jr	ra
8000e568:	27bd0028 	addiu	sp,sp,40

8000e56c <CmdWriteHword>:
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------

int CmdWriteHword( int argc, char* argv[] )
{
8000e56c:	27bdffd8 	addiu	sp,sp,-40
8000e570:	afbf0024 	sw	ra,36(sp)
8000e574:	afb30020 	sw	s3,32(sp)
8000e578:	afb2001c 	sw	s2,28(sp)
8000e57c:	afb10018 	sw	s1,24(sp)
8000e580:	afb00014 	sw	s0,20(sp)
8000e584:	00809821 	move	s3,a0
8000e588:	00a09021 	move	s2,a1
	
	unsigned long src;
	unsigned short value,i;
	
	src = strtoul((const char*)(argv[0]), (char **)NULL, 16);		
8000e58c:	8ca40000 	lw	a0,0(a1)
8000e590:	00002821 	move	a1,zero
8000e594:	0c0020c4 	jal	80008310 <strtoul>
8000e598:	24060010 	li	a2,16
	
	src &= 0xfffffffe;	

	for(i=0;i<argc-1;i++,src+=2)
8000e59c:	2673ffff 	addiu	s3,s3,-1
8000e5a0:	1a600010 	blez	s3,8000e5e4 <CmdWriteHword+0x78>
8000e5a4:	2410fffe 	li	s0,-2
	unsigned long src;
	unsigned short value,i;
	
	src = strtoul((const char*)(argv[0]), (char **)NULL, 16);		
	
	src &= 0xfffffffe;	
8000e5a8:	00508024 	and	s0,v0,s0
8000e5ac:	00008821 	move	s1,zero

	for(i=0;i<argc-1;i++,src+=2)
	{
		value= strtoul((const char*)(argv[i+1]), (char **)NULL, 16);	
8000e5b0:	26310001 	addiu	s1,s1,1
8000e5b4:	00111080 	sll	v0,s1,0x2
8000e5b8:	02421021 	addu	v0,s2,v0
8000e5bc:	8c440000 	lw	a0,0(v0)
8000e5c0:	00002821 	move	a1,zero
8000e5c4:	0c0020c4 	jal	80008310 <strtoul>
8000e5c8:	24060010 	li	a2,16
8000e5cc:	3042ffff 	andi	v0,v0,0xffff
		*(volatile unsigned short *)(src) = value;
8000e5d0:	a6020000 	sh	v0,0(s0)
	
	src = strtoul((const char*)(argv[0]), (char **)NULL, 16);		
	
	src &= 0xfffffffe;	

	for(i=0;i<argc-1;i++,src+=2)
8000e5d4:	3231ffff 	andi	s1,s1,0xffff
8000e5d8:	0233102a 	slt	v0,s1,s3
8000e5dc:	1440fff4 	bnez	v0,8000e5b0 <CmdWriteHword+0x44>
8000e5e0:	26100002 	addiu	s0,s0,2
	{
		value= strtoul((const char*)(argv[i+1]), (char **)NULL, 16);	
		*(volatile unsigned short *)(src) = value;
	}
	
}
8000e5e4:	8fbf0024 	lw	ra,36(sp)
8000e5e8:	8fb30020 	lw	s3,32(sp)
8000e5ec:	8fb2001c 	lw	s2,28(sp)
8000e5f0:	8fb10018 	lw	s1,24(sp)
8000e5f4:	8fb00014 	lw	s0,20(sp)
8000e5f8:	03e00008 	jr	ra
8000e5fc:	27bd0028 	addiu	sp,sp,40

8000e600 <CmdWriteWord>:
	ddump((unsigned char *)src,len);
}

//---------------------------------------------------------------------------
int CmdWriteWord( int argc, char* argv[] )
{
8000e600:	27bdffd8 	addiu	sp,sp,-40
8000e604:	afbf0024 	sw	ra,36(sp)
8000e608:	afb30020 	sw	s3,32(sp)
8000e60c:	afb2001c 	sw	s2,28(sp)
8000e610:	afb10018 	sw	s1,24(sp)
8000e614:	afb00014 	sw	s0,20(sp)
8000e618:	00809821 	move	s3,a0
8000e61c:	00a08821 	move	s1,a1
	
	unsigned long src;
	unsigned int value,i;
	
	src = strtoul((const char*)(argv[0]), (char **)NULL, 16);		
8000e620:	8ca40000 	lw	a0,0(a1)
8000e624:	00002821 	move	a1,zero
8000e628:	0c0020c4 	jal	80008310 <strtoul>
8000e62c:	24060010 	li	a2,16
8000e630:	00408021 	move	s0,v0
	while ( (src) & 0x03)
8000e634:	30420003 	andi	v0,v0,0x3
8000e638:	10400006 	beqz	v0,8000e654 <CmdWriteWord+0x54>
8000e63c:	00000000 	nop
		src++;
8000e640:	26100001 	addiu	s0,s0,1
	
	unsigned long src;
	unsigned int value,i;
	
	src = strtoul((const char*)(argv[0]), (char **)NULL, 16);		
	while ( (src) & 0x03)
8000e644:	32020003 	andi	v0,s0,0x3
8000e648:	1440fffe 	bnez	v0,8000e644 <CmdWriteWord+0x44>
8000e64c:	26100001 	addiu	s0,s0,1
8000e650:	2610ffff 	addiu	s0,s0,-1
		src++;

	for(i=0;i<argc-1;i++,src+=4)
8000e654:	2673ffff 	addiu	s3,s3,-1
8000e658:	1260000b 	beqz	s3,8000e688 <CmdWriteWord+0x88>
8000e65c:	00009021 	move	s2,zero
	{
		value= strtoul((const char*)(argv[i+1]), (char **)NULL, 16);	
8000e660:	26520001 	addiu	s2,s2,1
8000e664:	8e240004 	lw	a0,4(s1)
8000e668:	00002821 	move	a1,zero
8000e66c:	0c0020c4 	jal	80008310 <strtoul>
8000e670:	24060010 	li	a2,16
		*(volatile unsigned int *)(src) = value;
8000e674:	ae020000 	sw	v0,0(s0)
	
	src = strtoul((const char*)(argv[0]), (char **)NULL, 16);		
	while ( (src) & 0x03)
		src++;

	for(i=0;i<argc-1;i++,src+=4)
8000e678:	26100004 	addiu	s0,s0,4
8000e67c:	0253102b 	sltu	v0,s2,s3
8000e680:	1440fff7 	bnez	v0,8000e660 <CmdWriteWord+0x60>
8000e684:	26310004 	addiu	s1,s1,4
	{
		value= strtoul((const char*)(argv[i+1]), (char **)NULL, 16);	
		*(volatile unsigned int *)(src) = value;
	}
	
}
8000e688:	8fbf0024 	lw	ra,36(sp)
8000e68c:	8fb30020 	lw	s3,32(sp)
8000e690:	8fb2001c 	lw	s2,28(sp)
8000e694:	8fb10018 	lw	s1,24(sp)
8000e698:	8fb00014 	lw	s0,20(sp)
8000e69c:	03e00008 	jr	ra
8000e6a0:	27bd0028 	addiu	sp,sp,40

8000e6a4 <CmdNANDR>:
               
}


int CmdNANDR(int argc, char* argv[])
{
8000e6a4:	27bdffd8 	addiu	sp,sp,-40
8000e6a8:	afbf0024 	sw	ra,36(sp)
8000e6ac:	afb30020 	sw	s3,32(sp)
8000e6b0:	afb2001c 	sw	s2,28(sp)
8000e6b4:	afb10018 	sw	s1,24(sp)
8000e6b8:	afb00014 	sw	s0,20(sp)

    if(argc < 4 )
8000e6bc:	28840004 	slti	a0,a0,4
8000e6c0:	10800006 	beqz	a0,8000e6dc <CmdNANDR+0x38>
8000e6c4:	00a08021 	move	s0,a1
    {
        prom_printf("Parameters not enough!\n");
8000e6c8:	3c048001 	lui	a0,0x8001
8000e6cc:	0c0023a7 	jal	80008e9c <prom_printf>
8000e6d0:	248467a0 	addiu	a0,a0,26528
            src, *(unsigned long *)(src), *(unsigned long *)(src+4),
            *(unsigned long *)(src+8), *(unsigned long *)(src+12));
    }
#endif

}
8000e6d4:	080039d6 	j	8000e758 <CmdNANDR+0xb4>
8000e6d8:	24020001 	li	v0,1
        return 1;
    }

                 //rtk_nand_read_id();

    unsigned long flash_address= strtoul((const char*)(argv[0]), (char **)NULL, 16);
8000e6dc:	8ca40000 	lw	a0,0(a1)
8000e6e0:	00002821 	move	a1,zero
8000e6e4:	0c0020c4 	jal	80008310 <strtoul>
8000e6e8:	24060010 	li	a2,16
8000e6ec:	00408821 	move	s1,v0
    unsigned char *image_addr = strtoul((const char*)(argv[1]), (char **)NULL, 16);
8000e6f0:	8e040004 	lw	a0,4(s0)
8000e6f4:	00002821 	move	a1,zero
8000e6f8:	0c0020c4 	jal	80008310 <strtoul>
8000e6fc:	24060010 	li	a2,16
8000e700:	00409021 	move	s2,v0
    unsigned int image_size= strtoul((const char*)(argv[2]), (char **)NULL, 16);
8000e704:	8e040008 	lw	a0,8(s0)
8000e708:	00002821 	move	a1,zero
8000e70c:	0c0020c4 	jal	80008310 <strtoul>
8000e710:	24060010 	li	a2,16
8000e714:	00409821 	move	s3,v0
    char ecc_enable=strtoul((const char*)(argv[3]), (char **)NULL, 16);
8000e718:	8e04000c 	lw	a0,12(s0)
8000e71c:	00002821 	move	a1,zero
8000e720:	0c0020c4 	jal	80008310 <strtoul>
8000e724:	24060010 	li	a2,16
8000e728:	00408021 	move	s0,v0

    prom_printf("Read NAND Flash from 0x%X to 0x%X with 0x%X bytes ?\n",flash_address,image_addr,image_size);
8000e72c:	3c048001 	lui	a0,0x8001
8000e730:	248467b8 	addiu	a0,a0,26552
8000e734:	02202821 	move	a1,s1
8000e738:	02403021 	move	a2,s2
8000e73c:	0c0023a7 	jal	80008e9c <prom_printf>
8000e740:	02603821 	move	a3,s3
    else
        prom_printf("Read NAND Flash Failed!\n");
    else
        prom_printf("Abort!\n");
#else
    rtk_read_ecc_page (flash_address, image_addr,image_size,ecc_enable);
8000e744:	02202021 	move	a0,s1
8000e748:	02402821 	move	a1,s2
8000e74c:	02603021 	move	a2,s3
8000e750:	0c0013d4 	jal	80004f50 <rtk_read_ecc_page>
8000e754:	7c103c20 	seb	a3,s0
            src, *(unsigned long *)(src), *(unsigned long *)(src+4),
            *(unsigned long *)(src+8), *(unsigned long *)(src+12));
    }
#endif

}
8000e758:	8fbf0024 	lw	ra,36(sp)
8000e75c:	8fb30020 	lw	s3,32(sp)
8000e760:	8fb2001c 	lw	s2,28(sp)
8000e764:	8fb10018 	lw	s1,24(sp)
8000e768:	8fb00014 	lw	s0,20(sp)
8000e76c:	03e00008 	jr	ra
8000e770:	27bd0028 	addiu	sp,sp,40

8000e774 <CmdNAND_PIO_SINGLE_PAGE_READ>:




int CmdNAND_PIO_SINGLE_PAGE_READ(int argc, char* argv[])
{
8000e774:	27bdffe0 	addiu	sp,sp,-32
8000e778:	afbf001c 	sw	ra,28(sp)
8000e77c:	afb20018 	sw	s2,24(sp)
8000e780:	afb10014 	sw	s1,20(sp)
8000e784:	afb00010 	sw	s0,16(sp)
   if(argc< 3)
8000e788:	28840003 	slti	a0,a0,3
8000e78c:	1080000f 	beqz	a0,8000e7cc <CmdNAND_PIO_SINGLE_PAGE_READ+0x58>
8000e790:	00a08021 	move	s0,a1
   {	 		
		prom_printf("ex:NANDPIOR:<flash_Paddress><enable_page_content>\r\n");
8000e794:	3c048001 	lui	a0,0x8001
8000e798:	0c0023a7 	jal	80008e9c <prom_printf>
8000e79c:	248467f0 	addiu	a0,a0,26608
		prom_printf("<flash_Paddress>:NAND Flash's physical address\r\n");
8000e7a0:	3c048001 	lui	a0,0x8001
8000e7a4:	0c0023a7 	jal	80008e9c <prom_printf>
8000e7a8:	24846824 	addiu	a0,a0,26660
		prom_printf("<enable_page_content>:<1:show page content><0:show nothing>\r\n");
8000e7ac:	3c048001 	lui	a0,0x8001
8000e7b0:	0c0023a7 	jal	80008e9c <prom_printf>
8000e7b4:	24846858 	addiu	a0,a0,26712
		prom_printf("<report_bad_block>:<1:report bad block><0:report nothing>\r\n");
8000e7b8:	3c048001 	lui	a0,0x8001
8000e7bc:	0c0023a7 	jal	80008e9c <prom_printf>
8000e7c0:	24846898 	addiu	a0,a0,26776
		
	     
		return;	
8000e7c4:	08003a0b 	j	8000e82c <CmdNAND_PIO_SINGLE_PAGE_READ+0xb8>
8000e7c8:	8fbf001c 	lw	ra,28(sp)
   }   
 

    unsigned int flash_Paddress_start= strtoul((const char*)(argv[0]), (char **)NULL, 16);
8000e7cc:	8ca40000 	lw	a0,0(a1)
8000e7d0:	00002821 	move	a1,zero
8000e7d4:	0c0020c4 	jal	80008310 <strtoul>
8000e7d8:	24060010 	li	a2,16
8000e7dc:	00408821 	move	s1,v0
    unsigned int enable_page_content= strtoul((const char*)(argv[1]), (char **)NULL, 16);
8000e7e0:	8e040004 	lw	a0,4(s0)
8000e7e4:	00002821 	move	a1,zero
8000e7e8:	0c0020c4 	jal	80008310 <strtoul>
8000e7ec:	24060010 	li	a2,16
8000e7f0:	00409021 	move	s2,v0
    unsigned int report_bad_block= strtoul((const char*)(argv[2]), (char **)NULL, 16);
8000e7f4:	8e040008 	lw	a0,8(s0)
8000e7f8:	00002821 	move	a1,zero
8000e7fc:	0c0020c4 	jal	80008310 <strtoul>
8000e800:	24060010 	li	a2,16
8000e804:	00408021 	move	s0,v0
  
    //unsigned int length= strtoul((const char*)(argv[1]), (char **)NULL, 16);  
 

    prom_printf("NAND flash PIO read from flash_Paddress 0x%X \n",flash_Paddress_start);
8000e808:	3c048001 	lui	a0,0x8001
8000e80c:	248468d4 	addiu	a0,a0,26836
8000e810:	0c0023a7 	jal	80008e9c <prom_printf>
8000e814:	02202821 	move	a1,s1
   //{                 
   //NAND_Erase_Block_times=block_end_num-block_start_num; 
#if (defined(CONFIG_NAND_Flash_Small_Page_32MB_3cycles) || defined(CONFIG_NAND_Flash_Small_Page_64MB_4cycles))
       rtk_PIO_read_page (flash_Paddress_start,enable_page_content,report_bad_block);   //JSW 1block= 32(0x20) pages
#else
       rtk_PIO_read_page (flash_Paddress_start,enable_page_content,report_bad_block);   //JSW 1block= 64(0x40) pages
8000e818:	02202021 	move	a0,s1
8000e81c:	02402821 	move	a1,s2
8000e820:	0c001932 	jal	800064c8 <rtk_PIO_read_page>
8000e824:	02003021 	move	a2,s0
#endif    
//   }

               
}
8000e828:	8fbf001c 	lw	ra,28(sp)
8000e82c:	8fb20018 	lw	s2,24(sp)
8000e830:	8fb10014 	lw	s1,20(sp)
8000e834:	8fb00010 	lw	s0,16(sp)
8000e838:	03e00008 	jr	ra
8000e83c:	27bd0020 	addiu	sp,sp,32

8000e840 <CmdNANDID>:
#endif

#if defined (CONFIG_NAND_FLASH) ||(CONFIG_NAND_FLASH_BOOTING)

int CmdNANDID(int argc, char* argv[])
{
8000e840:	27bdffe8 	addiu	sp,sp,-24
8000e844:	afbf0014 	sw	ra,20(sp)

    //rtk_nand_read_id();

    rtk_nand_probe();
8000e848:	0c0019cd 	jal	80006734 <rtk_nand_probe>
8000e84c:	00000000 	nop
}
8000e850:	8fbf0014 	lw	ra,20(sp)
8000e854:	03e00008 	jr	ra
8000e858:	27bd0018 	addiu	sp,sp,24

8000e85c <CmdHelp>:
};


//==============================================================================
int CmdHelp( int argc, char* argv[] )
{
8000e85c:	27bdffd8 	addiu	sp,sp,-40
8000e860:	afbf0024 	sw	ra,36(sp)
8000e864:	afb30020 	sw	s3,32(sp)
8000e868:	afb2001c 	sw	s2,28(sp)
8000e86c:	afb10018 	sw	s1,24(sp)
8000e870:	afb00014 	sw	s0,20(sp)
	int	i ;

    printf("----------------- COMMAND MODE HELP ------------------\n");
8000e874:	3c048001 	lui	a0,0x8001
8000e878:	0c002325 	jal	80008c94 <dprintf>
8000e87c:	24846904 	addiu	a0,a0,26884
8000e880:	3c108001 	lui	s0,0x8001
8000e884:	26107748 	addiu	s0,s0,30536
#endif
};


//==============================================================================
int CmdHelp( int argc, char* argv[] )
8000e888:	3c118001 	lui	s1,0x8001
8000e88c:	263179e8 	addiu	s1,s1,31208
    printf("----------------- COMMAND MODE HELP ------------------\n");
	for( i=0  ; i < (sizeof(MainCmdTable) / sizeof(COMMAND_TABLE)) ; i++ )
	{
		if( MainCmdTable[i].msg )
		{
			printf( "%s\n", MainCmdTable[i].msg );
8000e890:	3c128001 	lui	s2,0x8001
8000e894:	265345f8 	addiu	s3,s2,17912
	int	i ;

    printf("----------------- COMMAND MODE HELP ------------------\n");
	for( i=0  ; i < (sizeof(MainCmdTable) / sizeof(COMMAND_TABLE)) ; i++ )
	{
		if( MainCmdTable[i].msg )
8000e898:	8e050000 	lw	a1,0(s0)
8000e89c:	10a00003 	beqz	a1,8000e8ac <CmdHelp+0x50>
8000e8a0:	00000000 	nop
		{
			printf( "%s\n", MainCmdTable[i].msg );
8000e8a4:	0c002325 	jal	80008c94 <dprintf>
8000e8a8:	02602021 	move	a0,s3
8000e8ac:	26100010 	addiu	s0,s0,16
int CmdHelp( int argc, char* argv[] )
{
	int	i ;

    printf("----------------- COMMAND MODE HELP ------------------\n");
	for( i=0  ; i < (sizeof(MainCmdTable) / sizeof(COMMAND_TABLE)) ; i++ )
8000e8b0:	1611fff9 	bne	s0,s1,8000e898 <CmdHelp+0x3c>
8000e8b4:	24020001 	li	v0,1
		}
	}
	/*Cyrus Tsai*/
    
	return TRUE ;
}
8000e8b8:	8fbf0024 	lw	ra,36(sp)
8000e8bc:	8fb30020 	lw	s3,32(sp)
8000e8c0:	8fb2001c 	lw	s2,28(sp)
8000e8c4:	8fb10018 	lw	s1,24(sp)
8000e8c8:	8fb00014 	lw	s0,20(sp)
8000e8cc:	03e00008 	jr	ra
8000e8d0:	27bd0028 	addiu	sp,sp,40

8000e8d4 <CmdLoad>:
#endif


//---------------------------------------------------------------------------
int CmdLoad(int argc, char* argv[])
{
8000e8d4:	27bdffe8 	addiu	sp,sp,-24
8000e8d8:	afbf0014 	sw	ra,20(sp)
	unsigned long addr;

	if(argc < 1) 
8000e8dc:	1c800007 	bgtz	a0,8000e8fc <CmdLoad+0x28>
8000e8e0:	3c048001 	lui	a0,0x8001
	{
		printf("TFTP Load Addr 0x%x\n",image_address);
8000e8e4:	24846940 	addiu	a0,a0,26944
8000e8e8:	3c028001 	lui	v0,0x8001
8000e8ec:	0c002325 	jal	80008c94 <dprintf>
8000e8f0:	8c4572b8 	lw	a1,29368(v0)
	}

	
	image_address= strtoul((const char*)(argv[0]), (char **)NULL, 16);		
	printf("Set TFTP Load Addr 0x%x\n",image_address);
}
8000e8f4:	08003a49 	j	8000e924 <CmdLoad+0x50>
8000e8f8:	24020001 	li	v0,1
		printf("TFTP Load Addr 0x%x\n",image_address);
		return 1;
	}

	
	image_address= strtoul((const char*)(argv[0]), (char **)NULL, 16);		
8000e8fc:	8ca40000 	lw	a0,0(a1)
8000e900:	00002821 	move	a1,zero
8000e904:	0c0020c4 	jal	80008310 <strtoul>
8000e908:	24060010 	li	a2,16
8000e90c:	3c038001 	lui	v1,0x8001
8000e910:	ac6272b8 	sw	v0,29368(v1)
	printf("Set TFTP Load Addr 0x%x\n",image_address);
8000e914:	3c048001 	lui	a0,0x8001
8000e918:	2484693c 	addiu	a0,a0,26940
8000e91c:	0c002325 	jal	80008c94 <dprintf>
8000e920:	00402821 	move	a1,v0
}
8000e924:	8fbf0014 	lw	ra,20(sp)
8000e928:	03e00008 	jr	ra
8000e92c:	27bd0018 	addiu	sp,sp,24

8000e930 <CmdAuto>:

//---------------------------------------------------------------------------
#ifndef RTL8197B
extern int autoBurn;
int CmdAuto(int argc, char* argv[])
{
8000e930:	27bdffe8 	addiu	sp,sp,-24
8000e934:	afbf0014 	sw	ra,20(sp)
	unsigned long addr;


	if(argv[0][0] == '0')
8000e938:	8ca20000 	lw	v0,0(a1)
8000e93c:	80430000 	lb	v1,0(v0)
8000e940:	24020030 	li	v0,48
8000e944:	14620004 	bne	v1,v0,8000e958 <CmdAuto+0x28>
8000e948:	24030001 	li	v1,1
		autoBurn = 0 ;
8000e94c:	3c028001 	lui	v0,0x8001
8000e950:	08003a58 	j	8000e960 <CmdAuto+0x30>
8000e954:	ac407364 	sw	zero,29540(v0)
	else
		autoBurn = 1 ;
8000e958:	3c028001 	lui	v0,0x8001
8000e95c:	ac437364 	sw	v1,29540(v0)
	printf("AutoBurning=%d\n",autoBurn);
8000e960:	3c048001 	lui	a0,0x8001
8000e964:	24846958 	addiu	a0,a0,26968
8000e968:	3c028001 	lui	v0,0x8001
8000e96c:	0c002325 	jal	80008c94 <dprintf>
8000e970:	8c457364 	lw	a1,29540(v0)
}
8000e974:	8fbf0014 	lw	ra,20(sp)
8000e978:	03e00008 	jr	ra
8000e97c:	27bd0018 	addiu	sp,sp,24

8000e980 <CmdCmp>:
		*(volatile unsigned char *)(src) = value;
	}
	
}
int CmdCmp(int argc, char* argv[])
{
8000e980:	27bdffd0 	addiu	sp,sp,-48
8000e984:	afbf002c 	sw	ra,44(sp)
8000e988:	afb50028 	sw	s5,40(sp)
8000e98c:	afb40024 	sw	s4,36(sp)
8000e990:	afb30020 	sw	s3,32(sp)
8000e994:	afb2001c 	sw	s2,28(sp)
8000e998:	afb10018 	sw	s1,24(sp)
8000e99c:	afb00014 	sw	s0,20(sp)
	unsigned long dst,src;
	unsigned long dst_value, src_value;
	unsigned int length;
	unsigned long error;

	if(argc < 3) {
8000e9a0:	28840003 	slti	a0,a0,3
8000e9a4:	10800006 	beqz	a0,8000e9c0 <CmdCmp+0x40>
8000e9a8:	00a08021 	move	s0,a1
		printf("Parameters not enough!\n");
8000e9ac:	3c048001 	lui	a0,0x8001
8000e9b0:	0c002325 	jal	80008c94 <dprintf>
8000e9b4:	248467a0 	addiu	a0,a0,26528
		}
	}
	if(!error)
		printf("No error found\n");

}
8000e9b8:	08003a99 	j	8000ea64 <CmdCmp+0xe4>
8000e9bc:	24020001 	li	v0,1

	if(argc < 3) {
		printf("Parameters not enough!\n");
		return 1;
	}
	dst = strtoul((const char*)(argv[0]), (char **)NULL, 16);
8000e9c0:	8ca40000 	lw	a0,0(a1)
8000e9c4:	00002821 	move	a1,zero
8000e9c8:	0c0020c4 	jal	80008310 <strtoul>
8000e9cc:	24060010 	li	a2,16
8000e9d0:	00409021 	move	s2,v0
	src = strtoul((const char*)(argv[1]), (char **)NULL, 16);
8000e9d4:	8e040004 	lw	a0,4(s0)
8000e9d8:	00002821 	move	a1,zero
8000e9dc:	0c0020c4 	jal	80008310 <strtoul>
8000e9e0:	24060010 	li	a2,16
8000e9e4:	00409821 	move	s3,v0
	length= strtoul((const char*)(argv[2]), (char **)NULL, 16);		
8000e9e8:	8e040008 	lw	a0,8(s0)
8000e9ec:	00002821 	move	a1,zero
8000e9f0:	0c0020c4 	jal	80008310 <strtoul>
8000e9f4:	24060010 	li	a2,16
	error = 0;
	for(i=0;i<length;i+=4) {
8000e9f8:	10400017 	beqz	v0,8000ea58 <CmdCmp+0xd8>
8000e9fc:	00408821 	move	s1,v0
8000ea00:	00001021 	move	v0,zero
8000ea04:	00008021 	move	s0,zero
8000ea08:	00002021 	move	a0,zero
		dst_value = *(volatile unsigned int *)(dst+i);
		src_value = *(volatile unsigned int *)(src+i);
		if(dst_value != src_value) {		
			printf("%dth data(%x %x) error\n",i, dst_value, src_value);
8000ea0c:	3c148001 	lui	s4,0x8001
8000ea10:	26946968 	addiu	s4,s4,26984
8000ea14:	24150001 	li	s5,1
	dst = strtoul((const char*)(argv[0]), (char **)NULL, 16);
	src = strtoul((const char*)(argv[1]), (char **)NULL, 16);
	length= strtoul((const char*)(argv[2]), (char **)NULL, 16);		
	error = 0;
	for(i=0;i<length;i+=4) {
		dst_value = *(volatile unsigned int *)(dst+i);
8000ea18:	00521821 	addu	v1,v0,s2
8000ea1c:	8c660000 	lw	a2,0(v1)
		src_value = *(volatile unsigned int *)(src+i);
8000ea20:	00531021 	addu	v0,v0,s3
8000ea24:	8c470000 	lw	a3,0(v0)
		if(dst_value != src_value) {		
8000ea28:	10c70005 	beq	a2,a3,8000ea40 <CmdCmp+0xc0>
8000ea2c:	00000000 	nop
			printf("%dth data(%x %x) error\n",i, dst_value, src_value);
8000ea30:	02802021 	move	a0,s4
8000ea34:	0c002325 	jal	80008c94 <dprintf>
8000ea38:	02002821 	move	a1,s0
8000ea3c:	02a02021 	move	a0,s5
	}
	dst = strtoul((const char*)(argv[0]), (char **)NULL, 16);
	src = strtoul((const char*)(argv[1]), (char **)NULL, 16);
	length= strtoul((const char*)(argv[2]), (char **)NULL, 16);		
	error = 0;
	for(i=0;i<length;i+=4) {
8000ea40:	26100004 	addiu	s0,s0,4
8000ea44:	0211182b 	sltu	v1,s0,s1
8000ea48:	1460fff3 	bnez	v1,8000ea18 <CmdCmp+0x98>
8000ea4c:	02001021 	move	v0,s0
		if(dst_value != src_value) {		
			printf("%dth data(%x %x) error\n",i, dst_value, src_value);
			error = 1;
		}
	}
	if(!error)
8000ea50:	14800005 	bnez	a0,8000ea68 <CmdCmp+0xe8>
8000ea54:	8fbf002c 	lw	ra,44(sp)
		printf("No error found\n");
8000ea58:	3c048001 	lui	a0,0x8001
8000ea5c:	0c002325 	jal	80008c94 <dprintf>
8000ea60:	24846980 	addiu	a0,a0,27008

}
8000ea64:	8fbf002c 	lw	ra,44(sp)
8000ea68:	8fb50028 	lw	s5,40(sp)
8000ea6c:	8fb40024 	lw	s4,36(sp)
8000ea70:	8fb30020 	lw	s3,32(sp)
8000ea74:	8fb2001c 	lw	s2,28(sp)
8000ea78:	8fb10018 	lw	s1,24(sp)
8000ea7c:	8fb00014 	lw	s0,20(sp)
8000ea80:	03e00008 	jr	ra
8000ea84:	27bd0030 	addiu	sp,sp,48

8000ea88 <CmdDumpWord>:
	prom_printf("Now your Host IP is %d.%d.%d.%d\n", ip[0],ip[1],ip[2],ip[3]);
#endif	
		
}	
int CmdDumpWord( int argc, char* argv[] )
{
8000ea88:	27bdffd0 	addiu	sp,sp,-48
8000ea8c:	afbf002c 	sw	ra,44(sp)
8000ea90:	afb30028 	sw	s3,40(sp)
8000ea94:	afb20024 	sw	s2,36(sp)
8000ea98:	afb10020 	sw	s1,32(sp)
8000ea9c:	afb0001c 	sw	s0,28(sp)
	
	unsigned long src;
	unsigned int len,i;

	if(argc<1)
8000eaa0:	1c800006 	bgtz	a0,8000eabc <CmdDumpWord+0x34>
8000eaa4:	00a08821 	move	s1,a1
	{	dprintf("Wrong argument number!\r\n");
8000eaa8:	3c048001 	lui	a0,0x8001
8000eaac:	0c002325 	jal	80008c94 <dprintf>
8000eab0:	24846990 	addiu	a0,a0,27024
		return;
8000eab4:	08003ae0 	j	8000eb80 <CmdDumpWord+0xf8>
8000eab8:	8fbf002c 	lw	ra,44(sp)
	}
	
	if(argv[0])	
8000eabc:	8ca40000 	lw	a0,0(a1)
8000eac0:	10800009 	beqz	a0,8000eae8 <CmdDumpWord+0x60>
8000eac4:	00000000 	nop
	{	src = strtoul((const char*)(argv[0]), (char **)NULL, 16);
8000eac8:	00002821 	move	a1,zero
8000eacc:	0c0020c4 	jal	80008310 <strtoul>
8000ead0:	24060010 	li	a2,16
		if(src <0x80000000)
8000ead4:	04400009 	bltz	v0,8000eafc <CmdDumpWord+0x74>
8000ead8:	00408021 	move	s0,v0
			src|=0x80000000;
8000eadc:	3c028000 	lui	v0,0x8000
8000eae0:	08003abf 	j	8000eafc <CmdDumpWord+0x74>
8000eae4:	02028025 	or	s0,s0,v0
	}
	else
	{	dprintf("Wrong argument number!\r\n");
8000eae8:	3c048001 	lui	a0,0x8001
8000eaec:	0c002325 	jal	80008c94 <dprintf>
8000eaf0:	24846990 	addiu	a0,a0,27024
		return;		
8000eaf4:	08003ae0 	j	8000eb80 <CmdDumpWord+0xf8>
8000eaf8:	8fbf002c 	lw	ra,44(sp)
	}
				
	if(!argv[1])
8000eafc:	8e240004 	lw	a0,4(s1)
8000eb00:	10800005 	beqz	a0,8000eb18 <CmdDumpWord+0x90>
8000eb04:	24120001 	li	s2,1
		len = 1;
	else
	len= strtoul((const char*)(argv[1]), (char **)NULL, 10);			
8000eb08:	00002821 	move	a1,zero
8000eb0c:	0c0020c4 	jal	80008310 <strtoul>
8000eb10:	2406000a 	li	a2,10
8000eb14:	00409021 	move	s2,v0
	while ( (src) & 0x03)
8000eb18:	32020003 	andi	v0,s0,0x3
8000eb1c:	10400006 	beqz	v0,8000eb38 <CmdDumpWord+0xb0>
8000eb20:	00000000 	nop
		src++;
8000eb24:	26100001 	addiu	s0,s0,1
				
	if(!argv[1])
		len = 1;
	else
	len= strtoul((const char*)(argv[1]), (char **)NULL, 10);			
	while ( (src) & 0x03)
8000eb28:	32020003 	andi	v0,s0,0x3
8000eb2c:	1440fffe 	bnez	v0,8000eb28 <CmdDumpWord+0xa0>
8000eb30:	26100001 	addiu	s0,s0,1
8000eb34:	2610ffff 	addiu	s0,s0,-1
		src++;

	for(i=0; i< len ; i+=4,src+=16)
8000eb38:	12400010 	beqz	s2,8000eb7c <CmdDumpWord+0xf4>
8000eb3c:	00008821 	move	s1,zero
	{	
		dprintf("%08X:	%08X	%08X	%08X	%08X\n",
8000eb40:	3c138001 	lui	s3,0x8001
8000eb44:	267369ac 	addiu	s3,s3,27052
8000eb48:	8e060000 	lw	a2,0(s0)
8000eb4c:	8e070004 	lw	a3,4(s0)
8000eb50:	8e020008 	lw	v0,8(s0)
8000eb54:	afa20010 	sw	v0,16(sp)
8000eb58:	8e02000c 	lw	v0,12(s0)
8000eb5c:	afa20014 	sw	v0,20(sp)
8000eb60:	02602021 	move	a0,s3
8000eb64:	0c002325 	jal	80008c94 <dprintf>
8000eb68:	02002821 	move	a1,s0
	else
	len= strtoul((const char*)(argv[1]), (char **)NULL, 10);			
	while ( (src) & 0x03)
		src++;

	for(i=0; i< len ; i+=4,src+=16)
8000eb6c:	26310004 	addiu	s1,s1,4
8000eb70:	0232102b 	sltu	v0,s1,s2
8000eb74:	1440fff4 	bnez	v0,8000eb48 <CmdDumpWord+0xc0>
8000eb78:	26100010 	addiu	s0,s0,16
		dprintf("%08X:	%08X	%08X	%08X	%08X\n",
		src, *(unsigned long *)(src), *(unsigned long *)(src+4), 
		*(unsigned long *)(src+8), *(unsigned long *)(src+12));
	}

}
8000eb7c:	8fbf002c 	lw	ra,44(sp)
8000eb80:	8fb30028 	lw	s3,40(sp)
8000eb84:	8fb20024 	lw	s2,36(sp)
8000eb88:	8fb10020 	lw	s1,32(sp)
8000eb8c:	8fb0001c 	lw	s0,28(sp)
8000eb90:	03e00008 	jr	ra
8000eb94:	27bd0030 	addiu	sp,sp,48

8000eb98 <YesOrNo>:

//---------------------------------------------------------------------------


int YesOrNo(void)
{
8000eb98:	27bdffe0 	addiu	sp,sp,-32
8000eb9c:	afbf001c 	sw	ra,28(sp)
	unsigned char iChar[2];

	GetLine( iChar, 2,1);
8000eba0:	27a40010 	addiu	a0,sp,16
8000eba4:	24050002 	li	a1,2
8000eba8:	0c002193 	jal	8000864c <GetLine>
8000ebac:	24060001 	li	a2,1
	printf("\n");//vicadd
8000ebb0:	3c048001 	lui	a0,0x8001
8000ebb4:	0c002325 	jal	80008c94 <dprintf>
8000ebb8:	248457b8 	addiu	a0,a0,22456
	if ((iChar[0] == 'Y') || (iChar[0] == 'y'))
8000ebbc:	93a30010 	lbu	v1,16(sp)
8000ebc0:	24040059 	li	a0,89
8000ebc4:	10640003 	beq	v1,a0,8000ebd4 <YesOrNo+0x3c>
8000ebc8:	24020001 	li	v0,1
8000ebcc:	38620079 	xori	v0,v1,0x79
8000ebd0:	2c420001 	sltiu	v0,v0,1
		return 1;
	else
		return 0;
}
8000ebd4:	8fbf001c 	lw	ra,28(sp)
8000ebd8:	03e00008 	jr	ra
8000ebdc:	27bd0020 	addiu	sp,sp,32

8000ebe0 <CmdNANDBadBlockDetect>:

}


int  CmdNANDBadBlockDetect(int argc, char* argv[])
{
8000ebe0:	27bdffe0 	addiu	sp,sp,-32
8000ebe4:	afbf001c 	sw	ra,28(sp)
8000ebe8:	afb10018 	sw	s1,24(sp)
8000ebec:	afb00014 	sw	s0,20(sp)
	 if(argc < 2 )
8000ebf0:	28840002 	slti	a0,a0,2
8000ebf4:	10800006 	beqz	a0,8000ec10 <CmdNANDBadBlockDetect+0x30>
8000ebf8:	00a08021 	move	s0,a1
    {
        prom_printf("Parameters not enough!\n");
8000ebfc:	3c048001 	lui	a0,0x8001
8000ec00:	0c0023a7 	jal	80008e9c <prom_printf>
8000ec04:	248467a0 	addiu	a0,a0,26528
    else
    {
        prom_printf("Abort!\n");
    }

}
8000ec08:	08003b22 	j	8000ec88 <CmdNANDBadBlockDetect+0xa8>
8000ec0c:	24020001 	li	v0,1

    //unsigned long flash_address= strtoul((const char*)(argv[0]), (char **)NULL, 16);
    //unsigned char *image_addr = strtoul((const char*)(argv[1]), (char **)NULL, 16);
    //unsigned int image_size= strtoul((const char*)(argv[2]), (char **)NULL, 16);

   unsigned int block_start_cnt= strtoul((const char*)(argv[0]), (char **)NULL, 16);
8000ec10:	8ca40000 	lw	a0,0(a1)
8000ec14:	00002821 	move	a1,zero
8000ec18:	0c0020c4 	jal	80008310 <strtoul>
8000ec1c:	24060010 	li	a2,16
8000ec20:	00408821 	move	s1,v0

   unsigned int block_end_cnt= strtoul((const char*)(argv[1]), (char **)NULL, 16);
8000ec24:	8e040004 	lw	a0,4(s0)
8000ec28:	00002821 	move	a1,zero
8000ec2c:	0c0020c4 	jal	80008310 <strtoul>
8000ec30:	24060010 	li	a2,16
8000ec34:	00408021 	move	s0,v0

    prom_printf("NAND flash bad block detect from block:0x%X to block:0x%X ?\n",block_start_cnt,block_end_cnt);
8000ec38:	3c048001 	lui	a0,0x8001
8000ec3c:	248469c8 	addiu	a0,a0,27080
8000ec40:	02202821 	move	a1,s1
8000ec44:	0c0023a7 	jal	80008e9c <prom_printf>
8000ec48:	00403021 	move	a2,v0
    prom_printf("(Y)es, (N)o->");
8000ec4c:	3c048001 	lui	a0,0x8001
8000ec50:	0c0023a7 	jal	80008e9c <prom_printf>
8000ec54:	24846a08 	addiu	a0,a0,27144
   if (YesOrNo())
8000ec58:	0c003ae6 	jal	8000eb98 <YesOrNo>
8000ec5c:	00000000 	nop
8000ec60:	10400006 	beqz	v0,8000ec7c <CmdNANDBadBlockDetect+0x9c>
8000ec64:	00000000 	nop
    {
        isBadBlock(block_start_cnt,block_end_cnt);     
8000ec68:	02202021 	move	a0,s1
8000ec6c:	0c000fe5 	jal	80003f94 <isBadBlock>
8000ec70:	02002821 	move	a1,s0
    else
    {
        prom_printf("Abort!\n");
    }

}
8000ec74:	08003b23 	j	8000ec8c <CmdNANDBadBlockDetect+0xac>
8000ec78:	8fbf001c 	lw	ra,28(sp)
    {
        isBadBlock(block_start_cnt,block_end_cnt);     
    }
    else
    {
        prom_printf("Abort!\n");
8000ec7c:	3c048001 	lui	a0,0x8001
8000ec80:	0c0023a7 	jal	80008e9c <prom_printf>
8000ec84:	24846a18 	addiu	a0,a0,27160
    }

}
8000ec88:	8fbf001c 	lw	ra,28(sp)
8000ec8c:	8fb10018 	lw	s1,24(sp)
8000ec90:	8fb00014 	lw	s0,20(sp)
8000ec94:	03e00008 	jr	ra
8000ec98:	27bd0020 	addiu	sp,sp,32

8000ec9c <CmdNANDW>:

}


int CmdNANDW(int argc, char* argv[])
{
8000ec9c:	27bdffe0 	addiu	sp,sp,-32
8000eca0:	afbf001c 	sw	ra,28(sp)
8000eca4:	afb20018 	sw	s2,24(sp)
8000eca8:	afb10014 	sw	s1,20(sp)
8000ecac:	afb00010 	sw	s0,16(sp)

    if(argc <3 )
8000ecb0:	28840003 	slti	a0,a0,3
8000ecb4:	10800006 	beqz	a0,8000ecd0 <CmdNANDW+0x34>
8000ecb8:	00a08021 	move	s0,a1
    {
        prom_printf("Parameters not enough!\n");
8000ecbc:	3c048001 	lui	a0,0x8001
8000ecc0:	0c0023a7 	jal	80008e9c <prom_printf>
8000ecc4:	248467a0 	addiu	a0,a0,26528
    else
    {
        prom_printf("Abort!\n");
    }

}
8000ecc8:	08003b58 	j	8000ed60 <CmdNANDW+0xc4>
8000eccc:	24020001 	li	v0,1
    {
        prom_printf("Parameters not enough!\n");
        return 1;
    }

    unsigned long flash_address= strtoul((const char*)(argv[0]), (char **)NULL, 16);
8000ecd0:	8ca40000 	lw	a0,0(a1)
8000ecd4:	00002821 	move	a1,zero
8000ecd8:	0c0020c4 	jal	80008310 <strtoul>
8000ecdc:	24060010 	li	a2,16
8000ece0:	00408821 	move	s1,v0
    unsigned char *image_addr = strtoul((const char*)(argv[1]), (char **)NULL, 16);
8000ece4:	8e040004 	lw	a0,4(s0)
8000ece8:	00002821 	move	a1,zero
8000ecec:	0c0020c4 	jal	80008310 <strtoul>
8000ecf0:	24060010 	li	a2,16
8000ecf4:	00409021 	move	s2,v0
    unsigned int image_size= strtoul((const char*)(argv[2]), (char **)NULL, 16);
8000ecf8:	8e040008 	lw	a0,8(s0)
8000ecfc:	00002821 	move	a1,zero
8000ed00:	0c0020c4 	jal	80008310 <strtoul>
8000ed04:	24060010 	li	a2,16
8000ed08:	00408021 	move	s0,v0

    prom_printf("Program NAND flash addr %X from %X with %X bytes ?\n",flash_address,image_addr,image_size);
8000ed0c:	3c048001 	lui	a0,0x8001
8000ed10:	24846a20 	addiu	a0,a0,27168
8000ed14:	02202821 	move	a1,s1
8000ed18:	02403021 	move	a2,s2
8000ed1c:	0c0023a7 	jal	80008e9c <prom_printf>
8000ed20:	00403821 	move	a3,v0
    prom_printf("(Y)es, (N)o->");
8000ed24:	3c048001 	lui	a0,0x8001
8000ed28:	0c0023a7 	jal	80008e9c <prom_printf>
8000ed2c:	24846a08 	addiu	a0,a0,27144
   if (YesOrNo())
8000ed30:	0c003ae6 	jal	8000eb98 <YesOrNo>
8000ed34:	00000000 	nop
8000ed38:	10400006 	beqz	v0,8000ed54 <CmdNANDW+0xb8>
8000ed3c:	02402821 	move	a1,s2
    {
        rtk_write_ecc_page (flash_address,image_addr, image_size);       
8000ed40:	02202021 	move	a0,s1
8000ed44:	0c0014a4 	jal	80005290 <rtk_write_ecc_page>
8000ed48:	02003021 	move	a2,s0
    else
    {
        prom_printf("Abort!\n");
    }

}
8000ed4c:	08003b59 	j	8000ed64 <CmdNANDW+0xc8>
8000ed50:	8fbf001c 	lw	ra,28(sp)
    {
        rtk_write_ecc_page (flash_address,image_addr, image_size);       
    }
    else
    {
        prom_printf("Abort!\n");
8000ed54:	3c048001 	lui	a0,0x8001
8000ed58:	0c0023a7 	jal	80008e9c <prom_printf>
8000ed5c:	24846a18 	addiu	a0,a0,27160
    }

}
8000ed60:	8fbf001c 	lw	ra,28(sp)
8000ed64:	8fb20018 	lw	s2,24(sp)
8000ed68:	8fb10014 	lw	s1,20(sp)
8000ed6c:	8fb00010 	lw	s0,16(sp)
8000ed70:	03e00008 	jr	ra
8000ed74:	27bd0020 	addiu	sp,sp,32

8000ed78 <CmdNAND_PIO_WRITE>:




int CmdNAND_PIO_WRITE(int argc, char* argv[])
{
8000ed78:	27bdffd8 	addiu	sp,sp,-40
8000ed7c:	afbf0024 	sw	ra,36(sp)
8000ed80:	afb30020 	sw	s3,32(sp)
8000ed84:	afb2001c 	sw	s2,28(sp)
8000ed88:	afb10018 	sw	s1,24(sp)
8000ed8c:	afb00014 	sw	s0,20(sp)
   if(argc< 3)
8000ed90:	28840003 	slti	a0,a0,3
8000ed94:	1080000f 	beqz	a0,8000edd4 <CmdNAND_PIO_WRITE+0x5c>
8000ed98:	00a09021 	move	s2,a1
   {	 		
		prom_printf("ex:CmdNAND_PIO_WRITE:<flash_Paddress><image_addr><image_size>\r\n");
8000ed9c:	3c048001 	lui	a0,0x8001
8000eda0:	0c0023a7 	jal	80008e9c <prom_printf>
8000eda4:	24846a54 	addiu	a0,a0,27220
		prom_printf("<flash_Paddress>:NAND Flash's physical address\r\n");
8000eda8:	3c048001 	lui	a0,0x8001
8000edac:	0c0023a7 	jal	80008e9c <prom_printf>
8000edb0:	24846824 	addiu	a0,a0,26660
		prom_printf("<image_addr>:source data\r\n");
8000edb4:	3c048001 	lui	a0,0x8001
8000edb8:	0c0023a7 	jal	80008e9c <prom_printf>
8000edbc:	24846a94 	addiu	a0,a0,27284
		prom_printf("<image_size>:data length\r\n");		
8000edc0:	3c048001 	lui	a0,0x8001
8000edc4:	0c0023a7 	jal	80008e9c <prom_printf>
8000edc8:	24846ab0 	addiu	a0,a0,27312
	     
		return;	
8000edcc:	08003ba1 	j	8000ee84 <CmdNAND_PIO_WRITE+0x10c>
8000edd0:	8fbf0024 	lw	ra,36(sp)
   }   
 

    unsigned int flash_Paddress_start= strtoul((const char*)(argv[0]), (char **)NULL, 16);
8000edd4:	8ca40000 	lw	a0,0(a1)
8000edd8:	00002821 	move	a1,zero
8000eddc:	0c0020c4 	jal	80008310 <strtoul>
8000ede0:	24060010 	li	a2,16
8000ede4:	00408021 	move	s0,v0
    unsigned int image_addr= strtoul((const char*)(argv[1]), (char **)NULL, 16);
8000ede8:	8e440004 	lw	a0,4(s2)
8000edec:	00002821 	move	a1,zero
8000edf0:	0c0020c4 	jal	80008310 <strtoul>
8000edf4:	24060010 	li	a2,16
8000edf8:	00408821 	move	s1,v0
    unsigned int image_size= strtoul((const char*)(argv[2]), (char **)NULL, 16);
8000edfc:	8e440008 	lw	a0,8(s2)
8000ee00:	00002821 	move	a1,zero
8000ee04:	0c0020c4 	jal	80008310 <strtoul>
8000ee08:	24060010 	li	a2,16
8000ee0c:	00409021 	move	s2,v0
  
    //unsigned int length= strtoul((const char*)(argv[1]), (char **)NULL, 16);  
 

    prom_printf("NAND flash PIO write size 0x%X from DRAM 0x%X to flash_Paddress 0x%X \n",image_size,image_addr,flash_Paddress_start);
8000ee10:	3c048001 	lui	a0,0x8001
8000ee14:	24846acc 	addiu	a0,a0,27340
8000ee18:	00402821 	move	a1,v0
8000ee1c:	02203021 	move	a2,s1
8000ee20:	0c0023a7 	jal	80008e9c <prom_printf>
8000ee24:	02003821 	move	a3,s0
    prom_printf("(Y)es, (N)o->");
8000ee28:	3c048001 	lui	a0,0x8001
8000ee2c:	0c0023a7 	jal	80008e9c <prom_printf>
8000ee30:	24846a08 	addiu	a0,a0,27144
   if (YesOrNo())
8000ee34:	0c003ae6 	jal	8000eb98 <YesOrNo>
8000ee38:	00000000 	nop
8000ee3c:	10400010 	beqz	v0,8000ee80 <CmdNAND_PIO_WRITE+0x108>
8000ee40:	3c133e0f 	lui	s3,0x3e0f
#if (defined(CONFIG_NAND_Flash_Small_Page_32MB_3cycles) || defined(CONFIG_NAND_Flash_Small_Page_64MB_4cycles))
       rtk_PIO_write_word (flash_Paddress_start,image_addr,image_size);   
#else
	   /*rtk_PIO_write_word seems can only write a page more safe,cl*/
	   int i;
	   for(i =0; i < (image_size)/2112;i++)
8000ee44:	367383e1 	ori	s3,s3,0x83e1
8000ee48:	02530019 	multu	s2,s3
8000ee4c:	00009810 	mfhi	s3
8000ee50:	00139a42 	srl	s3,s3,0x9
8000ee54:	1260000a 	beqz	s3,8000ee80 <CmdNAND_PIO_WRITE+0x108>
8000ee58:	00009021 	move	s2,zero
	   {
		   rtk_PIO_write_word (flash_Paddress_start,image_addr,2112); 
8000ee5c:	02002021 	move	a0,s0
8000ee60:	02202821 	move	a1,s1
8000ee64:	0c000fe7 	jal	80003f9c <rtk_PIO_write_word>
8000ee68:	24060840 	li	a2,2112
		   flash_Paddress_start += 2112;
8000ee6c:	26100840 	addiu	s0,s0,2112
#if (defined(CONFIG_NAND_Flash_Small_Page_32MB_3cycles) || defined(CONFIG_NAND_Flash_Small_Page_64MB_4cycles))
       rtk_PIO_write_word (flash_Paddress_start,image_addr,image_size);   
#else
	   /*rtk_PIO_write_word seems can only write a page more safe,cl*/
	   int i;
	   for(i =0; i < (image_size)/2112;i++)
8000ee70:	26520001 	addiu	s2,s2,1
8000ee74:	0253102b 	sltu	v0,s2,s3
8000ee78:	1440fff8 	bnez	v0,8000ee5c <CmdNAND_PIO_WRITE+0xe4>
8000ee7c:	26310840 	addiu	s1,s1,2112
#endif    
	}


               
}
8000ee80:	8fbf0024 	lw	ra,36(sp)
8000ee84:	8fb30020 	lw	s3,32(sp)
8000ee88:	8fb2001c 	lw	s2,28(sp)
8000ee8c:	8fb10018 	lw	s1,24(sp)
8000ee90:	8fb00014 	lw	s0,20(sp)
8000ee94:	03e00008 	jr	ra
8000ee98:	27bd0028 	addiu	sp,sp,40

8000ee9c <CmdNANDBE>:
    rtk_nand_probe();
}


int CmdNANDBE(int argc, char* argv[])
{
8000ee9c:	27bdffe0 	addiu	sp,sp,-32
8000eea0:	afbf001c 	sw	ra,28(sp)
8000eea4:	afb20018 	sw	s2,24(sp)
8000eea8:	afb10014 	sw	s1,20(sp)
8000eeac:	afb00010 	sw	s0,16(sp)

    if(argc < 2)
8000eeb0:	28840002 	slti	a0,a0,2
8000eeb4:	10800006 	beqz	a0,8000eed0 <CmdNANDBE+0x34>
8000eeb8:	00a08021 	move	s0,a1
    {
        prom_printf("Parameters not enough!\n");
8000eebc:	3c048001 	lui	a0,0x8001
8000eec0:	0c0023a7 	jal	80008e9c <prom_printf>
8000eec4:	248467a0 	addiu	a0,a0,26528
   else
   {
	 prom_printf("Abort!\n");
   }
               
}
8000eec8:	08003bd7 	j	8000ef5c <CmdNANDBE+0xc0>
8000eecc:	24020001 	li	v0,1
    {
        prom_printf("Parameters not enough!\n");
        return 1;
    }

    unsigned int block_start_num= strtoul((const char*)(argv[0]), (char **)NULL, 16);
8000eed0:	8ca40000 	lw	a0,0(a1)
8000eed4:	00002821 	move	a1,zero
8000eed8:	0c0020c4 	jal	80008310 <strtoul>
8000eedc:	24060010 	li	a2,16
8000eee0:	00408821 	move	s1,v0
    unsigned int block_end_num= strtoul((const char*)(argv[1]), (char **)NULL, 16);
8000eee4:	8e040004 	lw	a0,4(s0)
8000eee8:	00002821 	move	a1,zero
8000eeec:	0c0020c4 	jal	80008310 <strtoul>
8000eef0:	24060010 	li	a2,16
8000eef4:	00409021 	move	s2,v0
    unsigned int NAND_Erase_Block_num,NAND_Erase_Block_times;

     prom_printf("NAND flash block erase from block:0x%X to block:0x%X ?\n",block_start_num,block_end_num);
8000eef8:	3c048001 	lui	a0,0x8001
8000eefc:	24846b14 	addiu	a0,a0,27412
8000ef00:	02202821 	move	a1,s1
8000ef04:	0c0023a7 	jal	80008e9c <prom_printf>
8000ef08:	00403021 	move	a2,v0
    prom_printf("(Y)es, (N)o->");
8000ef0c:	3c048001 	lui	a0,0x8001
8000ef10:	0c0023a7 	jal	80008e9c <prom_printf>
8000ef14:	24846a08 	addiu	a0,a0,27144
   if (YesOrNo())
8000ef18:	0c003ae6 	jal	8000eb98 <YesOrNo>
8000ef1c:	00000000 	nop
8000ef20:	1040000b 	beqz	v0,8000ef50 <CmdNANDBE+0xb4>
8000ef24:	0251102b 	sltu	v0,s2,s1
   {    

                 //NAND_Erase_Block_times=block_end_num-block_start_num;
    for (NAND_Erase_Block_num=block_start_num;NAND_Erase_Block_num<=block_end_num;NAND_Erase_Block_num++)
8000ef28:	1440000c 	bnez	v0,8000ef5c <CmdNANDBE+0xc0>
8000ef2c:	00118180 	sll	s0,s1,0x6
	#if (defined(CONFIG_NAND_Flash_Small_Page_32MB_3cycles) || defined(CONFIG_NAND_Flash_Small_Page_64MB_4cycles))
      	  rtk_erase_block (NAND_Erase_Block_num*32);   //JSW 1block= 32(0x20) pages
	#endif	

	#if (defined(CONFIG_NAND_Flash_Large_Page_256MBto1GB_5cycles) || defined(CONFIG_NAND_Flash_Large_Page_128MB_4cycles))
		 rtk_erase_block (NAND_Erase_Block_num*64);   //JSW 1block= 64(0x40) pages
8000ef30:	0c001455 	jal	80005154 <rtk_erase_block>
8000ef34:	02002021 	move	a0,s0
    prom_printf("(Y)es, (N)o->");
   if (YesOrNo())
   {    

                 //NAND_Erase_Block_times=block_end_num-block_start_num;
    for (NAND_Erase_Block_num=block_start_num;NAND_Erase_Block_num<=block_end_num;NAND_Erase_Block_num++)
8000ef38:	26310001 	addiu	s1,s1,1
8000ef3c:	0251102b 	sltu	v0,s2,s1
8000ef40:	1040fffb 	beqz	v0,8000ef30 <CmdNANDBE+0x94>
8000ef44:	26100040 	addiu	s0,s0,64
   else
   {
	 prom_printf("Abort!\n");
   }
               
}
8000ef48:	08003bd8 	j	8000ef60 <CmdNANDBE+0xc4>
8000ef4c:	8fbf001c 	lw	ra,28(sp)

    }
   }
   else
   {
	 prom_printf("Abort!\n");
8000ef50:	3c048001 	lui	a0,0x8001
8000ef54:	0c0023a7 	jal	80008e9c <prom_printf>
8000ef58:	24846a18 	addiu	a0,a0,27160
   }
               
}
8000ef5c:	8fbf001c 	lw	ra,28(sp)
8000ef60:	8fb20018 	lw	s2,24(sp)
8000ef64:	8fb10014 	lw	s1,20(sp)
8000ef68:	8fb00010 	lw	s0,16(sp)
8000ef6c:	03e00008 	jr	ra
8000ef70:	27bd0020 	addiu	sp,sp,32

8000ef74 <CmdNWB>:
  }

#endif
#if defined (CONFIG_NAND_FLASH) ||(CONFIG_NAND_FLASH_BOOTING)
int CmdNWB(int argc, char* argv[])
{
8000ef74:	27bdffe0 	addiu	sp,sp,-32
8000ef78:	afbf001c 	sw	ra,28(sp)
8000ef7c:	afb00018 	sw	s0,24(sp)
                                                     //JSW check
    unsigned int  cnt=strtoul((const char*)(argv[0]), (char **)NULL, 16);
8000ef80:	8ca40000 	lw	a0,0(a1)
8000ef84:	00002821 	move	a1,zero
8000ef88:	0c0020c4 	jal	80008310 <strtoul>
8000ef8c:	24060010 	li	a2,16
    char* start = &_bootimg_start;
    char* end  = &_bootimg_end;
    unsigned int length = end - start;
8000ef90:	3c038002 	lui	v1,0x8002
8000ef94:	24632e44 	addiu	v1,v1,11844
8000ef98:	3c078001 	lui	a3,0x8001
8000ef9c:	24e779f0 	addiu	a3,a3,31216
8000efa0:	00678023 	subu	s0,v1,a3

    prom_printf("NAND Flash #%d will write 0x%X length of embedded boot code from 0x%X to 0x%X\n", cnt,length, start, end);
8000efa4:	afa30010 	sw	v1,16(sp)
8000efa8:	3c048001 	lui	a0,0x8001
8000efac:	24846b4c 	addiu	a0,a0,27468
8000efb0:	00402821 	move	a1,v0
8000efb4:	0c0023a7 	jal	80008e9c <prom_printf>
8000efb8:	02003021 	move	a2,s0
    prom_printf("(Y)es, (N)o->");
8000efbc:	3c048001 	lui	a0,0x8001
8000efc0:	0c0023a7 	jal	80008e9c <prom_printf>
8000efc4:	24846a08 	addiu	a0,a0,27144
    if (YesOrNo())
8000efc8:	0c003ae6 	jal	8000eb98 <YesOrNo>
8000efcc:	00000000 	nop
8000efd0:	10400007 	beqz	v0,8000eff0 <CmdNWB+0x7c>
8000efd4:	3c058001 	lui	a1,0x8001
    {
        rtk_write_ecc_page (0,start,length);       
8000efd8:	00002021 	move	a0,zero
8000efdc:	24a579f0 	addiu	a1,a1,31216
8000efe0:	0c0014a4 	jal	80005290 <rtk_write_ecc_page>
8000efe4:	02003021 	move	a2,s0
    }
    else
    {
        prom_printf("Abort!\n");
    }
}
8000efe8:	08003c00 	j	8000f000 <CmdNWB+0x8c>
8000efec:	8fbf001c 	lw	ra,28(sp)
    {
        rtk_write_ecc_page (0,start,length);       
    }
    else
    {
        prom_printf("Abort!\n");
8000eff0:	3c048001 	lui	a0,0x8001
8000eff4:	0c0023a7 	jal	80008e9c <prom_printf>
8000eff8:	24846a18 	addiu	a0,a0,27160
    }
}
8000effc:	8fbf001c 	lw	ra,28(sp)
8000f000:	8fb00018 	lw	s0,24(sp)
8000f004:	03e00008 	jr	ra
8000f008:	27bd0020 	addiu	sp,sp,32

8000f00c <monitor>:
#endif
	monitor_real(table_count);
}
#else
void monitor(void)
{
8000f00c:	27bdff38 	addiu	sp,sp,-200
8000f010:	afbf00c4 	sw	ra,196(sp)
8000f014:	afbe00c0 	sw	s8,192(sp)
8000f018:	afb700bc 	sw	s7,188(sp)
8000f01c:	afb600b8 	sw	s6,184(sp)
8000f020:	afb500b4 	sw	s5,180(sp)
8000f024:	afb400b0 	sw	s4,176(sp)
8000f028:	afb300ac 	sw	s3,172(sp)
8000f02c:	afb200a8 	sw	s2,168(sp)
8000f030:	afb100a4 	sw	s1,164(sp)
8000f034:	afb000a0 	sw	s0,160(sp)
	{	
		 #if CONFIG_ESD_SUPPORT//patch for ESD
                         REG32(0xb800311c)|= (1<<23);
        	#endif
	
		printf( "%s", MAIN_PROMPT );
8000f038:	3c178001 	lui	s7,0x8001
8000f03c:	26f742bc 	addiu	s7,s7,17084
8000f040:	3c1e8001 	lui	s8,0x8001
8000f044:	27de40d8 	addiu	s8,s8,16600
		memset( buffer, 0, MAX_MONITOR_BUFFER );
8000f048:	27b40010 	addiu	s4,sp,16
		GetLine( buffer, MAX_MONITOR_BUFFER,1);
		printf( "\n" );
		argc = GetArgc( (const char *)buffer );
		argv = GetArgv( (const char *)buffer );
		if( argc < 1 ) continue ;
		StrUpr( argv[0] );
8000f04c:	3c168001 	lui	s6,0x8001
8000f050:	26d6773c 	addiu	s6,s6,30524
		for( i=0 ; i < (sizeof(MainCmdTable) / sizeof(COMMAND_TABLE)) ; i++ )
8000f054:	2413002a 	li	s3,42
				retval = MainCmdTable[i].func( argc - 1 , argv+1 );
				memset(argv[0],0,sizeof(argv[0]));
				break;
			}
		}
		if(i==sizeof(MainCmdTable) / sizeof(COMMAND_TABLE)) printf("Unknown command !\r\n");
8000f058:	3c028001 	lui	v0,0x8001
8000f05c:	24426b9c 	addiu	v0,v0,27548
8000f060:	afa20098 	sw	v0,152(sp)
	{	
		 #if CONFIG_ESD_SUPPORT//patch for ESD
                         REG32(0xb800311c)|= (1<<23);
        	#endif
	
		printf( "%s", MAIN_PROMPT );
8000f064:	02e02021 	move	a0,s7
8000f068:	0c002325 	jal	80008c94 <dprintf>
8000f06c:	03c02821 	move	a1,s8
		memset( buffer, 0, MAX_MONITOR_BUFFER );
8000f070:	02802021 	move	a0,s4
8000f074:	00002821 	move	a1,zero
8000f078:	0c00203d 	jal	800080f4 <memset>
8000f07c:	24060080 	li	a2,128
		GetLine( buffer, MAX_MONITOR_BUFFER,1);
8000f080:	02802021 	move	a0,s4
8000f084:	24050080 	li	a1,128
8000f088:	0c002193 	jal	8000864c <GetLine>
8000f08c:	24060001 	li	a2,1
		printf( "\n" );
8000f090:	3c048001 	lui	a0,0x8001
8000f094:	0c002325 	jal	80008c94 <dprintf>
8000f098:	248457b8 	addiu	a0,a0,22456
		argc = GetArgc( (const char *)buffer );
8000f09c:	0c002129 	jal	800084a4 <GetArgc>
8000f0a0:	02802021 	move	a0,s4
8000f0a4:	0040a821 	move	s5,v0
		argv = GetArgv( (const char *)buffer );
8000f0a8:	0c002161 	jal	80008584 <GetArgv>
8000f0ac:	02802021 	move	a0,s4
		if( argc < 1 ) continue ;
8000f0b0:	1aa0ffec 	blez	s5,8000f064 <monitor+0x58>
8000f0b4:	00409021 	move	s2,v0
		StrUpr( argv[0] );
8000f0b8:	0c002118 	jal	80008460 <StrUpr>
8000f0bc:	8c440000 	lw	a0,0(v0)
8000f0c0:	02c08821 	move	s1,s6
8000f0c4:	00008021 	move	s0,zero
		for( i=0 ; i < (sizeof(MainCmdTable) / sizeof(COMMAND_TABLE)) ; i++ )
		{
			
			if( ! strcmp( argv[0], MainCmdTable[i].cmd ) )
8000f0c8:	8e440000 	lw	a0,0(s2)
8000f0cc:	0c002015 	jal	80008054 <strcmp>
8000f0d0:	8e250000 	lw	a1,0(s1)
8000f0d4:	14400010 	bnez	v0,8000f118 <monitor+0x10c>
8000f0d8:	26100001 	addiu	s0,s0,1
8000f0dc:	2610ffff 	addiu	s0,s0,-1
				if (MainCmdTable[i].n_arg != (argc - 1))
					printf("%s\n", MainCmdTable[i].msg);
				else
					retval = MainCmdTable[i].func( argc - 1 , argv+1 );
#endif
				retval = MainCmdTable[i].func( argc - 1 , argv+1 );
8000f0e0:	00101100 	sll	v0,s0,0x4
8000f0e4:	00561021 	addu	v0,v0,s6
8000f0e8:	8c420008 	lw	v0,8(v0)
8000f0ec:	26a4ffff 	addiu	a0,s5,-1
8000f0f0:	0040f809 	jalr	v0
8000f0f4:	26450004 	addiu	a1,s2,4
				memset(argv[0],0,sizeof(argv[0]));
8000f0f8:	8e420000 	lw	v0,0(s2)
8000f0fc:	a0400000 	sb	zero,0(v0)
8000f100:	a0400001 	sb	zero,1(v0)
8000f104:	a0400002 	sb	zero,2(v0)
				break;
			}
		}
		if(i==sizeof(MainCmdTable) / sizeof(COMMAND_TABLE)) printf("Unknown command !\r\n");
8000f108:	1613ffd6 	bne	s0,s3,8000f064 <monitor+0x58>
8000f10c:	a0400003 	sb	zero,3(v0)
8000f110:	08003c48 	j	8000f120 <monitor+0x114>
8000f114:	00000000 	nop
		printf( "\n" );
		argc = GetArgc( (const char *)buffer );
		argv = GetArgv( (const char *)buffer );
		if( argc < 1 ) continue ;
		StrUpr( argv[0] );
		for( i=0 ; i < (sizeof(MainCmdTable) / sizeof(COMMAND_TABLE)) ; i++ )
8000f118:	1613ffeb 	bne	s0,s3,8000f0c8 <monitor+0xbc>
8000f11c:	26310010 	addiu	s1,s1,16
				retval = MainCmdTable[i].func( argc - 1 , argv+1 );
				memset(argv[0],0,sizeof(argv[0]));
				break;
			}
		}
		if(i==sizeof(MainCmdTable) / sizeof(COMMAND_TABLE)) printf("Unknown command !\r\n");
8000f120:	0c002325 	jal	80008c94 <dprintf>
8000f124:	8fa40098 	lw	a0,152(sp)
	{	
		 #if CONFIG_ESD_SUPPORT//patch for ESD
                         REG32(0xb800311c)|= (1<<23);
        	#endif
	
		printf( "%s", MAIN_PROMPT );
8000f128:	08003c1a 	j	8000f068 <monitor+0x5c>
8000f12c:	02e02021 	move	a0,s7

8000f130 <CmdPHYregR>:

	return 0;
}

int CmdPHYregR(int argc, char* argv[])
{
8000f130:	27bdffd8 	addiu	sp,sp,-40
8000f134:	afbf0024 	sw	ra,36(sp)
8000f138:	afb10020 	sw	s1,32(sp)
8000f13c:	afb0001c 	sw	s0,28(sp)
8000f140:	00a08021 	move	s0,a1
    unsigned long phyid, regnum;
    unsigned int uid,tmp;

    phyid = strtoul((const char*)(argv[0]), (char **)NULL, 16);
8000f144:	8ca40000 	lw	a0,0(a1)
8000f148:	00002821 	move	a1,zero
8000f14c:	0c0020c4 	jal	80008310 <strtoul>
8000f150:	24060010 	li	a2,16
8000f154:	00408821 	move	s1,v0
    regnum = strtoul((const char*)(argv[1]), (char **)NULL, 16);
8000f158:	8e040004 	lw	a0,4(s0)
8000f15c:	00002821 	move	a1,zero
8000f160:	0c0020c4 	jal	80008310 <strtoul>
8000f164:	24060010 	li	a2,16
8000f168:	00408021 	move	s0,v0

    rtl8651_getAsicEthernetPHYReg( phyid, regnum, &tmp );
8000f16c:	02202021 	move	a0,s1
8000f170:	00402821 	move	a1,v0
8000f174:	0c000933 	jal	800024cc <rtl8651_getAsicEthernetPHYReg>
8000f178:	27a60010 	addiu	a2,sp,16
    uid=tmp;
    dprintf("PHYID=0x%x, regID=0x%x, data=0x%x\r\n", phyid, regnum, uid);
8000f17c:	3c048001 	lui	a0,0x8001
8000f180:	24846bb0 	addiu	a0,a0,27568
8000f184:	02202821 	move	a1,s1
8000f188:	02003021 	move	a2,s0
8000f18c:	0c002325 	jal	80008c94 <dprintf>
8000f190:	8fa70010 	lw	a3,16(sp)
	return 0;
}
8000f194:	00001021 	move	v0,zero
8000f198:	8fbf0024 	lw	ra,36(sp)
8000f19c:	8fb10020 	lw	s1,32(sp)
8000f1a0:	8fb0001c 	lw	s0,28(sp)
8000f1a4:	03e00008 	jr	ra
8000f1a8:	27bd0028 	addiu	sp,sp,40

8000f1ac <TestCmd_MDIOR>:
}
#endif
//---------------------------------------------------------------------------
#if SWITCH_CMD
int TestCmd_MDIOR( int argc, char* argv[] )
{
8000f1ac:	27bdffd0 	addiu	sp,sp,-48
8000f1b0:	afbf002c 	sw	ra,44(sp)
8000f1b4:	afb40028 	sw	s4,40(sp)
8000f1b8:	afb30024 	sw	s3,36(sp)
8000f1bc:	afb20020 	sw	s2,32(sp)
8000f1c0:	afb1001c 	sw	s1,28(sp)
8000f1c4:	afb00018 	sw	s0,24(sp)
	if(argc < 1) {
8000f1c8:	1c800005 	bgtz	a0,8000f1e0 <TestCmd_MDIOR+0x34>
8000f1cc:	3c048001 	lui	a0,0x8001
		printf("Parameters not enough!\n");
8000f1d0:	0c002325 	jal	80008c94 <dprintf>
8000f1d4:	248467a0 	addiu	a0,a0,26528
		return 1;
8000f1d8:	08003c8f 	j	8000f23c <TestCmd_MDIOR+0x90>
8000f1dc:	24020001 	li	v0,1
	}

//	unsigned int phyid = strtoul((const char*)(argv[0]), (char **)NULL, 16);		
	unsigned int reg = strtoul((const char*)(argv[0]), (char **)NULL, 10);		
8000f1e0:	8ca40000 	lw	a0,0(a1)
8000f1e4:	00002821 	move	a1,zero
8000f1e8:	0c0020c4 	jal	80008310 <strtoul>
8000f1ec:	2406000a 	li	a2,10
8000f1f0:	00408821 	move	s1,v0
8000f1f4:	00008021 	move	s0,zero
	int i,phyid;
	for(i=0;i<32;i++)
	{
		phyid=i;
		//REG32(PABCDDAT_REG) =  0xffff<<8;
	rtl8651_getAsicEthernetPHYReg(phyid,reg,&data); 	
8000f1f8:	27b40010 	addiu	s4,sp,16
		//REG32(PABCDDAT_REG) =  0<<8;	
	dprintf("PhyID=0x%02x Reg=%02d Data =0x%04x\r\n", phyid, reg,data);
8000f1fc:	3c128001 	lui	s2,0x8001
8000f200:	26526bd4 	addiu	s2,s2,27604

//	unsigned int phyid = strtoul((const char*)(argv[0]), (char **)NULL, 16);		
	unsigned int reg = strtoul((const char*)(argv[0]), (char **)NULL, 10);		
	unsigned int data;
	int i,phyid;
	for(i=0;i<32;i++)
8000f204:	24130020 	li	s3,32
	{
		phyid=i;
		//REG32(PABCDDAT_REG) =  0xffff<<8;
	rtl8651_getAsicEthernetPHYReg(phyid,reg,&data); 	
8000f208:	02002021 	move	a0,s0
8000f20c:	02202821 	move	a1,s1
8000f210:	0c000933 	jal	800024cc <rtl8651_getAsicEthernetPHYReg>
8000f214:	02803021 	move	a2,s4
		//REG32(PABCDDAT_REG) =  0<<8;	
	dprintf("PhyID=0x%02x Reg=%02d Data =0x%04x\r\n", phyid, reg,data);
8000f218:	02402021 	move	a0,s2
8000f21c:	02002821 	move	a1,s0
8000f220:	02203021 	move	a2,s1
8000f224:	0c002325 	jal	80008c94 <dprintf>
8000f228:	8fa70010 	lw	a3,16(sp)

//	unsigned int phyid = strtoul((const char*)(argv[0]), (char **)NULL, 16);		
	unsigned int reg = strtoul((const char*)(argv[0]), (char **)NULL, 10);		
	unsigned int data;
	int i,phyid;
	for(i=0;i<32;i++)
8000f22c:	26100001 	addiu	s0,s0,1
8000f230:	1613fff6 	bne	s0,s3,8000f20c <TestCmd_MDIOR+0x60>
8000f234:	02002021 	move	a0,s0
8000f238:	00001021 	move	v0,zero
		//REG32(PABCDDAT_REG) =  0<<8;	
	dprintf("PhyID=0x%02x Reg=%02d Data =0x%04x\r\n", phyid, reg,data);

	}
	return 0;
}
8000f23c:	8fbf002c 	lw	ra,44(sp)
8000f240:	8fb40028 	lw	s4,40(sp)
8000f244:	8fb30024 	lw	s3,36(sp)
8000f248:	8fb20020 	lw	s2,32(sp)
8000f24c:	8fb1001c 	lw	s1,28(sp)
8000f250:	8fb00018 	lw	s0,24(sp)
8000f254:	03e00008 	jr	ra
8000f258:	27bd0030 	addiu	sp,sp,48

8000f25c <CmdPHY_Script>:
#endif

//===============================================================================
//========================================================
int CmdPHY_Script(int argc, char* argv[])
{
8000f25c:	27bdff18 	addiu	sp,sp,-232
8000f260:	afbf00e4 	sw	ra,228(sp)
8000f264:	afbe00e0 	sw	s8,224(sp)
8000f268:	afb700dc 	sw	s7,220(sp)
8000f26c:	afb600d8 	sw	s6,216(sp)
8000f270:	afb500d4 	sw	s5,212(sp)
8000f274:	afb400d0 	sw	s4,208(sp)
8000f278:	afb300cc 	sw	s3,204(sp)
8000f27c:	afb200c8 	sw	s2,200(sp)
8000f280:	afb100c4 	sw	s1,196(sp)
8000f284:	afb000c0 	sw	s0,192(sp)
8000f288:	24130001 	li	s3,1
8000f28c:	0000f021 	move	s8,zero
8000f290:	2416000a 	li	s6,10
8000f294:	afa000a0 	sw	zero,160(sp)
	
    while(1)
    {


	if(rec==1)
8000f298:	24140001 	li	s4,1
	{	
		memset(buffer,0,LEN);
8000f29c:	27b20010 	addiu	s2,sp,16
		GetLine(buffer,LEN,1);
		printf("\n");
8000f2a0:	3c028001 	lui	v0,0x8001
8000f2a4:	244257b8 	addiu	v0,v0,22456
8000f2a8:	afa200ac 	sw	v0,172(sp)
		len=strlen(buffer);
		
		memcpy(ptr+pidx,buffer, len); 
8000f2ac:	3c158050 	lui	s5,0x8050


	StrUpr(argv[0]);
	WDBG("cmd=%s\n", argv[0] );
	
	if( (rec==1)  &&  !strcmp(argv[0],  "PHYID") )
8000f2b0:	3c028001 	lui	v0,0x8001
8000f2b4:	24426bfc 	addiu	v0,v0,27644
8000f2b8:	afa200b0 	sw	v0,176(sp)
	{
		phyid=strtoul((const char*)(argv[1]), (char **)NULL, 16);
		WDBG("id=%x\n", phyid);		
	}
	
	if(  (rec==1)  && !strcmp(argv[0],  "A") )
8000f2bc:	3c028001 	lui	v0,0x8001
8000f2c0:	244250a0 	addiu	v0,v0,20640
8000f2c4:	afa200b4 	sw	v0,180(sp)
	{
		cnt=strtoul((const char*)(argv[1]), (char **)NULL, 10);
		WDBG("rep=%x\n", cnt);		
	}
	if(  (rec==0)  && !strcmp(argv[0],  "W") )
8000f2c8:	3c028001 	lui	v0,0x8001
8000f2cc:	2442700c 	addiu	v0,v0,28684
8000f2d0:	afa200a4 	sw	v0,164(sp)
		val=(tmp&mask)|val;
		WDBG("W reg=%x\n",val);		
		rtl8651_setAsicEthernetPHYReg( phyid, reg,  val);	

	}
	if(  (rec==0)  && !strcmp(argv[0],  "R") )
8000f2d4:	3c028001 	lui	v0,0x8001
8000f2d8:	24426fc8 	addiu	v0,v0,28616
8000f2dc:	afa200a8 	sw	v0,168(sp)
		WDBG("mask=%x\n", mask);
		
		rtl8651_getAsicEthernetPHYReg( phyid, reg, &tmp );	
		tmp=(tmp&mask)>>bit1;
		WDBG("val=%x\n",tmp);
		printf("0x%x\n", tmp);
8000f2e0:	3c028001 	lui	v0,0x8001
8000f2e4:	2442432c 	addiu	v0,v0,17196
8000f2e8:	afa200bc 	sw	v0,188(sp)
	}	
	if( !strcmp(argv[0],  "PHY_END") )
8000f2ec:	3c178001 	lui	s7,0x8001
8000f2f0:	26f76c04 	addiu	s7,s7,27652
	
    while(1)
    {


	if(rec==1)
8000f2f4:	16740024 	bne	s3,s4,8000f388 <CmdPHY_Script+0x12c>
8000f2f8:	00002821 	move	a1,zero
	{	
		memset(buffer,0,LEN);
8000f2fc:	02402021 	move	a0,s2
8000f300:	0c00203d 	jal	800080f4 <memset>
8000f304:	24060080 	li	a2,128
		GetLine(buffer,LEN,1);
8000f308:	02402021 	move	a0,s2
8000f30c:	24050080 	li	a1,128
8000f310:	0c002193 	jal	8000864c <GetLine>
8000f314:	02803021 	move	a2,s4
		printf("\n");
8000f318:	0c002325 	jal	80008c94 <dprintf>
8000f31c:	8fa400ac 	lw	a0,172(sp)
		len=strlen(buffer);
8000f320:	0c002033 	jal	800080cc <strlen>
8000f324:	02402021 	move	a0,s2
8000f328:	00408021 	move	s0,v0
		
		memcpy(ptr+pidx,buffer, len); 
8000f32c:	03d52021 	addu	a0,s8,s5
8000f330:	02402821 	move	a1,s2
8000f334:	0c002046 	jal	80008118 <memcpy>
8000f338:	00403021 	move	a2,v0
		ptr[pidx+len]=0x0a;
8000f33c:	021ef021 	addu	s8,s0,s8
8000f340:	02be1021 	addu	v0,s5,s8
8000f344:	2403000a 	li	v1,10
8000f348:	a0430000 	sb	v1,0(v0)
		pidx+=(len+1);
8000f34c:	27de0001 	addiu	s8,s8,1
			ExtractACmdLine(ptr, buffer, 0);
	}

	
	WDBG("\n");
	argc = GetArgc( (const char *)buffer );
8000f350:	0c002129 	jal	800084a4 <GetArgc>
8000f354:	02402021 	move	a0,s2
	argv = GetArgv( (const char *)buffer );
8000f358:	0c002161 	jal	80008584 <GetArgv>
8000f35c:	02402021 	move	a0,s2
8000f360:	00408821 	move	s1,v0


	StrUpr(argv[0]);
8000f364:	0c002118 	jal	80008460 <StrUpr>
8000f368:	8c440000 	lw	a0,0(v0)
	WDBG("cmd=%s\n", argv[0] );
	
	if( (rec==1)  &&  !strcmp(argv[0],  "PHYID") )
8000f36c:	8e240000 	lw	a0,0(s1)
8000f370:	0c002015 	jal	80008054 <strcmp>
8000f374:	8fa500b0 	lw	a1,176(sp)
8000f378:	1440008c 	bnez	v0,8000f5ac <CmdPHY_Script+0x350>
8000f37c:	00000000 	nop
	{
		phyid=strtoul((const char*)(argv[1]), (char **)NULL, 16);
8000f380:	08003cef 	j	8000f3bc <CmdPHY_Script+0x160>
8000f384:	8e240004 	lw	a0,4(s1)
		ptr[pidx+len]=0x0a;
		pidx+=(len+1);
	}
	else
	{		
			ExtractACmdLine(ptr, buffer, 0);
8000f388:	02a02021 	move	a0,s5
8000f38c:	02402821 	move	a1,s2
8000f390:	0c002d33 	jal	8000b4cc <ExtractACmdLine>
8000f394:	00003021 	move	a2,zero
	}

	
	WDBG("\n");
	argc = GetArgc( (const char *)buffer );
8000f398:	0c002129 	jal	800084a4 <GetArgc>
8000f39c:	02402021 	move	a0,s2
	argv = GetArgv( (const char *)buffer );
8000f3a0:	0c002161 	jal	80008584 <GetArgv>
8000f3a4:	02402021 	move	a0,s2
8000f3a8:	00408821 	move	s1,v0


	StrUpr(argv[0]);
8000f3ac:	0c002118 	jal	80008460 <StrUpr>
8000f3b0:	8c440000 	lw	a0,0(v0)
8000f3b4:	08003cf9 	j	8000f3e4 <CmdPHY_Script+0x188>
8000f3b8:	00000000 	nop
	WDBG("cmd=%s\n", argv[0] );
	
	if( (rec==1)  &&  !strcmp(argv[0],  "PHYID") )
	{
		phyid=strtoul((const char*)(argv[1]), (char **)NULL, 16);
8000f3bc:	00002821 	move	a1,zero
8000f3c0:	0c0020c4 	jal	80008310 <strtoul>
8000f3c4:	24060010 	li	a2,16
8000f3c8:	08003d6b 	j	8000f5ac <CmdPHY_Script+0x350>
8000f3cc:	afa200a0 	sw	v0,160(sp)
		WDBG("id=%x\n", phyid);		
	}
	
	if(  (rec==1)  && !strcmp(argv[0],  "A") )
	{
		cnt=strtoul((const char*)(argv[1]), (char **)NULL, 10);
8000f3d0:	00002821 	move	a1,zero
8000f3d4:	0c0020c4 	jal	80008310 <strtoul>
8000f3d8:	2406000a 	li	a2,10
8000f3dc:	08003d4e 	j	8000f538 <CmdPHY_Script+0x2dc>
8000f3e0:	0040b021 	move	s6,v0
		WDBG("rep=%x\n", cnt);		
	}
	if(  (rec==0)  && !strcmp(argv[0],  "W") )
8000f3e4:	16600054 	bnez	s3,8000f538 <CmdPHY_Script+0x2dc>
8000f3e8:	00000000 	nop
8000f3ec:	8e240000 	lw	a0,0(s1)
8000f3f0:	0c002015 	jal	80008054 <strcmp>
8000f3f4:	8fa500a4 	lw	a1,164(sp)
8000f3f8:	14400073 	bnez	v0,8000f5c8 <CmdPHY_Script+0x36c>
8000f3fc:	00002821 	move	a1,zero
	{
		unsigned int reg,bit2,bit1,i,mask=0,val,tmp;
		reg=strtoul((const char*)(argv[1]), (char **)NULL, 10);
8000f400:	8e240004 	lw	a0,4(s1)
8000f404:	0c0020c4 	jal	80008310 <strtoul>
8000f408:	2406000a 	li	a2,10
8000f40c:	afa20098 	sw	v0,152(sp)
		bit2=strtoul((const char*)(argv[2]), (char **)NULL, 10);
8000f410:	8e240008 	lw	a0,8(s1)
8000f414:	00002821 	move	a1,zero
8000f418:	0c0020c4 	jal	80008310 <strtoul>
8000f41c:	2406000a 	li	a2,10
8000f420:	afa200b8 	sw	v0,184(sp)
		bit1=strtoul((const char*)(argv[3]), (char **)NULL, 10);
8000f424:	8e24000c 	lw	a0,12(s1)
8000f428:	00002821 	move	a1,zero
8000f42c:	0c0020c4 	jal	80008310 <strtoul>
8000f430:	2406000a 	li	a2,10
8000f434:	00408021 	move	s0,v0
		val=strtoul((const char*)(argv[4]), (char **)NULL, 16);
8000f438:	8e240010 	lw	a0,16(s1)
8000f43c:	00002821 	move	a1,zero
8000f440:	0c0020c4 	jal	80008310 <strtoul>
8000f444:	24060010 	li	a2,16
8000f448:	afa2009c 	sw	v0,156(sp)

		for(i=0; i<=(bit2-bit1); i++)
8000f44c:	8fa200b8 	lw	v0,184(sp)
8000f450:	00502823 	subu	a1,v0,s0
8000f454:	00001821 	move	v1,zero
8000f458:	00001021 	move	v0,zero
			mask= (mask<<1)|1;
8000f45c:	00031840 	sll	v1,v1,0x1
		reg=strtoul((const char*)(argv[1]), (char **)NULL, 10);
		bit2=strtoul((const char*)(argv[2]), (char **)NULL, 10);
		bit1=strtoul((const char*)(argv[3]), (char **)NULL, 10);
		val=strtoul((const char*)(argv[4]), (char **)NULL, 16);

		for(i=0; i<=(bit2-bit1); i++)
8000f460:	24420001 	addiu	v0,v0,1
8000f464:	00a2202b 	sltu	a0,a1,v0
8000f468:	1080fffc 	beqz	a0,8000f45c <CmdPHY_Script+0x200>
8000f46c:	34630001 	ori	v1,v1,0x1
			mask= (mask<<1)|1;
		mask=0xffffffff-(mask<<bit1);
8000f470:	02038004 	sllv	s0,v1,s0
		
		rtl8651_getAsicEthernetPHYReg( phyid, reg, &tmp );	
8000f474:	8fa400a0 	lw	a0,160(sp)
8000f478:	8fa50098 	lw	a1,152(sp)
8000f47c:	0c000933 	jal	800024cc <rtl8651_getAsicEthernetPHYReg>
8000f480:	27a60090 	addiu	a2,sp,144
		WDBG("mask=%x\n", mask);
		val=(tmp&mask)|val;
		WDBG("W reg=%x\n",val);		
		rtl8651_setAsicEthernetPHYReg( phyid, reg,  val);	
8000f484:	00108027 	nor	s0,zero,s0
8000f488:	8fa20090 	lw	v0,144(sp)
8000f48c:	02023024 	and	a2,s0,v0
8000f490:	8fa400a0 	lw	a0,160(sp)
8000f494:	8fa50098 	lw	a1,152(sp)
8000f498:	8fa3009c 	lw	v1,156(sp)
8000f49c:	0c000941 	jal	80002504 <rtl8651_setAsicEthernetPHYReg>
8000f4a0:	00c33025 	or	a2,a2,v1

	}
	if(  (rec==0)  && !strcmp(argv[0],  "R") )
8000f4a4:	08003d73 	j	8000f5cc <CmdPHY_Script+0x370>
8000f4a8:	8e240000 	lw	a0,0(s1)
	{
		unsigned int reg,bit2,bit1,mask=0,i,val,tmp;
		reg=strtoul((const char*)(argv[1]), (char **)NULL, 10);
8000f4ac:	00002821 	move	a1,zero
8000f4b0:	0c0020c4 	jal	80008310 <strtoul>
8000f4b4:	2406000a 	li	a2,10
8000f4b8:	afa2009c 	sw	v0,156(sp)
		bit2=strtoul((const char*)(argv[2]), (char **)NULL, 10);
8000f4bc:	8e240008 	lw	a0,8(s1)
8000f4c0:	00002821 	move	a1,zero
8000f4c4:	0c0020c4 	jal	80008310 <strtoul>
8000f4c8:	2406000a 	li	a2,10
8000f4cc:	00408021 	move	s0,v0
		bit1=strtoul((const char*)(argv[3]), (char **)NULL, 10);		
8000f4d0:	8e24000c 	lw	a0,12(s1)
8000f4d4:	00002821 	move	a1,zero
8000f4d8:	0c0020c4 	jal	80008310 <strtoul>
8000f4dc:	2406000a 	li	a2,10
8000f4e0:	afa20098 	sw	v0,152(sp)


		for(i=0; i<=(bit2-bit1); i++)
8000f4e4:	02022023 	subu	a0,s0,v0
8000f4e8:	00001021 	move	v0,zero
8000f4ec:	00008021 	move	s0,zero
			mask= (mask<<1)|1;
8000f4f0:	00108040 	sll	s0,s0,0x1
		reg=strtoul((const char*)(argv[1]), (char **)NULL, 10);
		bit2=strtoul((const char*)(argv[2]), (char **)NULL, 10);
		bit1=strtoul((const char*)(argv[3]), (char **)NULL, 10);		


		for(i=0; i<=(bit2-bit1); i++)
8000f4f4:	24420001 	addiu	v0,v0,1
8000f4f8:	0082182b 	sltu	v1,a0,v0
8000f4fc:	1060fffc 	beqz	v1,8000f4f0 <CmdPHY_Script+0x294>
8000f500:	36100001 	ori	s0,s0,0x1
			mask= (mask<<1)|1;
		mask=mask<<bit1;
		WDBG("mask=%x\n", mask);
		
		rtl8651_getAsicEthernetPHYReg( phyid, reg, &tmp );	
8000f504:	8fa400a0 	lw	a0,160(sp)
8000f508:	8fa5009c 	lw	a1,156(sp)
8000f50c:	0c000933 	jal	800024cc <rtl8651_getAsicEthernetPHYReg>
8000f510:	27a60090 	addiu	a2,sp,144
		tmp=(tmp&mask)>>bit1;
8000f514:	8fa20098 	lw	v0,152(sp)
8000f518:	00502804 	sllv	a1,s0,v0
8000f51c:	8fa20090 	lw	v0,144(sp)
8000f520:	00a22824 	and	a1,a1,v0
8000f524:	8fa30098 	lw	v1,152(sp)
8000f528:	00652806 	srlv	a1,a1,v1
8000f52c:	afa50090 	sw	a1,144(sp)
		WDBG("val=%x\n",tmp);
		printf("0x%x\n", tmp);
8000f530:	0c002325 	jal	80008c94 <dprintf>
8000f534:	8fa400bc 	lw	a0,188(sp)
	}	
	if( !strcmp(argv[0],  "PHY_END") )
8000f538:	8e240000 	lw	a0,0(s1)
8000f53c:	0c002015 	jal	80008054 <strcmp>
8000f540:	02e02821 	move	a1,s7
8000f544:	1440ff6b 	bnez	v0,8000f2f4 <CmdPHY_Script+0x98>
8000f548:	00000000 	nop
	{	
		if(rec==1)
8000f54c:	16740006 	bne	s3,s4,8000f568 <CmdPHY_Script+0x30c>
8000f550:	02a02021 	move	a0,s5
		{

			ExtractACmdLine(ptr, buffer, 1);
8000f554:	02402821 	move	a1,s2
8000f558:	0c002d33 	jal	8000b4cc <ExtractACmdLine>
8000f55c:	02803021 	move	a2,s4
8000f560:	08003cbd 	j	8000f2f4 <CmdPHY_Script+0x98>
8000f564:	00009821 	move	s3,zero
			rec=0;
		}
		else
		{
			ExtractACmdLine(ptr, buffer, 1);
8000f568:	02402821 	move	a1,s2
8000f56c:	0c002d33 	jal	8000b4cc <ExtractACmdLine>
8000f570:	02803021 	move	a2,s4
			cnt--;
8000f574:	26d6ffff 	addiu	s6,s6,-1
			if(cnt==0)
8000f578:	16c0ff5e 	bnez	s6,8000f2f4 <CmdPHY_Script+0x98>
8000f57c:	8fbf00e4 	lw	ra,228(sp)
	}	

	
    }

}
8000f580:	8fbe00e0 	lw	s8,224(sp)
8000f584:	8fb700dc 	lw	s7,220(sp)
8000f588:	8fb600d8 	lw	s6,216(sp)
8000f58c:	8fb500d4 	lw	s5,212(sp)
8000f590:	8fb400d0 	lw	s4,208(sp)
8000f594:	8fb300cc 	lw	s3,204(sp)
8000f598:	8fb200c8 	lw	s2,200(sp)
8000f59c:	8fb100c4 	lw	s1,196(sp)
8000f5a0:	8fb000c0 	lw	s0,192(sp)
8000f5a4:	03e00008 	jr	ra
8000f5a8:	27bd00e8 	addiu	sp,sp,232
	{
		phyid=strtoul((const char*)(argv[1]), (char **)NULL, 16);
		WDBG("id=%x\n", phyid);		
	}
	
	if(  (rec==1)  && !strcmp(argv[0],  "A") )
8000f5ac:	8e240000 	lw	a0,0(s1)
8000f5b0:	0c002015 	jal	80008054 <strcmp>
8000f5b4:	8fa500b4 	lw	a1,180(sp)
8000f5b8:	1440ff8a 	bnez	v0,8000f3e4 <CmdPHY_Script+0x188>
8000f5bc:	00000000 	nop
	{
		cnt=strtoul((const char*)(argv[1]), (char **)NULL, 10);
8000f5c0:	08003cf4 	j	8000f3d0 <CmdPHY_Script+0x174>
8000f5c4:	8e240004 	lw	a0,4(s1)
		val=(tmp&mask)|val;
		WDBG("W reg=%x\n",val);		
		rtl8651_setAsicEthernetPHYReg( phyid, reg,  val);	

	}
	if(  (rec==0)  && !strcmp(argv[0],  "R") )
8000f5c8:	8e240000 	lw	a0,0(s1)
8000f5cc:	0c002015 	jal	80008054 <strcmp>
8000f5d0:	8fa500a8 	lw	a1,168(sp)
8000f5d4:	1440ffd8 	bnez	v0,8000f538 <CmdPHY_Script+0x2dc>
8000f5d8:	00000000 	nop
	{
		unsigned int reg,bit2,bit1,mask=0,i,val,tmp;
		reg=strtoul((const char*)(argv[1]), (char **)NULL, 10);
8000f5dc:	08003d2b 	j	8000f4ac <CmdPHY_Script+0x250>
8000f5e0:	8e240004 	lw	a0,4(s1)

8000f5e4 <CmdPhyPageRegW>:
    dprintf("PHYID=0x%x, regID=0x%x, data=0x%x\r\n", phyid, regnum, uid);
	return 0;
}

int CmdPhyPageRegW(int argc, char* argv[])
{
8000f5e4:	27bdffd0 	addiu	sp,sp,-48
8000f5e8:	afbf002c 	sw	ra,44(sp)
8000f5ec:	afb30028 	sw	s3,40(sp)
8000f5f0:	afb20024 	sw	s2,36(sp)
8000f5f4:	afb10020 	sw	s1,32(sp)
8000f5f8:	afb0001c 	sw	s0,28(sp)
8000f5fc:	00a08821 	move	s1,a1
    unsigned long phyid, regnum, page;
    unsigned long data;
    unsigned int uid;

    phyid = strtoul((const char*)(argv[0]), (char **)NULL, 16);
8000f600:	8ca40000 	lw	a0,0(a1)
8000f604:	00002821 	move	a1,zero
8000f608:	0c0020c4 	jal	80008310 <strtoul>
8000f60c:	24060010 	li	a2,16
8000f610:	00408021 	move	s0,v0
    page = strtoul((const char*)(argv[1]), (char **)NULL, 16);
8000f614:	8e240004 	lw	a0,4(s1)
8000f618:	00002821 	move	a1,zero
8000f61c:	0c0020c4 	jal	80008310 <strtoul>
8000f620:	24060010 	li	a2,16
8000f624:	00409821 	move	s3,v0
    regnum = strtoul((const char*)(argv[2]), (char **)NULL, 16);
8000f628:	8e240008 	lw	a0,8(s1)
8000f62c:	00002821 	move	a1,zero
8000f630:	0c0020c4 	jal	80008310 <strtoul>
8000f634:	24060010 	li	a2,16
8000f638:	00409021 	move	s2,v0
    data= strtoul((const char*)(argv[3]), (char **)NULL, 16);
8000f63c:	8e24000c 	lw	a0,12(s1)
8000f640:	00002821 	move	a1,zero
8000f644:	0c0020c4 	jal	80008310 <strtoul>
8000f648:	24060010 	li	a2,16
8000f64c:	00408821 	move	s1,v0

	if (phyid == 0) phyid = 8;
8000f650:	24020008 	li	v0,8
	if(page > 0)
8000f654:	12600013 	beqz	s3,8000f6a4 <CmdPhyPageRegW+0xc0>
8000f658:	0050800a 	movz	s0,v0,s0
		rtl8651_setAsicEthernetPHYReg( phyid, 31, page  );
8000f65c:	02002021 	move	a0,s0
8000f660:	2405001f 	li	a1,31
8000f664:	0c000941 	jal	80002504 <rtl8651_setAsicEthernetPHYReg>
8000f668:	02603021 	move	a2,s3

    rtl8651_setAsicEthernetPHYReg( phyid, regnum, data );
8000f66c:	02002021 	move	a0,s0
8000f670:	02402821 	move	a1,s2
8000f674:	0c000941 	jal	80002504 <rtl8651_setAsicEthernetPHYReg>
8000f678:	02203021 	move	a2,s1
    rtl8651_getAsicEthernetPHYReg( phyid, regnum, &uid );
8000f67c:	02002021 	move	a0,s0
8000f680:	02402821 	move	a1,s2
8000f684:	0c000933 	jal	800024cc <rtl8651_getAsicEthernetPHYReg>
8000f688:	27a60010 	addiu	a2,sp,16

	if(page > 0)
		rtl8651_setAsicEthernetPHYReg( phyid, 31, 0  );
8000f68c:	02002021 	move	a0,s0
8000f690:	2405001f 	li	a1,31
8000f694:	0c000941 	jal	80002504 <rtl8651_setAsicEthernetPHYReg>
8000f698:	00003021 	move	a2,zero

    dprintf("PHYID=0x%x ,regID=0x%x, read back data=0x%x\r\n", phyid, regnum, uid);
8000f69c:	08003db2 	j	8000f6c8 <CmdPhyPageRegW+0xe4>
8000f6a0:	3c048001 	lui	a0,0x8001

	if (phyid == 0) phyid = 8;
	if(page > 0)
		rtl8651_setAsicEthernetPHYReg( phyid, 31, page  );

    rtl8651_setAsicEthernetPHYReg( phyid, regnum, data );
8000f6a4:	02002021 	move	a0,s0
8000f6a8:	02402821 	move	a1,s2
8000f6ac:	0c000941 	jal	80002504 <rtl8651_setAsicEthernetPHYReg>
8000f6b0:	02203021 	move	a2,s1
    rtl8651_getAsicEthernetPHYReg( phyid, regnum, &uid );
8000f6b4:	02002021 	move	a0,s0
8000f6b8:	02402821 	move	a1,s2
8000f6bc:	0c000933 	jal	800024cc <rtl8651_getAsicEthernetPHYReg>
8000f6c0:	27a60010 	addiu	a2,sp,16

	if(page > 0)
		rtl8651_setAsicEthernetPHYReg( phyid, 31, 0  );

    dprintf("PHYID=0x%x ,regID=0x%x, read back data=0x%x\r\n", phyid, regnum, uid);
8000f6c4:	3c048001 	lui	a0,0x8001
8000f6c8:	24846c0c 	addiu	a0,a0,27660
8000f6cc:	02002821 	move	a1,s0
8000f6d0:	02403021 	move	a2,s2
8000f6d4:	0c002325 	jal	80008c94 <dprintf>
8000f6d8:	8fa70010 	lw	a3,16(sp)
	return 0;
}
8000f6dc:	00001021 	move	v0,zero
8000f6e0:	8fbf002c 	lw	ra,44(sp)
8000f6e4:	8fb30028 	lw	s3,40(sp)
8000f6e8:	8fb20024 	lw	s2,36(sp)
8000f6ec:	8fb10020 	lw	s1,32(sp)
8000f6f0:	8fb0001c 	lw	s0,28(sp)
8000f6f4:	03e00008 	jr	ra
8000f6f8:	27bd0030 	addiu	sp,sp,48

8000f6fc <CmdPhyPageRegR>:
    dprintf("PHYID=0x%x ,regID=0x%x, read back data=0x%x\r\n", phyid, regnum, uid);
	return 0;
}

int CmdPhyPageRegR(int argc, char* argv[])
{
8000f6fc:	27bdffd8 	addiu	sp,sp,-40
8000f700:	afbf0024 	sw	ra,36(sp)
8000f704:	afb20020 	sw	s2,32(sp)
8000f708:	afb1001c 	sw	s1,28(sp)
8000f70c:	afb00018 	sw	s0,24(sp)
8000f710:	00a08821 	move	s1,a1
    unsigned long phyid, regnum, page;
    unsigned int uid;

    phyid = strtoul((const char*)(argv[0]), (char **)NULL, 16);
8000f714:	8ca40000 	lw	a0,0(a1)
8000f718:	00002821 	move	a1,zero
8000f71c:	0c0020c4 	jal	80008310 <strtoul>
8000f720:	24060010 	li	a2,16
8000f724:	00408021 	move	s0,v0
    page = strtoul((const char*)(argv[1]), (char **)NULL, 16);
8000f728:	8e240004 	lw	a0,4(s1)
8000f72c:	00002821 	move	a1,zero
8000f730:	0c0020c4 	jal	80008310 <strtoul>
8000f734:	24060010 	li	a2,16
8000f738:	00409021 	move	s2,v0
    regnum = strtoul((const char*)(argv[2]), (char **)NULL, 16);
8000f73c:	8e240008 	lw	a0,8(s1)
8000f740:	00002821 	move	a1,zero
8000f744:	0c0020c4 	jal	80008310 <strtoul>
8000f748:	24060010 	li	a2,16
8000f74c:	00408821 	move	s1,v0

	if (phyid == 0) phyid = 8;
8000f750:	24020008 	li	v0,8
	if(page > 0)
8000f754:	1240000f 	beqz	s2,8000f794 <CmdPhyPageRegR+0x98>
8000f758:	0050800a 	movz	s0,v0,s0
		rtl8651_setAsicEthernetPHYReg( phyid, 31, page  );
8000f75c:	02002021 	move	a0,s0
8000f760:	2405001f 	li	a1,31
8000f764:	0c000941 	jal	80002504 <rtl8651_setAsicEthernetPHYReg>
8000f768:	02403021 	move	a2,s2
	
    rtl8651_getAsicEthernetPHYReg( phyid, regnum, &uid );
8000f76c:	02002021 	move	a0,s0
8000f770:	02202821 	move	a1,s1
8000f774:	0c000933 	jal	800024cc <rtl8651_getAsicEthernetPHYReg>
8000f778:	27a60010 	addiu	a2,sp,16

	if(page > 0)
		rtl8651_setAsicEthernetPHYReg( phyid, 31, 0  );
8000f77c:	02002021 	move	a0,s0
8000f780:	2405001f 	li	a1,31
8000f784:	0c000941 	jal	80002504 <rtl8651_setAsicEthernetPHYReg>
8000f788:	00003021 	move	a2,zero
	
    dprintf("PHYID=0x%x, regID=0x%x, data=0x%x\r\n", phyid, regnum, uid);
8000f78c:	08003dea 	j	8000f7a8 <CmdPhyPageRegR+0xac>
8000f790:	3c048001 	lui	a0,0x8001

	if (phyid == 0) phyid = 8;
	if(page > 0)
		rtl8651_setAsicEthernetPHYReg( phyid, 31, page  );
	
    rtl8651_getAsicEthernetPHYReg( phyid, regnum, &uid );
8000f794:	02002021 	move	a0,s0
8000f798:	02202821 	move	a1,s1
8000f79c:	0c000933 	jal	800024cc <rtl8651_getAsicEthernetPHYReg>
8000f7a0:	27a60010 	addiu	a2,sp,16

	if(page > 0)
		rtl8651_setAsicEthernetPHYReg( phyid, 31, 0  );
	
    dprintf("PHYID=0x%x, regID=0x%x, data=0x%x\r\n", phyid, regnum, uid);
8000f7a4:	3c048001 	lui	a0,0x8001
8000f7a8:	24846bb0 	addiu	a0,a0,27568
8000f7ac:	02002821 	move	a1,s0
8000f7b0:	02203021 	move	a2,s1
8000f7b4:	0c002325 	jal	80008c94 <dprintf>
8000f7b8:	8fa70010 	lw	a3,16(sp)
	return 0;
}
8000f7bc:	00001021 	move	v0,zero
8000f7c0:	8fbf0024 	lw	ra,36(sp)
8000f7c4:	8fb20020 	lw	s2,32(sp)
8000f7c8:	8fb1001c 	lw	s1,28(sp)
8000f7cc:	8fb00018 	lw	s0,24(sp)
8000f7d0:	03e00008 	jr	ra
8000f7d4:	27bd0028 	addiu	sp,sp,40

8000f7d8 <CmdPHYregW>:
    dprintf("PHYID=0x%x, regID=0x%x, data=0x%x\r\n", phyid, regnum, uid);
	return 0;
}

int CmdPHYregW(int argc, char* argv[])
{
8000f7d8:	27bdffd8 	addiu	sp,sp,-40
8000f7dc:	afbf0024 	sw	ra,36(sp)
8000f7e0:	afb20020 	sw	s2,32(sp)
8000f7e4:	afb1001c 	sw	s1,28(sp)
8000f7e8:	afb00018 	sw	s0,24(sp)
8000f7ec:	00a08021 	move	s0,a1
    unsigned long phyid, regnum;
    unsigned long data;
    unsigned int uid,tmp;

    phyid = strtoul((const char*)(argv[0]), (char **)NULL, 16);
8000f7f0:	8ca40000 	lw	a0,0(a1)
8000f7f4:	00002821 	move	a1,zero
8000f7f8:	0c0020c4 	jal	80008310 <strtoul>
8000f7fc:	24060010 	li	a2,16
8000f800:	00408821 	move	s1,v0
    regnum = strtoul((const char*)(argv[1]), (char **)NULL, 16);
8000f804:	8e040004 	lw	a0,4(s0)
8000f808:	00002821 	move	a1,zero
8000f80c:	0c0020c4 	jal	80008310 <strtoul>
8000f810:	24060010 	li	a2,16
8000f814:	00409021 	move	s2,v0
    data= strtoul((const char*)(argv[2]), (char **)NULL, 16);
8000f818:	8e040008 	lw	a0,8(s0)
8000f81c:	00002821 	move	a1,zero
8000f820:	0c0020c4 	jal	80008310 <strtoul>
8000f824:	24060010 	li	a2,16

    rtl8651_setAsicEthernetPHYReg( phyid, regnum, data );
8000f828:	02202021 	move	a0,s1
8000f82c:	02402821 	move	a1,s2
8000f830:	0c000941 	jal	80002504 <rtl8651_setAsicEthernetPHYReg>
8000f834:	00403021 	move	a2,v0
    rtl8651_getAsicEthernetPHYReg( phyid, regnum, &tmp );
8000f838:	02202021 	move	a0,s1
8000f83c:	02402821 	move	a1,s2
8000f840:	0c000933 	jal	800024cc <rtl8651_getAsicEthernetPHYReg>
8000f844:	27a60010 	addiu	a2,sp,16
    uid=tmp;
    dprintf("PHYID=0x%x ,regID=0x%x, read back data=0x%x\r\n", phyid, regnum, uid);
8000f848:	3c048001 	lui	a0,0x8001
8000f84c:	24846c0c 	addiu	a0,a0,27660
8000f850:	02202821 	move	a1,s1
8000f854:	02403021 	move	a2,s2
8000f858:	0c002325 	jal	80008c94 <dprintf>
8000f85c:	8fa70010 	lw	a3,16(sp)
	return 0;
}
8000f860:	00001021 	move	v0,zero
8000f864:	8fbf0024 	lw	ra,36(sp)
8000f868:	8fb20020 	lw	s2,32(sp)
8000f86c:	8fb1001c 	lw	s1,28(sp)
8000f870:	8fb00018 	lw	s0,24(sp)
8000f874:	03e00008 	jr	ra
8000f878:	27bd0028 	addiu	sp,sp,40

8000f87c <TestCmd_MDIOW>:
	}
	return 0;
}

int TestCmd_MDIOW( int argc, char* argv[] )
{
8000f87c:	27bdffe0 	addiu	sp,sp,-32
8000f880:	afbf001c 	sw	ra,28(sp)
8000f884:	afb20018 	sw	s2,24(sp)
8000f888:	afb10014 	sw	s1,20(sp)
8000f88c:	afb00010 	sw	s0,16(sp)
	if(argc < 3) {
8000f890:	28840003 	slti	a0,a0,3
8000f894:	10800006 	beqz	a0,8000f8b0 <TestCmd_MDIOW+0x34>
8000f898:	00a08021 	move	s0,a1
		printf("Parameters not enough!\n");
8000f89c:	3c048001 	lui	a0,0x8001
8000f8a0:	0c002325 	jal	80008c94 <dprintf>
8000f8a4:	248467a0 	addiu	a0,a0,26528
		return 1;
8000f8a8:	08003e46 	j	8000f918 <TestCmd_MDIOW+0x9c>
8000f8ac:	24020001 	li	v0,1
	}
	
	unsigned int phyid = strtoul((const char*)(argv[0]), (char **)NULL, 16);		
8000f8b0:	8ca40000 	lw	a0,0(a1)
8000f8b4:	00002821 	move	a1,zero
8000f8b8:	0c0020c4 	jal	80008310 <strtoul>
8000f8bc:	24060010 	li	a2,16
8000f8c0:	00408821 	move	s1,v0
	unsigned int reg = strtoul((const char*)(argv[1]), (char **)NULL, 10);		
8000f8c4:	8e040004 	lw	a0,4(s0)
8000f8c8:	00002821 	move	a1,zero
8000f8cc:	0c0020c4 	jal	80008310 <strtoul>
8000f8d0:	2406000a 	li	a2,10
8000f8d4:	00409021 	move	s2,v0
	unsigned int data = strtoul((const char*)(argv[2]), (char **)NULL, 16);		
8000f8d8:	8e040008 	lw	a0,8(s0)
8000f8dc:	00002821 	move	a1,zero
8000f8e0:	0c0020c4 	jal	80008310 <strtoul>
8000f8e4:	24060010 	li	a2,16
8000f8e8:	00408021 	move	s0,v0

	dprintf("Write PhyID=0x%x Reg=%02d data=0x%x\r\n",phyid, reg,data);
8000f8ec:	3c048001 	lui	a0,0x8001
8000f8f0:	24846c3c 	addiu	a0,a0,27708
8000f8f4:	02202821 	move	a1,s1
8000f8f8:	02403021 	move	a2,s2
8000f8fc:	0c002325 	jal	80008c94 <dprintf>
8000f900:	00403821 	move	a3,v0
	rtl8651_setAsicEthernetPHYReg(phyid,reg,data); 
8000f904:	02202021 	move	a0,s1
8000f908:	02402821 	move	a1,s2
8000f90c:	0c000941 	jal	80002504 <rtl8651_setAsicEthernetPHYReg>
8000f910:	02003021 	move	a2,s0
8000f914:	00001021 	move	v0,zero

	return 0;
}
8000f918:	8fbf001c 	lw	ra,28(sp)
8000f91c:	8fb20018 	lw	s2,24(sp)
8000f920:	8fb10014 	lw	s1,20(sp)
8000f924:	8fb00010 	lw	s0,16(sp)
8000f928:	03e00008 	jr	ra
8000f92c:	27bd0020 	addiu	sp,sp,32

8000f930 <CmdTest>:

}
//============================================================================

int CmdTest(int argc, char* argv[])
{
8000f930:	27bdffc8 	addiu	sp,sp,-56
8000f934:	afbf0034 	sw	ra,52(sp)
8000f938:	afb60030 	sw	s6,48(sp)
8000f93c:	afb5002c 	sw	s5,44(sp)
8000f940:	afb40028 	sw	s4,40(sp)
8000f944:	afb30024 	sw	s3,36(sp)
8000f948:	afb20020 	sw	s2,32(sp)
8000f94c:	afb1001c 	sw	s1,28(sp)
8000f950:	afb00018 	sw	s0,24(sp)


#if 1
	int i,j,s,size,loop,st=0,ed=0;

	if( argc < 1 ) 
8000f954:	1c800006 	bgtz	a0,8000f970 <CmdTest+0x40>
8000f958:	00a08021 	move	s0,a1
	{
		dprintf("Usage: test <len> <loop>\n");		
8000f95c:	3c048001 	lui	a0,0x8001
8000f960:	0c002325 	jal	80008c94 <dprintf>
8000f964:	24846c64 	addiu	a0,a0,27748
		return;	
8000f968:	08003e8a 	j	8000fa28 <CmdTest+0xf8>
8000f96c:	8fbf0034 	lw	ra,52(sp)
	}
	size = strtoul((const char*)(argv[0]), (char **)NULL, 16);
8000f970:	8ca40000 	lw	a0,0(a1)
8000f974:	00002821 	move	a1,zero
8000f978:	0c0020c4 	jal	80008310 <strtoul>
8000f97c:	24060010 	li	a2,16
8000f980:	0040a821 	move	s5,v0
	loop = strtoul((const char*)(argv[1]), (char **)NULL, 16);
8000f984:	8e040004 	lw	a0,4(s0)
8000f988:	00002821 	move	a1,zero
8000f98c:	0c0020c4 	jal	80008310 <strtoul>
8000f990:	24060010 	li	a2,16



	flush_cache();
8000f994:	0c001eae 	jal	80007ab8 <flush_cache>
8000f998:	00409821 	move	s3,v0
8000f99c:	40098002 	mfc0	t1,c0_config2
	//disable L2
	s=(1<<12);
	write_32bit_cp0_register_sel(16, s, 2);
	printf("Disable L2 cache\n");
#else
	s=read_32bit_cp0_register_sel(16,  2);
8000f9a0:	01292825 	or	a1,t1,t1
	printf("L2 cache ByPass=%d\n", (s&(1<<12))>>12);
8000f9a4:	3c048001 	lui	a0,0x8001
8000f9a8:	24846c80 	addiu	a0,a0,27776
8000f9ac:	0c002325 	jal	80008c94 <dprintf>
8000f9b0:	7ca50300 	ext	a1,a1,0xc,0x1
#endif

	for(j=0; j<loop; j++)
8000f9b4:	1a60001b 	blez	s3,8000fa24 <CmdTest+0xf4>
8000f9b8:	00008821 	move	s1,zero
	{
		st=jiffies;
8000f9bc:	3c128002 	lui	s2,0x8002
		for(i=0x80300000;i<0x80300000+size; i+=4)    //seq
		{
			REG32(i)=REG32(i);
		}
*/
		for(i=0x80300000;i<0x80300000+size; i+=32)   //cacheline
8000f9c0:	3c148030 	lui	s4,0x8030
8000f9c4:	02b48021 	addu	s0,s5,s4
8000f9c8:	36950001 	ori	s5,s4,0x1
8000f9cc:	0215a82b 	sltu	s5,s0,s5
			REG32(i)=REG32(i);
		}

		
		ed=jiffies;
		printf("loop=%d, st=%d, ed=%d, spend j=%d\n", j, st,ed,ed-st);		
8000f9d0:	3c168001 	lui	s6,0x8001
8000f9d4:	26d66c94 	addiu	s6,s6,27796
	printf("L2 cache ByPass=%d\n", (s&(1<<12))>>12);
#endif

	for(j=0; j<loop; j++)
	{
		st=jiffies;
8000f9d8:	8e463e60 	lw	a2,15968(s2)
		for(i=0x80300000;i<0x80300000+size; i+=4)    //seq
		{
			REG32(i)=REG32(i);
		}
*/
		for(i=0x80300000;i<0x80300000+size; i+=32)   //cacheline
8000f9dc:	16a00007 	bnez	s5,8000f9fc <CmdTest+0xcc>
8000f9e0:	02801021 	move	v0,s4
		{
			REG32(i)=REG32(i);
8000f9e4:	8c430000 	lw	v1,0(v0)
8000f9e8:	ac430000 	sw	v1,0(v0)
		for(i=0x80300000;i<0x80300000+size; i+=4)    //seq
		{
			REG32(i)=REG32(i);
		}
*/
		for(i=0x80300000;i<0x80300000+size; i+=32)   //cacheline
8000f9ec:	24420020 	addiu	v0,v0,32
8000f9f0:	0050182b 	sltu	v1,v0,s0
8000f9f4:	1460fffb 	bnez	v1,8000f9e4 <CmdTest+0xb4>
8000f9f8:	00000000 	nop
		{
			REG32(i)=REG32(i);
		}

		
		ed=jiffies;
8000f9fc:	8e473e60 	lw	a3,15968(s2)
		printf("loop=%d, st=%d, ed=%d, spend j=%d\n", j, st,ed,ed-st);		
8000fa00:	00e61023 	subu	v0,a3,a2
8000fa04:	afa20010 	sw	v0,16(sp)
8000fa08:	02c02021 	move	a0,s6
8000fa0c:	0c002325 	jal	80008c94 <dprintf>
8000fa10:	02202821 	move	a1,s1
#else
	s=read_32bit_cp0_register_sel(16,  2);
	printf("L2 cache ByPass=%d\n", (s&(1<<12))>>12);
#endif

	for(j=0; j<loop; j++)
8000fa14:	26310001 	addiu	s1,s1,1
8000fa18:	0233102a 	slt	v0,s1,s3
8000fa1c:	1440ffee 	bnez	v0,8000f9d8 <CmdTest+0xa8>
8000fa20:	00000000 	nop

	
#endif

	
}
8000fa24:	8fbf0034 	lw	ra,52(sp)
8000fa28:	8fb60030 	lw	s6,48(sp)
8000fa2c:	8fb5002c 	lw	s5,44(sp)
8000fa30:	8fb40028 	lw	s4,40(sp)
8000fa34:	8fb30024 	lw	s3,36(sp)
8000fa38:	8fb20020 	lw	s2,32(sp)
8000fa3c:	8fb1001c 	lw	s1,28(sp)
8000fa40:	8fb00018 	lw	s0,24(sp)
8000fa44:	03e00008 	jr	ra
8000fa48:	27bd0038 	addiu	sp,sp,56

8000fa4c <CmdXModem>:
//==============================================================

//------------------------------------------------------------------------
#ifndef CONFIG_RTL8196E
int CmdXModem(int argc, char* argv[])
{
8000fa4c:	27bdffd8 	addiu	sp,sp,-40
8000fa50:	afbf0024 	sw	ra,36(sp)
8000fa54:	afb30020 	sw	s3,32(sp)
8000fa58:	afb2001c 	sw	s2,28(sp)
8000fa5c:	afb10018 	sw	s1,24(sp)
8000fa60:	afb00014 	sw	s0,20(sp)
8000fa64:	00808021 	move	s0,a0
	unsigned char *load_buf = (char*)0x80300000;
	unsigned int jump=0;
	//unsigned char *dest_buf = (char*)0xbd000000;

	if( argc < 1 ) 
8000fa68:	1c800006 	bgtz	a0,8000fa84 <CmdXModem+0x38>
8000fa6c:	00a08821 	move	s1,a1
	{
		dprintf("Usage: xmodem <buf_addr> [jump]\n");		
8000fa70:	3c048001 	lui	a0,0x8001
8000fa74:	0c002325 	jal	80008c94 <dprintf>
8000fa78:	24846cb8 	addiu	a0,a0,27832
		flush_cache(); 
		prom_printf("\nJump to.......\n");

		jumpF();
	}
}; 
8000fa7c:	08003ed0 	j	8000fb40 <CmdXModem+0xf4>
8000fa80:	8fbf0024 	lw	ra,36(sp)
	if( argc < 1 ) 
	{
		dprintf("Usage: xmodem <buf_addr> [jump]\n");		
		return;	
	}
	load_buf = strtoul((const char*)(argv[0]), (char **)NULL, 16);
8000fa84:	8ca40000 	lw	a0,0(a1)
8000fa88:	00002821 	move	a1,zero
8000fa8c:	0c0020c4 	jal	80008310 <strtoul>
8000fa90:	24060010 	li	a2,16
8000fa94:	00409021 	move	s2,v0
	
	if(argc>1)	
8000fa98:	2a100002 	slti	s0,s0,2
8000fa9c:	16000006 	bnez	s0,8000fab8 <CmdXModem+0x6c>
8000faa0:	00009821 	move	s3,zero
	jump = strtoul((const char*)(argv[1]), (char **)NULL, 16);	
8000faa4:	8e240004 	lw	a0,4(s1)
8000faa8:	00002821 	move	a1,zero
8000faac:	0c0020c4 	jal	80008310 <strtoul>
8000fab0:	24060010 	li	a2,16
8000fab4:	00409821 	move	s3,v0
	

	int len;
	len=xmodem_receive(load_buf);
8000fab8:	0c0035b5 	jal	8000d6d4 <xmodem_receive>
8000fabc:	02402021 	move	a0,s2
		if(len!=0)
8000fac0:	10400007 	beqz	v0,8000fae0 <CmdXModem+0x94>
8000fac4:	00408021 	move	s0,v0
		{	printf("Rx len=%d \n", len);			
8000fac8:	3c048001 	lui	a0,0x8001
8000facc:	24846cdc 	addiu	a0,a0,27868
8000fad0:	0c002325 	jal	80008c94 <dprintf>
8000fad4:	00402821 	move	a1,v0
8000fad8:	08003ecf 	j	8000fb3c <CmdXModem+0xf0>
8000fadc:	02001021 	move	v0,s0
			return  len;			
		}
		else
			printf("Download failed!!\n");
8000fae0:	3c048001 	lui	a0,0x8001
8000fae4:	0c002325 	jal	80008c94 <dprintf>
8000fae8:	24846ce8 	addiu	a0,a0,27880


	if(jump)
8000faec:	12600014 	beqz	s3,8000fb40 <CmdXModem+0xf4>
8000faf0:	8fbf0024 	lw	ra,36(sp)
	{	
		void (*jumpF)(void);
		jumpF = (void *)(load_buf);
	
		REG32(GIMR_REG)=0; // mask all interrupt	    
8000faf4:	3c02b800 	lui	v0,0xb800
8000faf8:	34423000 	ori	v0,v0,0x3000
8000fafc:	ac400000 	sw	zero,0(v0)
8000fb00:	40016000 	mfc0	at,c0_status
8000fb04:	34210001 	ori	at,at,0x1
8000fb08:	38210001 	xori	at,at,0x1
8000fb0c:	40816000 	mtc0	at,c0_status
8000fb10:	000000c0 	ehb
	...
		cli();
	
		flush_cache(); 
8000fb20:	0c001eae 	jal	80007ab8 <flush_cache>
8000fb24:	00000000 	nop
		prom_printf("\nJump to.......\n");
8000fb28:	3c048001 	lui	a0,0x8001
8000fb2c:	0c0023a7 	jal	80008e9c <prom_printf>
8000fb30:	24846cfc 	addiu	a0,a0,27900

		jumpF();
8000fb34:	0240f809 	jalr	s2
8000fb38:	00000000 	nop
	}
}; 
8000fb3c:	8fbf0024 	lw	ra,36(sp)
8000fb40:	8fb30020 	lw	s3,32(sp)
8000fb44:	8fb2001c 	lw	s2,28(sp)
8000fb48:	8fb10018 	lw	s1,24(sp)
8000fb4c:	8fb00014 	lw	s0,20(sp)
8000fb50:	03e00008 	jr	ra
8000fb54:	27bd0028 	addiu	sp,sp,40

8000fb58 <MxSpdupThanLexra>:
//==============================================================



void MxSpdupThanLexra()
{
8000fb58:	27bdffe8 	addiu	sp,sp,-24
8000fb5c:	afbf0014 	sw	ra,20(sp)

	//printf("MxSpdupThanLexra\n");

	#define GET_BITVAL(v,bitpos,pat) ((v& ((unsigned int)pat<<bitpos))>>bitpos)
	#define RANG5  0x1f
	unsigned char m2x_freq_sel=GET_BITVAL(REG32(SYS_HW_STRAP), 10, RANG5);
8000fb60:	3c02b800 	lui	v0,0xb800
8000fb64:	34420008 	ori	v0,v0,0x8
8000fb68:	8c420000 	lw	v0,0(v0)
	

	if(m2x_freq_sel>= 0x0f)           // M2x > lexra=200M   
8000fb6c:	7c422280 	ext	v0,v0,0xa,0x5
8000fb70:	2c42000f 	sltiu	v0,v0,15
8000fb74:	14400026 	bnez	v0,8000fc10 <MxSpdupThanLexra+0xb8>
8000fb78:	8fbf0014 	lw	ra,20(sp)
		printf("Mx clk > Lexra clk\n");
8000fb7c:	3c048001 	lui	a0,0x8001
8000fb80:	0c002325 	jal	80008c94 <dprintf>
8000fb84:	24846d10 	addiu	a0,a0,27920
	else
		return ;

	//-------------------------
  	request_IRQ(8, &irq_timer, NULL); 
8000fb88:	24040008 	li	a0,8
8000fb8c:	3c058001 	lui	a1,0x8001
8000fb90:	24a57720 	addiu	a1,a1,30496
8000fb94:	0c000274 	jal	800009d0 <request_IRQ>
8000fb98:	00003021 	move	a2,zero


	extern long glexra_clock;
       timer_init(glexra_clock);	   //run 10msec
8000fb9c:	3c028001 	lui	v0,0x8001
8000fba0:	0c0038f4 	jal	8000e3d0 <timer_init>
8000fba4:	8c447710 	lw	a0,30480(v0)
	//--------------------------
	
	#define SYS_HS0_CTRL 0xb80000a0
	#define BIT(x)	(1 << x)	
	REG32(SYS_HS0_CTRL) |= BIT(0) | BIT(1) | BIT(2);   // LX0 > Mx clock
8000fba8:	3c02b800 	lui	v0,0xb800
8000fbac:	344300a0 	ori	v1,v0,0xa0
8000fbb0:	8c640000 	lw	a0,0(v1)
8000fbb4:	34840007 	ori	a0,a0,0x7
8000fbb8:	ac640000 	sw	a0,0(v1)
	
	
		#if 1			
			//printf("llx0\n");
			REG32(SYS_BIST_CTRL) |= (1<<2) ;	  //lock bus arb2
8000fbbc:	34420014 	ori	v0,v0,0x14
8000fbc0:	8c430000 	lw	v1,0(v0)
8000fbc4:	34630004 	ori	v1,v1,0x4
8000fbc8:	ac430000 	sw	v1,0(v0)
			while( (REG32(SYS_BIST_DONE)&(1<<0))==0)  {}; //wait bit to 1, is mean lock ok	
8000fbcc:	3c03b800 	lui	v1,0xb800
8000fbd0:	34630020 	ori	v1,v1,0x20
8000fbd4:	8c620000 	lw	v0,0(v1)
8000fbd8:	30420001 	andi	v0,v0,0x1
8000fbdc:	1040fffd 	beqz	v0,8000fbd4 <MxSpdupThanLexra+0x7c>
8000fbe0:	3c02b800 	lui	v0,0xb800
	//	__asm__ volatile("nop");


		#if 1
			//printf("ulx0\n");	
			REG32(SYS_BIST_CTRL) &= ~(1<<2);	//unlock
8000fbe4:	34420014 	ori	v0,v0,0x14
8000fbe8:	8c440000 	lw	a0,0(v0)
8000fbec:	2403fffb 	li	v1,-5
8000fbf0:	00831824 	and	v1,a0,v1
8000fbf4:	ac430000 	sw	v1,0(v0)
			while( (REG32(SYS_BIST_DONE)&(1<<0))==(1<<0)) {};  //wait bit to 0  unlock
8000fbf8:	3c03b800 	lui	v1,0xb800
8000fbfc:	34630020 	ori	v1,v1,0x20
8000fc00:	8c620000 	lw	v0,0(v1)
8000fc04:	30420001 	andi	v0,v0,0x1
8000fc08:	1440fffd 	bnez	v0,8000fc00 <MxSpdupThanLexra+0xa8>
8000fc0c:	8fbf0014 	lw	ra,20(sp)
			//while( (REG32(SYS_BIST_DONE)&(1<<2))==(1<<2)) {};  //wait bit to 0  unlock				
		#endif

			//printf("done\n");

}
8000fc10:	03e00008 	jr	ra
8000fc14:	27bd0018 	addiu	sp,sp,24

8000fc18 <check_cpu_speed>:
#else
unsigned long loops_per_sec = 0x1db000 * HZ;	// @CPU 390MHz, DDR 195 MHz (this will be update in check_cpu_speed())
#endif

int check_cpu_speed(void)
{
8000fc18:	27bdffd8 	addiu	sp,sp,-40
8000fc1c:	afbf0024 	sw	ra,36(sp)
8000fc20:	afb20020 	sw	s2,32(sp)
8000fc24:	afb1001c 	sw	s1,28(sp)
8000fc28:	afb00018 	sw	s0,24(sp)

	unsigned volatile long ticks, loopbit;
	int lps_precision = LPS_PREC;
      
  // RTL8198
  	request_IRQ(14, &irq_timer, NULL); 
8000fc2c:	2404000e 	li	a0,14
8000fc30:	3c058001 	lui	a1,0x8001
8000fc34:	24a57720 	addiu	a1,a1,30496
8000fc38:	0c000274 	jal	800009d0 <request_IRQ>
8000fc3c:	00003021 	move	a2,zero

	extern long glexra_clock;
//	printf("timer init\n");
    timer_init(glexra_clock);	
8000fc40:	3c028001 	lui	v0,0x8001
8000fc44:	0c0038f4 	jal	8000e3d0 <timer_init>
8000fc48:	8c447710 	lw	a0,30480(v0)

//return 999;

	loops_per_jiffy = (1<<12);
8000fc4c:	24031000 	li	v1,4096
8000fc50:	3c028001 	lui	v0,0x8001
8000fc54:	ac4379ec 	sw	v1,31212(v0)
	while (loops_per_jiffy <<= 1) {
8000fc58:	00408821 	move	s1,v0
8000fc5c:	08003f2b 	j	8000fcac <check_cpu_speed+0x94>
8000fc60:	3c108002 	lui	s0,0x8002
		/* wait for "start of" clock tick */
		ticks = jiffies;
8000fc64:	8e023e60 	lw	v0,15968(s0)
8000fc68:	afa20010 	sw	v0,16(sp)
		while (ticks == jiffies)
8000fc6c:	8fa30010 	lw	v1,16(sp)
8000fc70:	8e023e60 	lw	v0,15968(s0)
8000fc74:	1062fffd 	beq	v1,v0,8000fc6c <check_cpu_speed+0x54>
8000fc78:	00000000 	nop
			/* nothing */;
		/* Go .. */
		ticks = jiffies;
8000fc7c:	8e023e60 	lw	v0,15968(s0)
8000fc80:	afa20010 	sw	v0,16(sp)
		__delay(loops_per_jiffy);
8000fc84:	8e2479ec 	lw	a0,31212(s1)
8000fc88:	0c0038e0 	jal	8000e380 <__delay>
8000fc8c:	00000000 	nop
		ticks = jiffies - ticks;
8000fc90:	8e033e60 	lw	v1,15968(s0)
8000fc94:	8fa20010 	lw	v0,16(sp)
8000fc98:	00621023 	subu	v0,v1,v0
8000fc9c:	afa20010 	sw	v0,16(sp)
		if (ticks)
8000fca0:	8fa20010 	lw	v0,16(sp)
8000fca4:	14400007 	bnez	v0,8000fcc4 <check_cpu_speed+0xac>
8000fca8:	3c028001 	lui	v0,0x8001
    timer_init(glexra_clock);	

//return 999;

	loops_per_jiffy = (1<<12);
	while (loops_per_jiffy <<= 1) {
8000fcac:	8e2279ec 	lw	v0,31212(s1)
8000fcb0:	00021040 	sll	v0,v0,0x1
8000fcb4:	ae2279ec 	sw	v0,31212(s1)
8000fcb8:	8e2279ec 	lw	v0,31212(s1)
8000fcbc:	1440ffe9 	bnez	v0,8000fc64 <check_cpu_speed+0x4c>
8000fcc0:	3c028001 	lui	v0,0x8001
		if (ticks)
			break;
	}
/* Do a binary approximation to get loops_per_jiffy set to equal one clock
   (up to lps_precision bits) */
	loops_per_jiffy >>= 1;
8000fcc4:	8c4379ec 	lw	v1,31212(v0)
8000fcc8:	00031842 	srl	v1,v1,0x1
8000fccc:	ac4379ec 	sw	v1,31212(v0)
	loopbit = loops_per_jiffy;
8000fcd0:	8c4279ec 	lw	v0,31212(v0)
8000fcd4:	afa20014 	sw	v0,20(sp)
8000fcd8:	24120007 	li	s2,7
	while ( lps_precision-- && (loopbit >>= 1) ) 
	{
		loops_per_jiffy |= loopbit;
8000fcdc:	3c118001 	lui	s1,0x8001
		ticks = jiffies;
8000fce0:	08003f54 	j	8000fd50 <check_cpu_speed+0x138>
8000fce4:	3c108002 	lui	s0,0x8002
   (up to lps_precision bits) */
	loops_per_jiffy >>= 1;
	loopbit = loops_per_jiffy;
	while ( lps_precision-- && (loopbit >>= 1) ) 
	{
		loops_per_jiffy |= loopbit;
8000fce8:	8e2279ec 	lw	v0,31212(s1)
8000fcec:	8fa30014 	lw	v1,20(sp)
8000fcf0:	00621025 	or	v0,v1,v0
8000fcf4:	ae2279ec 	sw	v0,31212(s1)
		ticks = jiffies;
8000fcf8:	8e023e60 	lw	v0,15968(s0)
8000fcfc:	afa20010 	sw	v0,16(sp)
		while (ticks == jiffies);
8000fd00:	8fa30010 	lw	v1,16(sp)
8000fd04:	8e023e60 	lw	v0,15968(s0)
8000fd08:	1062fffd 	beq	v1,v0,8000fd00 <check_cpu_speed+0xe8>
8000fd0c:	00000000 	nop
		ticks = jiffies;
8000fd10:	8e023e60 	lw	v0,15968(s0)
8000fd14:	afa20010 	sw	v0,16(sp)
		__delay(loops_per_jiffy);
8000fd18:	8e2479ec 	lw	a0,31212(s1)
8000fd1c:	0c0038e0 	jal	8000e380 <__delay>
8000fd20:	00000000 	nop
		if (jiffies != ticks)	/* longer than 1 tick */
8000fd24:	8e033e60 	lw	v1,15968(s0)
8000fd28:	8fa20010 	lw	v0,16(sp)
8000fd2c:	10620006 	beq	v1,v0,8000fd48 <check_cpu_speed+0x130>
8000fd30:	00000000 	nop
			loops_per_jiffy &= ~loopbit;
8000fd34:	8fa20014 	lw	v0,20(sp)
8000fd38:	8e2379ec 	lw	v1,31212(s1)
8000fd3c:	00021027 	nor	v0,zero,v0
8000fd40:	00431024 	and	v0,v0,v1
8000fd44:	ae2279ec 	sw	v0,31212(s1)
	}
/* Do a binary approximation to get loops_per_jiffy set to equal one clock
   (up to lps_precision bits) */
	loops_per_jiffy >>= 1;
	loopbit = loops_per_jiffy;
	while ( lps_precision-- && (loopbit >>= 1) ) 
8000fd48:	12400007 	beqz	s2,8000fd68 <check_cpu_speed+0x150>
8000fd4c:	2652ffff 	addiu	s2,s2,-1
8000fd50:	8fa20014 	lw	v0,20(sp)
8000fd54:	00021042 	srl	v0,v0,0x1
8000fd58:	afa20014 	sw	v0,20(sp)
8000fd5c:	8fa20014 	lw	v0,20(sp)
8000fd60:	1440ffe1 	bnez	v0,8000fce8 <check_cpu_speed+0xd0>
8000fd64:	00000000 	nop
	
	//timer_stop();	//wei del, because not close timer
	//free_IRQ(8);
	//prom_printf("cpu run %d.%d MIPS\n", loops_per_jiffy/(500000/HZ),      (loops_per_jiffy/(5000/HZ)) % 100);
//	return ((loops_per_jiffy/(500000/HZ))+1);
	return ((loops_per_jiffy/(500000/HZ))+1)*2;	 //for 1074k 
8000fd68:	3c028001 	lui	v0,0x8001
8000fd6c:	8c4379ec 	lw	v1,31212(v0)
8000fd70:	3c02d1b7 	lui	v0,0xd1b7
8000fd74:	34421759 	ori	v0,v0,0x1759
8000fd78:	00620019 	multu	v1,v0
8000fd7c:	00001010 	mfhi	v0
8000fd80:	00021302 	srl	v0,v0,0xc
8000fd84:	24420001 	addiu	v0,v0,1
	
}
8000fd88:	00021040 	sll	v0,v0,0x1
8000fd8c:	8fbf0024 	lw	ra,36(sp)
8000fd90:	8fb20020 	lw	s2,32(sp)
8000fd94:	8fb1001c 	lw	s1,28(sp)
8000fd98:	8fb00018 	lw	s0,24(sp)
8000fd9c:	03e00008 	jr	ra
8000fda0:	27bd0028 	addiu	sp,sp,40

8000fda4 <CmdTimerInit>:


//============================================================================

int CmdTimerInit(int argc, char* argv[])
{
8000fda4:	27bdffe8 	addiu	sp,sp,-24
8000fda8:	afbf0014 	sw	ra,20(sp)
		}
	}
#endif
	
#else
	int clk=check_cpu_speed();
8000fdac:	0c003f06 	jal	8000fc18 <check_cpu_speed>
8000fdb0:	00000000 	nop
	printf("CPU=%d MHz\n", clk);
8000fdb4:	3c048001 	lui	a0,0x8001
8000fdb8:	24846d24 	addiu	a0,a0,27940
8000fdbc:	0c002325 	jal	80008c94 <dprintf>
8000fdc0:	00402821 	move	a1,v0
#endif




}
8000fdc4:	8fbf0014 	lw	ra,20(sp)
8000fdc8:	03e00008 	jr	ra
8000fdcc:	27bd0018 	addiu	sp,sp,24

8000fdd0 <CmdDumpByte>:

}

//---------------------------------------------------------------------------
int CmdDumpByte( int argc, char* argv[] )
{
8000fdd0:	27bdffe0 	addiu	sp,sp,-32
8000fdd4:	afbf001c 	sw	ra,28(sp)
8000fdd8:	afb10018 	sw	s1,24(sp)
8000fddc:	afb00014 	sw	s0,20(sp)
	
	unsigned long src;
	unsigned int len,i;

	if(argc<1)
8000fde0:	1c800006 	bgtz	a0,8000fdfc <CmdDumpByte+0x2c>
8000fde4:	00a08021 	move	s0,a1
	{	dprintf("Wrong argument number!\r\n");
8000fde8:	3c048001 	lui	a0,0x8001
8000fdec:	0c002325 	jal	80008c94 <dprintf>
8000fdf0:	24846990 	addiu	a0,a0,27024
		return;
8000fdf4:	08003f8e 	j	8000fe38 <CmdDumpByte+0x68>
8000fdf8:	8fbf001c 	lw	ra,28(sp)
	}
	
	src = strtoul((const char*)(argv[0]), (char **)NULL, 16);		
8000fdfc:	8ca40000 	lw	a0,0(a1)
8000fe00:	00002821 	move	a1,zero
8000fe04:	0c0020c4 	jal	80008310 <strtoul>
8000fe08:	24060010 	li	a2,16
8000fe0c:	00408821 	move	s1,v0
	if(!argv[1])
8000fe10:	8e040004 	lw	a0,4(s0)
8000fe14:	10800005 	beqz	a0,8000fe2c <CmdDumpByte+0x5c>
8000fe18:	24050010 	li	a1,16
		len = 16;
	else
	len= strtoul((const char*)(argv[1]), (char **)NULL, 10);			
8000fe1c:	00002821 	move	a1,zero
8000fe20:	0c0020c4 	jal	80008310 <strtoul>
8000fe24:	2406000a 	li	a2,10
8000fe28:	00402821 	move	a1,v0


	ddump((unsigned char *)src,len);
8000fe2c:	0c002332 	jal	80008cc8 <ddump>
8000fe30:	02202021 	move	a0,s1
}
8000fe34:	8fbf001c 	lw	ra,28(sp)
8000fe38:	8fb10018 	lw	s1,24(sp)
8000fe3c:	8fb00014 	lw	s0,20(sp)
8000fe40:	03e00008 	jr	ra
8000fe44:	27bd0020 	addiu	sp,sp,32

8000fe48 <CmdIp>:
//---------------------------------------------------------------------------
/* This command can be used to configure host ip and target ip	*/

extern char eth0_mac[6];
int CmdIp(int argc, char* argv[])
{
8000fe48:	27bdffc8 	addiu	sp,sp,-56
8000fe4c:	afbf0034 	sw	ra,52(sp)
8000fe50:	afb20030 	sw	s2,48(sp)
8000fe54:	afb1002c 	sw	s1,44(sp)
8000fe58:	afb00028 	sw	s0,40(sp)
	unsigned char  *ptr;
	unsigned int i;
	int  ip[4];
	
	if (argc==0)
8000fe5c:	1480000d 	bnez	a0,8000fe94 <CmdIp+0x4c>
8000fe60:	27b10018 	addiu	s1,sp,24
	{	
		printf(" Target Address=%d.%d.%d.%d\n",
8000fe64:	3c028002 	lui	v0,0x8002
8000fe68:	904540f0 	lbu	a1,16624(v0)
8000fe6c:	244240f0 	addiu	v0,v0,16624
8000fe70:	90460001 	lbu	a2,1(v0)
8000fe74:	90470002 	lbu	a3,2(v0)
8000fe78:	90420003 	lbu	v0,3(v0)
8000fe7c:	afa20010 	sw	v0,16(sp)
8000fe80:	3c048001 	lui	a0,0x8001
8000fe84:	0c002325 	jal	80008c94 <dprintf>
8000fe88:	24846d30 	addiu	a0,a0,27952
#ifdef HTTP_SERVER
		printf("   Http Address=%d.%d.%d.%d\n",
		arptable_tftp[HTTPD_ARPENTRY].ipaddr.ip[0], arptable_tftp[HTTPD_ARPENTRY].ipaddr.ip[1], 
		arptable_tftp[HTTPD_ARPENTRY].ipaddr.ip[2], arptable_tftp[HTTPD_ARPENTRY].ipaddr.ip[3]);
#endif
		return;	 
8000fe8c:	08003fd3 	j	8000ff4c <CmdIp+0x104>
8000fe90:	8fbf0034 	lw	ra,52(sp)
	}			
	
	ptr = argv[0];
8000fe94:	8cb00000 	lw	s0,0(a1)
#if defined(CONFIG_BOOT_DEBUG_ENABLE)	
//---------------------------------------------------------------------------
/* This command can be used to configure host ip and target ip	*/

extern char eth0_mac[6];
int CmdIp(int argc, char* argv[])
8000fe98:	27b20028 	addiu	s2,sp,40
	
	ptr = argv[0];

	for(i=0; i< 4; i++)
	{
		ip[i]=strtol((const char *)ptr,(char **)NULL, 10);		
8000fe9c:	02002021 	move	a0,s0
8000fea0:	00002821 	move	a1,zero
8000fea4:	0c002090 	jal	80008240 <strtol>
8000fea8:	2406000a 	li	a2,10
8000feac:	ae220000 	sw	v0,0(s1)
		ptr = strchr(ptr, '.');
8000feb0:	02002021 	move	a0,s0
8000feb4:	0c00201f 	jal	8000807c <strchr>
8000feb8:	2405002e 	li	a1,46
		ptr++;
8000febc:	26310004 	addiu	s1,s1,4
		return;	 
	}			
	
	ptr = argv[0];

	for(i=0; i< 4; i++)
8000fec0:	1632fff6 	bne	s1,s2,8000fe9c <CmdIp+0x54>
8000fec4:	24500001 	addiu	s0,v0,1
	{
		ip[i]=strtol((const char *)ptr,(char **)NULL, 10);		
		ptr = strchr(ptr, '.');
		ptr++;
	}
	arptable_tftp[TFTP_SERVER].ipaddr.ip[0]=ip[0];
8000fec8:	8fa50018 	lw	a1,24(sp)
8000fecc:	3c028002 	lui	v0,0x8002
8000fed0:	a04540f0 	sb	a1,16624(v0)
	arptable_tftp[TFTP_SERVER].ipaddr.ip[1]=ip[1];
8000fed4:	8fa6001c 	lw	a2,28(sp)
8000fed8:	244240f0 	addiu	v0,v0,16624
8000fedc:	a0460001 	sb	a2,1(v0)
	arptable_tftp[TFTP_SERVER].ipaddr.ip[2]=ip[2];
8000fee0:	8fa70020 	lw	a3,32(sp)
8000fee4:	a0470002 	sb	a3,2(v0)
	arptable_tftp[TFTP_SERVER].ipaddr.ip[3]=ip[3];
8000fee8:	8fa40024 	lw	a0,36(sp)
8000feec:	a0440003 	sb	a0,3(v0)
/*replace the MAC address middle 4 bytes.*/
	eth0_mac[1]=ip[0];
8000fef0:	7c054c20 	seb	t1,a1
8000fef4:	3c088001 	lui	t0,0x8001
8000fef8:	25037590 	addiu	v1,t0,30096
8000fefc:	a0690001 	sb	t1,1(v1)
	eth0_mac[2]=ip[1];
8000ff00:	7c065420 	seb	t2,a2
8000ff04:	a06a0002 	sb	t2,2(v1)
	eth0_mac[3]=ip[2];
8000ff08:	7c075c20 	seb	t3,a3
8000ff0c:	a06b0003 	sb	t3,3(v1)
	eth0_mac[4]=ip[3];
8000ff10:	7c046420 	seb	t4,a0
8000ff14:	a06c0004 	sb	t4,4(v1)
	arptable_tftp[TFTP_SERVER].node[5]=eth0_mac[5];
8000ff18:	90630005 	lbu	v1,5(v1)
8000ff1c:	a0430009 	sb	v1,9(v0)
	arptable_tftp[TFTP_SERVER].node[4]=eth0_mac[4];
8000ff20:	a04c0008 	sb	t4,8(v0)
	arptable_tftp[TFTP_SERVER].node[3]=eth0_mac[3];
8000ff24:	a04b0007 	sb	t3,7(v0)
	arptable_tftp[TFTP_SERVER].node[2]=eth0_mac[2];
8000ff28:	a04a0006 	sb	t2,6(v0)
	arptable_tftp[TFTP_SERVER].node[1]=eth0_mac[1];
8000ff2c:	a0490005 	sb	t1,5(v0)
	arptable_tftp[TFTP_SERVER].node[0]=eth0_mac[0];
8000ff30:	91037590 	lbu	v1,30096(t0)
8000ff34:	a0430004 	sb	v1,4(v0)
	prom_printf("Now your Target IP is %d.%d.%d.%d\n", ip[0],ip[1],ip[2],ip[3]);
8000ff38:	afa40010 	sw	a0,16(sp)
8000ff3c:	3c048001 	lui	a0,0x8001
8000ff40:	0c0023a7 	jal	80008e9c <prom_printf>
8000ff44:	24846d50 	addiu	a0,a0,27984
	arptable[ARP_SERVER].ipaddr.ip[2]=ip[2];
	arptable[ARP_SERVER].ipaddr.ip[3]=ip[3];
	prom_printf("Now your Host IP is %d.%d.%d.%d\n", ip[0],ip[1],ip[2],ip[3]);
#endif	
		
}	
8000ff48:	8fbf0034 	lw	ra,52(sp)
8000ff4c:	8fb20030 	lw	s2,48(sp)
8000ff50:	8fb1002c 	lw	s1,44(sp)
8000ff54:	8fb00028 	lw	s0,40(sp)
8000ff58:	03e00008 	jr	ra
8000ff5c:	27bd0038 	addiu	sp,sp,56

8000ff60 <CmdCfn>:



extern unsigned long ETH0_ADD;
int CmdCfn(int argc, char* argv[])
{
8000ff60:	27bdffe0 	addiu	sp,sp,-32
8000ff64:	afbf001c 	sw	ra,28(sp)
8000ff68:	afb00018 	sw	s0,24(sp)
	unsigned long		Address;
	void	(*jump)(void);
	if( argc > 0 )
8000ff6c:	1880000c 	blez	a0,8000ffa0 <CmdCfn+0x40>
8000ff70:	3c048001 	lui	a0,0x8001
	{
		if(!Hex2Val( argv[0], &Address ))
8000ff74:	8ca40000 	lw	a0,0(a1)
8000ff78:	0c00213e 	jal	800084f8 <Hex2Val>
8000ff7c:	27a50010 	addiu	a1,sp,16
8000ff80:	14400006 	bnez	v0,8000ff9c <CmdCfn+0x3c>
8000ff84:	00000000 	nop
		{
			printf(" Invalid Address(HEX) value.\n");
8000ff88:	3c048001 	lui	a0,0x8001
8000ff8c:	0c002325 	jal	80008c94 <dprintf>
8000ff90:	24846d74 	addiu	a0,a0,28020
#endif
#endif
	//flush_cache();
	jump();	
	
}
8000ff94:	08003ffe 	j	8000fff8 <CmdCfn+0x98>
8000ff98:	00001021 	move	v0,zero
			printf(" Invalid Address(HEX) value.\n");
			return FALSE ;
		}
	}

	dprintf("---Jump to address=%X\n",Address);
8000ff9c:	3c048001 	lui	a0,0x8001
8000ffa0:	24846d94 	addiu	a0,a0,28052
8000ffa4:	0c002325 	jal	80008c94 <dprintf>
8000ffa8:	8fa50010 	lw	a1,16(sp)
	jump = (void *)(Address);
8000ffac:	8fb00010 	lw	s0,16(sp)
8000ffb0:	3c03b800 	lui	v1,0xb800
8000ffb4:	00001021 	move	v0,zero
8000ffb8:	ac623000 	sw	v0,12288(v1)
8000ffbc:	40016000 	mfc0	at,c0_status
8000ffc0:	34210001 	ori	at,at,0x1
8000ffc4:	38210001 	xori	at,at,0x1
8000ffc8:	40816000 	mtc0	at,c0_status
8000ffcc:	000000c0 	ehb
	...
	outl(0,GIMR0); // mask all interrupt
	cli(); 
	flush_cache(); 
8000ffdc:	0c001eae 	jal	80007ab8 <flush_cache>
8000ffe0:	00000000 	nop
	prom_printf("\nreboot.......\n");
8000ffe4:	3c048001 	lui	a0,0x8001
8000ffe8:	0c0023a7 	jal	80008e9c <prom_printf>
8000ffec:	24844074 	addiu	a0,a0,16500
     	}
#endif
#endif
#endif
	//flush_cache();
	jump();	
8000fff0:	0200f809 	jalr	s0
8000fff4:	00000000 	nop
	
}
8000fff8:	8fbf001c 	lw	ra,28(sp)
8000fffc:	8fb00018 	lw	s0,24(sp)
80010000:	03e00008 	jr	ra
80010004:	27bd0020 	addiu	sp,sp,32
	...
80010010:	80001154 	lb	zero,4436(zero)
80010014:	80001040 	lb	zero,4160(zero)
80010018:	80001058 	lb	zero,4184(zero)
8001001c:	800010d0 	lb	zero,4304(zero)
80010020:	80001124 	lb	zero,4388(zero)
80010024:	80001038 	lb	zero,4152(zero)
80010028:	800010e8 	lb	zero,4328(zero)

8001002c <BootStateEvent>:
8001002c:	80001220 80000d9c 80001570 800017bc     ... .......p....
8001003c:	80001164 80001164 80001164 80001164     ...d...d...d...d
8001004c:	80001220 80000d9c 80001570 80000d80     ... .......p....
8001005c:	80001f3c 80001444 80000d80 80000d80     ...<...D........
8001006c:	80001220 80000d9c 80000d80 800017bc     ... ............
8001007c:	80001f3c 80001444 80000d80 80000d80     ...<...D........

8001008c <__FUNCTION__.2368>:
8001008c:	63686563 6b417574 6f466c61 7368696e     checkAutoFlashin
8001009c:	67000000                                g...

800100a0 <fidHashTable>:
800100a0:	000ff0ff 00000000 00000000 00000000     ................
800100b0:	80003d20 80003d20 80003d44 80003ddc     ..= ..= ..=D..=.
800100c0:	80003d64 80003ddc 80003ddc 80003ddc     ..=d..=...=...=.
800100d0:	80003d84 00000000 00000000 00000000     ..=.............

800100e0 <nand_device>:
800100e0:	8001502c ecd514b6 80000000 80000000     ..P,............
800100f0:	08000000 00004000 00020000 00400100     ......@......@..
80010100:	74000000 80015038 ecd35195 40000000     t.....P8..Q.@...
80010110:	40000000 08000000 00002000 00020000     @......... .....
80010120:	00400100 58000000 80015044 ecdc1095     .@..X.....PD....
80010130:	20000000 20000000 08000000 00001000      ... ...........
80010140:	00020000 00400100 54000000 80015050     .....@..T.....PP
80010150:	ecda1095 10000000 10000000 08000000     ................
80010160:	00000800 00020000 00400100 44000000     .........@..D...
80010170:	8001505c ecf10095 08000000 08000000     ..P\............
80010180:	08000000 00000400 00020000 00400100     .............@..
80010190:	00000000 80015068 c2f1801d 08000000     ......Ph........
800101a0:	08000000 08000000 00000400 00020000     ................
800101b0:	00400100 00000000 80015074 2cf18095     .@........Pt,...
800101c0:	08000000 08000000 08000000 00000400     ................
800101d0:	00020000 00400100 00000000 80015088     .....@........P.
800101e0:	adf1801d 08000000 08000000 08000000     ................
800101f0:	00000400 00020000 00400100 00000000     .........@......
80010200:	80015098 92f18095 00000080 08000000     ..P.............
80010210:	08000000 00000400 00020000 00400100     .............@..
80010220:	00000000 800150a4 c8dc9095 20000000     ......P..... ...
80010230:	20000000 08000000 00001000 00020000      ...............
80010240:	00400100 00000000 800150b0 01f1801d     .@........P.....
80010250:	00000080 08000000 08000000 00000400     ................
80010260:	00020000 00400100 00000000 800150c4     .....@........P.
80010270:	ec765a3f 04000000 04000000 02000000     .vZ?............
80010280:	00001000 00004000 00100100 00000000     ......@.........
80010290:	800150d0 ec75a5bd 02000000 02000000     ..P..u..........
800102a0:	02000000 00000800 00004000 00100100     ..........@.....
800102b0:	00000000 800150dc ad75ad75 02000000     ......P..u.u....
800102c0:	02000000 02000000 00000800 00004000     ..............@.
800102d0:	00100100 00000000 800150ec 01da9095     ..........P.....
800102e0:	10000000 10000000 08000000 00000800     ................
800102f0:	00020000 00400100 44000000              .....@..D...

800102fc <__FUNCTION__.3092>:
800102fc:	72746b5f 75706461 74655f62 62740000     rtk_update_bbt..

8001030c <__FUNCTION__.2999>:
8001030c:	72746b5f 6e616e64 5f736361 6e5f6262     rtk_nand_scan_bb
8001031c:	74000000                                t...

80010320 <__FUNCTION__.2783>:
80010320:	72746b5f 63726561 74655f62 62740000     rtk_create_bbt..

80010330 <__func__.2778>:
80010330:	72746b5f 63726561 74655f62 62740000     rtk_create_bbt..

80010340 <__FUNCTION__.2704>:
80010340:	7363616e 5f6c6173 745f6469 655f4242     scan_last_die_BB
80010350:	00000000                                ....

80010354 <__func__.2692>:
80010354:	7363616e 5f6c6173 745f6469 655f4242     scan_last_die_BB
80010364:	00000000                                ....

80010368 <__FUNCTION__.2901>:
80010368:	72746b5f 7363616e 5f763272 5f626274     rtk_scan_v2r_bbt
80010378:	00000000                                ....

8001037c <__FUNCTION__.2841>:
8001037c:	63726561 74655f76 32725f72 656d6170     create_v2r_remap
8001038c:	70696e67 00000000                       ping....

80010394 <__func__.2828>:
80010394:	63726561 74655f76 32725f72 656d6170     create_v2r_remap
800103a4:	70696e67 00000000                       ping....

800103ac <__func__.2563>:
800103ac:	72746b5f 77726974 655f6563 635f7061     rtk_write_ecc_pa
800103bc:	67655f61 00000000                       ge_a....

800103c4 <__func__.2494>:
800103c4:	72746b5f 65726173 655f626c 6f636b5f     rtk_erase_block_
800103d4:	61000000                                a...

800103d8 <__FUNCTION__.2447>:
800103d8:	63686563 6b5f4242 54000000              check_BBT...

800103e4 <__FUNCTION__.2344>:
800103e4:	72746b5f 626c6f63 6b5f6973 62616400     rtk_block_isbad.

800103f4 <__FUNCTION__.2182>:
800103f4:	72746b5f 63686563 6b5f7061 67654461     rtk_check_pageDa
80010404:	74610000                                ta..

80010408 <__FUNCTION__.2148>:
80010408:	72746b5f 50494f5f 72656164 5f626173     rtk_PIO_read_bas
80010418:	69630000                                ic..

8001041c <__FUNCTION__.2120>:
8001041c:	72746b5f 63686563 6b5f616c 6c6f6e65     rtk_check_allone
8001042c:	00000000                                ....

80010430 <__FUNCTION__.1839>:
80010430:	6e616e64 5f777269 74655f65 63635f6f     nand_write_ecc_o
80010440:	62000000                                b...

80010444 <__FUNCTION__.2466>:
80010444:	64756d70 5f424254 00000000              dump_BBT....

80010450 <__FUNCTION__.1680>:
80010450:	6e616e64 5f726561 645f6563 635f6f62     nand_read_ecc_ob
80010460:	00000000                                ....

80010464 <__func__.1573>:
80010464:	72746b5f 77726974 655f6563 635f7061     rtk_write_ecc_pa
80010474:	67650000                                ge..

80010478 <__FUNCTION__.1400>:
80010478:	6e616e64 5f657261 73655f6e 616e6400     nand_erase_nand.

80010488 <__func__.1346>:
80010488:	72746b5f 65726173 655f626c 6f636b00     rtk_erase_block.
	...

800104a0 <tiddles.2020>:
800104a0:	2d5c7c2f 00000000 00000000 00000000     -\|/............

800104b0 <cpu_clksel_table>:
800104b0:	000001c2 000001f4 00000226 00000258     ...........&...X
800104c0:	0000028a 000002bc 000002ee 00000320     ............... 
800104d0:	00000352 00000384 000003b6 000003e8     ...R............
800104e0:	0000041a 0000044c 0000047e 000004b0     .......L...~....

800104f0 <m2x_clksel_table>:
800104f0:	000000fa 0000010e 00000122 00000136     ..........."...6
80010500:	0000014a 0000015e 00000172 00000235     ...J...^...r...5
80010510:	0000019a 000001ae 000001c2 000001d6     ................
80010520:	000001ea 000001fe 00000212 00000226     ...............&
80010530:	00000186 00000244 00000253 00000262     .......D...S...b
80010540:	00000271 00000280 0000028f 0000029e     ...q............
80010550:	000002ad 000002bc 000002d0 000002e4     ................
80010560:	000002f3 00000302 00000311 00000320     ............... 
80010570:	8000d758 8000d7ac 8000d7e8 8000d92c     ...X...........,
80010580:	8000d93c 00000000 00000000 00000000     ...<............
	...
