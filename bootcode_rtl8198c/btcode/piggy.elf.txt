
piggy.elf:     file format elf32-tradbigmips

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001930  a0100000  a0100000  00010000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .reginfo      00000018  a0101930  a0101930  00011930  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA, LINK_ONCE_SAME_SIZE
  2 .data         00008b04  a0101950  a0101950  00011950  2**4
                  CONTENTS, ALLOC, LOAD, DATA
  3 .pdr          00000120  00000000  00000000  0001a454  2**2
                  CONTENTS, READONLY
  4 .comment      0000002b  00000000  00000000  0001a574  2**0
                  CONTENTS, READONLY
  5 .gnu.attributes 00000010  00000000  00000000  0001a59f  2**0
                  CONTENTS, READONLY
  6 .debug_line   000003f4  00000000  00000000  0001a5af  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00000f55  00000000  00000000  0001a9a3  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000003ba  00000000  00000000  0001b8f8  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 00000060  00000000  00000000  0001bcb8  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000158  00000000  00000000  0001bd18  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000a7e  00000000  00000000  0001be70  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_pubnames 0000004a  00000000  00000000  0001c8ee  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    0000027e  00000000  00000000  0001c938  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00000208  00000000  00000000  0001cbb6  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

a0100000 <__start>:

1:
#endif

		//setup stack pointer
		la	t0, __bss_end
a0100000:	3c 08 a0 11 25 08 a4 54 00 00 00 00 21 08 20 00     <...%..T....!. .
		nop
		//addi 	t0, t0, 4096
		addi 	t0, t0, 8192//For NAND Flash booting necessary
		nop
a0100010:	00 00 00 00 01 00 e8 21 00 00 00 00                 .......!....

a010001c <test>:
		move 	sp, t0
		nop
test:
		jal	boot_entry
a010001c:	0c04000c 	jal	a0100030 <boot_entry>
		nop
a0100020:	00000000 	nop
	...

a0100030 <boot_entry>:
//-------------------------------------------------------



void boot_entry(void)
{
a0100030:	27bdffd0 	addiu	sp,sp,-48
a0100034:	afbf002c 	sw	ra,44(sp)

#ifdef DEBUG_MODE
	UINT32 heap_addr=((UINT32)dl_heap&(~7))+8 ;
  	i_alloc((void *)heap_addr, heap_addr+sizeof(dl_heap)-8);
#endif
	inbuf = (unsigned char *)(((unsigned int)__boot_start)|0x20000000);
a0100038:	3c02a010 	lui	v0,0xa010
a010003c:	24431960 	addiu	v1,v0,6496
a0100040:	3c022000 	lui	v0,0x2000
a0100044:	00621025 	or	v0,v1,v0
a0100048:	afa2001c 	sw	v0,28(sp)
	outbuf = (unsigned char *)(DECOMP_ADDR|0x20000000);
a010004c:	3c02a000 	lui	v0,0xa000
a0100050:	afa20018 	sw	v0,24(sp)
	insize = 0x7fffffff;
a0100054:	3c027fff 	lui	v0,0x7fff
a0100058:	3442ffff 	ori	v0,v0,0xffff
a010005c:	afa20020 	sw	v0,32(sp)
	outsize = 0x7fffffff;
a0100060:	3c027fff 	lui	v0,0x7fff
a0100064:	3442ffff 	ori	v0,v0,0xffff
a0100068:	afa20024 	sw	v0,36(sp)
	//print_msg('Q');	
#ifndef LZMA_COMPRESS
	gunzip(inbuf, &insize, outbuf, &outsize);
a010006c:	27a30020 	addiu	v1,sp,32
a0100070:	27a20024 	addiu	v0,sp,36
a0100074:	8fa4001c 	lw	a0,28(sp)
a0100078:	00602821 	move	a1,v1
a010007c:	8fa60018 	lw	a2,24(sp)
a0100080:	00403821 	move	a3,v0
a0100084:	0c0403be 	jal	a0100ef8 <gunzip>
a0100088:	00000000 	nop
      return 0;	 
    } 

}
#endif
	jumpF = (void (*)(void))(DECOMP_ADDR);
a010008c:	3c02a000 	lui	v0,0xa000
a0100090:	afa20010 	sw	v0,16(sp)
	(*jumpF)();
a0100094:	8fa20010 	lw	v0,16(sp)
a0100098:	0040f809 	jalr	v0
a010009c:	00000000 	nop
}
a01000a0:	8fbf002c 	lw	ra,44(sp)
a01000a4:	27bd0030 	addiu	sp,sp,48
a01000a8:	03e00008 	jr	ra
a01000ac:	00000000 	nop

a01000b0 <huft_build_table>:
	huft_code *t         /* result: starting table */
	)
{
	int i;

	for (i = 0; i < n; i++) {
a01000b0:	18a00031 	blez	a1,a0100178 <huft_build_table+0xc8>
a01000b4:	00005821 	move	t3,zero
	if (bits == 0)
		return 0;

	for (i = 0; i < n; i++) {
		if (b[i] < bits && b[i] > 0)
			code += 1 << (b[k] - b[i]);
a01000b8:	240c0001 	li	t4,1
	int n,                  /* number of codes (assumed <= N_MAX) */
	int k                   /* index */
	)
{
	huft_code code = 0;
	huft_bits bits = b[k];
a01000bc:	008b1021 	addu	v0,a0,t3
a01000c0:	90430000 	lbu	v1,0(v0)
	int i;

	if (bits == 0)
a01000c4:	1060002e 	beqz	v1,a0100180 <huft_build_table+0xd0>
a01000c8:	00005021 	move	t2,zero
a01000cc:	00004021 	move	t0,zero
a01000d0:	0804003e 	j	a01000f8 <huft_build_table+0x48>
a01000d4:	00001021 	move	v0,zero
		return 0;

	for (i = 0; i < n; i++) {
		if (b[i] < bits && b[i] > 0)
			code += 1 << (b[k] - b[i]);
a01000d8:	00674823 	subu	t1,v1,a3
a01000dc:	012c4804 	sllv	t1,t4,t1

	if (bits == 0)
		return 0;

	for (i = 0; i < n; i++) {
		if (b[i] < bits && b[i] > 0)
a01000e0:	10e0000a 	beqz	a3,a010010c <huft_build_table+0x5c>
a01000e4:	01094821 	addu	t1,t0,t1
			code += 1 << (b[k] - b[i]);
a01000e8:	3128ffff 	andi	t0,t1,0xffff
	int i;

	if (bits == 0)
		return 0;

	for (i = 0; i < n; i++) {
a01000ec:	24420001 	addiu	v0,v0,1
a01000f0:	1045000e 	beq	v0,a1,a010012c <huft_build_table+0x7c>
a01000f4:	00000000 	nop
		if (b[i] < bits && b[i] > 0)
a01000f8:	00823821 	addu	a3,a0,v0
a01000fc:	90e70000 	lbu	a3,0(a3)
a0100100:	00e3482b 	sltu	t1,a3,v1
a0100104:	1520fff4 	bnez	t1,a01000d8 <huft_build_table+0x28>
a0100108:	004b502a 	slt	t2,v0,t3
			code += 1 << (b[k] - b[i]);
		else if ((i < k) && (b[i] == bits))
a010010c:	1140fff7 	beqz	t2,a01000ec <huft_build_table+0x3c>
a0100110:	00000000 	nop
a0100114:	1467fff5 	bne	v1,a3,a01000ec <huft_build_table+0x3c>
a0100118:	00000000 	nop
			code += 1;
a010011c:	25080001 	addiu	t0,t0,1
	int i;

	if (bits == 0)
		return 0;

	for (i = 0; i < n; i++) {
a0100120:	24420001 	addiu	v0,v0,1
a0100124:	1445fff4 	bne	v0,a1,a01000f8 <huft_build_table+0x48>
a0100128:	3108ffff 	andi	t0,t0,0xffff
static huft_code bit_reverse(huft_code code, huft_bits bits)
{
	huft_code ret = 0;
	int i;

	for (i = 0; i < bits; i++) {
a010012c:	18600014 	blez	v1,a0100180 <huft_build_table+0xd0>
a0100130:	00005021 	move	t2,zero
a0100134:	00001021 	move	v0,zero
		if (code & (1 << i))
			ret |= (1 << (bits - i - 1));
a0100138:	246effff 	addiu	t6,v1,-1
a010013c:	01c23823 	subu	a3,t6,v0
{
	huft_code ret = 0;
	int i;

	for (i = 0; i < bits; i++) {
		if (code & (1 << i))
a0100140:	00484807 	srav	t1,t0,v0
			ret |= (1 << (bits - i - 1));
a0100144:	00ec3804 	sllv	a3,t4,a3
static huft_code bit_reverse(huft_code code, huft_bits bits)
{
	huft_code ret = 0;
	int i;

	for (i = 0; i < bits; i++) {
a0100148:	24420001 	addiu	v0,v0,1
		if (code & (1 << i))
a010014c:	31290001 	andi	t1,t1,0x1
			ret |= (1 << (bits - i - 1));
a0100150:	00ea6825 	or	t5,a3,t2
{
	huft_code ret = 0;
	int i;

	for (i = 0; i < bits; i++) {
		if (code & (1 << i))
a0100154:	11200002 	beqz	t1,a0100160 <huft_build_table+0xb0>
a0100158:	0043382a 	slt	a3,v0,v1
			ret |= (1 << (bits - i - 1));
a010015c:	31aaffff 	andi	t2,t5,0xffff
static huft_code bit_reverse(huft_code code, huft_bits bits)
{
	huft_code ret = 0;
	int i;

	for (i = 0; i < bits; i++) {
a0100160:	14e0fff6 	bnez	a3,a010013c <huft_build_table+0x8c>
a0100164:	00000000 	nop
	huft_code *t         /* result: starting table */
	)
{
	int i;

	for (i = 0; i < n; i++) {
a0100168:	256b0001 	addiu	t3,t3,1
		t[i] = huft_get_code(b, n, i);
a010016c:	a4ca0000 	sh	t2,0(a2)
	huft_code *t         /* result: starting table */
	)
{
	int i;

	for (i = 0; i < n; i++) {
a0100170:	1565ffd2 	bne	t3,a1,a01000bc <huft_build_table+0xc>
a0100174:	24c60002 	addiu	a2,a2,2
		t[i] = huft_get_code(b, n, i);
	}

	return 0;
}
a0100178:	03e00008 	jr	ra
a010017c:	00001021 	move	v0,zero
	huft_code *t         /* result: starting table */
	)
{
	int i;

	for (i = 0; i < n; i++) {
a0100180:	256b0001 	addiu	t3,t3,1
		t[i] = huft_get_code(b, n, i);
a0100184:	a4ca0000 	sh	t2,0(a2)
	huft_code *t         /* result: starting table */
	)
{
	int i;

	for (i = 0; i < n; i++) {
a0100188:	1565ffcc 	bne	t3,a1,a01000bc <huft_build_table+0xc>
a010018c:	24c60002 	addiu	a2,a2,2
		t[i] = huft_get_code(b, n, i);
	}

	return 0;
}
a0100190:	03e00008 	jr	ra
a0100194:	00001021 	move	v0,zero

a0100198 <get_bits>:

static huft_code get_bits(gunzip_t *guz, huft_bits n)
{
	huft_code r;

	while (guz->bufbits < (n))
a0100198:	8c83001c 	lw	v1,28(a0)
	guz->bitbuf >>= (n);
	guz->bufbits -= (n);
}

static huft_code get_bits(gunzip_t *guz, huft_bits n)
{
a010019c:	30a500ff 	andi	a1,a1,0xff
	huft_code r;

	while (guz->bufbits < (n))
a01001a0:	0065102b 	sltu	v0,v1,a1
a01001a4:	1040001e 	beqz	v0,a0100220 <get_bits+0x88>
a01001a8:	00000000 	nop
a01001ac:	8c820018 	lw	v0,24(a0)
	{
		guz->bitbuf |= ((ulong)get_uchar(guz)) << guz->bufbits;
a01001b0:	8c8a0004 	lw	t2,4(a0)
a01001b4:	8c860008 	lw	a2,8(a0)
a01001b8:	00003821 	move	a3,zero
a01001bc:	00ca402b 	sltu	t0,a2,t2
a01001c0:	11000006 	beqz	t0,a01001dc <get_bits+0x44>
a01001c4:	24c90001 	addiu	t1,a2,1
a01001c8:	8c870000 	lw	a3,0(a0)
a01001cc:	00e63021 	addu	a2,a3,a2
a01001d0:	90c70000 	lbu	a3,0(a2)
a01001d4:	ac890008 	sw	t1,8(a0)
a01001d8:	00673804 	sllv	a3,a3,v1
		guz->bufbits += 8;
a01001dc:	24630008 	addiu	v1,v1,8
{
	huft_code r;

	while (guz->bufbits < (n))
	{
		guz->bitbuf |= ((ulong)get_uchar(guz)) << guz->bufbits;
a01001e0:	00471025 	or	v0,v0,a3

static huft_code get_bits(gunzip_t *guz, huft_bits n)
{
	huft_code r;

	while (guz->bufbits < (n))
a01001e4:	0065302b 	sltu	a2,v1,a1
	{
		guz->bitbuf |= ((ulong)get_uchar(guz)) << guz->bufbits;
a01001e8:	ac820018 	sw	v0,24(a0)

static huft_code get_bits(gunzip_t *guz, huft_bits n)
{
	huft_code r;

	while (guz->bufbits < (n))
a01001ec:	14c0fff1 	bnez	a2,a01001b4 <get_bits+0x1c>
a01001f0:	ac83001c 	sw	v1,28(a0)
	{
		guz->bitbuf |= ((ulong)get_uchar(guz)) << guz->bufbits;
		guz->bufbits += 8;
	}
	r = guz->bitbuf & mask_bits[n];
a01001f4:	3c06a010 	lui	a2,0xa010
a01001f8:	00053840 	sll	a3,a1,0x1
a01001fc:	24c613b0 	addiu	a2,a2,5040
a0100200:	00e63021 	addu	a2,a3,a2
a0100204:	94c60000 	lhu	a2,0(a2)

	guz->bitbuf >>= (n);
	guz->bufbits -= (n);
a0100208:	00651823 	subu	v1,v1,a1
		guz->bitbuf |= ((ulong)get_uchar(guz)) << guz->bufbits;
		guz->bufbits += 8;
	}
	r = guz->bitbuf & mask_bits[n];

	guz->bitbuf >>= (n);
a010020c:	00a22806 	srlv	a1,v0,a1
	guz->bufbits -= (n);
a0100210:	ac83001c 	sw	v1,28(a0)
		guz->bitbuf |= ((ulong)get_uchar(guz)) << guz->bufbits;
		guz->bufbits += 8;
	}
	r = guz->bitbuf & mask_bits[n];

	guz->bitbuf >>= (n);
a0100214:	ac850018 	sw	a1,24(a0)
	guz->bufbits -= (n);

	return r;
}
a0100218:	03e00008 	jr	ra
a010021c:	00461024 	and	v0,v0,a2

static huft_code get_bits(gunzip_t *guz, huft_bits n)
{
	huft_code r;

	while (guz->bufbits < (n))
a0100220:	0804007d 	j	a01001f4 <get_bits+0x5c>
a0100224:	8c820018 	lw	v0,24(a0)

a0100228 <inflate_codes>:
	huft_bits *ld,
	huft_code *td,     /* distance decoder tables */
	int nl,            /* number of bits decoded by tl[] */
	int nd             /* number of bits decoded by td[] */
	)
{
a0100228:	27bdf7b8 	addiu	sp,sp,-2120
a010022c:	afbf0844 	sw	ra,2116(sp)
a0100230:	afbe0840 	sw	s8,2112(sp)
a0100234:	afb7083c 	sw	s7,2108(sp)
a0100238:	afb60838 	sw	s6,2104(sp)
a010023c:	afb50834 	sw	s5,2100(sp)
a0100240:	afb40830 	sw	s4,2096(sp)
a0100244:	afb3082c 	sw	s3,2092(sp)
a0100248:	afb20828 	sw	s2,2088(sp)
a010024c:	afb10824 	sw	s1,2084(sp)
a0100250:	afb00820 	sw	s0,2080(sp)
a0100254:	8fb3085c 	lw	s3,2140(sp)
a0100258:	8fb20860 	lw	s2,2144(sp)
	huft_bits bits_tmp;
	huft_code ftl[256], ftlex[512], ftd[256];
	int ftnex = 0;
	int len, dist;

	outbuf = guz->outbuf;
a010025c:	8c95000c 	lw	s5,12(a0)
	outptr = guz->outptr;
a0100260:	8c910014 	lw	s1,20(a0)
	huft_bits *ld,
	huft_code *td,     /* distance decoder tables */
	int nl,            /* number of bits decoded by tl[] */
	int nd             /* number of bits decoded by td[] */
	)
{
a0100264:	afa60850 	sw	a2,2128(sp)
a0100268:	00808021 	move	s0,a0
a010026c:	00a0a021 	move	s4,a1
	huft_code ftl[256], ftlex[512], ftd[256];
	int ftnex = 0;
	int len, dist;

	outbuf = guz->outbuf;
	outptr = guz->outptr;
a0100270:	00001021 	move	v0,zero
a0100274:	27b70010 	addiu	s7,sp,16
a0100278:	27a80210 	addiu	t0,sp,528

	for (i = 0; i < 256; i++) {
		ftl[i] = 0xffff;
a010027c:	2403ffff 	li	v1,-1
	int len, dist;

	outbuf = guz->outbuf;
	outptr = guz->outptr;

	for (i = 0; i < 256; i++) {
a0100280:	24060200 	li	a2,512
		ftl[i] = 0xffff;
a0100284:	02e22821 	addu	a1,s7,v0
		ftd[i] = 0xffff;
a0100288:	01022021 	addu	a0,t0,v0
a010028c:	24420002 	addiu	v0,v0,2

	outbuf = guz->outbuf;
	outptr = guz->outptr;

	for (i = 0; i < 256; i++) {
		ftl[i] = 0xffff;
a0100290:	a4a30000 	sh	v1,0(a1)
	int len, dist;

	outbuf = guz->outbuf;
	outptr = guz->outptr;

	for (i = 0; i < 256; i++) {
a0100294:	1446fffb 	bne	v0,a2,a0100284 <inflate_codes+0x5c>
a0100298:	a4830000 	sh	v1,0(a0)
a010029c:	27a20410 	addiu	v0,sp,1040
	guz->bufbits -= (n);

	return r;
}

static int inflate_codes(gunzip_t *guz,
a01002a0:	27a40810 	addiu	a0,sp,2064
		ftl[i] = 0xffff;
		ftd[i] = 0xffff;
	}

	for (i = 0; i < 512; i++)
		ftlex[i] = 0xffff;
a01002a4:	2403ffff 	li	v1,-1
a01002a8:	a4430000 	sh	v1,0(v0)
a01002ac:	24420002 	addiu	v0,v0,2
	for (i = 0; i < 256; i++) {
		ftl[i] = 0xffff;
		ftd[i] = 0xffff;
	}

	for (i = 0; i < 512; i++)
a01002b0:	1444fffd 	bne	v0,a0,a01002a8 <inflate_codes+0x80>
a01002b4:	00000000 	nop
		ftlex[i] = 0xffff;

	for (i = 0; i < nl; i++) {
a01002b8:	1a600022 	blez	s3,a0100344 <inflate_codes+0x11c>
a01002bc:	00000000 	nop
a01002c0:	8faa0850 	lw	t2,2128(sp)
a01002c4:	00006821 	move	t5,zero
a01002c8:	00004821 	move	t1,zero
				ftl[tl[i] | (j << bits)] = code;
			}

		} else if (bits > 8 && bits < 12 && ftnex < 64) {
			code = tl[i] & 0xff;
			if (ftl[code] == 0xffff) {
a01002cc:	340fffff 	li	t7,0xffff
			} else
				n = ftl[code] & 0x7fff;

			code = (ushort)i | (bits << 9);
			n += tl[i] >> 8;
			for (j = 0; j < (1 << (11 - bits)); j++) {
a01002d0:	240e000b 	li	t6,11
a01002d4:	240b0001 	li	t3,1

		} else if (bits > 8 && bits < 12 && ftnex < 64) {
			code = tl[i] & 0xff;
			if (ftl[code] == 0xffff) {
				n = (ftnex++) << 3;
				ftl[code] = 0x8000 | n;
a01002d8:	24188000 	li	t8,-32768
	for (i = 0; i < nl; i++) {

		bits = ll[i];
		if (bits > 0 && bits <= 8) {
			code = (ushort)i | (bits << 9);
			for (j = 0; j < (1 << (8 - bits)); j++) {
a01002dc:	240c0008 	li	t4,8
	for (i = 0; i < 512; i++)
		ftlex[i] = 0xffff;

	for (i = 0; i < nl; i++) {

		bits = ll[i];
a01002e0:	02891021 	addu	v0,s4,t1
a01002e4:	90440000 	lbu	a0,0(v0)
		if (bits > 0 && bits <= 8) {
a01002e8:	2482ffff 	addiu	v0,a0,-1
a01002ec:	304200ff 	andi	v0,v0,0xff
a01002f0:	2c420008 	sltiu	v0,v0,8
a01002f4:	1040013a 	beqz	v0,a01007e0 <inflate_codes+0x5b8>
a01002f8:	2482fff7 	addiu	v0,a0,-9
			code = (ushort)i | (bits << 9);
a01002fc:	00044240 	sll	t0,a0,0x9
			for (j = 0; j < (1 << (8 - bits)); j++) {
a0100300:	01842823 	subu	a1,t4,a0

	for (i = 0; i < nl; i++) {

		bits = ll[i];
		if (bits > 0 && bits <= 8) {
			code = (ushort)i | (bits << 9);
a0100304:	01094025 	or	t0,t0,t1
			for (j = 0; j < (1 << (8 - bits)); j++) {
a0100308:	00ab2804 	sllv	a1,t3,a1
a010030c:	18a0000a 	blez	a1,a0100338 <inflate_codes+0x110>
a0100310:	3108ffff 	andi	t0,t0,0xffff
a0100314:	95460000 	lhu	a2,0(t2)
a0100318:	00001021 	move	v0,zero
				ftl[tl[i] | (j << bits)] = code;
a010031c:	00821804 	sllv	v1,v0,a0
a0100320:	00661825 	or	v1,v1,a2
a0100324:	00031840 	sll	v1,v1,0x1
a0100328:	02e31821 	addu	v1,s7,v1
	for (i = 0; i < nl; i++) {

		bits = ll[i];
		if (bits > 0 && bits <= 8) {
			code = (ushort)i | (bits << 9);
			for (j = 0; j < (1 << (8 - bits)); j++) {
a010032c:	24420001 	addiu	v0,v0,1
a0100330:	1445fffa 	bne	v0,a1,a010031c <inflate_codes+0xf4>
a0100334:	a4680000 	sh	t0,0(v1)
	}

	for (i = 0; i < 512; i++)
		ftlex[i] = 0xffff;

	for (i = 0; i < nl; i++) {
a0100338:	25290001 	addiu	t1,t1,1
a010033c:	1533ffe8 	bne	t1,s3,a01002e0 <inflate_codes+0xb8>
a0100340:	254a0002 	addiu	t2,t2,2
				ftlex[n | (j << (bits - 8))] = code;
			}
		}
	}

	for (i = 0; i < nd; i++) {
a0100344:	1a40001d 	blez	s2,a01003bc <inflate_codes+0x194>
a0100348:	00000000 	nop
a010034c:	8faa0858 	lw	t2,2136(sp)
a0100350:	00004821 	move	t1,zero
		bits = ld[i];
		code = (ushort)i + (bits << 9);
		if (bits > 0 && bits <= 8) {
			for (j = 0; j < (1 << (8 - bits)); j++) {
a0100354:	240c0008 	li	t4,8
a0100358:	240b0001 	li	t3,1
			}
		}
	}

	for (i = 0; i < nd; i++) {
		bits = ld[i];
a010035c:	00e91021 	addu	v0,a3,t1
a0100360:	90440000 	lbu	a0,0(v0)
		code = (ushort)i + (bits << 9);
		if (bits > 0 && bits <= 8) {
a0100364:	2482ffff 	addiu	v0,a0,-1
a0100368:	304200ff 	andi	v0,v0,0xff
		}
	}

	for (i = 0; i < nd; i++) {
		bits = ld[i];
		code = (ushort)i + (bits << 9);
a010036c:	00042a40 	sll	a1,a0,0x9
a0100370:	00a92821 	addu	a1,a1,t1
		if (bits > 0 && bits <= 8) {
a0100374:	2c420008 	sltiu	v0,v0,8
a0100378:	1040000d 	beqz	v0,a01003b0 <inflate_codes+0x188>
a010037c:	30a5ffff 	andi	a1,a1,0xffff
			for (j = 0; j < (1 << (8 - bits)); j++) {
a0100380:	01843023 	subu	a2,t4,a0
a0100384:	00cb3004 	sllv	a2,t3,a2
a0100388:	18c00009 	blez	a2,a01003b0 <inflate_codes+0x188>
a010038c:	00001021 	move	v0,zero
a0100390:	95480000 	lhu	t0,0(t2)
				ftd[td[i] | (j << bits)] = code;
a0100394:	00821804 	sllv	v1,v0,a0
a0100398:	00681825 	or	v1,v1,t0
a010039c:	00031840 	sll	v1,v1,0x1
a01003a0:	02e31821 	addu	v1,s7,v1

	for (i = 0; i < nd; i++) {
		bits = ld[i];
		code = (ushort)i + (bits << 9);
		if (bits > 0 && bits <= 8) {
			for (j = 0; j < (1 << (8 - bits)); j++) {
a01003a4:	24420001 	addiu	v0,v0,1
a01003a8:	1446fffa 	bne	v0,a2,a0100394 <inflate_codes+0x16c>
a01003ac:	a4650200 	sh	a1,512(v1)
				ftlex[n | (j << (bits - 8))] = code;
			}
		}
	}

	for (i = 0; i < nd; i++) {
a01003b0:	25290001 	addiu	t1,t1,1
a01003b4:	1532ffe9 	bne	t1,s2,a010035c <inflate_codes+0x134>
a01003b8:	254a0002 	addiu	t2,t2,2
	}

	while (1) {


        *((volatile unsigned long *)(0xb800311c)) |= 1<<23;
a01003bc:	3c03b800 	lui	v1,0xb800
a01003c0:	3463311c 	ori	v1,v1,0x311c

		if (!(ftl[code] & 0x8000)) {
			value = ftl[code] & 0x01ff;
			bits = ftl[code] >> 9;

		} else if (ftl[code] != 0xffff) {
a01003c4:	341effff 	li	s8,0xffff
	}

	while (1) {


        *((volatile unsigned long *)(0xb800311c)) |= 1<<23;
a01003c8:	8c620000 	lw	v0,0(v1)
a01003cc:	3c040080 	lui	a0,0x80
a01003d0:	00441025 	or	v0,v0,a0
a01003d4:	ac620000 	sw	v0,0(v1)

static huft_code peek_bits(gunzip_t *guz, huft_bits n)
{
	huft_code r;

	while (guz->bufbits < (n))
a01003d8:	8e04001c 	lw	a0,28(s0)
a01003dc:	2c820008 	sltiu	v0,a0,8
a01003e0:	1040002e 	beqz	v0,a010049c <inflate_codes+0x274>
a01003e4:	00000000 	nop
a01003e8:	8e020018 	lw	v0,24(s0)
	{
		guz->bitbuf |= ((ulong)get_uchar(guz)) << guz->bufbits;
a01003ec:	8e0a0004 	lw	t2,4(s0)
a01003f0:	8e050008 	lw	a1,8(s0)
a01003f4:	00003021 	move	a2,zero
a01003f8:	00aa402b 	sltu	t0,a1,t2
a01003fc:	11000006 	beqz	t0,a0100418 <inflate_codes+0x1f0>
a0100400:	24a90001 	addiu	t1,a1,1
a0100404:	8e060000 	lw	a2,0(s0)
a0100408:	00c52821 	addu	a1,a2,a1
a010040c:	90a60000 	lbu	a2,0(a1)
a0100410:	ae090008 	sw	t1,8(s0)
a0100414:	00863004 	sllv	a2,a2,a0
		guz->bufbits += 8;
a0100418:	24840008 	addiu	a0,a0,8
{
	huft_code r;

	while (guz->bufbits < (n))
	{
		guz->bitbuf |= ((ulong)get_uchar(guz)) << guz->bufbits;
a010041c:	00461025 	or	v0,v0,a2

static huft_code peek_bits(gunzip_t *guz, huft_bits n)
{
	huft_code r;

	while (guz->bufbits < (n))
a0100420:	2c850008 	sltiu	a1,a0,8
	{
		guz->bitbuf |= ((ulong)get_uchar(guz)) << guz->bufbits;
a0100424:	ae020018 	sw	v0,24(s0)

static huft_code peek_bits(gunzip_t *guz, huft_bits n)
{
	huft_code r;

	while (guz->bufbits < (n))
a0100428:	14a0fff1 	bnez	a1,a01003f0 <inflate_codes+0x1c8>
a010042c:	ae04001c 	sw	a0,28(s0)
	{
		guz->bitbuf |= ((ulong)get_uchar(guz)) << guz->bufbits;
		guz->bufbits += 8;
	}
	r = guz->bitbuf & mask_bits[n];
a0100430:	3045ffff 	andi	a1,v0,0xffff

        *((volatile unsigned long *)(0xb800311c)) |= 1<<23;

		code = peek_bits(guz, 8);

		if (!(ftl[code] & 0x8000)) {
a0100434:	30a600ff 	andi	a2,a1,0xff
a0100438:	00063040 	sll	a2,a2,0x1
a010043c:	02e63021 	addu	a2,s7,a2
a0100440:	94d60000 	lhu	s6,0(a2)
a0100444:	7c163620 	seh	a2,s6
a0100448:	04c0001d 	bltz	a2,a01004c0 <inflate_codes+0x298>
a010044c:	00000000 	nop
			n = ftl[code] & 0x7fff;
			code = peek_bits(guz, 11);
			codex = code >> 8;
			if (ftlex[n + codex] != 0xffff) {
				value = ftlex[n + codex] & 0x01ff;
				bits = ftlex[n + codex] >> 9;
a0100450:	00162a42 	srl	a1,s6,0x9
		} else if (ftl[code] != 0xffff) {
			n = ftl[code] & 0x7fff;
			code = peek_bits(guz, 11);
			codex = code >> 8;
			if (ftlex[n + codex] != 0xffff) {
				value = ftlex[n + codex] & 0x01ff;
a0100454:	32d601ff 	andi	s6,s6,0x1ff
}

static void skip_bits(gunzip_t *guz, huft_bits n)
{
	guz->bitbuf >>= (n);
	guz->bufbits -= (n);
a0100458:	00852023 	subu	a0,a0,a1
	return r;
}

static void skip_bits(gunzip_t *guz, huft_bits n)
{
	guz->bitbuf >>= (n);
a010045c:	00a21006 	srlv	v0,v0,a1
			if (value == -1)
				return 1;         /* error in compressed data */
		}
		skip_bits(guz, bits);

		if (value < 256) {
a0100460:	2ac60100 	slti	a2,s6,256
	return r;
}

static void skip_bits(gunzip_t *guz, huft_bits n)
{
	guz->bitbuf >>= (n);
a0100464:	ae020018 	sw	v0,24(s0)
			if (value == -1)
				return 1;         /* error in compressed data */
		}
		skip_bits(guz, bits);

		if (value < 256) {
a0100468:	10c00061 	beqz	a2,a01005f0 <inflate_codes+0x3c8>
a010046c:	ae04001c 	sw	a0,28(s0)
			outbuf[outptr++] = (uchar)value;
a0100470:	02b11021 	addu	v0,s5,s1
a0100474:	a0560000 	sb	s6,0(v0)
	}

	while (1) {


        *((volatile unsigned long *)(0xb800311c)) |= 1<<23;
a0100478:	8c620000 	lw	v0,0(v1)
a010047c:	3c040080 	lui	a0,0x80
				return 1;         /* error in compressed data */
		}
		skip_bits(guz, bits);

		if (value < 256) {
			outbuf[outptr++] = (uchar)value;
a0100480:	26310001 	addiu	s1,s1,1
	}

	while (1) {


        *((volatile unsigned long *)(0xb800311c)) |= 1<<23;
a0100484:	00441025 	or	v0,v0,a0
a0100488:	ac620000 	sw	v0,0(v1)

static huft_code peek_bits(gunzip_t *guz, huft_bits n)
{
	huft_code r;

	while (guz->bufbits < (n))
a010048c:	8e04001c 	lw	a0,28(s0)
a0100490:	2c820008 	sltiu	v0,a0,8
a0100494:	1440ffd4 	bnez	v0,a01003e8 <inflate_codes+0x1c0>
a0100498:	00000000 	nop
a010049c:	8e020018 	lw	v0,24(s0)
	{
		guz->bitbuf |= ((ulong)get_uchar(guz)) << guz->bufbits;
		guz->bufbits += 8;
	}
	r = guz->bitbuf & mask_bits[n];
a01004a0:	3045ffff 	andi	a1,v0,0xffff

        *((volatile unsigned long *)(0xb800311c)) |= 1<<23;

		code = peek_bits(guz, 8);

		if (!(ftl[code] & 0x8000)) {
a01004a4:	30a600ff 	andi	a2,a1,0xff
a01004a8:	00063040 	sll	a2,a2,0x1
a01004ac:	02e63021 	addu	a2,s7,a2
a01004b0:	94d60000 	lhu	s6,0(a2)
a01004b4:	7c163620 	seh	a2,s6
a01004b8:	04c1ffe5 	bgez	a2,a0100450 <inflate_codes+0x228>
a01004bc:	00000000 	nop
			value = ftl[code] & 0x01ff;
			bits = ftl[code] >> 9;

		} else if (ftl[code] != 0xffff) {
a01004c0:	12de00eb 	beq	s6,s8,a0100870 <inflate_codes+0x648>
a01004c4:	2c86000b 	sltiu	a2,a0,11

static huft_code peek_bits(gunzip_t *guz, huft_bits n)
{
	huft_code r;

	while (guz->bufbits < (n))
a01004c8:	10c00013 	beqz	a2,a0100518 <inflate_codes+0x2f0>
a01004cc:	00000000 	nop
	{
		guz->bitbuf |= ((ulong)get_uchar(guz)) << guz->bufbits;
a01004d0:	8e090004 	lw	t1,4(s0)
a01004d4:	8e050008 	lw	a1,8(s0)
a01004d8:	00003021 	move	a2,zero
a01004dc:	00a9402b 	sltu	t0,a1,t1
a01004e0:	11000006 	beqz	t0,a01004fc <inflate_codes+0x2d4>
a01004e4:	24aa0001 	addiu	t2,a1,1
a01004e8:	8e060000 	lw	a2,0(s0)
a01004ec:	00c52821 	addu	a1,a2,a1
a01004f0:	90a60000 	lbu	a2,0(a1)
a01004f4:	ae0a0008 	sw	t2,8(s0)
a01004f8:	00863004 	sllv	a2,a2,a0
		guz->bufbits += 8;
a01004fc:	24840008 	addiu	a0,a0,8
{
	huft_code r;

	while (guz->bufbits < (n))
	{
		guz->bitbuf |= ((ulong)get_uchar(guz)) << guz->bufbits;
a0100500:	00461025 	or	v0,v0,a2

static huft_code peek_bits(gunzip_t *guz, huft_bits n)
{
	huft_code r;

	while (guz->bufbits < (n))
a0100504:	2c85000b 	sltiu	a1,a0,11
	{
		guz->bitbuf |= ((ulong)get_uchar(guz)) << guz->bufbits;
a0100508:	ae020018 	sw	v0,24(s0)

static huft_code peek_bits(gunzip_t *guz, huft_bits n)
{
	huft_code r;

	while (guz->bufbits < (n))
a010050c:	14a0fff1 	bnez	a1,a01004d4 <inflate_codes+0x2ac>
a0100510:	ae04001c 	sw	a0,28(s0)
a0100514:	3045ffff 	andi	a1,v0,0xffff

		} else if (ftl[code] != 0xffff) {
			n = ftl[code] & 0x7fff;
			code = peek_bits(guz, 11);
			codex = code >> 8;
			if (ftlex[n + codex] != 0xffff) {
a0100518:	32d67fff 	andi	s6,s6,0x7fff
a010051c:	7ca61200 	ext	a2,a1,0x8,0x3
a0100520:	00d63021 	addu	a2,a2,s6
a0100524:	00063040 	sll	a2,a2,0x1
a0100528:	02e63021 	addu	a2,s7,a2
a010052c:	94d60400 	lhu	s6,1024(a2)
a0100530:	16deffc7 	bne	s6,s8,a0100450 <inflate_codes+0x228>
a0100534:	2c860010 	sltiu	a2,a0,16

static huft_code peek_bits(gunzip_t *guz, huft_bits n)
{
	huft_code r;

	while (guz->bufbits < (n))
a0100538:	10c00013 	beqz	a2,a0100588 <inflate_codes+0x360>
a010053c:	00000000 	nop
	{
		guz->bitbuf |= ((ulong)get_uchar(guz)) << guz->bufbits;
a0100540:	8e0a0004 	lw	t2,4(s0)
a0100544:	8e050008 	lw	a1,8(s0)
a0100548:	00003021 	move	a2,zero
a010054c:	00aa402b 	sltu	t0,a1,t2
a0100550:	11000006 	beqz	t0,a010056c <inflate_codes+0x344>
a0100554:	24a90001 	addiu	t1,a1,1
a0100558:	8e060000 	lw	a2,0(s0)
a010055c:	00c52821 	addu	a1,a2,a1
a0100560:	90a60000 	lbu	a2,0(a1)
a0100564:	ae090008 	sw	t1,8(s0)
a0100568:	00863004 	sllv	a2,a2,a0
		guz->bufbits += 8;
a010056c:	24840008 	addiu	a0,a0,8
{
	huft_code r;

	while (guz->bufbits < (n))
	{
		guz->bitbuf |= ((ulong)get_uchar(guz)) << guz->bufbits;
a0100570:	00461025 	or	v0,v0,a2

static huft_code peek_bits(gunzip_t *guz, huft_bits n)
{
	huft_code r;

	while (guz->bufbits < (n))
a0100574:	2c850010 	sltiu	a1,a0,16
	{
		guz->bitbuf |= ((ulong)get_uchar(guz)) << guz->bufbits;
a0100578:	ae020018 	sw	v0,24(s0)

static huft_code peek_bits(gunzip_t *guz, huft_bits n)
{
	huft_code r;

	while (guz->bufbits < (n))
a010057c:	14a0fff1 	bnez	a1,a0100544 <inflate_codes+0x31c>
a0100580:	ae04001c 	sw	a0,28(s0)
a0100584:	3045ffff 	andi	a1,v0,0xffff
	huft_bits *bits
	)
{
	int i, j;

	for (i = 0; i < n; i++) {
a0100588:	1a60000f 	blez	s3,a01005c8 <inflate_codes+0x3a0>
a010058c:	0000b021 	move	s6,zero
a0100590:	8fa80850 	lw	t0,2128(sp)
		if (b[i] == 0)
a0100594:	02963021 	addu	a2,s4,s6
a0100598:	90c60000 	lbu	a2,0(a2)
			continue;

		if ((code & ~(0xffff << b[i])) == t[i])
a010059c:	00de4804 	sllv	t1,s8,a2
a01005a0:	00094827 	nor	t1,zero,t1
	)
{
	int i, j;

	for (i = 0; i < n; i++) {
		if (b[i] == 0)
a01005a4:	10c00004 	beqz	a2,a01005b8 <inflate_codes+0x390>
a01005a8:	00a94824 	and	t1,a1,t1
			continue;

		if ((code & ~(0xffff << b[i])) == t[i])
a01005ac:	95060000 	lhu	a2,0(t0)
a01005b0:	11260005 	beq	t1,a2,a01005c8 <inflate_codes+0x3a0>
a01005b4:	00000000 	nop
	huft_bits *bits
	)
{
	int i, j;

	for (i = 0; i < n; i++) {
a01005b8:	26d60001 	addiu	s6,s6,1
a01005bc:	02d3302a 	slt	a2,s6,s3
a01005c0:	14c0fff4 	bnez	a2,a0100594 <inflate_codes+0x36c>
a01005c4:	25080002 	addiu	t0,t0,2

		if ((code & ~(0xffff << b[i])) == t[i])
			break;
	}

	if (i == n)
a01005c8:	127600d0 	beq	s3,s6,a010090c <inflate_codes+0x6e4>
a01005cc:	00000000 	nop
		return -1;

	*bits = b[i];
a01005d0:	02962821 	addu	a1,s4,s6
a01005d4:	90a50000 	lbu	a1,0(a1)
			if (value == -1)
				return 1;         /* error in compressed data */
		}
		skip_bits(guz, bits);

		if (value < 256) {
a01005d8:	2ac60100 	slti	a2,s6,256
}

static void skip_bits(gunzip_t *guz, huft_bits n)
{
	guz->bitbuf >>= (n);
	guz->bufbits -= (n);
a01005dc:	00852023 	subu	a0,a0,a1
	return r;
}

static void skip_bits(gunzip_t *guz, huft_bits n)
{
	guz->bitbuf >>= (n);
a01005e0:	00a21006 	srlv	v0,v0,a1
a01005e4:	ae020018 	sw	v0,24(s0)
			if (value == -1)
				return 1;         /* error in compressed data */
		}
		skip_bits(guz, bits);

		if (value < 256) {
a01005e8:	14c0ffa1 	bnez	a2,a0100470 <inflate_codes+0x248>
a01005ec:	ae04001c 	sw	a0,28(s0)
			outbuf[outptr++] = (uchar)value;
		} else if (value > 256) {
a01005f0:	24050100 	li	a1,256
a01005f4:	12c500c9 	beq	s6,a1,a010091c <inflate_codes+0x6f4>
a01005f8:	26d6feff 	addiu	s6,s6,-257
			code = get_bits(guz, cplext[value - 257]);
a01005fc:	3c0ba010 	lui	t3,0xa010
a0100600:	0016b040 	sll	s6,s6,0x1
a0100604:	256b13d4 	addiu	t3,t3,5076
a0100608:	02cb1021 	addu	v0,s6,t3
a010060c:	90450001 	lbu	a1,1(v0)
a0100610:	02002021 	move	a0,s0
a0100614:	afa30818 	sw	v1,2072(sp)
a0100618:	0c040066 	jal	a0100198 <get_bits>
a010061c:	afa70814 	sw	a3,2068(sp)

static huft_code peek_bits(gunzip_t *guz, huft_bits n)
{
	huft_code r;

	while (guz->bufbits < (n))
a0100620:	8e04001c 	lw	a0,28(s0)

		if (value < 256) {
			outbuf[outptr++] = (uchar)value;
		} else if (value > 256) {
			code = get_bits(guz, cplext[value - 257]);
			len = cplens[value - 257] + code;
a0100624:	3c05a010 	lui	a1,0xa010
a0100628:	24a51414 	addiu	a1,a1,5140
a010062c:	02c5b021 	addu	s6,s6,a1

static huft_code peek_bits(gunzip_t *guz, huft_bits n)
{
	huft_code r;

	while (guz->bufbits < (n))
a0100630:	2c850008 	sltiu	a1,a0,8

		if (value < 256) {
			outbuf[outptr++] = (uchar)value;
		} else if (value > 256) {
			code = get_bits(guz, cplext[value - 257]);
			len = cplens[value - 257] + code;
a0100634:	96c80000 	lhu	t0,0(s6)

static huft_code peek_bits(gunzip_t *guz, huft_bits n)
{
	huft_code r;

	while (guz->bufbits < (n))
a0100638:	8fa30818 	lw	v1,2072(sp)
a010063c:	10a000b5 	beqz	a1,a0100914 <inflate_codes+0x6ec>
a0100640:	8fa70814 	lw	a3,2068(sp)
a0100644:	8e060018 	lw	a2,24(s0)
	{
		guz->bitbuf |= ((ulong)get_uchar(guz)) << guz->bufbits;
a0100648:	8e0c0004 	lw	t4,4(s0)
a010064c:	8e050008 	lw	a1,8(s0)
a0100650:	00004821 	move	t1,zero
a0100654:	00ac502b 	sltu	t2,a1,t4
a0100658:	11400006 	beqz	t2,a0100674 <inflate_codes+0x44c>
a010065c:	24ab0001 	addiu	t3,a1,1
a0100660:	8e090000 	lw	t1,0(s0)
a0100664:	01252821 	addu	a1,t1,a1
a0100668:	90a90000 	lbu	t1,0(a1)
a010066c:	ae0b0008 	sw	t3,8(s0)
a0100670:	00894804 	sllv	t1,t1,a0
		guz->bufbits += 8;
a0100674:	24840008 	addiu	a0,a0,8
{
	huft_code r;

	while (guz->bufbits < (n))
	{
		guz->bitbuf |= ((ulong)get_uchar(guz)) << guz->bufbits;
a0100678:	00c93025 	or	a2,a2,t1

static huft_code peek_bits(gunzip_t *guz, huft_bits n)
{
	huft_code r;

	while (guz->bufbits < (n))
a010067c:	2c850008 	sltiu	a1,a0,8
	{
		guz->bitbuf |= ((ulong)get_uchar(guz)) << guz->bufbits;
a0100680:	ae060018 	sw	a2,24(s0)

static huft_code peek_bits(gunzip_t *guz, huft_bits n)
{
	huft_code r;

	while (guz->bufbits < (n))
a0100684:	14a0fff1 	bnez	a1,a010064c <inflate_codes+0x424>
a0100688:	ae04001c 	sw	a0,28(s0)
	{
		guz->bitbuf |= ((ulong)get_uchar(guz)) << guz->bufbits;
		guz->bufbits += 8;
	}
	r = guz->bitbuf & mask_bits[n];
a010068c:	30ccffff 	andi	t4,a2,0xffff
		} else if (value > 256) {
			code = get_bits(guz, cplext[value - 257]);
			len = cplens[value - 257] + code;

			code = peek_bits(guz, 8);
			if (ftd[code] != 0xffff) {
a0100690:	318500ff 	andi	a1,t4,0xff
a0100694:	00052840 	sll	a1,a1,0x1
a0100698:	02e52821 	addu	a1,s7,a1
a010069c:	94a50200 	lhu	a1,512(a1)
a01006a0:	10be0026 	beq	a1,s8,a010073c <inflate_codes+0x514>
a01006a4:	00055242 	srl	t2,a1,0x9
				value = ftd[code] & 0x01ff;
a01006a8:	30a501ff 	andi	a1,a1,0x1ff
}

static void skip_bits(gunzip_t *guz, huft_bits n)
{
	guz->bitbuf >>= (n);
	guz->bufbits -= (n);
a01006ac:	008a2023 	subu	a0,a0,t2
a01006b0:	ae04001c 	sw	a0,28(s0)
				bits = bits_tmp;
				if (value == -1)
					return 1;         /* error in compressed data */
			}
			skip_bits(guz, bits);
			dist = cpdist[value] + get_bits(guz, cpdext[value]);
a01006b4:	3c0ba010 	lui	t3,0xa010
a01006b8:	3c04a010 	lui	a0,0xa010
a01006bc:	00054840 	sll	t1,a1,0x1
a01006c0:	256b1490 	addiu	t3,t3,5264
a01006c4:	24841454 	addiu	a0,a0,5204
a01006c8:	012b2821 	addu	a1,t1,t3

		if (value < 256) {
			outbuf[outptr++] = (uchar)value;
		} else if (value > 256) {
			code = get_bits(guz, cplext[value - 257]);
			len = cplens[value - 257] + code;
a01006cc:	0048b021 	addu	s6,v0,t0
				bits = bits_tmp;
				if (value == -1)
					return 1;         /* error in compressed data */
			}
			skip_bits(guz, bits);
			dist = cpdist[value] + get_bits(guz, cpdext[value]);
a01006d0:	01241021 	addu	v0,t1,a0
a01006d4:	94420000 	lhu	v0,0(v0)
a01006d8:	90a50001 	lbu	a1,1(a1)
	return r;
}

static void skip_bits(gunzip_t *guz, huft_bits n)
{
	guz->bitbuf >>= (n);
a01006dc:	01463006 	srlv	a2,a2,t2
a01006e0:	ae060018 	sw	a2,24(s0)
				bits = bits_tmp;
				if (value == -1)
					return 1;         /* error in compressed data */
			}
			skip_bits(guz, bits);
			dist = cpdist[value] + get_bits(guz, cpdext[value]);
a01006e4:	02002021 	move	a0,s0
a01006e8:	afa30818 	sw	v1,2072(sp)
a01006ec:	afa70814 	sw	a3,2068(sp)
a01006f0:	0c040066 	jal	a0100198 <get_bits>
a01006f4:	afa20810 	sw	v0,2064(sp)

			for (i = 0; i < len; i++)
a01006f8:	8fa30818 	lw	v1,2072(sp)
a01006fc:	12c0ff32 	beqz	s6,a01003c8 <inflate_codes+0x1a0>
a0100700:	8fa70814 	lw	a3,2068(sp)
a0100704:	8fab0810 	lw	t3,2064(sp)
a0100708:	02b12021 	addu	a0,s5,s1
a010070c:	01622821 	addu	a1,t3,v0
a0100710:	02252823 	subu	a1,s1,a1
a0100714:	02a52821 	addu	a1,s5,a1
a0100718:	00001021 	move	v0,zero
				outbuf[outptr++] = outbuf[outptr - dist];
a010071c:	90a60000 	lbu	a2,0(a1)
					return 1;         /* error in compressed data */
			}
			skip_bits(guz, bits);
			dist = cpdist[value] + get_bits(guz, cpdext[value]);

			for (i = 0; i < len; i++)
a0100720:	24420001 	addiu	v0,v0,1
a0100724:	24a50001 	addiu	a1,a1,1
				outbuf[outptr++] = outbuf[outptr - dist];
a0100728:	a0860000 	sb	a2,0(a0)
					return 1;         /* error in compressed data */
			}
			skip_bits(guz, bits);
			dist = cpdist[value] + get_bits(guz, cpdext[value]);

			for (i = 0; i < len; i++)
a010072c:	1456fffb 	bne	v0,s6,a010071c <inflate_codes+0x4f4>
a0100730:	24840001 	addiu	a0,a0,1
a0100734:	080400f2 	j	a01003c8 <inflate_codes+0x1a0>
a0100738:	02228821 	addu	s1,s1,v0

static huft_code peek_bits(gunzip_t *guz, huft_bits n)
{
	huft_code r;

	while (guz->bufbits < (n))
a010073c:	2c850010 	sltiu	a1,a0,16
a0100740:	10a00013 	beqz	a1,a0100790 <inflate_codes+0x568>
a0100744:	00000000 	nop
	{
		guz->bitbuf |= ((ulong)get_uchar(guz)) << guz->bufbits;
a0100748:	8e0c0004 	lw	t4,4(s0)
a010074c:	8e050008 	lw	a1,8(s0)
a0100750:	00004821 	move	t1,zero
a0100754:	00ac502b 	sltu	t2,a1,t4
a0100758:	11400006 	beqz	t2,a0100774 <inflate_codes+0x54c>
a010075c:	24ab0001 	addiu	t3,a1,1
a0100760:	8e090000 	lw	t1,0(s0)
a0100764:	01252821 	addu	a1,t1,a1
a0100768:	90a90000 	lbu	t1,0(a1)
a010076c:	ae0b0008 	sw	t3,8(s0)
a0100770:	00894804 	sllv	t1,t1,a0
		guz->bufbits += 8;
a0100774:	24840008 	addiu	a0,a0,8
{
	huft_code r;

	while (guz->bufbits < (n))
	{
		guz->bitbuf |= ((ulong)get_uchar(guz)) << guz->bufbits;
a0100778:	00c93025 	or	a2,a2,t1

static huft_code peek_bits(gunzip_t *guz, huft_bits n)
{
	huft_code r;

	while (guz->bufbits < (n))
a010077c:	2c850010 	sltiu	a1,a0,16
	{
		guz->bitbuf |= ((ulong)get_uchar(guz)) << guz->bufbits;
a0100780:	ae060018 	sw	a2,24(s0)

static huft_code peek_bits(gunzip_t *guz, huft_bits n)
{
	huft_code r;

	while (guz->bufbits < (n))
a0100784:	14a0fff1 	bnez	a1,a010074c <inflate_codes+0x524>
a0100788:	ae04001c 	sw	a0,28(s0)
a010078c:	30ccffff 	andi	t4,a2,0xffff
	huft_bits *bits
	)
{
	int i, j;

	for (i = 0; i < n; i++) {
a0100790:	1a40000f 	blez	s2,a01007d0 <inflate_codes+0x5a8>
a0100794:	00002821 	move	a1,zero
a0100798:	8faa0858 	lw	t2,2136(sp)
		if (b[i] == 0)
a010079c:	00e54821 	addu	t1,a3,a1
a01007a0:	91290000 	lbu	t1,0(t1)
			continue;

		if ((code & ~(0xffff << b[i])) == t[i])
a01007a4:	013e5804 	sllv	t3,s8,t1
a01007a8:	000b5827 	nor	t3,zero,t3
	)
{
	int i, j;

	for (i = 0; i < n; i++) {
		if (b[i] == 0)
a01007ac:	11200004 	beqz	t1,a01007c0 <inflate_codes+0x598>
a01007b0:	018b5824 	and	t3,t4,t3
			continue;

		if ((code & ~(0xffff << b[i])) == t[i])
a01007b4:	95490000 	lhu	t1,0(t2)
a01007b8:	11690005 	beq	t3,t1,a01007d0 <inflate_codes+0x5a8>
a01007bc:	00000000 	nop
	huft_bits *bits
	)
{
	int i, j;

	for (i = 0; i < n; i++) {
a01007c0:	24a50001 	addiu	a1,a1,1
a01007c4:	00b2482a 	slt	t1,a1,s2
a01007c8:	1520fff4 	bnez	t1,a010079c <inflate_codes+0x574>
a01007cc:	254a0002 	addiu	t2,t2,2

		if ((code & ~(0xffff << b[i])) == t[i])
			break;
	}

	if (i == n)
a01007d0:	1245004e 	beq	s2,a1,a010090c <inflate_codes+0x6e4>
a01007d4:	00e54821 	addu	t1,a3,a1
		return -1;

	*bits = b[i];
a01007d8:	080401ab 	j	a01006ac <inflate_codes+0x484>
a01007dc:	912a0000 	lbu	t2,0(t1)
			code = (ushort)i | (bits << 9);
			for (j = 0; j < (1 << (8 - bits)); j++) {
				ftl[tl[i] | (j << bits)] = code;
			}

		} else if (bits > 8 && bits < 12 && ftnex < 64) {
a01007e0:	304200ff 	andi	v0,v0,0xff
a01007e4:	2c420003 	sltiu	v0,v0,3
a01007e8:	1040fed3 	beqz	v0,a0100338 <inflate_codes+0x110>
a01007ec:	00000000 	nop
a01007f0:	29a20040 	slti	v0,t5,64
a01007f4:	1040fed0 	beqz	v0,a0100338 <inflate_codes+0x110>
a01007f8:	00000000 	nop
			code = tl[i] & 0xff;
a01007fc:	95460000 	lhu	a2,0(t2)
			if (ftl[code] == 0xffff) {
a0100800:	30c500ff 	andi	a1,a2,0xff
a0100804:	00052840 	sll	a1,a1,0x1
a0100808:	02e52821 	addu	a1,s7,a1
a010080c:	94a30000 	lhu	v1,0(a1)
a0100810:	106f0051 	beq	v1,t7,a0100958 <inflate_codes+0x730>
a0100814:	30627fff 	andi	v0,v1,0x7fff
				n = (ftnex++) << 3;
				ftl[code] = 0x8000 | n;
			} else
				n = ftl[code] & 0x7fff;

			code = (ushort)i | (bits << 9);
a0100818:	00044240 	sll	t0,a0,0x9
			n += tl[i] >> 8;
			for (j = 0; j < (1 << (11 - bits)); j++) {
a010081c:	01c42823 	subu	a1,t6,a0
				n = (ftnex++) << 3;
				ftl[code] = 0x8000 | n;
			} else
				n = ftl[code] & 0x7fff;

			code = (ushort)i | (bits << 9);
a0100820:	01094025 	or	t0,t0,t1
			n += tl[i] >> 8;
a0100824:	00063202 	srl	a2,a2,0x8
			for (j = 0; j < (1 << (11 - bits)); j++) {
a0100828:	00ab2804 	sllv	a1,t3,a1
				ftl[code] = 0x8000 | n;
			} else
				n = ftl[code] & 0x7fff;

			code = (ushort)i | (bits << 9);
			n += tl[i] >> 8;
a010082c:	00463021 	addu	a2,v0,a2
			for (j = 0; j < (1 << (11 - bits)); j++) {
a0100830:	18a0fec1 	blez	a1,a0100338 <inflate_codes+0x110>
a0100834:	3108ffff 	andi	t0,t0,0xffff
a0100838:	2484fff8 	addiu	a0,a0,-8
a010083c:	00001021 	move	v0,zero
				ftlex[n | (j << (bits - 8))] = code;
a0100840:	00821804 	sllv	v1,v0,a0
a0100844:	00661825 	or	v1,v1,a2
a0100848:	00031840 	sll	v1,v1,0x1
a010084c:	02e31821 	addu	v1,s7,v1
			} else
				n = ftl[code] & 0x7fff;

			code = (ushort)i | (bits << 9);
			n += tl[i] >> 8;
			for (j = 0; j < (1 << (11 - bits)); j++) {
a0100850:	24420001 	addiu	v0,v0,1
a0100854:	1445fffa 	bne	v0,a1,a0100840 <inflate_codes+0x618>
a0100858:	a4680400 	sh	t0,1024(v1)
	}

	for (i = 0; i < 512; i++)
		ftlex[i] = 0xffff;

	for (i = 0; i < nl; i++) {
a010085c:	25290001 	addiu	t1,t1,1
a0100860:	1533fe9f 	bne	t1,s3,a01002e0 <inflate_codes+0xb8>
a0100864:	254a0002 	addiu	t2,t2,2
a0100868:	080400d1 	j	a0100344 <inflate_codes+0x11c>
a010086c:	00000000 	nop

static huft_code peek_bits(gunzip_t *guz, huft_bits n)
{
	huft_code r;

	while (guz->bufbits < (n))
a0100870:	2c860010 	sltiu	a2,a0,16
a0100874:	10c00013 	beqz	a2,a01008c4 <inflate_codes+0x69c>
a0100878:	00000000 	nop
	{
		guz->bitbuf |= ((ulong)get_uchar(guz)) << guz->bufbits;
a010087c:	8e0a0004 	lw	t2,4(s0)
a0100880:	8e050008 	lw	a1,8(s0)
a0100884:	00003021 	move	a2,zero
a0100888:	00aa402b 	sltu	t0,a1,t2
a010088c:	11000006 	beqz	t0,a01008a8 <inflate_codes+0x680>
a0100890:	24a90001 	addiu	t1,a1,1
a0100894:	8e060000 	lw	a2,0(s0)
a0100898:	00c52821 	addu	a1,a2,a1
a010089c:	90a60000 	lbu	a2,0(a1)
a01008a0:	ae090008 	sw	t1,8(s0)
a01008a4:	00863004 	sllv	a2,a2,a0
		guz->bufbits += 8;
a01008a8:	24840008 	addiu	a0,a0,8
{
	huft_code r;

	while (guz->bufbits < (n))
	{
		guz->bitbuf |= ((ulong)get_uchar(guz)) << guz->bufbits;
a01008ac:	00461025 	or	v0,v0,a2

static huft_code peek_bits(gunzip_t *guz, huft_bits n)
{
	huft_code r;

	while (guz->bufbits < (n))
a01008b0:	2c850010 	sltiu	a1,a0,16
	{
		guz->bitbuf |= ((ulong)get_uchar(guz)) << guz->bufbits;
a01008b4:	ae020018 	sw	v0,24(s0)

static huft_code peek_bits(gunzip_t *guz, huft_bits n)
{
	huft_code r;

	while (guz->bufbits < (n))
a01008b8:	14a0fff1 	bnez	a1,a0100880 <inflate_codes+0x658>
a01008bc:	ae04001c 	sw	a0,28(s0)
a01008c0:	3045ffff 	andi	a1,v0,0xffff
	huft_bits *bits
	)
{
	int i, j;

	for (i = 0; i < n; i++) {
a01008c4:	1a60ff40 	blez	s3,a01005c8 <inflate_codes+0x3a0>
a01008c8:	0000b021 	move	s6,zero
a01008cc:	8fa80850 	lw	t0,2128(sp)
		if (b[i] == 0)
a01008d0:	02963021 	addu	a2,s4,s6
a01008d4:	90c60000 	lbu	a2,0(a2)
			continue;

		if ((code & ~(0xffff << b[i])) == t[i])
a01008d8:	00de4804 	sllv	t1,s8,a2
a01008dc:	00094827 	nor	t1,zero,t1
	)
{
	int i, j;

	for (i = 0; i < n; i++) {
		if (b[i] == 0)
a01008e0:	10c00004 	beqz	a2,a01008f4 <inflate_codes+0x6cc>
a01008e4:	00a94824 	and	t1,a1,t1
			continue;

		if ((code & ~(0xffff << b[i])) == t[i])
a01008e8:	95060000 	lhu	a2,0(t0)
a01008ec:	1126ff36 	beq	t1,a2,a01005c8 <inflate_codes+0x3a0>
a01008f0:	00000000 	nop
	huft_bits *bits
	)
{
	int i, j;

	for (i = 0; i < n; i++) {
a01008f4:	26d60001 	addiu	s6,s6,1
a01008f8:	02d3302a 	slt	a2,s6,s3
a01008fc:	14c0fff4 	bnez	a2,a01008d0 <inflate_codes+0x6a8>
a0100900:	25080002 	addiu	t0,t0,2

		if ((code & ~(0xffff << b[i])) == t[i])
			break;
	}

	if (i == n)
a0100904:	1676ff32 	bne	s3,s6,a01005d0 <inflate_codes+0x3a8>
a0100908:	00000000 	nop
	}

	guz->outbuf = outbuf;
	guz->outptr = outptr;

	return 0;
a010090c:	0804024a 	j	a0100928 <inflate_codes+0x700>
a0100910:	24020001 	li	v0,1

static huft_code peek_bits(gunzip_t *guz, huft_bits n)
{
	huft_code r;

	while (guz->bufbits < (n))
a0100914:	080401a3 	j	a010068c <inflate_codes+0x464>
a0100918:	8e060018 	lw	a2,24(s0)
			break;
		}
	}

	guz->outbuf = outbuf;
	guz->outptr = outptr;
a010091c:	ae110014 	sw	s1,20(s0)
		} else {
			break;
		}
	}

	guz->outbuf = outbuf;
a0100920:	ae15000c 	sw	s5,12(s0)
	guz->outptr = outptr;
a0100924:	00001021 	move	v0,zero

	return 0;
}
a0100928:	8fbf0844 	lw	ra,2116(sp)
a010092c:	8fbe0840 	lw	s8,2112(sp)
a0100930:	8fb7083c 	lw	s7,2108(sp)
a0100934:	8fb60838 	lw	s6,2104(sp)
a0100938:	8fb50834 	lw	s5,2100(sp)
a010093c:	8fb40830 	lw	s4,2096(sp)
a0100940:	8fb3082c 	lw	s3,2092(sp)
a0100944:	8fb20828 	lw	s2,2088(sp)
a0100948:	8fb10824 	lw	s1,2084(sp)
a010094c:	8fb00820 	lw	s0,2080(sp)
a0100950:	03e00008 	jr	ra
a0100954:	27bd0848 	addiu	sp,sp,2120
			}

		} else if (bits > 8 && bits < 12 && ftnex < 64) {
			code = tl[i] & 0xff;
			if (ftl[code] == 0xffff) {
				n = (ftnex++) << 3;
a0100958:	000d10c0 	sll	v0,t5,0x3
				ftl[code] = 0x8000 | n;
a010095c:	00581825 	or	v1,v0,t8
a0100960:	a4a30000 	sh	v1,0(a1)
			}

		} else if (bits > 8 && bits < 12 && ftnex < 64) {
			code = tl[i] & 0xff;
			if (ftl[code] == 0xffff) {
				n = (ftnex++) << 3;
a0100964:	08040206 	j	a0100818 <inflate_codes+0x5f0>
a0100968:	25ad0001 	addiu	t5,t5,1

a010096c <inflate_fixed>:

	return 0;
}

static int inflate_fixed(gunzip_t *guz)
{
a010096c:	27bdfc08 	addiu	sp,sp,-1016
a0100970:	afbf03f4 	sw	ra,1012(sp)
a0100974:	afb403f0 	sw	s4,1008(sp)
a0100978:	afb303ec 	sw	s3,1004(sp)
a010097c:	afb203e8 	sw	s2,1000(sp)
a0100980:	afb103e4 	sw	s1,996(sp)
a0100984:	afb003e0 	sw	s0,992(sp)
a0100988:	27b10080 	addiu	s1,sp,128
a010098c:	0080a021 	move	s4,a0
a0100990:	02201021 	move	v0,s1
		output_char(guz, (uchar)get_bits(guz, 8));

	return 0;
}

static int inflate_fixed(gunzip_t *guz)
a0100994:	27a40110 	addiu	a0,sp,272
	int value;
	int i, len, dist;

	/* set up literal table */
	for (i = 0; i < 144; i++)
		ll[i] = 8;
a0100998:	24030008 	li	v1,8
a010099c:	a0430000 	sb	v1,0(v0)
a01009a0:	24420001 	addiu	v0,v0,1
	huft_code code;
	int value;
	int i, len, dist;

	/* set up literal table */
	for (i = 0; i < 144; i++)
a01009a4:	1444fffd 	bne	v0,a0,a010099c <inflate_fixed+0x30>
a01009a8:	00000000 	nop
		output_char(guz, (uchar)get_bits(guz, 8));

	return 0;
}

static int inflate_fixed(gunzip_t *guz)
a01009ac:	26240100 	addiu	a0,s1,256

	/* set up literal table */
	for (i = 0; i < 144; i++)
		ll[i] = 8;
	for (; i < 256; i++)
		ll[i] = 9;
a01009b0:	24030009 	li	v1,9
a01009b4:	a0430000 	sb	v1,0(v0)
a01009b8:	24420001 	addiu	v0,v0,1
	int i, len, dist;

	/* set up literal table */
	for (i = 0; i < 144; i++)
		ll[i] = 8;
	for (; i < 256; i++)
a01009bc:	1444fffd 	bne	v0,a0,a01009b4 <inflate_fixed+0x48>
a01009c0:	00000000 	nop
a01009c4:	27a20180 	addiu	v0,sp,384
		output_char(guz, (uchar)get_bits(guz, 8));

	return 0;
}

static int inflate_fixed(gunzip_t *guz)
a01009c8:	26240118 	addiu	a0,s1,280
	for (i = 0; i < 144; i++)
		ll[i] = 8;
	for (; i < 256; i++)
		ll[i] = 9;
	for (; i < 280; i++)
		ll[i] = 7;
a01009cc:	24030007 	li	v1,7
a01009d0:	a0430000 	sb	v1,0(v0)
a01009d4:	24420001 	addiu	v0,v0,1
	/* set up literal table */
	for (i = 0; i < 144; i++)
		ll[i] = 8;
	for (; i < 256; i++)
		ll[i] = 9;
	for (; i < 280; i++)
a01009d8:	1444fffd 	bne	v0,a0,a01009d0 <inflate_fixed+0x64>
a01009dc:	00000000 	nop
a01009e0:	27a20198 	addiu	v0,sp,408
		output_char(guz, (uchar)get_bits(guz, 8));

	return 0;
}

static int inflate_fixed(gunzip_t *guz)
a01009e4:	26240120 	addiu	a0,s1,288
	for (; i < 256; i++)
		ll[i] = 9;
	for (; i < 280; i++)
		ll[i] = 7;
	for (; i < 288; i++)          /* make a complete, but wrong code set */
		ll[i] = 8;
a01009e8:	24030008 	li	v1,8
a01009ec:	a0430000 	sb	v1,0(v0)
a01009f0:	24420001 	addiu	v0,v0,1
		ll[i] = 8;
	for (; i < 256; i++)
		ll[i] = 9;
	for (; i < 280; i++)
		ll[i] = 7;
	for (; i < 288; i++)          /* make a complete, but wrong code set */
a01009f4:	1444fffd 	bne	v0,a0,a01009ec <inflate_fixed+0x80>
a01009f8:	27b301a0 	addiu	s3,sp,416
		ll[i] = 8;
	huft_build_table(ll, 288, tl);
a01009fc:	02202021 	move	a0,s1
a0100a00:	24050120 	li	a1,288
a0100a04:	02603021 	move	a2,s3
a0100a08:	0c04002c 	jal	a01000b0 <huft_build_table>
a0100a0c:	27b20020 	addiu	s2,sp,32
a0100a10:	02401021 	move	v0,s2
		output_char(guz, (uchar)get_bits(guz, 8));

	return 0;
}

static int inflate_fixed(gunzip_t *guz)
a0100a14:	27a4003e 	addiu	a0,sp,62
	for (; i < 288; i++)          /* make a complete, but wrong code set */
		ll[i] = 8;
	huft_build_table(ll, 288, tl);

	for (i = 0; i < 30; i++)
		ld[i] = 5;
a0100a18:	24030005 	li	v1,5
a0100a1c:	a0430000 	sb	v1,0(v0)
a0100a20:	24420001 	addiu	v0,v0,1
		ll[i] = 7;
	for (; i < 288; i++)          /* make a complete, but wrong code set */
		ll[i] = 8;
	huft_build_table(ll, 288, tl);

	for (i = 0; i < 30; i++)
a0100a24:	1444fffd 	bne	v0,a0,a0100a1c <inflate_fixed+0xb0>
a0100a28:	27b00040 	addiu	s0,sp,64
		ld[i] = 5;
	huft_build_table(ld, 30, td);
a0100a2c:	02402021 	move	a0,s2
a0100a30:	02003021 	move	a2,s0
a0100a34:	0c04002c 	jal	a01000b0 <huft_build_table>
a0100a38:	2405001e 	li	a1,30

	return inflate_codes(guz, ll, tl, ld, td, 288, 30);
a0100a3c:	24020120 	li	v0,288
a0100a40:	02802021 	move	a0,s4
a0100a44:	02202821 	move	a1,s1
a0100a48:	02603021 	move	a2,s3
a0100a4c:	02403821 	move	a3,s2
a0100a50:	afa20014 	sw	v0,20(sp)
a0100a54:	2402001e 	li	v0,30
a0100a58:	afb00010 	sw	s0,16(sp)
a0100a5c:	0c04008a 	jal	a0100228 <inflate_codes>
a0100a60:	afa20018 	sw	v0,24(sp)

}
a0100a64:	8fbf03f4 	lw	ra,1012(sp)
a0100a68:	8fb403f0 	lw	s4,1008(sp)
a0100a6c:	8fb303ec 	lw	s3,1004(sp)
a0100a70:	8fb203e8 	lw	s2,1000(sp)
a0100a74:	8fb103e4 	lw	s1,996(sp)
a0100a78:	8fb003e0 	lw	s0,992(sp)
a0100a7c:	03e00008 	jr	ra
a0100a80:	27bd03f8 	addiu	sp,sp,1016

a0100a84 <build_bits_table>:
	huft_code *tb,
	int nb,
	huft_bits *ll,
	int nl
	)
{
a0100a84:	27bdffc0 	addiu	sp,sp,-64
a0100a88:	afbf003c 	sw	ra,60(sp)
a0100a8c:	afbe0038 	sw	s8,56(sp)
a0100a90:	afb70034 	sw	s7,52(sp)
a0100a94:	afb60030 	sw	s6,48(sp)
a0100a98:	afb5002c 	sw	s5,44(sp)
a0100a9c:	afb40028 	sw	s4,40(sp)
a0100aa0:	afb30024 	sw	s3,36(sp)
a0100aa4:	afb20020 	sw	s2,32(sp)
a0100aa8:	afb1001c 	sw	s1,28(sp)
a0100aac:	afb00018 	sw	s0,24(sp)
a0100ab0:	8fb20054 	lw	s2,84(sp)
a0100ab4:	00808021 	move	s0,a0
a0100ab8:	00a08821 	move	s1,a1
a0100abc:	00c0b021 	move	s6,a2
	huft_bits bits;
	huft_code code;
	int value, i, n;

	i = 0;
	while (i < nl) {
a0100ac0:	1a400045 	blez	s2,a0100bd8 <build_bits_table+0x154>
a0100ac4:	8fb70050 	lw	s7,80(sp)
a0100ac8:	0000a821 	move	s5,zero

	for (i = 0; i < n; i++) {
		if (b[i] == 0)
			continue;

		if ((code & ~(0xffff << b[i])) == t[i])
a0100acc:	3413ffff 	li	s3,0xffff
	huft_bits *bits
	)
{
	int i, j;

	for (i = 0; i < n; i++) {
a0100ad0:	24140013 	li	s4,19
		if (value == -1)
			return 1;         /* error in compressed data */
		skip_bits(guz, bits);
		if (value < 16) {
			ll[i++] = value;
		} else if (value == 16) {
a0100ad4:	241e0010 	li	s8,16
			code = get_bits(guz, 2);
			for (n = 0; n < code + 3; n++) {
				ll[i++] = ll[i - 1];
			}
		} else if (value == 17) {
a0100ad8:	24030011 	li	v1,17
			code = get_bits(guz, 3);
			for (n = 0; n < code + 3; n++)
				ll[i++] = 0;
		} else if (value == 18)	{
a0100adc:	24060012 	li	a2,18

static huft_code peek_bits(gunzip_t *guz, huft_bits n)
{
	huft_code r;

	while (guz->bufbits < (n))
a0100ae0:	8e04001c 	lw	a0,28(s0)
a0100ae4:	2c820010 	sltiu	v0,a0,16
a0100ae8:	10400055 	beqz	v0,a0100c40 <build_bits_table+0x1bc>
a0100aec:	00000000 	nop
a0100af0:	8e080018 	lw	t0,24(s0)
	{
		guz->bitbuf |= ((ulong)get_uchar(guz)) << guz->bufbits;
a0100af4:	8e0a0004 	lw	t2,4(s0)
a0100af8:	8e020008 	lw	v0,8(s0)
a0100afc:	00002821 	move	a1,zero
a0100b00:	004a382b 	sltu	a3,v0,t2
a0100b04:	10e00006 	beqz	a3,a0100b20 <build_bits_table+0x9c>
a0100b08:	24490001 	addiu	t1,v0,1
a0100b0c:	8e050000 	lw	a1,0(s0)
a0100b10:	00a21021 	addu	v0,a1,v0
a0100b14:	90450000 	lbu	a1,0(v0)
a0100b18:	ae090008 	sw	t1,8(s0)
a0100b1c:	00852804 	sllv	a1,a1,a0
		guz->bufbits += 8;
a0100b20:	24840008 	addiu	a0,a0,8
{
	huft_code r;

	while (guz->bufbits < (n))
	{
		guz->bitbuf |= ((ulong)get_uchar(guz)) << guz->bufbits;
a0100b24:	01054025 	or	t0,t0,a1

static huft_code peek_bits(gunzip_t *guz, huft_bits n)
{
	huft_code r;

	while (guz->bufbits < (n))
a0100b28:	2c820010 	sltiu	v0,a0,16
	{
		guz->bitbuf |= ((ulong)get_uchar(guz)) << guz->bufbits;
a0100b2c:	ae080018 	sw	t0,24(s0)

static huft_code peek_bits(gunzip_t *guz, huft_bits n)
{
	huft_code r;

	while (guz->bufbits < (n))
a0100b30:	1440fff1 	bnez	v0,a0100af8 <build_bits_table+0x74>
a0100b34:	ae04001c 	sw	a0,28(s0)
	int value, i, n;

	i = 0;
	while (i < nl) {
		code = peek_bits(guz, 16);
		value = huft_get_value(lb, tb, 19, code, &bits);
a0100b38:	310affff 	andi	t2,t0,0xffff
a0100b3c:	02c03821 	move	a3,s6
a0100b40:	00001021 	move	v0,zero
	)
{
	int i, j;

	for (i = 0; i < n; i++) {
		if (b[i] == 0)
a0100b44:	02222821 	addu	a1,s1,v0
a0100b48:	90a50000 	lbu	a1,0(a1)
			continue;

		if ((code & ~(0xffff << b[i])) == t[i])
a0100b4c:	00b34804 	sllv	t1,s3,a1
a0100b50:	00094827 	nor	t1,zero,t1
	)
{
	int i, j;

	for (i = 0; i < n; i++) {
		if (b[i] == 0)
a0100b54:	10a00004 	beqz	a1,a0100b68 <build_bits_table+0xe4>
a0100b58:	01494824 	and	t1,t2,t1
			continue;

		if ((code & ~(0xffff << b[i])) == t[i])
a0100b5c:	94eb0000 	lhu	t3,0(a3)
a0100b60:	112b0011 	beq	t1,t3,a0100ba8 <build_bits_table+0x124>
a0100b64:	00000000 	nop
	huft_bits *bits
	)
{
	int i, j;

	for (i = 0; i < n; i++) {
a0100b68:	24420001 	addiu	v0,v0,1
a0100b6c:	1454fff5 	bne	v0,s4,a0100b44 <build_bits_table+0xc0>
a0100b70:	24e70002 	addiu	a3,a3,2
{
	huft_code r;

	while (guz->bufbits < (n))
	{
		guz->bitbuf |= ((ulong)get_uchar(guz)) << guz->bufbits;
a0100b74:	24020001 	li	v0,1
				ll[i++] = 0;
		}
	}

	return 0;
}
a0100b78:	8fbf003c 	lw	ra,60(sp)
a0100b7c:	8fbe0038 	lw	s8,56(sp)
a0100b80:	8fb70034 	lw	s7,52(sp)
a0100b84:	8fb60030 	lw	s6,48(sp)
a0100b88:	8fb5002c 	lw	s5,44(sp)
a0100b8c:	8fb40028 	lw	s4,40(sp)
a0100b90:	8fb30024 	lw	s3,36(sp)
a0100b94:	8fb20020 	lw	s2,32(sp)
a0100b98:	8fb1001c 	lw	s1,28(sp)
a0100b9c:	8fb00018 	lw	s0,24(sp)
a0100ba0:	03e00008 	jr	ra
a0100ba4:	27bd0040 	addiu	sp,sp,64
}

static void skip_bits(gunzip_t *guz, huft_bits n)
{
	guz->bitbuf >>= (n);
	guz->bufbits -= (n);
a0100ba8:	00852023 	subu	a0,a0,a1
		code = peek_bits(guz, 16);
		value = huft_get_value(lb, tb, 19, code, &bits);
		if (value == -1)
			return 1;         /* error in compressed data */
		skip_bits(guz, bits);
		if (value < 16) {
a0100bac:	28470010 	slti	a3,v0,16
	return r;
}

static void skip_bits(gunzip_t *guz, huft_bits n)
{
	guz->bitbuf >>= (n);
a0100bb0:	00a82806 	srlv	a1,t0,a1
a0100bb4:	ae050018 	sw	a1,24(s0)
		code = peek_bits(guz, 16);
		value = huft_get_value(lb, tb, 19, code, &bits);
		if (value == -1)
			return 1;         /* error in compressed data */
		skip_bits(guz, bits);
		if (value < 16) {
a0100bb8:	10e00009 	beqz	a3,a0100be0 <build_bits_table+0x15c>
a0100bbc:	ae04001c 	sw	a0,28(s0)
			ll[i++] = value;
a0100bc0:	02f52021 	addu	a0,s7,s5
a0100bc4:	a0820000 	sb	v0,0(a0)
a0100bc8:	26b50001 	addiu	s5,s5,1
	huft_bits bits;
	huft_code code;
	int value, i, n;

	i = 0;
	while (i < nl) {
a0100bcc:	02b2102a 	slt	v0,s5,s2
a0100bd0:	1440ffc3 	bnez	v0,a0100ae0 <build_bits_table+0x5c>
a0100bd4:	00000000 	nop
{
	huft_code r;

	while (guz->bufbits < (n))
	{
		guz->bitbuf |= ((ulong)get_uchar(guz)) << guz->bufbits;
a0100bd8:	080402de 	j	a0100b78 <build_bits_table+0xf4>
a0100bdc:	00001021 	move	v0,zero
		if (value == -1)
			return 1;         /* error in compressed data */
		skip_bits(guz, bits);
		if (value < 16) {
			ll[i++] = value;
		} else if (value == 16) {
a0100be0:	105e0019 	beq	v0,s8,a0100c48 <build_bits_table+0x1c4>
a0100be4:	02002021 	move	a0,s0
			code = get_bits(guz, 2);
			for (n = 0; n < code + 3; n++) {
				ll[i++] = ll[i - 1];
			}
		} else if (value == 17) {
a0100be8:	10430029 	beq	v0,v1,a0100c90 <build_bits_table+0x20c>
a0100bec:	24050003 	li	a1,3
			code = get_bits(guz, 3);
			for (n = 0; n < code + 3; n++)
				ll[i++] = 0;
		} else if (value == 18)	{
a0100bf0:	1446fff7 	bne	v0,a2,a0100bd0 <build_bits_table+0x14c>
a0100bf4:	02b2102a 	slt	v0,s5,s2
			code = get_bits(guz, 7);
a0100bf8:	02002021 	move	a0,s0
a0100bfc:	24050007 	li	a1,7
a0100c00:	afa30010 	sw	v1,16(sp)
a0100c04:	0c040066 	jal	a0100198 <get_bits>
a0100c08:	afa60014 	sw	a2,20(sp)
			for (n = 0; n < code + 11; n++)
a0100c0c:	8fa60014 	lw	a2,20(sp)
a0100c10:	8fa30010 	lw	v1,16(sp)
a0100c14:	2442000a 	addiu	v0,v0,10
a0100c18:	02f52821 	addu	a1,s7,s5
a0100c1c:	00002021 	move	a0,zero
a0100c20:	24840001 	addiu	a0,a0,1
a0100c24:	0044382a 	slt	a3,v0,a0
				ll[i++] = 0;
a0100c28:	a0a00000 	sb	zero,0(a1)
			code = get_bits(guz, 3);
			for (n = 0; n < code + 3; n++)
				ll[i++] = 0;
		} else if (value == 18)	{
			code = get_bits(guz, 7);
			for (n = 0; n < code + 11; n++)
a0100c2c:	10e0fffc 	beqz	a3,a0100c20 <build_bits_table+0x19c>
a0100c30:	24a50001 	addiu	a1,a1,1

	return inflate_codes(guz, ll, tl, ld, td, 288, 30);

}

static int build_bits_table(gunzip_t *guz,
a0100c34:	26b50001 	addiu	s5,s5,1
a0100c38:	080402f3 	j	a0100bcc <build_bits_table+0x148>
a0100c3c:	02a2a821 	addu	s5,s5,v0

static huft_code peek_bits(gunzip_t *guz, huft_bits n)
{
	huft_code r;

	while (guz->bufbits < (n))
a0100c40:	080402ce 	j	a0100b38 <build_bits_table+0xb4>
a0100c44:	8e080018 	lw	t0,24(s0)
			return 1;         /* error in compressed data */
		skip_bits(guz, bits);
		if (value < 16) {
			ll[i++] = value;
		} else if (value == 16) {
			code = get_bits(guz, 2);
a0100c48:	24050002 	li	a1,2
a0100c4c:	afa30010 	sw	v1,16(sp)
a0100c50:	0c040066 	jal	a0100198 <get_bits>
a0100c54:	afa60014 	sw	a2,20(sp)
			for (n = 0; n < code + 3; n++) {
a0100c58:	8fa60014 	lw	a2,20(sp)
a0100c5c:	8fa30010 	lw	v1,16(sp)
a0100c60:	24420002 	addiu	v0,v0,2
a0100c64:	02f52021 	addu	a0,s7,s5
a0100c68:	00002821 	move	a1,zero
				ll[i++] = ll[i - 1];
a0100c6c:	9088ffff 	lbu	t0,-1(a0)
		skip_bits(guz, bits);
		if (value < 16) {
			ll[i++] = value;
		} else if (value == 16) {
			code = get_bits(guz, 2);
			for (n = 0; n < code + 3; n++) {
a0100c70:	24a50001 	addiu	a1,a1,1
a0100c74:	0045382a 	slt	a3,v0,a1
				ll[i++] = ll[i - 1];
a0100c78:	a0880000 	sb	t0,0(a0)
		skip_bits(guz, bits);
		if (value < 16) {
			ll[i++] = value;
		} else if (value == 16) {
			code = get_bits(guz, 2);
			for (n = 0; n < code + 3; n++) {
a0100c7c:	10e0fffb 	beqz	a3,a0100c6c <build_bits_table+0x1e8>
a0100c80:	24840001 	addiu	a0,a0,1

	return inflate_codes(guz, ll, tl, ld, td, 288, 30);

}

static int build_bits_table(gunzip_t *guz,
a0100c84:	26b50001 	addiu	s5,s5,1
a0100c88:	080402f3 	j	a0100bcc <build_bits_table+0x148>
a0100c8c:	02a2a821 	addu	s5,s5,v0
			code = get_bits(guz, 2);
			for (n = 0; n < code + 3; n++) {
				ll[i++] = ll[i - 1];
			}
		} else if (value == 17) {
			code = get_bits(guz, 3);
a0100c90:	afa30010 	sw	v1,16(sp)
a0100c94:	0c040066 	jal	a0100198 <get_bits>
a0100c98:	afa60014 	sw	a2,20(sp)
			for (n = 0; n < code + 3; n++)
a0100c9c:	8fa60014 	lw	a2,20(sp)
a0100ca0:	8fa30010 	lw	v1,16(sp)
a0100ca4:	24420002 	addiu	v0,v0,2
a0100ca8:	02f52821 	addu	a1,s7,s5
a0100cac:	00002021 	move	a0,zero
a0100cb0:	24840001 	addiu	a0,a0,1
a0100cb4:	0044382a 	slt	a3,v0,a0
				ll[i++] = 0;
a0100cb8:	a0a00000 	sb	zero,0(a1)
			for (n = 0; n < code + 3; n++) {
				ll[i++] = ll[i - 1];
			}
		} else if (value == 17) {
			code = get_bits(guz, 3);
			for (n = 0; n < code + 3; n++)
a0100cbc:	10e0fffc 	beqz	a3,a0100cb0 <build_bits_table+0x22c>
a0100cc0:	24a50001 	addiu	a1,a1,1

	return inflate_codes(guz, ll, tl, ld, td, 288, 30);

}

static int build_bits_table(gunzip_t *guz,
a0100cc4:	26b50001 	addiu	s5,s5,1
a0100cc8:	080402f3 	j	a0100bcc <build_bits_table+0x148>
a0100ccc:	02a2a821 	addu	s5,s5,v0

a0100cd0 <inflate_dynamic>:

	return 0;
}

static int inflate_dynamic(gunzip_t *guz)
{
a0100cd0:	27bdfbb8 	addiu	sp,sp,-1096
a0100cd4:	afbf0444 	sw	ra,1092(sp)
a0100cd8:	afbe0440 	sw	s8,1088(sp)
a0100cdc:	afb7043c 	sw	s7,1084(sp)
a0100ce0:	afb60438 	sw	s6,1080(sp)
a0100ce4:	afb50434 	sw	s5,1076(sp)
a0100ce8:	afb40430 	sw	s4,1072(sp)
a0100cec:	afb3042c 	sw	s3,1068(sp)
a0100cf0:	afb20428 	sw	s2,1064(sp)
a0100cf4:	afb10424 	sw	s1,1060(sp)
a0100cf8:	afb00420 	sw	s0,1056(sp)
	int nl;          /* number of literal/length codes */
	int nd;          /* number of distance codes */
	int value, i, n;

	/* read in table lengths */
	nl = 257 + get_bits(guz, 5);      /* number of literal/length codes */
a0100cfc:	24050005 	li	a1,5
a0100d00:	0c040066 	jal	a0100198 <get_bits>
a0100d04:	00808821 	move	s1,a0
	nd = 1 + get_bits(guz, 5);        /* number of distance codes */
a0100d08:	24050005 	li	a1,5
a0100d0c:	02202021 	move	a0,s1
a0100d10:	0c040066 	jal	a0100198 <get_bits>
a0100d14:	24520101 	addiu	s2,v0,257
	nb = 4 + get_bits(guz, 4);        /* number of bit length codes */
a0100d18:	02202021 	move	a0,s1
a0100d1c:	24050004 	li	a1,4
a0100d20:	0c040066 	jal	a0100198 <get_bits>
a0100d24:	00409821 	move	s3,v0
	if (nl > 286 || nd > 30)
a0100d28:	2a43011f 	slti	v1,s2,287
a0100d2c:	10600051 	beqz	v1,a0100e74 <inflate_dynamic+0x1a4>
a0100d30:	24570004 	addiu	s7,v0,4
	int nd;          /* number of distance codes */
	int value, i, n;

	/* read in table lengths */
	nl = 257 + get_bits(guz, 5);      /* number of literal/length codes */
	nd = 1 + get_bits(guz, 5);        /* number of distance codes */
a0100d34:	26730001 	addiu	s3,s3,1
	nb = 4 + get_bits(guz, 4);        /* number of bit length codes */
	if (nl > 286 || nd > 30)
a0100d38:	2a62001f 	slti	v0,s3,31
a0100d3c:	1040004d 	beqz	v0,a0100e74 <inflate_dynamic+0x1a4>
a0100d40:	3c1ea010 	lui	s8,0xa010
a0100d44:	27de14cc 	addiu	s8,s8,5324
a0100d48:	03c0a821 	move	s5,s8
a0100d4c:	0000a021 	move	s4,zero
a0100d50:	27b00020 	addiu	s0,sp,32
		return 1;                 /* bad lengths */

	/* read in bit-length-code lengths */
	for (i = 0; i < nb; i++)
		lb[border[i]] = get_bits(guz, 3);
a0100d54:	8eb60000 	lw	s6,0(s5)
	nb = 4 + get_bits(guz, 4);        /* number of bit length codes */
	if (nl > 286 || nd > 30)
		return 1;                 /* bad lengths */

	/* read in bit-length-code lengths */
	for (i = 0; i < nb; i++)
a0100d58:	26940001 	addiu	s4,s4,1
		lb[border[i]] = get_bits(guz, 3);
a0100d5c:	02202021 	move	a0,s1
a0100d60:	0c040066 	jal	a0100198 <get_bits>
a0100d64:	24050003 	li	a1,3
a0100d68:	0216b021 	addu	s6,s0,s6
	nb = 4 + get_bits(guz, 4);        /* number of bit length codes */
	if (nl > 286 || nd > 30)
		return 1;                 /* bad lengths */

	/* read in bit-length-code lengths */
	for (i = 0; i < nb; i++)
a0100d6c:	0297182a 	slt	v1,s4,s7
		lb[border[i]] = get_bits(guz, 3);
a0100d70:	a2c20000 	sb	v0,0(s6)
	nb = 4 + get_bits(guz, 4);        /* number of bit length codes */
	if (nl > 286 || nd > 30)
		return 1;                 /* bad lengths */

	/* read in bit-length-code lengths */
	for (i = 0; i < nb; i++)
a0100d74:	1460fff7 	bnez	v1,a0100d54 <inflate_dynamic+0x84>
a0100d78:	26b50004 	addiu	s5,s5,4
		lb[border[i]] = get_bits(guz, 3);
	for (; i < 19; i++)
a0100d7c:	2a820013 	slti	v0,s4,19
a0100d80:	10400009 	beqz	v0,a0100da8 <inflate_dynamic+0xd8>
a0100d84:	00141080 	sll	v0,s4,0x2
a0100d88:	03c2f021 	addu	s8,s8,v0
		lb[border[i]] = 0;
a0100d8c:	8fc30000 	lw	v1,0(s8)
		return 1;                 /* bad lengths */

	/* read in bit-length-code lengths */
	for (i = 0; i < nb; i++)
		lb[border[i]] = get_bits(guz, 3);
	for (; i < 19; i++)
a0100d90:	26940001 	addiu	s4,s4,1
a0100d94:	2a820013 	slti	v0,s4,19
		lb[border[i]] = 0;
a0100d98:	02031821 	addu	v1,s0,v1
a0100d9c:	a0600000 	sb	zero,0(v1)
		return 1;                 /* bad lengths */

	/* read in bit-length-code lengths */
	for (i = 0; i < nb; i++)
		lb[border[i]] = get_bits(guz, 3);
	for (; i < 19; i++)
a0100da0:	1440fffa 	bnez	v0,a0100d8c <inflate_dynamic+0xbc>
a0100da4:	27de0004 	addiu	s8,s8,4
		lb[border[i]] = 0;
	huft_build_table(lb, 19, tb);
a0100da8:	27b50054 	addiu	s5,sp,84
a0100dac:	02002021 	move	a0,s0
a0100db0:	02a03021 	move	a2,s5
a0100db4:	0c04002c 	jal	a01000b0 <huft_build_table>
a0100db8:	24050013 	li	a1,19

	build_bits_table(guz, lb, tb, 19, ll, nl);
a0100dbc:	27b400bc 	addiu	s4,sp,188
	huft_build_table(ll, nl, tl);
a0100dc0:	27b601dc 	addiu	s6,sp,476
		lb[border[i]] = get_bits(guz, 3);
	for (; i < 19; i++)
		lb[border[i]] = 0;
	huft_build_table(lb, 19, tb);

	build_bits_table(guz, lb, tb, 19, ll, nl);
a0100dc4:	24070013 	li	a3,19
a0100dc8:	02202021 	move	a0,s1
a0100dcc:	02002821 	move	a1,s0
a0100dd0:	02a03021 	move	a2,s5
a0100dd4:	afb40010 	sw	s4,16(sp)
a0100dd8:	0c0402a1 	jal	a0100a84 <build_bits_table>
a0100ddc:	afb20014 	sw	s2,20(sp)
	huft_build_table(ll, nl, tl);
a0100de0:	02802021 	move	a0,s4
a0100de4:	02402821 	move	a1,s2
a0100de8:	0c04002c 	jal	a01000b0 <huft_build_table>
a0100dec:	02c03021 	move	a2,s6

	build_bits_table(guz, lb, tb, 19, ld, nd);
a0100df0:	02002821 	move	a1,s0
a0100df4:	02a03021 	move	a2,s5
a0100df8:	27b00034 	addiu	s0,sp,52
	huft_build_table(ld, nd, td);
a0100dfc:	27b5007c 	addiu	s5,sp,124
	huft_build_table(lb, 19, tb);

	build_bits_table(guz, lb, tb, 19, ll, nl);
	huft_build_table(ll, nl, tl);

	build_bits_table(guz, lb, tb, 19, ld, nd);
a0100e00:	24070013 	li	a3,19
a0100e04:	02202021 	move	a0,s1
a0100e08:	afb00010 	sw	s0,16(sp)
a0100e0c:	0c0402a1 	jal	a0100a84 <build_bits_table>
a0100e10:	afb30014 	sw	s3,20(sp)
	huft_build_table(ld, nd, td);
a0100e14:	02002021 	move	a0,s0
a0100e18:	02602821 	move	a1,s3
a0100e1c:	0c04002c 	jal	a01000b0 <huft_build_table>
a0100e20:	02a03021 	move	a2,s5

	return inflate_codes(guz, ll, tl, ld, td, nl, nd);
a0100e24:	02202021 	move	a0,s1
a0100e28:	02802821 	move	a1,s4
a0100e2c:	02c03021 	move	a2,s6
a0100e30:	02003821 	move	a3,s0
a0100e34:	afb50010 	sw	s5,16(sp)
a0100e38:	afb20014 	sw	s2,20(sp)
a0100e3c:	0c04008a 	jal	a0100228 <inflate_codes>
a0100e40:	afb30018 	sw	s3,24(sp)
}
a0100e44:	8fbf0444 	lw	ra,1092(sp)
a0100e48:	8fbe0440 	lw	s8,1088(sp)
a0100e4c:	8fb7043c 	lw	s7,1084(sp)
a0100e50:	8fb60438 	lw	s6,1080(sp)
a0100e54:	8fb50434 	lw	s5,1076(sp)
a0100e58:	8fb40430 	lw	s4,1072(sp)
a0100e5c:	8fb3042c 	lw	s3,1068(sp)
a0100e60:	8fb20428 	lw	s2,1064(sp)
a0100e64:	8fb10424 	lw	s1,1060(sp)
a0100e68:	8fb00420 	lw	s0,1056(sp)
a0100e6c:	03e00008 	jr	ra
a0100e70:	27bd0448 	addiu	sp,sp,1096
a0100e74:	8fbf0444 	lw	ra,1092(sp)
a0100e78:	8fbe0440 	lw	s8,1088(sp)
a0100e7c:	8fb7043c 	lw	s7,1084(sp)
a0100e80:	8fb60438 	lw	s6,1080(sp)
a0100e84:	8fb50434 	lw	s5,1076(sp)
a0100e88:	8fb40430 	lw	s4,1072(sp)
a0100e8c:	8fb3042c 	lw	s3,1068(sp)
a0100e90:	8fb20428 	lw	s2,1064(sp)
a0100e94:	8fb10424 	lw	s1,1060(sp)
a0100e98:	8fb00420 	lw	s0,1056(sp)
	huft_build_table(ll, nl, tl);

	build_bits_table(guz, lb, tb, 19, ld, nd);
	huft_build_table(ld, nd, td);

	return inflate_codes(guz, ll, tl, ld, td, nl, nd);
a0100e9c:	24020001 	li	v0,1
}
a0100ea0:	03e00008 	jr	ra
a0100ea4:	27bd0448 	addiu	sp,sp,1096

a0100ea8 <get_crc>:
	ulong crc;
	uchar ch;
	int i;

	crc = 0xffffffffL;
	for (i = 0; i < len; i++) {
a0100ea8:	18a00011 	blez	a1,a0100ef0 <get_crc+0x48>
a0100eac:	00001021 	move	v0,zero
a0100eb0:	3c08a010 	lui	t0,0xa010
a0100eb4:	25081518 	addiu	t0,t0,5400
a0100eb8:	00001821 	move	v1,zero
a0100ebc:	2402ffff 	li	v0,-1
		ch = buf[i];
		crc = crc_32_tab[((int)crc ^ ch) & 0xff] ^ (crc >> 8);
a0100ec0:	00833021 	addu	a2,a0,v1
a0100ec4:	90c70000 	lbu	a3,0(a2)
a0100ec8:	00023202 	srl	a2,v0,0x8
	ulong crc;
	uchar ch;
	int i;

	crc = 0xffffffffL;
	for (i = 0; i < len; i++) {
a0100ecc:	24630001 	addiu	v1,v1,1
		ch = buf[i];
		crc = crc_32_tab[((int)crc ^ ch) & 0xff] ^ (crc >> 8);
a0100ed0:	00471026 	xor	v0,v0,a3
a0100ed4:	304200ff 	andi	v0,v0,0xff
a0100ed8:	00021080 	sll	v0,v0,0x2
a0100edc:	01021021 	addu	v0,t0,v0
a0100ee0:	8c420000 	lw	v0,0(v0)
	ulong crc;
	uchar ch;
	int i;

	crc = 0xffffffffL;
	for (i = 0; i < len; i++) {
a0100ee4:	1465fff6 	bne	v1,a1,a0100ec0 <get_crc+0x18>
a0100ee8:	00461026 	xor	v0,v0,a2
a0100eec:	00021027 	nor	v0,zero,v0
		crc = crc_32_tab[((int)crc ^ ch) & 0xff] ^ (crc >> 8);
	}
	crc = (crc ^ 0xffffffffL);

	return crc;
}
a0100ef0:	03e00008 	jr	ra
a0100ef4:	00000000 	nop

a0100ef8 <gunzip>:

int gunzip(uchar *inbuf, ulong *insize, uchar *outbuf, ulong *outsize)
{
a0100ef8:	27bdffa8 	addiu	sp,sp,-88
a0100efc:	afbf0054 	sw	ra,84(sp)
a0100f00:	afb50050 	sw	s5,80(sp)
a0100f04:	afb4004c 	sw	s4,76(sp)
a0100f08:	afb30048 	sw	s3,72(sp)
a0100f0c:	afb20044 	sw	s2,68(sp)
a0100f10:	afb10040 	sw	s1,64(sp)
a0100f14:	afb0003c 	sw	s0,60(sp)
	ulong orig_crc = 0;       /* original crc */
	ulong orig_len = 0;       /* original uncompressed length */
	int res;

	guz = &guz_struct;
	init_gunzip_struct(guz, inbuf, *insize, outbuf, *outsize);
a0100f18:	8ca20000 	lw	v0,0(a1)
a0100f1c:	8ce30000 	lw	v1,0(a3)

	return crc;
}

int gunzip(uchar *inbuf, ulong *insize, uchar *outbuf, ulong *outsize)
{
a0100f20:	00a08021 	move	s0,a1
{
	guz->inbuf = inbuf;
	guz->insize = insize;
	guz->inptr = 0;

	guz->outbuf = outbuf;
a0100f24:	afa6001c 	sw	a2,28(sp)
	guz->outsize = outsize;
a0100f28:	afa30020 	sw	v1,32(sp)
}

static void init_gunzip_struct(gunzip_t *guz,
	uchar *inbuf, ulong insize, uchar *outbuf, ulong outsize)
{
	guz->inbuf = inbuf;
a0100f2c:	afa40010 	sw	a0,16(sp)
	guz->insize = insize;
a0100f30:	afa20014 	sw	v0,20(sp)
	guz->inptr = 0;

	guz->outbuf = outbuf;
	guz->outsize = outsize;
	guz->outptr = 0;
a0100f34:	afa00024 	sw	zero,36(sp)

	guz->bitbuf = 0;
a0100f38:	afa00028 	sw	zero,40(sp)
	int res;

	guz = &guz_struct;
	init_gunzip_struct(guz, inbuf, *insize, outbuf, *outsize);

	magic[0] = get_uchar(guz);
a0100f3c:	10400014 	beqz	v0,a0100f90 <gunzip+0x98>
a0100f40:	afa0002c 	sw	zero,44(sp)
a0100f44:	24050001 	li	a1,1
a0100f48:	afa50018 	sw	a1,24(sp)
	magic[1] = get_uchar(guz);
a0100f4c:	2c430002 	sltiu	v1,v0,2
a0100f50:	1460010e 	bnez	v1,a010138c <gunzip+0x494>
a0100f54:	90850000 	lbu	a1,0(a0)
a0100f58:	24030002 	li	v1,2
a0100f5c:	afa30018 	sw	v1,24(sp)
	method = get_uchar(guz);
a0100f60:	2c420003 	sltiu	v0,v0,3

	guz = &guz_struct;
	init_gunzip_struct(guz, inbuf, *insize, outbuf, *outsize);

	magic[0] = get_uchar(guz);
	magic[1] = get_uchar(guz);
a0100f64:	90860001 	lbu	a2,1(a0)
	method = get_uchar(guz);
a0100f68:	14400004 	bnez	v0,a0100f7c <gunzip+0x84>
a0100f6c:	00001821 	move	v1,zero
a0100f70:	24020003 	li	v0,3
a0100f74:	90830002 	lbu	v1,2(a0)
a0100f78:	afa20018 	sw	v0,24(sp)

	if (magic[0] != 0x1f || magic[1] != 0x8b)
a0100f7c:	2402001f 	li	v0,31
a0100f80:	14a20003 	bne	a1,v0,a0100f90 <gunzip+0x98>
a0100f84:	2402008b 	li	v0,139
a0100f88:	10c2000b 	beq	a2,v0,a0100fb8 <gunzip+0xc0>
a0100f8c:	24040008 	li	a0,8
		return ERR_LENGTH;

	*insize = guz->inptr;
	*outsize = guz->outptr;

	return 0;
a0100f90:	24020001 	li	v0,1
}
a0100f94:	8fbf0054 	lw	ra,84(sp)
a0100f98:	8fb50050 	lw	s5,80(sp)
a0100f9c:	8fb4004c 	lw	s4,76(sp)
a0100fa0:	8fb30048 	lw	s3,72(sp)
a0100fa4:	8fb20044 	lw	s2,68(sp)
a0100fa8:	8fb10040 	lw	s1,64(sp)
a0100fac:	8fb0003c 	lw	s0,60(sp)
a0100fb0:	03e00008 	jr	ra
a0100fb4:	27bd0058 	addiu	sp,sp,88

	if (magic[0] != 0x1f || magic[1] != 0x8b)
		return ERR_BADMAGIC;

	/* We only support method #8, DEFLATED */
	if (method != 8)
a0100fb8:	1464fff6 	bne	v1,a0,a0100f94 <gunzip+0x9c>
a0100fbc:	24020002 	li	v0,2
		return ERR_BADMETHOD;

	flags  = get_uchar(guz);
a0100fc0:	8fa40018 	lw	a0,24(sp)
a0100fc4:	8fa30014 	lw	v1,20(sp)
a0100fc8:	0083102b 	sltu	v0,a0,v1
a0100fcc:	1040005c 	beqz	v0,a0101140 <gunzip+0x248>
a0100fd0:	27b20010 	addiu	s2,sp,16
	if (flags & ENCRYPTED)
a0100fd4:	8fa50010 	lw	a1,16(sp)
a0100fd8:	00a42821 	addu	a1,a1,a0
a0100fdc:	90a50000 	lbu	a1,0(a1)
a0100fe0:	30a60020 	andi	a2,a1,0x20
a0100fe4:	14c0ffeb 	bnez	a2,a0100f94 <gunzip+0x9c>
a0100fe8:	24020003 	li	v0,3
		return ERR_ENCRYPTED;

	if (flags & CONTINUATION)
a0100fec:	30a60002 	andi	a2,a1,0x2
a0100ff0:	14c0ffe8 	bnez	a2,a0100f94 <gunzip+0x9c>
a0100ff4:	24020004 	li	v0,4

	/* We only support method #8, DEFLATED */
	if (method != 8)
		return ERR_BADMETHOD;

	flags  = get_uchar(guz);
a0100ff8:	24860001 	addiu	a2,a0,1
		return ERR_ENCRYPTED;

	if (flags & CONTINUATION)
		return ERR_MULTIPART;

	if (flags & RESERVED)
a0100ffc:	30a800c0 	andi	t0,a1,0xc0

	/* We only support method #8, DEFLATED */
	if (method != 8)
		return ERR_BADMETHOD;

	flags  = get_uchar(guz);
a0101000:	afa60018 	sw	a2,24(sp)
		return ERR_ENCRYPTED;

	if (flags & CONTINUATION)
		return ERR_MULTIPART;

	if (flags & RESERVED)
a0101004:	1500ffe3 	bnez	t0,a0100f94 <gunzip+0x9c>
a0101008:	24020005 	li	v0,5
		return ERR_INVALIDFLAGS;

	get_ulong(guz);        /* Get timestamp */
a010100c:	00c3302b 	sltu	a2,a2,v1
a0101010:	10c00016 	beqz	a2,a010106c <gunzip+0x174>
a0101014:	24820002 	addiu	v0,a0,2
a0101018:	0043302b 	sltu	a2,v0,v1
a010101c:	10c00013 	beqz	a2,a010106c <gunzip+0x174>
a0101020:	afa20018 	sw	v0,24(sp)
a0101024:	24840003 	addiu	a0,a0,3
a0101028:	0083102b 	sltu	v0,a0,v1
a010102c:	1040000f 	beqz	v0,a010106c <gunzip+0x174>
a0101030:	afa40018 	sw	a0,24(sp)
a0101034:	24820001 	addiu	v0,a0,1
a0101038:	0043302b 	sltu	a2,v0,v1
a010103c:	10c0000b 	beqz	a2,a010106c <gunzip+0x174>
a0101040:	afa20018 	sw	v0,24(sp)
a0101044:	24820002 	addiu	v0,a0,2

	get_uchar(guz);        /* Ignore extra flags for the moment */
a0101048:	0043302b 	sltu	a2,v0,v1
a010104c:	10c00007 	beqz	a2,a010106c <gunzip+0x174>
a0101050:	afa20018 	sw	v0,24(sp)
a0101054:	24820003 	addiu	v0,a0,3
	get_uchar(guz);        /* Ignore OS type for the moment */
a0101058:	0043302b 	sltu	a2,v0,v1
a010105c:	10c00003 	beqz	a2,a010106c <gunzip+0x174>
a0101060:	afa20018 	sw	v0,24(sp)
a0101064:	24840004 	addiu	a0,a0,4
a0101068:	afa40018 	sw	a0,24(sp)

	if (flags & EXTRA_FIELD) {
a010106c:	30a20004 	andi	v0,a1,0x4
a0101070:	1040001a 	beqz	v0,a01010dc <gunzip+0x1e4>
a0101074:	30a20008 	andi	v0,a1,0x8
		ushort len;

		len = get_ushort(guz);
a0101078:	8fa40018 	lw	a0,24(sp)
a010107c:	0083302b 	sltu	a2,a0,v1
a0101080:	10c00011 	beqz	a2,a01010c8 <gunzip+0x1d0>
a0101084:	00001021 	move	v0,zero
a0101088:	8fa80010 	lw	t0,16(sp)
a010108c:	24860001 	addiu	a2,a0,1
a0101090:	00c3482b 	sltu	t1,a2,v1
a0101094:	01041021 	addu	v0,t0,a0
a0101098:	90420000 	lbu	v0,0(v0)
a010109c:	112000be 	beqz	t1,a0101398 <gunzip+0x4a0>
a01010a0:	afa60018 	sw	a2,24(sp)
a01010a4:	01063021 	addu	a2,t0,a2
a01010a8:	80c60000 	lb	a2,0(a2)
a01010ac:	24840002 	addiu	a0,a0,2
a01010b0:	00063200 	sll	a2,a2,0x8
a01010b4:	00c21025 	or	v0,a2,v0
		while (len--)
a01010b8:	08040432 	j	a01010c8 <gunzip+0x1d0>
a01010bc:	3042ffff 	andi	v0,v0,0xffff
			get_uchar(guz);
a01010c0:	00862021 	addu	a0,a0,a2
a01010c4:	3102ffff 	andi	v0,t0,0xffff
a01010c8:	2448ffff 	addiu	t0,v0,-1

	if (flags & EXTRA_FIELD) {
		ushort len;

		len = get_ushort(guz);
		while (len--)
a01010cc:	1440fffc 	bnez	v0,a01010c0 <gunzip+0x1c8>
a01010d0:	0083302b 	sltu	a2,a0,v1
a01010d4:	afa40018 	sw	a0,24(sp)
			get_uchar(guz);
	}

	/* Get original file name if it was truncated */
	if (flags & ORIG_NAME) {
a01010d8:	30a20008 	andi	v0,a1,0x8
a01010dc:	1040000a 	beqz	v0,a0101108 <gunzip+0x210>
a01010e0:	8fa40010 	lw	a0,16(sp)
a01010e4:	8fa20018 	lw	v0,24(sp)
		/* Discard the old name */
		while (get_uchar(guz) != 0);
a01010e8:	00822021 	addu	a0,a0,v0
a01010ec:	0043302b 	sltu	a2,v0,v1
a01010f0:	10c00005 	beqz	a2,a0101108 <gunzip+0x210>
a01010f4:	24420001 	addiu	v0,v0,1
a01010f8:	90860000 	lbu	a2,0(a0)
a01010fc:	afa20018 	sw	v0,24(sp)
a0101100:	14c0fffa 	bnez	a2,a01010ec <gunzip+0x1f4>
a0101104:	24840001 	addiu	a0,a0,1
	}

	/* Discard file comment if any */
	if (flags & COMMENT) {
a0101108:	30a50010 	andi	a1,a1,0x10
a010110c:	10a0000c 	beqz	a1,a0101140 <gunzip+0x248>
a0101110:	27b20010 	addiu	s2,sp,16
a0101114:	8fa20018 	lw	v0,24(sp)
		while (get_uchar(guz) != 0);
a0101118:	8fa40010 	lw	a0,16(sp)
a010111c:	00822021 	addu	a0,a0,v0
a0101120:	0043282b 	sltu	a1,v0,v1
a0101124:	10a00005 	beqz	a1,a010113c <gunzip+0x244>
a0101128:	24420001 	addiu	v0,v0,1
a010112c:	90850000 	lbu	a1,0(a0)
a0101130:	afa20018 	sw	v0,24(sp)
a0101134:	14a0fffa 	bnez	a1,a0101120 <gunzip+0x228>
a0101138:	24840001 	addiu	a0,a0,1
a010113c:	27b20010 	addiu	s2,sp,16
static int inflate_block(gunzip_t *guz, ulong *e)
{
	ulong t;           /* block type */

	/* read in last block bit */
	*e = get_bits(guz, 1);
a0101140:	24050001 	li	a1,1
a0101144:	02402021 	move	a0,s2
a0101148:	0c040066 	jal	a0100198 <get_bits>
a010114c:	afa70030 	sw	a3,48(sp)

	/* read in block type */
	t = get_bits(guz, 2);
a0101150:	02402021 	move	a0,s2
a0101154:	24050002 	li	a1,2
a0101158:	0c040066 	jal	a0100198 <get_bits>
a010115c:	0040a821 	move	s5,v0

	/* inflate that block type */
	if (t == 0)
a0101160:	1040000c 	beqz	v0,a0101194 <gunzip+0x29c>
a0101164:	8fa70030 	lw	a3,48(sp)
		return inflate_stored(guz);
	if (t == 1)
a0101168:	24030001 	li	v1,1
a010116c:	10430078 	beq	v0,v1,a0101350 <gunzip+0x458>
a0101170:	24030002 	li	v1,2
		return inflate_fixed(guz);
	if (t == 2)
a0101174:	10430018 	beq	v0,v1,a01011d8 <gunzip+0x2e0>
a0101178:	24030001 	li	v1,1
	crc = (crc ^ 0xffffffffL);

	return crc;
}

int gunzip(uchar *inbuf, ulong *insize, uchar *outbuf, ulong *outsize)
a010117c:	3c02a010 	lui	v0,0xa010
a0101180:	24421918 	addiu	v0,v0,6424
a0101184:	00031880 	sll	v1,v1,0x2
a0101188:	00621821 	addu	v1,v1,v0
a010118c:	080403e5 	j	a0100f94 <gunzip+0x9c>
a0101190:	8c620000 	lw	v0,0(v1)
{
	ulong n;           /* number of bytes in block */

	/* go to byte boundary */
	n = guz->bufbits & 7;
	get_bits(guz, n);
a0101194:	8fa5002c 	lw	a1,44(sp)
a0101198:	02402021 	move	a0,s2
a010119c:	0c040066 	jal	a0100198 <get_bits>
a01011a0:	30a50007 	andi	a1,a1,0x7

	/* get the length and its complement */
	n = get_bits(guz, 16);
a01011a4:	02402021 	move	a0,s2
a01011a8:	0c040066 	jal	a0100198 <get_bits>
a01011ac:	24050010 	li	a1,16
	if (n != (~get_bits(guz, 16) & 0xffff))
a01011b0:	02402021 	move	a0,s2
a01011b4:	24050010 	li	a1,16
a01011b8:	0c040066 	jal	a0100198 <get_bits>
a01011bc:	00409821 	move	s3,v0
a01011c0:	00021027 	nor	v0,zero,v0
a01011c4:	3042ffff 	andi	v0,v0,0xffff
a01011c8:	1262004f 	beq	s3,v0,a0101308 <gunzip+0x410>
a01011cc:	8fa70030 	lw	a3,48(sp)
		return ERR_LENGTH;

	*insize = guz->inptr;
	*outsize = guz->outptr;

	return 0;
a01011d0:	0804045f 	j	a010117c <gunzip+0x284>
a01011d4:	00001821 	move	v1,zero
	if (t == 0)
		return inflate_stored(guz);
	if (t == 1)
		return inflate_fixed(guz);
	if (t == 2)
		return inflate_dynamic(guz);
a01011d8:	02402021 	move	a0,s2
a01011dc:	0c040334 	jal	a0100cd0 <inflate_dynamic>
a01011e0:	afa70030 	sw	a3,48(sp)
	unsigned h;           /* maximum struct huft's malloc'ed */
	void *ptr;

	/* decompress until the last block */
	do {
		if ((r = inflate_block(guz, &e)) != 0) {
a01011e4:	14400063 	bnez	v0,a0101374 <gunzip+0x47c>
a01011e8:	8fa70030 	lw	a3,48(sp)
			return r;
		}
	} while (!e);
a01011ec:	12a0ffd5 	beqz	s5,a0101144 <gunzip+0x24c>
a01011f0:	24050001 	li	a1,1

	/* Undo too much lookahead. The next read will be byte aligned so we
	 * can discard unused bits in the last meaningful byte.
	 */
	while (guz->bufbits >= 8) {
a01011f4:	8fa2002c 	lw	v0,44(sp)
a01011f8:	2c430008 	sltiu	v1,v0,8
a01011fc:	1460005b 	bnez	v1,a010136c <gunzip+0x474>
a0101200:	2444fff8 	addiu	a0,v0,-8
	crc = (crc ^ 0xffffffffL);

	return crc;
}

int gunzip(uchar *inbuf, ulong *insize, uchar *outbuf, ulong *outsize)
a0101204:	8fa20018 	lw	v0,24(sp)
a0101208:	000418c2 	srl	v1,a0,0x3
a010120c:	000328c0 	sll	a1,v1,0x3
a0101210:	2442ffff 	addiu	v0,v0,-1
a0101214:	00852023 	subu	a0,a0,a1
a0101218:	00431023 	subu	v0,v0,v1
a010121c:	afa4002c 	sw	a0,44(sp)
a0101220:	afa20018 	sw	v0,24(sp)

	/* Get the crc and original length */
	/* crc32  (see algorithm.doc)
	 * uncompressed input size modulo 2^32
	 */
	orig_crc = get_ulong(guz);
a0101224:	8fa30014 	lw	v1,20(sp)
a0101228:	0043202b 	sltu	a0,v0,v1
a010122c:	1080002e 	beqz	a0,a01012e8 <gunzip+0x3f0>
a0101230:	00002021 	move	a0,zero
a0101234:	24440001 	addiu	a0,v0,1
a0101238:	0083282b 	sltu	a1,a0,v1
a010123c:	10a00042 	beqz	a1,a0101348 <gunzip+0x450>
a0101240:	afa40018 	sw	a0,24(sp)
a0101244:	24440002 	addiu	a0,v0,2
a0101248:	0083282b 	sltu	a1,a0,v1
a010124c:	10a0003e 	beqz	a1,a0101348 <gunzip+0x450>
a0101250:	afa40018 	sw	a0,24(sp)
a0101254:	24440003 	addiu	a0,v0,3
a0101258:	0083282b 	sltu	a1,a0,v1
a010125c:	10a0003a 	beqz	a1,a0101348 <gunzip+0x450>
a0101260:	afa40018 	sw	a0,24(sp)
a0101264:	24440004 	addiu	a0,v0,4
	orig_len = get_ulong(guz);
a0101268:	0083282b 	sltu	a1,a0,v1
a010126c:	10a00036 	beqz	a1,a0101348 <gunzip+0x450>
a0101270:	afa40018 	sw	a0,24(sp)
a0101274:	8fa50010 	lw	a1,16(sp)
a0101278:	24460005 	addiu	a2,v0,5
a010127c:	00c3402b 	sltu	t0,a2,v1
a0101280:	00a42021 	addu	a0,a1,a0
a0101284:	90840000 	lbu	a0,0(a0)
a0101288:	11000017 	beqz	t0,a01012e8 <gunzip+0x3f0>
a010128c:	afa60018 	sw	a2,24(sp)
a0101290:	00a63021 	addu	a2,a1,a2
a0101294:	90c90000 	lbu	t1,0(a2)
a0101298:	24460006 	addiu	a2,v0,6
a010129c:	00c3402b 	sltu	t0,a2,v1
a01012a0:	00094a00 	sll	t1,t1,0x8
a01012a4:	00892025 	or	a0,a0,t1
a01012a8:	1100000f 	beqz	t0,a01012e8 <gunzip+0x3f0>
a01012ac:	afa60018 	sw	a2,24(sp)
a01012b0:	00a63021 	addu	a2,a1,a2
a01012b4:	90c80000 	lbu	t0,0(a2)
a01012b8:	24460007 	addiu	a2,v0,7
a01012bc:	00c3182b 	sltu	v1,a2,v1
a01012c0:	00084400 	sll	t0,t0,0x10
a01012c4:	00882025 	or	a0,a0,t0
a01012c8:	10600007 	beqz	v1,a01012e8 <gunzip+0x3f0>
a01012cc:	afa60018 	sw	a2,24(sp)
a01012d0:	00a62821 	addu	a1,a1,a2
a01012d4:	90a30000 	lbu	v1,0(a1)
a01012d8:	24420008 	addiu	v0,v0,8
a01012dc:	afa20018 	sw	v0,24(sp)
a01012e0:	00031600 	sll	v0,v1,0x18
a01012e4:	00822025 	or	a0,a0,v0

	/* Validate decompression */
//	if (orig_crc != get_crc(guz->outbuf, guz->outptr))
//		return ERR_CRC;

	if (orig_len != guz->outptr)
a01012e8:	8fa30024 	lw	v1,36(sp)
a01012ec:	1483ff29 	bne	a0,v1,a0100f94 <gunzip+0x9c>
a01012f0:	2402000b 	li	v0,11
		return ERR_LENGTH;

	*insize = guz->inptr;
a01012f4:	8fa30018 	lw	v1,24(sp)
	*outsize = guz->outptr;
a01012f8:	00001021 	move	v0,zero
//		return ERR_CRC;

	if (orig_len != guz->outptr)
		return ERR_LENGTH;

	*insize = guz->inptr;
a01012fc:	ae030000 	sw	v1,0(s0)
	*outsize = guz->outptr;

	return 0;
a0101300:	080403e5 	j	a0100f94 <gunzip+0x9c>
a0101304:	ace40000 	sw	a0,0(a3)
	n = get_bits(guz, 16);
	if (n != (~get_bits(guz, 16) & 0xffff))
		return 1;                   /* error in compressed data */

	/* read and output the compressed data */
	while (n--)
a0101308:	1260ffb8 	beqz	s3,a01011ec <gunzip+0x2f4>
a010130c:	8fb10024 	lw	s1,36(sp)
		output_char(guz, (uchar)get_bits(guz, 8));
a0101310:	8fb4001c 	lw	s4,28(sp)
a0101314:	02402021 	move	a0,s2
a0101318:	24050008 	li	a1,8
a010131c:	0291a021 	addu	s4,s4,s1
a0101320:	0c040066 	jal	a0100198 <get_bits>
a0101324:	afa70030 	sw	a3,48(sp)
a0101328:	a2820000 	sb	v0,0(s4)
a010132c:	26310001 	addiu	s1,s1,1
a0101330:	2673ffff 	addiu	s3,s3,-1
a0101334:	afb10024 	sw	s1,36(sp)
	n = get_bits(guz, 16);
	if (n != (~get_bits(guz, 16) & 0xffff))
		return 1;                   /* error in compressed data */

	/* read and output the compressed data */
	while (n--)
a0101338:	1660fff5 	bnez	s3,a0101310 <gunzip+0x418>
a010133c:	8fa70030 	lw	a3,48(sp)
a0101340:	0804047b 	j	a01011ec <gunzip+0x2f4>
a0101344:	00000000 	nop

	/* Get the crc and original length */
	/* crc32  (see algorithm.doc)
	 * uncompressed input size modulo 2^32
	 */
	orig_crc = get_ulong(guz);
a0101348:	080404ba 	j	a01012e8 <gunzip+0x3f0>
a010134c:	00002021 	move	a0,zero

	/* inflate that block type */
	if (t == 0)
		return inflate_stored(guz);
	if (t == 1)
		return inflate_fixed(guz);
a0101350:	02402021 	move	a0,s2
a0101354:	0c04025b 	jal	a010096c <inflate_fixed>
a0101358:	afa70030 	sw	a3,48(sp)
	unsigned h;           /* maximum struct huft's malloc'ed */
	void *ptr;

	/* decompress until the last block */
	do {
		if ((r = inflate_block(guz, &e)) != 0) {
a010135c:	1040ffa3 	beqz	v0,a01011ec <gunzip+0x2f4>
a0101360:	8fa70030 	lw	a3,48(sp)
	crc = (crc ^ 0xffffffffL);

	return crc;
}

int gunzip(uchar *inbuf, ulong *insize, uchar *outbuf, ulong *outsize)
a0101364:	080404de 	j	a0101378 <gunzip+0x480>
a0101368:	2443ffff 	addiu	v1,v0,-1
		return ERR_LENGTH;

	*insize = guz->inptr;
	*outsize = guz->outptr;

	return 0;
a010136c:	08040489 	j	a0101224 <gunzip+0x32c>
a0101370:	8fa20018 	lw	v0,24(sp)
	crc = (crc ^ 0xffffffffL);

	return crc;
}

int gunzip(uchar *inbuf, ulong *insize, uchar *outbuf, ulong *outsize)
a0101374:	2443ffff 	addiu	v1,v0,-1
a0101378:	2c640003 	sltiu	a0,v1,3
a010137c:	1080ff05 	beqz	a0,a0100f94 <gunzip+0x9c>
a0101380:	24020009 	li	v0,9
a0101384:	08040460 	j	a0101180 <gunzip+0x288>
a0101388:	3c02a010 	lui	v0,0xa010

	guz = &guz_struct;
	init_gunzip_struct(guz, inbuf, *insize, outbuf, *outsize);

	magic[0] = get_uchar(guz);
	magic[1] = get_uchar(guz);
a010138c:	00003021 	move	a2,zero
a0101390:	080403df 	j	a0100f7c <gunzip+0x84>
a0101394:	00001821 	move	v1,zero
	get_uchar(guz);        /* Ignore OS type for the moment */

	if (flags & EXTRA_FIELD) {
		ushort len;

		len = get_ushort(guz);
a0101398:	3042ffff 	andi	v0,v0,0xffff
a010139c:	08040432 	j	a01010c8 <gunzip+0x1d0>
a01013a0:	00c02021 	move	a0,a2
	...

a01013b0 <mask_bits>:
a01013b0:	00000001 00030007 000f001f 003f007f     .............?..
a01013c0:	00ff01ff 03ff07ff 0fff1fff 3fff7fff     ............?...
a01013d0:	ffff0000                                ....

a01013d4 <cplext>:
	...
a01013e4:	00010001 00010001 00020002 00020002     ................
a01013f4:	00030003 00030003 00040004 00040004     ................
a0101404:	00050005 00050005 00000063 00630000     ...........c.c..

a0101414 <cplens>:
a0101414:	00030004 00050006 00070008 0009000a     ................
a0101424:	000b000d 000f0011 00130017 001b001f     ................
a0101434:	0023002b 0033003b 00430053 00630073     .#.+.3.;.C.S.c.s
a0101444:	008300a3 00c300e3 01020000 00000000     ................

a0101454 <cpdist>:
a0101454:	00010002 00030004 00050007 0009000d     ................
a0101464:	00110019 00210031 00410061 008100c1     .....!.1.A.a....
a0101474:	01010181 02010301 04010601 08010c01     ................
a0101484:	10011801 20013001 40016001              .... .0.@.`.

a0101490 <cpdext>:
	...
a0101498:	00010001 00020002 00030003 00040004     ................
a01014a8:	00050005 00060006 00070007 00080008     ................
a01014b8:	00090009 000a000a 000b000b 000c000c     ................
a01014c8:	000d000d                                ....

a01014cc <border>:
a01014cc:	00000010 00000011 00000012 00000000     ................
a01014dc:	00000008 00000007 00000009 00000006     ................
a01014ec:	0000000a 00000005 0000000b 00000004     ................
a01014fc:	0000000c 00000003 0000000d 00000002     ................
a010150c:	0000000e 00000001 0000000f              ............

a0101518 <crc_32_tab>:
a0101518:	00000000 77073096 ee0e612c 990951ba     ....w.0...a,..Q.
a0101528:	076dc419 706af48f e963a535 9e6495a3     .m..pj...c.5.d..
a0101538:	0edb8832 79dcb8a4 e0d5e91e 97d2d988     ...2y...........
a0101548:	09b64c2b 7eb17cbd e7b82d07 90bf1d91     ..L+~.|...-.....
a0101558:	1db71064 6ab020f2 f3b97148 84be41de     ...dj. ...qH..A.
a0101568:	1adad47d 6ddde4eb f4d4b551 83d385c7     ...}m......Q....
a0101578:	136c9856 646ba8c0 fd62f97a 8a65c9ec     .l.Vdk...b.z.e..
a0101588:	14015c4f 63066cd9 fa0f3d63 8d080df5     ..\Oc.l...=c....
a0101598:	3b6e20c8 4c69105e d56041e4 a2677172     ;n .Li.^.`A..gqr
a01015a8:	3c03e4d1 4b04d447 d20d85fd a50ab56b     <...K..G.......k
a01015b8:	35b5a8fa 42b2986c dbbbc9d6 acbcf940     5...B..l.......@
a01015c8:	32d86ce3 45df5c75 dcd60dcf abd13d59     2.l.E.\u......=Y
a01015d8:	26d930ac 51de003a c8d75180 bfd06116     &.0.Q..:..Q...a.
a01015e8:	21b4f4b5 56b3c423 cfba9599 b8bda50f     !...V..#........
a01015f8:	2802b89e 5f058808 c60cd9b2 b10be924     (..._..........$
a0101608:	2f6f7c87 58684c11 c1611dab b6662d3d     /o|.XhL..a...f-=
a0101618:	76dc4190 01db7106 98d220bc efd5102a     v.A...q... ....*
a0101628:	71b18589 06b6b51f 9fbfe4a5 e8b8d433     q..............3
a0101638:	7807c9a2 0f00f934 9609a88e e10e9818     x......4........
a0101648:	7f6a0dbb 086d3d2d 91646c97 e6635c01     .j...m=-.dl..c\.
a0101658:	6b6b51f4 1c6c6162 856530d8 f262004e     kkQ..lab.e0..b.N
a0101668:	6c0695ed 1b01a57b 8208f4c1 f50fc457     l......{.......W
a0101678:	65b0d9c6 12b7e950 8bbeb8ea fcb9887c     e......P.......|
a0101688:	62dd1ddf 15da2d49 8cd37cf3 fbd44c65     b.....-I..|...Le
a0101698:	4db26158 3ab551ce a3bc0074 d4bb30e2     M.aX:.Q....t..0.
a01016a8:	4adfa541 3dd895d7 a4d1c46d d3d6f4fb     J..A=......m....
a01016b8:	4369e96a 346ed9fc ad678846 da60b8d0     Ci.j4n...g.F.`..
a01016c8:	44042d73 33031de5 aa0a4c5f dd0d7cc9     D.-s3.....L_..|.
a01016d8:	5005713c 270241aa be0b1010 c90c2086     P.q<'.A....... .
a01016e8:	5768b525 206f85b3 b966d409 ce61e49f     Wh.% o...f...a..
a01016f8:	5edef90e 29d9c998 b0d09822 c7d7a8b4     ^...)......"....
a0101708:	59b33d17 2eb40d81 b7bd5c3b c0ba6cad     Y.=.......\;..l.
a0101718:	edb88320 9abfb3b6 03b6e20c 74b1d29a     ... ........t...
a0101728:	ead54739 9dd277af 04db2615 73dc1683     ..G9..w...&.s...
a0101738:	e3630b12 94643b84 0d6d6a3e 7a6a5aa8     .c...d;..mj>zjZ.
a0101748:	e40ecf0b 9309ff9d 0a00ae27 7d079eb1     ...........'}...
a0101758:	f00f9344 8708a3d2 1e01f268 6906c2fe     ...D.......hi...
a0101768:	f762575d 806567cb 196c3671 6e6b06e7     .bW].eg..l6qnk..
a0101778:	fed41b76 89d32be0 10da7a5a 67dd4acc     ...v..+...zZg.J.
a0101788:	f9b9df6f 8ebeeff9 17b7be43 60b08ed5     ...o.......C`...
a0101798:	d6d6a3e8 a1d1937e 38d8c2c4 4fdff252     .......~8...O..R
a01017a8:	d1bb67f1 a6bc5767 3fb506dd 48b2364b     ..g...Wg?...H.6K
a01017b8:	d80d2bda af0a1b4c 36034af6 41047a60     ..+....L6.J.A.z`
a01017c8:	df60efc3 a867df55 316e8eef 4669be79     .`...g.U1n..Fi.y
a01017d8:	cb61b38c bc66831a 256fd2a0 5268e236     .a...f..%o..Rh.6
a01017e8:	cc0c7795 bb0b4703 220216b9 5505262f     ..w...G."...U.&/
a01017f8:	c5ba3bbe b2bd0b28 2bb45a92 5cb36a04     ..;....(+.Z.\.j.
a0101808:	c2d7ffa7 b5d0cf31 2cd99e8b 5bdeae1d     .......1,...[...
a0101818:	9b64c2b0 ec63f226 756aa39c 026d930a     .d...c.&uj...m..
a0101828:	9c0906a9 eb0e363f 72076785 05005713     ......6?r.g...W.
a0101838:	95bf4a82 e2b87a14 7bb12bae 0cb61b38     ..J...z.{.+....8
a0101848:	92d28e9b e5d5be0d 7cdcefb7 0bdbdf21     ........|......!
a0101858:	86d3d2d4 f1d4e242 68ddb3f8 1fda836e     .......Bh......n
a0101868:	81be16cd f6b9265b 6fb077e1 18b74777     ......&[o.w...Gw
a0101878:	88085ae6 ff0f6a70 66063bca 11010b5c     ..Z...jpf.;....\
a0101888:	8f659eff f862ae69 616bffd3 166ccf45     .e...b.iak...l.E
a0101898:	a00ae278 d70dd2ee 4e048354 3903b3c2     ...x....N..T9...
a01018a8:	a7672661 d06016f7 4969474d 3e6e77db     .g&a.`..IiGM>nw.
a01018b8:	aed16a4a d9d65adc 40df0b66 37d83bf0     ..jJ..Z.@..f7.;.
a01018c8:	a9bcae53 debb9ec5 47b2cf7f 30b5ffe9     ...S....G...0...
a01018d8:	bdbdf21c cabac28a 53b39330 24b4a3a6     ........S..0$...
a01018e8:	bad03605 cdd70693 54de5729 23d967bf     ..6.....T.W)#.g.
a01018f8:	b3667a2e c4614ab8 5d681b02 2a6f2b94     .fz..aJ.]h..*o+.
a0101908:	b40bbe37 c30c8ea1 5a05df1b 2d02ef8d     ...7....Z...-...

a0101918 <CSWTCH.61>:
a0101918:	00000006 00000007 00000008 00000000     ................
	...
