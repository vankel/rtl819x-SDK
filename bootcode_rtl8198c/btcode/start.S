#include <asm/asm.h>
#include <asm/regdef.h>
#include <asm/mipsregs.h>
#include "start.h"
#include "../autoconf.h"


		.text
		.set noreorder
		.globl __start
__start:

		j 	reset
		nop     
		nop
		
//	.word 0x20120607		//ROM code version tag, 
//	.word 0x00000005
//--------------------------------------------------------------------------------              


reset:

	
	#if 1
		jal uart_show    //show boot msg
		nop
	#endif
	

	nop
	REG32_W(0xb8000098, 0x0); //Disable OTG_DETECT
	nop


#ifdef CONFIG_NAND_FLASH_BOOTING          //For NAND Flash booting



/////////////////////DDR ZQ calibration setting for both DDR2 and DDR3////////////////////////


REG32_ANDOR(0xb8001000, 0xFFFFFFFF, 0x1e0);  //DBFM	


#if 1
//REG32(0xb8001090)&=~(1<<25);//20140205:Fix tDQSH timing fail issue 
lui	v1,0xb800
ori	v0,v1,0x1090
lw	a1,0(v0)
lui	a0,0xfdff
ori	a0,a0,0xffff
and	a0,a1,a0
sw	a0,0(v0)
nop

//	REG32(0xb80000a0)|=(1<<24);//enable ZQ function for RTL8198C
ori	a0,v1,0xa0
lw	a2,0(a0)
lui	a1,0x100
or	a1,a2,a1
sw	a1,0(a0)
nop

//	REG32(0xb8001090)|=(1<<31);//Force ZQ
lw	a1,0(v0)
lui	a0,0x8000
or	a0,a1,a0
sw	a0,0(v0)
nop

	/* Trigger the calibration */
	
	//*zq_cali_reg = auto_cali_value | 0x80000000;//RTL8198C
	//REG32(0xb8001094)= 0x00024B16 | 0x80000000;//Force ZQ
ori	v1,v1,0x1094
lui	v0,0x8002
ori	v0,v0,0x4b16
sw	v0,0(v1)
nop

#if 0 //wait loop 
		UART_PRINT(nand_CDF_msg0); 
#endif

REG32_W(0xb800107c,0x0);//ODT low

#endif

////////////////////////////////////////////////////////////////////////


////////////////////////NAND+DDR2 configuration////////////////////////


#ifdef CONFIG_DDR2_32MB_16bit
REG32_W(0xb8001004,0x11210000);
#endif

#ifdef CONFIG_DDR2_64MB_16bit
REG32_W(0xb8001004,0x11220000);
#endif

#ifdef CONFIG_DDR2_128MB_16bit
REG32_W(0xb8001004,0x21220000);
#endif


#ifdef CONFIG_DDR2_390MHZ 
REG32_W(0xb8000010,0x80000800);
REG32_W(0xb8001800,0x40000000);
REG32_W(0xb8001064,0x100000ff);
REG32_W(0xb80000dc,0x24900400);
REG32_W(0xb8001804,0xb50f0000);
//REG32_W(0xb800101c,0x00100a52);
//REG32_W(0xb800101c,0x00110000);
//REG32_W(0xb800101c,0x00120000);
REG32_W(0xb8001000,0x12041de0);
REG32_W(0xb8001008,0x44333a30);
REG32_W(0xb800100c,0x05050313);
REG32_W(0xb8001010,0x08311000);
REG32_W(0xb8001500,0x80020210);
REG32_W(0xb8001050,0x1f1f0000);
REG32_W(0xb8001510,0x00040200);
REG32_W(0xb8001514,0x00040200);
REG32_W(0xb8001518,0x00040200);
REG32_W(0xb800151c,0x00040200);
REG32_W(0xb8001520,0x00040200);
REG32_W(0xb8001524,0x00040200);
REG32_W(0xb8001528,0x00040200);
REG32_W(0xb800152c,0x00040200);
REG32_W(0xb8001530,0x00040200);
REG32_W(0xb8001534,0x00040200);
REG32_W(0xb8001538,0x00040200);
REG32_W(0xb800153c,0x00040200);
REG32_W(0xb8001540,0x00040200);
REG32_W(0xb8001544,0x00040200);
REG32_W(0xb8001548,0x00040200);
REG32_W(0xb800154c,0x00040200);
REG32_W(0xb8001550,0x00040200);
REG32_W(0xb8001554,0x00040200);
REG32_W(0xb8001558,0x00040200);
REG32_W(0xb800155c,0x00040200);
REG32_W(0xb8001560,0x00040200);
REG32_W(0xb8001564,0x00040200);
REG32_W(0xb8001568,0x00040200);
REG32_W(0xb800156c,0x00040200);
REG32_W(0xb8001570,0x00040200);
REG32_W(0xb8001574,0x00040200);
REG32_W(0xb8001578,0x00040200);
REG32_W(0xb800157c,0x00040200);
REG32_W(0xb8001580,0x00040200);
REG32_W(0xb8001584,0x00040200);
REG32_W(0xb8001588,0x00040200);
REG32_W(0xb800158c,0x00040200);
//MR[1]=0x00110040
REG32_W(0xb800101c,0x00110040);

//MR[0]=0x00100952
REG32_W(0xb800101c,0x00100952);

//MR[2]=0x00120000
REG32_W(0xb800101c,0x00120000);

#endif



#ifdef CONFIG_DDR2_530MHZ 

#endif

////////////////////////////////////////////////////////////////////////



////////////////////////NAND+DDR3 configuration////////////////////////

#ifdef CONFIG_DDR3_128MB_16bit
REG32_W(0xb8001004,0x21220000);
#endif

#ifdef CONFIG_DDR3_256MB_16bit
REG32_W(0xb8001004,0x21320000);
#endif

#ifdef CONFIG_DDR3_512MB_16bit
REG32_W(0xb8001004,0x21420000);
#endif


#ifdef CONFIG_DDR3_250MHZ 
REG32_W(0xb80000a0,0x29000007);
REG32_W(0xb8001590,0x00000000);
REG32_W(0xb8000010,0x80000800);
REG32_W(0xb8001800,0x40000000);
REG32_W(0xb8001064,0x100000ff);
REG32_W(0xb80000dc,0x24900400);
REG32_W(0xb8001804,0xb50f0000);
//REG32_W(0xb800101c,0x00101210);
//REG32_W(0xb800101c,0x00110042);
//REG32_W(0xb800101c,0x00120200);
REG32_W(0xb8001000,0x22041de0);
REG32_W(0xb8001008,0x44433e20);
REG32_W(0xb800100c,0x0303030c);
REG32_W(0xb8001010,0x0510b000);
REG32_W(0xb8001500,0x80040410);
REG32_W(0xb8001050,0x1f1f0000);
REG32_W(0xb8001510,0x00040200);
REG32_W(0xb8001514,0x00040200);
REG32_W(0xb8001518,0x00040200);
REG32_W(0xb800151c,0x00040200);
REG32_W(0xb8001520,0x00040200);
REG32_W(0xb8001524,0x00040200);
REG32_W(0xb8001528,0x00040200);
REG32_W(0xb800152c,0x00040200);
REG32_W(0xb8001530,0x00040200);
REG32_W(0xb8001534,0x00040200);
REG32_W(0xb8001538,0x00040200);
REG32_W(0xb800153c,0x00040200);
REG32_W(0xb8001540,0x00040200);
REG32_W(0xb8001544,0x00040200);
REG32_W(0xb8001548,0x00040200);
REG32_W(0xb800154c,0x00040200);
REG32_W(0xb8001550,0x00040200);
REG32_W(0xb8001554,0x00040200);
REG32_W(0xb8001558,0x00040200);
REG32_W(0xb800155c,0x00040200);
REG32_W(0xb8001560,0x00040200);
REG32_W(0xb8001564,0x00040200);
REG32_W(0xb8001568,0x00040200);
REG32_W(0xb800156c,0x00040200);
REG32_W(0xb8001570,0x00040200);
REG32_W(0xb8001574,0x00040200);
REG32_W(0xb8001578,0x00040200);
REG32_W(0xb800157c,0x00040200);
REG32_W(0xb8001580,0x00040200);
REG32_W(0xb8001584,0x00040200);
REG32_W(0xb8001588,0x00040200);
REG32_W(0xb800158c,0x00040200);
//REG32_W(0xb800107c,0xc0000000);?
//MR[2]=0x00120200
REG32_W(0xb800101c,0x00120200);

//MR[3]=0x00130000
REG32_W(0xb800101c,0x00130000);

//MR[1]=0x00110042
REG32_W(0xb800101c,0x00110042);

//MR[0]=0x00101310
REG32_W(0xb800101c,0x00101310);
#endif


#ifdef CONFIG_DDR3_390MHZ 
REG32_W(0xb80000a0,0x29000007);
REG32_W(0xb8001590,0x00000000);
REG32_W(0xb8000010,0x80000800);
REG32_W(0xb8001800,0x40000000);
REG32_W(0xb8001064,0x100000ff);
REG32_W(0xb80000dc,0x24900400);
REG32_W(0xb8001804,0xb50f0000);
//REG32_W(0xb800101c,0x00101410);
//REG32_W(0xb800101c,0x00110042);
//REG32_W(0xb800101c,0x00120200);
REG32_W(0xb8001000,0x22041de0);
REG32_W(0xb8001008,0x45433a30);
REG32_W(0xb800100c,0x05050313);
REG32_W(0xb8001010,0x08311000);
REG32_W(0xb8001500,0x80030310);
REG32_W(0xb8001050,0x1f1f0000);
REG32_W(0xb8001510,0x00040200);
REG32_W(0xb8001514,0x00040200);
REG32_W(0xb8001518,0x00040200);
REG32_W(0xb800151c,0x00040200);
REG32_W(0xb8001520,0x00040200);
REG32_W(0xb8001524,0x00040200);
REG32_W(0xb8001528,0x00040200);
REG32_W(0xb800152c,0x00040200);
REG32_W(0xb8001530,0x00040200);
REG32_W(0xb8001534,0x00040200);
REG32_W(0xb8001538,0x00040200);
REG32_W(0xb800153c,0x00040200);
REG32_W(0xb8001540,0x00040200);
REG32_W(0xb8001544,0x00040200);
REG32_W(0xb8001548,0x00040200);
REG32_W(0xb800154c,0x00040200);
REG32_W(0xb8001550,0x00040200);
REG32_W(0xb8001554,0x00040200);
REG32_W(0xb8001558,0x00040200);
REG32_W(0xb800155c,0x00040200);
REG32_W(0xb8001560,0x00040200);
REG32_W(0xb8001564,0x00040200);
REG32_W(0xb8001568,0x00040200);
REG32_W(0xb800156c,0x00040200);
REG32_W(0xb8001570,0x00040200);
REG32_W(0xb8001574,0x00040200);
REG32_W(0xb8001578,0x00040200);
REG32_W(0xb800157c,0x00040200);
REG32_W(0xb8001580,0x00040200);
REG32_W(0xb8001584,0x00040200);
REG32_W(0xb8001588,0x00040200);
REG32_W(0xb800158c,0x00040200);
//REG32_W(0xb800107c,0xc0000000);
//MR[2]=0x00120200
REG32_W(0xb800101c,0x00120200);

//MR[3]=0x00130000
REG32_W(0xb800101c,0x00130000);

//MR[1]=0x00110042
REG32_W(0xb800101c,0x00110042);

//MR[0]=0x00101510
REG32_W(0xb800101c,0x00101510);
#endif


#ifdef CONFIG_DDR3_410MHZ
REG32_W(0xb80000a0,0x29000007);
REG32_W(0xb8001590,0x00000000);
REG32_W(0xb8000010,0x80000800);
REG32_W(0xb8001800,0x40000000);
REG32_W(0xb8001064,0x100000ff);
REG32_W(0xb80000dc,0x24900400);
REG32_W(0xb8001804,0xb50f0000);
//REG32_W(0xb800101c,0x00101630);
//REG32_W(0xb800101c,0x00110042);
//REG32_W(0xb800101c,0x00120208);
REG32_W(0xb8001000,0x22041de0);
REG32_W(0xb8001008,0x66533b30);
REG32_W(0xb800100c,0x06060414);
REG32_W(0xb8001010,0x08812000);
REG32_W(0xb8001500,0x80030210);
REG32_W(0xb8001050,0x1f1f0000);
REG32_W(0xb8001510,0x00040200);
REG32_W(0xb8001514,0x00040200);
REG32_W(0xb8001518,0x00040200);
REG32_W(0xb800151c,0x00040200);
REG32_W(0xb8001520,0x00040200);
REG32_W(0xb8001524,0x00040200);
REG32_W(0xb8001528,0x00040200);
REG32_W(0xb800152c,0x00040200);
REG32_W(0xb8001530,0x00040200);
REG32_W(0xb8001534,0x00040200);
REG32_W(0xb8001538,0x00040200);
REG32_W(0xb800153c,0x00040200);
REG32_W(0xb8001540,0x00040200);
REG32_W(0xb8001544,0x00040200);
REG32_W(0xb8001548,0x00040200);
REG32_W(0xb800154c,0x00040200);
REG32_W(0xb8001550,0x00040200);
REG32_W(0xb8001554,0x00040200);
REG32_W(0xb8001558,0x00040200);
REG32_W(0xb800155c,0x00040200);
REG32_W(0xb8001560,0x00040200);
REG32_W(0xb8001564,0x00040200);
REG32_W(0xb8001568,0x00040200);
REG32_W(0xb800156c,0x00040200);
REG32_W(0xb8001570,0x00040200);
REG32_W(0xb8001574,0x00040200);
REG32_W(0xb8001578,0x00040200);
REG32_W(0xb800157c,0x00040200);
REG32_W(0xb8001580,0x00040200);
REG32_W(0xb8001584,0x00040200);
REG32_W(0xb8001588,0x00040200);
REG32_W(0xb800158c,0x00040200);
//REG32_W(0xb800107c,0xc0000000);
//MR[2]=0x00120208
REG32_W(0xb800101c,0x00120208);

//MR[3]=0x00130000
REG32_W(0xb800101c,0x00130000);

//MR[1]=0x00110042
REG32_W(0xb800101c,0x00110042);

//MR[0]=0x00101730
REG32_W(0xb800101c,0x00101730);
#endif

#ifdef CONFIG_DDR3_490MHZ 
REG32_W(0xb80000a0,0x29000007);
REG32_W(0xb8001590,0x00000000);
REG32_W(0xb8000010,0x80000800);
REG32_W(0xb8001800,0x40000000);
REG32_W(0xb8001064,0x100000ff);
REG32_W(0xb80000dc,0x24900400);
REG32_W(0xb8001804,0xb50f0000);
//REG32_W(0xb800101c,0x00101830);
//REG32_W(0xb800101c,0x00110042);
//REG32_W(0xb800101c,0x00120208);
REG32_W(0xb8001000,0x22041de0);
REG32_W(0xb8001008,0x67533d30);
REG32_W(0xb800100c,0x07070418);
REG32_W(0xb8001010,0x0a316000);
REG32_W(0xb8001500,0x80020210);
REG32_W(0xb8001050,0x1f1f0000);
REG32_W(0xb8001510,0x00040200);
REG32_W(0xb8001514,0x00040200);
REG32_W(0xb8001518,0x00040200);
REG32_W(0xb800151c,0x00040200);
REG32_W(0xb8001520,0x00040200);
REG32_W(0xb8001524,0x00040200);
REG32_W(0xb8001528,0x00040200);
REG32_W(0xb800152c,0x00040200);
REG32_W(0xb8001530,0x00040200);
REG32_W(0xb8001534,0x00040200);
REG32_W(0xb8001538,0x00040200);
REG32_W(0xb800153c,0x00040200);
REG32_W(0xb8001540,0x00040200);
REG32_W(0xb8001544,0x00040200);
REG32_W(0xb8001548,0x00040200);
REG32_W(0xb800154c,0x00040200);
REG32_W(0xb8001550,0x00040200);
REG32_W(0xb8001554,0x00040200);
REG32_W(0xb8001558,0x00040200);
REG32_W(0xb800155c,0x00040200);
REG32_W(0xb8001560,0x00040200);
REG32_W(0xb8001564,0x00040200);
REG32_W(0xb8001568,0x00040200);
REG32_W(0xb800156c,0x00040200);
REG32_W(0xb8001570,0x00040200);
REG32_W(0xb8001574,0x00040200);
REG32_W(0xb8001578,0x00040200);
REG32_W(0xb800157c,0x00040200);
REG32_W(0xb8001580,0x00040200);
REG32_W(0xb8001584,0x00040200);
REG32_W(0xb8001588,0x00040200);
REG32_W(0xb800158c,0x00040200);
//REG32_W(0xb800107c,0xc0000000);
//MR[2]=0x00120208
REG32_W(0xb800101c,0x00120208);

//MR[3]=0x00130000
REG32_W(0xb800101c,0x00130000);

//MR[1]=0x00110042
REG32_W(0xb800101c,0x00110042);

//MR[0]=0x00101930
REG32_W(0xb800101c,0x00101930);
#endif	


#ifdef CONFIG_DDR3_510MHZ
REG32_W(0xb80000a0,0x29000007);
REG32_W(0xb8001590,0x00000000);
REG32_W(0xb8000010,0x80000800);
REG32_W(0xb8001800,0x40000000);
REG32_W(0xb8001064,0x100000ff);
REG32_W(0xb80000dc,0x24900400);
REG32_W(0xb8001804,0xb50f0000);
//REG32_W(0xb800101c,0x00101830);
//REG32_W(0xb800101c,0x00110042);
//REG32_W(0xb800101c,0x00120208);
REG32_W(0xb8001000,0x22041de0);
REG32_W(0xb8001008,0x67544e30);
REG32_W(0xb800100c,0x0707051a);
REG32_W(0xb8001010,0x0ac17000);
REG32_W(0xb8001500,0x80020210);
REG32_W(0xb8001050,0x1f1f0000);
REG32_W(0xb8001510,0x00040200);
REG32_W(0xb8001514,0x00040200);
REG32_W(0xb8001518,0x00040200);
REG32_W(0xb800151c,0x00040200);
REG32_W(0xb8001520,0x00040200);
REG32_W(0xb8001524,0x00040200);
REG32_W(0xb8001528,0x00040200);
REG32_W(0xb800152c,0x00040200);
REG32_W(0xb8001530,0x00040200);
REG32_W(0xb8001534,0x00040200);
REG32_W(0xb8001538,0x00040200);
REG32_W(0xb800153c,0x00040200);
REG32_W(0xb8001540,0x00040200);
REG32_W(0xb8001544,0x00040200);
REG32_W(0xb8001548,0x00040200);
REG32_W(0xb800154c,0x00040200);
REG32_W(0xb8001550,0x00040200);
REG32_W(0xb8001554,0x00040200);
REG32_W(0xb8001558,0x00040200);
REG32_W(0xb800155c,0x00040200);
REG32_W(0xb8001560,0x00040200);
REG32_W(0xb8001564,0x00040200);
REG32_W(0xb8001568,0x00040200);
REG32_W(0xb800156c,0x00040200);
REG32_W(0xb8001570,0x00040200);
REG32_W(0xb8001574,0x00040200);
REG32_W(0xb8001578,0x00040200);
REG32_W(0xb800157c,0x00040200);
REG32_W(0xb8001580,0x00040200);
REG32_W(0xb8001584,0x00040200);
REG32_W(0xb8001588,0x00040200);
REG32_W(0xb800158c,0x00040200);
//REG32_W(0xb800107c,0xc0000000);
//MR[2]=0x00120208
REG32_W(0xb800101c,0x00120208);

//MR[3]=0x00130000
REG32_W(0xb800101c,0x00130000);

//MR[1]=0x00110042
REG32_W(0xb800101c,0x00110042);

//MR[0]=0x00101930
REG32_W(0xb800101c,0x00101930);

#endif

#ifdef CONFIG_DDR3_530MHZ
REG32_W(0xb80000a0,0x29000007);
REG32_W(0xb8001590,0x00000000);
REG32_W(0xb8000010,0x80000800);
REG32_W(0xb8001800,0x40000000);
REG32_W(0xb8001064,0x100000ff);
REG32_W(0xb80000dc,0x24900400);
REG32_W(0xb8001804,0xb50f0000);
//REG32_W(0xb800101c,0x00101a30);
//REG32_W(0xb800101c,0x00110042);
//REG32_W(0xb800101c,0x00120208);
REG32_W(0xb8001000,0x22041de0);
REG32_W(0xb8001008,0x68544740);
REG32_W(0xb800100c,0x0808051b);
REG32_W(0xb8001010,0x0b618000);
REG32_W(0xb8001500,0x80010210);
REG32_W(0xb8001050,0x1f1f0000);
REG32_W(0xb8001510,0x00040200);
REG32_W(0xb8001514,0x00040200);
REG32_W(0xb8001518,0x00040200);
REG32_W(0xb800151c,0x00040200);
REG32_W(0xb8001520,0x00040200);
REG32_W(0xb8001524,0x00040200);
REG32_W(0xb8001528,0x00040200);
REG32_W(0xb800152c,0x00040200);
REG32_W(0xb8001530,0x00040200);
REG32_W(0xb8001534,0x00040200);
REG32_W(0xb8001538,0x00040200);
REG32_W(0xb800153c,0x00040200);
REG32_W(0xb8001540,0x00040200);
REG32_W(0xb8001544,0x00040200);
REG32_W(0xb8001548,0x00040200);
REG32_W(0xb800154c,0x00040200);
REG32_W(0xb8001550,0x00040200);
REG32_W(0xb8001554,0x00040200);
REG32_W(0xb8001558,0x00040200);
REG32_W(0xb800155c,0x00040200);
REG32_W(0xb8001560,0x00040200);
REG32_W(0xb8001564,0x00040200);
REG32_W(0xb8001568,0x00040200);
REG32_W(0xb800156c,0x00040200);
REG32_W(0xb8001570,0x00040200);
REG32_W(0xb8001574,0x00040200);
REG32_W(0xb8001578,0x00040200);
REG32_W(0xb800157c,0x00040200);
REG32_W(0xb8001580,0x00040200);
REG32_W(0xb8001584,0x00040200);
REG32_W(0xb8001588,0x00040200);
REG32_W(0xb800158c,0x00040200);
//REG32_W(0xb800107c,0xc0000000);
//MR[2]=0x00120208
REG32_W(0xb800101c,0x00120208);

//MR[3]=0x00130000
REG32_W(0xb800101c,0x00130000);

//MR[1]=0x00110042
REG32_W(0xb800101c,0x00110042);

//MR[0]=0x00101b30
REG32_W(0xb800101c,0x00101b30);
#endif

#ifdef CONFIG_DDR3_550MHZ
REG32_W(0xb80000a0,0x29002107);
REG32_W(0xb8001590,0x08080000);
REG32_W(0xb8000010,0x80000908);
REG32_W(0xb8001800,0xc1080000);
REG32_W(0xb8001064,0x000000ff);
REG32_W(0xb80000dc,0x00000400);
REG32_W(0xb8001804,0x150f0000);
//REG32_W(0xb800101c,0x00101a40);
//REG32_W(0xb800101c,0x00110042);
//REG32_W(0xb800101c,0x00120210);
REG32_W(0xb8001000,0x22041de0);
REG32_W(0xb8001008,0x88644740);
REG32_W(0xb800100c,0x0808051b);
REG32_W(0xb8001010,0x0b618000);
REG32_W(0xb8001500,0x80020210);
REG32_W(0xb8001050,0x1f1f0000);
REG32_W(0xb8001510,0x08040200);
REG32_W(0xb8001514,0x08040200);
REG32_W(0xb8001518,0x08040200);
REG32_W(0xb800151c,0x08040200);
REG32_W(0xb8001520,0x08040200);
REG32_W(0xb8001524,0x08040200);
REG32_W(0xb8001528,0x08040200);
REG32_W(0xb800152c,0x08040200);
REG32_W(0xb8001530,0x08040200);
REG32_W(0xb8001534,0x08040200);
REG32_W(0xb8001538,0x08040200);
REG32_W(0xb800153c,0x08040200);
REG32_W(0xb8001540,0x08040200);
REG32_W(0xb8001544,0x08040200);
REG32_W(0xb8001548,0x08040200);
REG32_W(0xb800154c,0x08040200);
REG32_W(0xb8001550,0x00040200);
REG32_W(0xb8001554,0x00040200);
REG32_W(0xb8001558,0x00040200);
REG32_W(0xb800155c,0x00040200);
REG32_W(0xb8001560,0x00040200);
REG32_W(0xb8001564,0x00040200);
REG32_W(0xb8001568,0x00040200);
REG32_W(0xb800156c,0x00040200);
REG32_W(0xb8001570,0x00040200);
REG32_W(0xb8001574,0x00040200);
REG32_W(0xb8001578,0x00040200);
REG32_W(0xb800157c,0x00040200);
REG32_W(0xb8001580,0x00040200);
REG32_W(0xb8001584,0x00040200);
REG32_W(0xb8001588,0x00040200);
REG32_W(0xb800158c,0x00040200);
//REG32_W(0xb800107c,0xc0000000);
//MR[2]=0x00120210
REG32_W(0xb800101c,0x00120210);

//MR[3]=0x00130000
REG32_W(0xb800101c,0x00130000);

//MR[1]=0x00110042
REG32_W(0xb800101c,0x00110042);

//MR[0]=0x00101b40
REG32_W(0xb800101c,0x00101b40);
#endif

#ifdef CONFIG_DDR3_580MHZ
REG32_W(0xb80000a0,0x29002107);
REG32_W(0xb8001590,0x08080000);
REG32_W(0xb8000010,0x80000908);
REG32_W(0xb8001800,0xc1080000);
REG32_W(0xb8001064,0x000000ff);
REG32_W(0xb80000dc,0x00000400);
REG32_W(0xb8001804,0x150f0000);
//REG32_W(0xb800101c,0x00101a40);
//REG32_W(0xb800101c,0x00110042);
//REG32_W(0xb800101c,0x00120210);
REG32_W(0xb8001000,0x22041de0);
REG32_W(0xb8001008,0x88644740);
REG32_W(0xb800100c,0x0808051d);
REG32_W(0xb8001010,0x0c01a000);
REG32_W(0xb8001500,0x80010210);
REG32_W(0xb8001050,0x1f1f0000);
REG32_W(0xb8001510,0x08040200);
REG32_W(0xb8001514,0x08040200);
REG32_W(0xb8001518,0x08040200);
REG32_W(0xb800151c,0x08040200);
REG32_W(0xb8001520,0x08040200);
REG32_W(0xb8001524,0x08040200);
REG32_W(0xb8001528,0x08040200);
REG32_W(0xb800152c,0x08040200);
REG32_W(0xb8001530,0x08040200);
REG32_W(0xb8001534,0x08040200);
REG32_W(0xb8001538,0x08040200);
REG32_W(0xb800153c,0x08040200);
REG32_W(0xb8001540,0x08040200);
REG32_W(0xb8001544,0x08040200);
REG32_W(0xb8001548,0x08040200);
REG32_W(0xb800154c,0x08040200);
REG32_W(0xb8001550,0x00040200);
REG32_W(0xb8001554,0x00040200);
REG32_W(0xb8001558,0x00040200);
REG32_W(0xb800155c,0x00040200);
REG32_W(0xb8001560,0x00040200);
REG32_W(0xb8001564,0x00040200);
REG32_W(0xb8001568,0x00040200);
REG32_W(0xb800156c,0x00040200);
REG32_W(0xb8001570,0x00040200);
REG32_W(0xb8001574,0x00040200);
REG32_W(0xb8001578,0x00040200);
REG32_W(0xb800157c,0x00040200);
REG32_W(0xb8001580,0x00040200);
REG32_W(0xb8001584,0x00040200);
REG32_W(0xb8001588,0x00040200);
REG32_W(0xb800158c,0x00040200);
//REG32_W(0xb800107c,0xc0000000);
//flow B
#if 1
//MR[2]=0x00120210
REG32_W(0xb800101c,0x00120210);

//MR[3]=0x00130000
REG32_W(0xb800101c,0x00130000);

//MR[1]=0x00110042
REG32_W(0xb800101c,0x00110042);

//MR[0]=0x00101b40
REG32_W(0xb800101c,0x00101b40);
#endif
#endif

#ifdef CONFIG_DDR3_595MHZ
REG32_W(0xb80000a0,0x29002107);
REG32_W(0xb8001590,0x08080000);
REG32_W(0xb8000010,0x80000908);
REG32_W(0xb8001800,0xc1080000);
REG32_W(0xb8001064,0x000000ff);
REG32_W(0xb80000dc,0x00000400);
REG32_W(0xb8001804,0x150f0000);
//REG32_W(0xb800101c,0x00101c40);
//REG32_W(0xb800101c,0x00110042);
//REG32_W(0xb800101c,0x00120210);
REG32_W(0xb8001000,0x22041de0);
REG32_W(0xb8001008,0x89644840);
REG32_W(0xb800100c,0x0909061f);
REG32_W(0xb8001010,0x0cc1c000);
REG32_W(0xb8001500,0x80010210);
REG32_W(0xb8001050,0x1f1f0000);
REG32_W(0xb8001510,0x08040200);
REG32_W(0xb8001514,0x08040200);
REG32_W(0xb8001518,0x08040200);
REG32_W(0xb800151c,0x08040200);
REG32_W(0xb8001520,0x08040200);
REG32_W(0xb8001524,0x08040200);
REG32_W(0xb8001528,0x08040200);
REG32_W(0xb800152c,0x08040200);
REG32_W(0xb8001530,0x08040200);
REG32_W(0xb8001534,0x08040200);
REG32_W(0xb8001538,0x08040200);
REG32_W(0xb800153c,0x08040200);
REG32_W(0xb8001540,0x08040200);
REG32_W(0xb8001544,0x08040200);
REG32_W(0xb8001548,0x08040200);
REG32_W(0xb800154c,0x08040200);
REG32_W(0xb8001550,0x00040200);
REG32_W(0xb8001554,0x00040200);
REG32_W(0xb8001558,0x00040200);
REG32_W(0xb800155c,0x00040200);
REG32_W(0xb8001560,0x00040200);
REG32_W(0xb8001564,0x00040200);
REG32_W(0xb8001568,0x00040200);
REG32_W(0xb800156c,0x00040200);
REG32_W(0xb8001570,0x00040200);
REG32_W(0xb8001574,0x00040200);
REG32_W(0xb8001578,0x00040200);
REG32_W(0xb800157c,0x00040200);
REG32_W(0xb8001580,0x00040200);
REG32_W(0xb8001584,0x00040200);
REG32_W(0xb8001588,0x00040200);
REG32_W(0xb800158c,0x00040200);
//REG32_W(0xb800107c,0xc0000000);
//MR[2]=0x00120210
REG32_W(0xb800101c,0x00120210);

//MR[3]=0x00130000
REG32_W(0xb800101c,0x00130000);

//MR[1]=0x00110042
REG32_W(0xb800101c,0x00110042);

//MR[0]=0x00101d40
REG32_W(0xb800101c,0x00101d40);
#endif	


#ifdef CONFIG_DDR3_640MHZ
REG32_W(0xb80000a0,0x29002107);
REG32_W(0xb8001590,0x08080000);
REG32_W(0xb8000010,0x80000908);
REG32_W(0xb8001800,0xc1080000);
REG32_W(0xb8001064,0x000000ff);
REG32_W(0xb80000dc,0x00000400);
REG32_W(0xb8001804,0x150f0000);
//REG32_W(0xb800101c,0x00101c40);
//REG32_W(0xb800101c,0x00110042);
//REG32_W(0xb800101c,0x00120210);
REG32_W(0xb8001000,0x22041de0);
REG32_W(0xb8001008,0x89655840);
REG32_W(0xb800100c,0x09090621);
REG32_W(0xb8001010,0x0da1d000);
REG32_W(0xb8001500,0x80010110);
REG32_W(0xb8001050,0x1f1f0000);
REG32_W(0xb8001510,0x08040200);
REG32_W(0xb8001514,0x08040200);
REG32_W(0xb8001518,0x08040200);
REG32_W(0xb800151c,0x08040200);
REG32_W(0xb8001520,0x08040200);
REG32_W(0xb8001524,0x08040200);
REG32_W(0xb8001528,0x08040200);
REG32_W(0xb800152c,0x08040200);
REG32_W(0xb8001530,0x08040200);
REG32_W(0xb8001534,0x08040200);
REG32_W(0xb8001538,0x08040200);
REG32_W(0xb800153c,0x08040200);
REG32_W(0xb8001540,0x08040200);
REG32_W(0xb8001544,0x08040200);
REG32_W(0xb8001548,0x08040200);
REG32_W(0xb800154c,0x08040200);
REG32_W(0xb8001550,0x00040200);
REG32_W(0xb8001554,0x00040200);
REG32_W(0xb8001558,0x00040200);
REG32_W(0xb800155c,0x00040200);
REG32_W(0xb8001560,0x00040200);
REG32_W(0xb8001564,0x00040200);
REG32_W(0xb8001568,0x00040200);
REG32_W(0xb800156c,0x00040200);
REG32_W(0xb8001570,0x00040200);
REG32_W(0xb8001574,0x00040200);
REG32_W(0xb8001578,0x00040200);
REG32_W(0xb800157c,0x00040200);
REG32_W(0xb8001580,0x00040200);
REG32_W(0xb8001584,0x00040200);
REG32_W(0xb8001588,0x00040200);
REG32_W(0xb800158c,0x00040200);
//REG32_W(0xb800107c,0xc0000000);
//MR[2]=0x00120210
REG32_W(0xb800101c,0x00120210);

//MR[3]=0x00130000
REG32_W(0xb800101c,0x00130000);

//MR[1]=0x00110042
REG32_W(0xb800101c,0x00110042);

//MR[0]=0x00101d40
REG32_W(0xb800101c,0x00101d40);
#endif

#ifdef CONFIG_DDR3_670MHZ
REG32_W(0xb80000a0,0x29002107);
REG32_W(0xb8001590,0x08080000);
REG32_W(0xb8000010,0x80000908);
REG32_W(0xb8001800,0xc1080000);
REG32_W(0xb8001064,0x000000ff);
REG32_W(0xb80000dc,0x00000400);
REG32_W(0xb8001804,0x150f0000);
//REG32_W(0xb800101c,0x00101460);
//REG32_W(0xb800101c,0x00110042);
//REG32_W(0xb800101c,0x00120218);
REG32_W(0xb8001000,0x22041de0);
REG32_W(0xb8001008,0xaa755940);
REG32_W(0xb800100c,0x0a0a0723);
REG32_W(0xb8001010,0x0ea20000);
REG32_W(0xb8001500,0x80010110);
REG32_W(0xb8001050,0x1f1f0000);
REG32_W(0xb8001510,0x08040200);
REG32_W(0xb8001514,0x08040200);
REG32_W(0xb8001518,0x08040200);
REG32_W(0xb800151c,0x08040200);
REG32_W(0xb8001520,0x08040200);
REG32_W(0xb8001524,0x08040200);
REG32_W(0xb8001528,0x08040200);
REG32_W(0xb800152c,0x08040200);
REG32_W(0xb8001530,0x08040200);
REG32_W(0xb8001534,0x08040200);
REG32_W(0xb8001538,0x08040200);
REG32_W(0xb800153c,0x08040200);
REG32_W(0xb8001540,0x08040200);
REG32_W(0xb8001544,0x08040200);
REG32_W(0xb8001548,0x08040200);
REG32_W(0xb800154c,0x08040200);
REG32_W(0xb8001550,0x00040200);
REG32_W(0xb8001554,0x00040200);
REG32_W(0xb8001558,0x00040200);
REG32_W(0xb800155c,0x00040200);
REG32_W(0xb8001560,0x00040200);
REG32_W(0xb8001564,0x00040200);
REG32_W(0xb8001568,0x00040200);
REG32_W(0xb800156c,0x00040200);
REG32_W(0xb8001570,0x00040200);
REG32_W(0xb8001574,0x00040200);
REG32_W(0xb8001578,0x00040200);
REG32_W(0xb800157c,0x00040200);
REG32_W(0xb8001580,0x00040200);
REG32_W(0xb8001584,0x00040200);
REG32_W(0xb8001588,0x00040200);
REG32_W(0xb800158c,0x00040200);
//REG32_W(0xb800107c,0xc0000000);
//MR[2]=0x00120218
REG32_W(0xb800101c,0x00120218);

//MR[3]=0x00130000
REG32_W(0xb800101c,0x00130000);

//MR[1]=0x00110042
REG32_W(0xb800101c,0x00110042);


//MR[0]=0x00101d60
REG32_W(0xb800101c,0x00101d60);
#endif


#ifdef CONFIG_DDR3_700MHZ
REG32_W(0xb80000a0,0x29002107);
REG32_W(0xb8001590,0x08080000);
REG32_W(0xb8000010,0x80000908);
REG32_W(0xb8001800,0xc1080000);
REG32_W(0xb8001064,0x000000ff);
REG32_W(0xb80000dc,0x00000400);
REG32_W(0xb8001804,0x150f0000);
//REG32_W(0xb800101c,0x00101460);
//REG32_W(0xb800101c,0x00110042);
//REG32_W(0xb800101c,0x00120218);
REG32_W(0xb8001000,0x22041de0);
REG32_W(0xb8001008,0xaa755940);
//REG32_W(0xb8001008,0xAB755940);

REG32_W(0xb800100c,0x0a0a0723);
REG32_W(0xb8001010,0x0ea20000);
REG32_W(0xb8001500,0x80010110);
REG32_W(0xb8001050,0x1f1f0000);
REG32_W(0xb8001510,0x08040200);
REG32_W(0xb8001514,0x08040200);
REG32_W(0xb8001518,0x08040200);
REG32_W(0xb800151c,0x08040200);
REG32_W(0xb8001520,0x08040200);
REG32_W(0xb8001524,0x08040200);
REG32_W(0xb8001528,0x08040200);
REG32_W(0xb800152c,0x08040200);
REG32_W(0xb8001530,0x08040200);
REG32_W(0xb8001534,0x08040200);
REG32_W(0xb8001538,0x08040200);
REG32_W(0xb800153c,0x08040200);
REG32_W(0xb8001540,0x08040200);
REG32_W(0xb8001544,0x08040200);
REG32_W(0xb8001548,0x08040200);
REG32_W(0xb800154c,0x08040200);
REG32_W(0xb8001550,0x00040200);
REG32_W(0xb8001554,0x00040200);
REG32_W(0xb8001558,0x00040200);
REG32_W(0xb800155c,0x00040200);
REG32_W(0xb8001560,0x00040200);
REG32_W(0xb8001564,0x00040200);
REG32_W(0xb8001568,0x00040200);
REG32_W(0xb800156c,0x00040200);
REG32_W(0xb8001570,0x00040200);
REG32_W(0xb8001574,0x00040200);
REG32_W(0xb8001578,0x00040200);
REG32_W(0xb800157c,0x00040200);
REG32_W(0xb8001580,0x00040200);
REG32_W(0xb8001584,0x00040200);
REG32_W(0xb8001588,0x00040200);
REG32_W(0xb800158c,0x00040200);
//flow B
#if 1
//REG32_W(0xb800107c,0xc0000000);
//MR[2]=0x00120218
REG32_W(0xb800101c,0x00120218);

//MR[3]=0x00130000
REG32_W(0xb800101c,0x00130000);

//MR[1]=0x00110042
REG32_W(0xb800101c,0x00110042);


//MR[0]=0x00101d60
REG32_W(0xb800101c,0x00101d60);
#endif
#endif



#ifdef CONFIG_DDR3_740MHZ
REG32_W(0xb80000a0,0x29002107);
REG32_W(0xb8001590,0x08080000);
REG32_W(0xb8000010,0x80000908);
REG32_W(0xb8001800,0xc1080000);
REG32_W(0xb8001064,0x000000ff);
REG32_W(0xb80000dc,0x00000400);
REG32_W(0xb8001804,0x150f0000);
//REG32_W(0xb800101c,0x00101e60);
//REG32_W(0xb800101c,0x00110042);
//REG32_W(0xb800101c,0x00120218);
REG32_W(0xb8001000,0x22041de0);
REG32_W(0xb8001008,0xab766a40);
REG32_W(0xb800100c,0x0b0b0726);
REG32_W(0xb8001010,0x0fc22000);
REG32_W(0xb8001500,0x80010110);
REG32_W(0xb8001050,0x1f1f0000);
REG32_W(0xb8001510,0x08040200);
REG32_W(0xb8001514,0x08040200);
REG32_W(0xb8001518,0x08040200);
REG32_W(0xb800151c,0x08040200);
REG32_W(0xb8001520,0x08040200);
REG32_W(0xb8001524,0x08040200);
REG32_W(0xb8001528,0x08040200);
REG32_W(0xb800152c,0x08040200);
REG32_W(0xb8001530,0x08040200);
REG32_W(0xb8001534,0x08040200);
REG32_W(0xb8001538,0x08040200);
REG32_W(0xb800153c,0x08040200);
REG32_W(0xb8001540,0x08040200);
REG32_W(0xb8001544,0x08040200);
REG32_W(0xb8001548,0x08040200);
REG32_W(0xb800154c,0x08040200);
REG32_W(0xb8001550,0x00040200);
REG32_W(0xb8001554,0x00040200);
REG32_W(0xb8001558,0x00040200);
REG32_W(0xb800155c,0x00040200);
REG32_W(0xb8001560,0x00040200);
REG32_W(0xb8001564,0x00040200);
REG32_W(0xb8001568,0x00040200);
REG32_W(0xb800156c,0x00040200);
REG32_W(0xb8001570,0x00040200);
REG32_W(0xb8001574,0x00040200);
REG32_W(0xb8001578,0x00040200);
REG32_W(0xb800157c,0x00040200);
REG32_W(0xb8001580,0x00040200);
REG32_W(0xb8001584,0x00040200);
REG32_W(0xb8001588,0x00040200);
REG32_W(0xb800158c,0x00040200);
//REG32_W(0xb800107c,0xc0000000);
//MR[2]=0x00120218
REG32_W(0xb800101c,0x00120218);

//MR[3]=0x00130000
REG32_W(0xb800101c,0x00130000);

//MR[1]=0x00110042
REG32_W(0xb800101c,0x00110042);


//MR[0]=0x00101d60
REG32_W(0xb800101c,0x00101d60);
#endif
////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////


	#if 0
	//enable unmap
		#if 0
		//REG32_W(0xb8001304,0x5);   //unmap seg len=4K
		REG32_W(0xb8001304,0x6);   //unmap seg len=8K
		REG32_W(0xb8001300,VIR2PHY(SRAM_BASE) |1);   //unmap seg addr
		nop
		nop	
		//enable sram
		//REG32_W(0xb8004004,0x05);   //sram seg len=4K
		REG32_W(0xb8004004,0x06);   //sram seg len=8K
		REG32_W(0xb8004000,VIR2PHY(SRAM_BASE) |1);   //sram seg addr
		nop
		nop	
		#endif

		
		li sp,SRAM_TOP-0x4//
		//li sp,SRAM_TOP-0x1f00
		nop
		nop		

		nop
		nop	
		/*Go start_c.c for more DRAM setting*/
		jal start_c
		nop
       	nop
       	
	#endif


#else


#endif //end of CONFIG_NAND_FLASH_BOOTING
	

	/* Clear watch registers */
	mtc0	zero, CP0_WATCHLO
	mtc0	zero, CP0_WATCHHI

	/* WP(Watch Pending), SW0/1 should be cleared */
	mtc0	zero, CP0_CAUSE
	

	mfc0	t0, CP0_STATUS
	and t0, 0xffff00e0   //disable all interrupt
	or  t0, 0x10000400   //enable hw1
	mtc0	t0, CP0_STATUS
	.set	noreorder
	sll	zero, 3				# ehb


	/* Init Timer */
	mtc0	zero, CP0_COUNT
	mtc0	zero, CP0_COMPARE





//-------------------------------------------------------------------------------- 
#if 1
		jal flush_cache_r
		nop
		nop

		//enable cache
#if 0
		li t0,0x80048482  //cache for single core 
#else
		li t0,0x80048485  //cache-coherence for dual core 
#endif		
		mtc0 t0, $16
		nop

		//Allow interventions
		li	t1, 0xff
		li  t0, 0xbfbfa008
		sw	t1, 0(t0)
		sll zero,zero,3
		nop
#endif      
//------------------------------------------------	 	
#if 1  //0xbfc00000->0x9fc00000
		la t0, cache_start
		and t0,0xdfffffff
		
		jr t0
		nop
		nop
cache_start:
////////////////////////////////////////////////////////
//jasonwang
#if 0
 	mfc0    k0,CP0_CONFIG
        li      k1,~CONF_CM_CMASK
        and     k0,k0,k1
        ori     k0,k0,CONF_CM_UNCACHED
        mtc0    k0,CP0_CONFIG
        /* Give it a few cycles to sink in... */
        nop
        nop
        nop
	        nop
        nop
#endif
//////////////////////////////////////////////////////////
#endif
//============================================================================




#if 0
		jal	lowlevel_init
		 nop
#endif

//------------------------------------------------	 	


#if 1 //wei add for 1074k core 1
        mfc0    v1, CP0_PRID, 1
        andi    v1, 0x3ff
        beqz    v1, 2f   //ID=0 go out
 //       bnez    v1, 2f        //ID!=0 go out        
        nop

//--------------	
//core1_ready:
   		#define PATT_SLEEP  0x3333
   		#define PATT_READY  0x5555
   		#define PATT_MAGIC 0x7777
   		#define PATT_GO     0x9999		
		#define LAUNCH_REG  0xb8000068		
		#define POLLING_REG 0xb800006c
core1_sleep:
		REG32_W(POLLING_REG, PATT_SLEEP);
                nop	


	mfc0	t0, CP0_STATUS
	and t0, 0xffff00e0   //disable all interrupt
	or  t0, 0x10000400   //enable hw1
	mtc0	t0, CP0_STATUS
	.set	noreorder
	sll	zero, 3				# ehb

		
		wait   //goto sleep	
		nop
                nop
                nop		
core1_ready:
		REG32_W(POLLING_REG, PATT_READY);
		nop
//--------------	
core1_loop:		

		REG32_R(POLLING_REG, t1);
        beq t1,PATT_MAGIC, core1_go
        nop
		
        nop			
        nop
	
        b core1_loop
		nop
        nop


//--------------	
core1_go:	
		UART_WRITE('G');
		UART_WRITE('O');		

		REG32_W(POLLING_REG, PATT_GO);
		REG32_R(LAUNCH_REG, t1);

		jr t1
		nop


 
   #if 0
   loop:
        nop
		nop
 		la t0, loop
 		and t0,0xdfffffff
 		jr t0
 		nop
 		nop
   #endif
		
        nop
        nop
2:
#endif
//============================================================================
#define RTL_8198C 0
#define RTL_DEFAULT 1
#define RTL_DEFAULT1 0x81
#define RTL_8198CD 0x2
#define RTL8954E 0x3
#define RTL_8198CS 0x80
#define RTL8954ES 0x83



#if 1	//cpu freq

	REG32_W(0xb8000004,2);

#ifdef CONFIG_NAND_FLASH_BOOTING
	//REG32_ANDOR(0xb8000008, 0xffffffff, (11<<15)); //1000MHZ
	REG32_ANDOR(0xb8000008, 0xffffffff, (7<<15)); //800MHZ  //Normal 800MHZ
#else
        nop
        REG32_R(0xb800000c,t8);
	nop
        IF_EQ(t8,RTL_8198C, lab_1G);
        nop
	nop
        IF_EQ(t8,RTL_8198CD, lab_600MH);
        nop
        nop
	IF_EQ(t8,RTL8954E, lab_1G);
        nop
        IF_EQ(t8,RTL_8198CS, lab_1G);
        nop
        nop
        IF_EQ(t8,RTL8954ES, lab_1G);
        nop
        nop
	IF_EQ(t8,RTL_DEFAULT, lab_800MHZ);
        nop
        nop
	
	IF_EQ(t8,RTL_DEFAULT1, lab_800MHZ);
        nop
        nop

	//REG32_ANDOR(0xb8000008, 0xffffffff, (2<<15)); //550MHZ

lab_600MH:
	 REG32_ANDOR(0xb8000008, 0xffffffff, (3<<15)); //600MHZ
	 nop
	 j lab_end_cpu
         nop
lab_800MHZ: // 800MHz
	REG32_ANDOR(0xb8000008, 0xffffffff, (7<<15)); //800MHz
	nop
	nop
	j lab_end_cpu
	nop
lab_1G: // 1000MHz
	REG32_ANDOR(0xb8000008, 0xffffffff, (0xb<<15)); //800MHz
	nop
	nop
lab_end_cpu:

#endif
	
	#define GIC_BASE_ADDR	0xbbdc0000
	#define GCR_BASE_ADDR 	0xbfbf8000

	REG32_W(GCR_BASE_ADDR+0x0080, 0x1bdc0001);

	REG32_W(GIC_BASE_ADDR+0x100, 0xffffffff);
	REG32_W(GIC_BASE_ADDR+0x104, 0x0003FFFF);	

	REG32_W(GIC_BASE_ADDR+0x05ac, 0x80000000);
	REG32_W(GIC_BASE_ADDR+0x2560,1);


	REG32_W(GIC_BASE_ADDR+0x384,0x800);
        nop
        nop
	nop
	nop
	nop
	nop	
	wait
	nop
	nop
	nop
	nop
#endif

//============================================================================

#ifdef CONFIG_NAND_FLASH_BOOTING          //For NAND Flash booting
	
	//REG32(0xb800101c)=(1<<24);//disable DRAM refresh 
	REG32_ANDOR(0xb800101c,0xFFFFFFFF,(1<<24)); 	

	#if 1
/* Check DMCR if ready */
//	while(REG32(DMCR)& 0x80000000);
	lui	a0,0xb800
	ori	v0,a0,0x101c
memctlc_ZQ_calibration_nand_0x1:
	lw	v1,0(v0)
	bltz	v1,memctlc_ZQ_calibration_nand_0x1
	nop
	#endif

	REG32_ANDOR(0xb8001040, 0xFFFFFFFF,(1<<28));  //->CKE low

	//REG32_ANDOR(0xb8001800, 0xBFFFFFFF,0);  // DDR3 reset low , fail

	#if 0 //wait loop 
		UART_PRINT(nand_CDF_msg1);  //DRAM DLL reset flow 
	#endif

	
	


/////////////////////DDR PLL Freq setting reference table////////////////////////
	//SYS_HW_STRAP=0xb8000008	

	//REG32_ANDOR(0xb8000008, 0xFFFF83FF, (0<<10)); //Set memory clock=250MHZ	
	
	//REG32_ANDOR(0xb8000008, 0xFFFF83FF, (2<<10)); //Set memory clock=290MHZ	

	//REG32_ANDOR(0xb8000008, 0xFFFF83FF, (4<<10)); //Set memory clock=330MHZ	
	
	//REG32_ANDOR(0xb8000008, 0xFFFF83FF, (5<<10));  //Set memory clock=350MHZ	
	
	//REG32_ANDOR(0xb8000008, 0xFFFF83FF, (6<<10));  //Set memory clock=370MHZ	
	
	//REG32_ANDOR(0xb8000008, 0xFFFF83FF, (16<<10));  //Set memory clock=390MHZ	
	
	//REG32_ANDOR(0xb8000008, 0xFFFF83FF, (8<<10));  //Set memory clock=410MHZ	

	//REG32_ANDOR(0xb8000008, 0xFFFF83FF, (9<<10));  //Set memory clock=430MHZ	

	//REG32_ANDOR(0xb8000008, 0xFFFF83FF, (10<<10)); //Set memory clock=450MHZ		
	
	//REG32_ANDOR(0xb8000008, 0xFFFF83FF, (12<<10)); //Set memory clock=490MHZ	

	//REG32_ANDOR(0xb8000008, 0xFFFF83FF, (13<<10)); //Set memory clock=510MHZ	

	//REG32_ANDOR(0xb8000008, 0xFFFF83FF, (14<<10)); //Set memory clock=530MHZ	

	//REG32_ANDOR(0xb8000008, 0xFFFF83FF, (15<<10)); //Set memory clock=550MHZ	

	//REG32_ANDOR(0xb8000008, 0xFFFF83FF, (17<<10)); //Set memory clock=580MHZ	 

	//REG32_ANDOR(0xb8000008, 0xFFFF83FF, (18<<10)); //Set memory clock=595MHZ
	
	//REG32_ANDOR(0xb8000008, 0xFFFF83FF, (19<<10)); //Set memory clock=610MHZ

	//REG32_ANDOR(0xb8000008, 0xFFFF83FF, (20<<10)); //Set memory clock=625MHZ		

	//REG32_ANDOR(0xb8000008, 0xFFFF83FF, (21<<10)); //Set memory clock=640MHZ	

	//REG32_ANDOR(0xb8000008, 0xFFFF83FF, (22<<10)); //Set memory clock=655MHZ

	//REG32_ANDOR(0xb8000008, 0xFFFF83FF, (23<<10)); //Set memory clock=670MHZ

	//REG32_ANDOR(0xb8000008, 0xFFFF83FF, (24<<10));  //Set memory clock=685MHZ

	//REG32_ANDOR(0xb8000008, 0xFFFF83FF, (25<<10)); //Set memory clock=700MHZ

	//REG32_ANDOR(0xb8000008, 0xFFFF83FF, (26<<10)); //Set memory clock=720MHZ

	//REG32_ANDOR(0xb8000008, 0xFFFF83FF, (27<<10)); //Set memory clock=740MHZ

////////////////////////////////////////////////////////////////////////

	
//============================================================================
#ifdef CONFIG_DDR3_250MHZ
	REG32_ANDOR(0xb8000008, 0xFFFF83FF, (0<<10)); //Set memory clock=250MHZ
#endif

#ifdef CONFIG_DDR2_390MHZ
	REG32_ANDOR(0xb8000008, 0xFFFF83FF, (16<<10));  //Set memory clock=390MHZ	
#endif

#ifdef CONFIG_DDR3_390MHZ
	REG32_ANDOR(0xb8000008, 0xFFFF83FF, (16<<10));  //Set memory clock=390MHZ	
#endif



#ifdef CONFIG_DDR3_410MHZ
	REG32_ANDOR(0xb8000008, 0xFFFF83FF, (8<<10));  //Set memory clock=410MHZ	
#endif

#ifdef CONFIG_DDR3_490MHZ
	REG32_ANDOR(0xb8000008, 0xFFFF83FF, (12<<10)); //Set memory clock=490MHZ	
#endif

#ifdef CONFIG_DDR3_510MHZ
	REG32_ANDOR(0xb8000008, 0xFFFF83FF, (13<<10)); //Set memory clock=510MHZ	
#endif


#ifdef CONFIG_DDR2_530MHZ
	REG32_ANDOR(0xb8000008, 0xFFFF83FF, (14<<10)); //Set memory clock=530MHZ	
#endif


#ifdef CONFIG_DDR3_530MHZ
	REG32_ANDOR(0xb8000008, 0xFFFF83FF, (14<<10)); //Set memory clock=530MHZ	
#endif


#ifdef CONFIG_DDR3_550MHZ
	REG32_ANDOR(0xb8000008, 0xFFFF83FF, (15<<10)); //Set memory clock=550MHZ	
#endif

#ifdef CONFIG_DDR3_580MHZ
	REG32_ANDOR(0xb8000008, 0xFFFF83FF, (17<<10)); //Set memory clock=580MHZ	 
#endif

#ifdef CONFIG_DDR3_595MHZ
	REG32_ANDOR(0xb8000008, 0xFFFF83FF, (18<<10)); //Set memory clock=595MHZ
#endif
	
#ifdef CONFIG_DDR3_640MHZ
	REG32_ANDOR(0xb8000008, 0xFFFF83FF, (21<<10));  //Set memory clock=640MHZ	
#endif //end of CONFIG_DDR3_640MHZ	
	
#ifdef CONFIG_DDR3_670MHZ
	REG32_ANDOR(0xb8000008, 0xFFFF83FF, (23<<10)); //Set memory clock=670MHZ
#endif 	
	

#ifdef CONFIG_DDR3_700MHZ
	REG32_ANDOR(0xb8000008, 0xFFFF83FF, (25<<10)); //Set memory clock=700MHZ
#endif 

#ifdef CONFIG_DDR3_740MHZ
	REG32_ANDOR(0xb8000008, 0xFFFF83FF, (27<<10)); //Set memory clock=740MHZ
#endif 


//--------------------------------------------------------------------------------

//REG32_ANDOR(0xb8001800, 0xFFFFFFFF,(1<<30));  // DDR3 reset high , fail


	#if 0 //wait loop 
		UART_PRINT(nand_CDF_msg2);  //wait 98C PLL changeing clock for 20ns 
	#endif


	
REG32_ANDOR(0xb8001040, 0x0FFFFFFF,0);  //->CKE High	

	
#if 0 //wait loop 
		UART_PRINT(nand_CDF_msg2);  //
#endif



//Flow A
#if 0//def CONFIG_DDR3_250MHZ
//MR[0]=0x00101310
REG32_W(0xb800101c,0x00101310);
#endif


//Flow A
#if 0//def CONFIG_DDR3_390MHZ
//MR[0]=0x00101510
REG32_W(0xb800101c,0x00101510);
#endif


//Flow A
#if 0//def CONFIG_DDR3_410MHZ
//MR[0]=0x00101730
REG32_W(0xb800101c,0x00101730);
#endif



#if 0//def CONFIG_DDR3_490MHZ
//MR[0]=0x00101930
REG32_W(0xb800101c,0x00101930);
#endif


#if 0//def CONFIG_DDR3_510MHZ
//MR[0]=0x00101930
REG32_W(0xb800101c,0x00101930);
#endif


#if 0//def CONFIG_DDR3_530MHZ
//MR[0]=0x00101b40
REG32_W(0xb800101c,0x00101b30);
#endif

//Flow A
#if 0//def CONFIG_DDR3_550MHZ
//MR[0]=0x00101b40
REG32_W(0xb800101c,0x00101b40);
#endif


//Flow A
#if 0//def CONFIG_DDR3_580MHZ
//MR[0]=0x00101b40
REG32_W(0xb800101c,0x00101b40);
#endif

//flow A
#if 0//def CONFIG_DDR3_595MHZ
//MR[0]=0x00101d40
REG32_W(0xb800101c,0x00101d40);
#endif


//flow A
#if 0//def CONFIG_DDR3_640MHZ
//MR[0]=0x00101d40
REG32_W(0xb800101c,0x00101d40);
#endif


//flow A
#if 0//def CONFIG_DDR3_670MHZ
//MR[0]=0x00101d60
REG32_W(0xb800101c,0x00101d60);
#endif

//flow A
#if 0//def CONFIG_DDR3_700MHZ
//MR[0]=0x00101d60
REG32_W(0xb800101c,0x00101d60);
#endif

//flow A
#if 0//def CONFIG_DDR3_740MHZ
//MR[0]=0x00101d60
REG32_W(0xb800101c,0x00101d60);
#endif




	#if 0 //wait loop
		UART_PRINT(nand_CDF_msg3);
	#endif

#if 1
	/*DRAM ZQ long calibration */
	
	//ZQ long calibration
//	REG32(0xb8001080)|= 0x80000000;
lui	v0,0xb800
ori	v0,v0,0x1080
lw	a0,0(v0)
lui	v1,0x8000
or	v1,a0,v1
sw	v1,0(v0)
nop
#endif

#if 0 //wait loop 
		UART_PRINT(nand_CDF_msg4);  //wait ZQ long calibrationdone 

#endif

	/* DDR3 Enable DRAM refresh operation */		
	//REG32(0xb800101c)&=~(1<<24);//enable DRAM refresh	
	REG32_ANDOR(0xb800101c,0xFEFFFFFF,0); 


	#if 0 //wait loop
		UART_PRINT(nand_CDF_msg5);
	#endif



#if 0 //wait loop

		UART_PRINT(nand_CDF_msg5);
#endif


#if 0
/* Check DMCR if ready */
//	while(REG32(DMCR)& 0x80000000);
	lui	a0,0xb800
	ori	v0,a0,0x101c
memctlc_ZQ_calibration_nand_0x80:
	lw	v1,0(v0)
	bltz	v1,memctlc_ZQ_calibration_nand_0x80
	nop
#endif

REG32_W(0xb800107c,0xc0000000);

#else //else of CONFIG_NAND_FLASH_BOOTING

lab_start_c:
		//enable unmap
		REG32_W(0xb8001304,0x5);   //unmap seg len=4K
		REG32_W(0xb8001300,VIR2PHY(SRAM_BASE) |1);   //unmap seg addr

		//enable sram
		REG32_W(0xb8004004,0x05);   //sram seg len=4K		
		REG32_W(0xb8004000,VIR2PHY(SRAM_BASE) |1);   //sram seg addr
		nop
		nop	
		li sp,SRAM_TOP-0x4
		nop
		jal start_c
		nop
       	nop

#endif //end of CONFIG_NAND_FLASH_BOOTING




//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------		

flash2ram:
#ifndef  CONFIG_NAND_FLASH_BOOTING                   //Booting from NOR and SPI Flash
// Load to 80100000 for compress
// Load to 80000000 for non-compress

//#define __boot_start 0xbfc00000
//#define __boot_end   0xbfcd0000 
//#define BOOT_ADDR    0x80100000
//jasonwang

//jasonwang
		nop
	//	jal flush_cache_r
                nop
                nop


		la		k0, __boot_start
		la		k1, (__boot_end + 4)
		la		t1, BOOT_ADDR
1:
		#if 1
		jal SPI_show    //show SPI msg
		nop
		#endif
		
		lw		t0, 0(k0)
		nop
	
		sw		t0, 0(t1)	//*(t1)=*(t0)   t1+=4;  t0+=4;   t1=BOOT_ADDR, t0=__boot_start, run loop
		nop
	

		addu	t1, 4
		
		addu	k0, 4
		
		bne		k1, k0, 1b
		nop

//		UART_PRINT_DELAY(SPI_done_msg);
		//		Jump to booting	
		li		k0, BOOT_ADDR
		jr		k0
		nop 
              //all END             
	
#else //For NAND Flash booting


//REG32_W(0xb8000014,0xe800);   //JSW:Turn on Bus TimeOut Arbiter
REG32_W(0xb801a004,0xC0044553);

#define NAND_CTRL_BASE 0xB801A000



#if (defined (CONFIG_NAND_Flash_Large_Page_5cycles_Pages8KB_8GB))
                 //start from page 1(Due to first 8KB will move to SRAM automatically) , set 3rd cycle=>A15= page2 = from 8KB start (1page= 8KB)
#define NAND_FLASH_START 0x00008000
#endif


#if (defined (CONFIG_NAND_Flash_Large_Page_5cycles_Pages8KB_4GB))
                 //start from page 2(Due to first 8KB will move to SRAM automatically) , set 3rd cycle=>A15= page2 = from 8KB start (1page= 8KB)
 #define NAND_FLASH_START 0x00008000
 //#define NAND_FLASH_START 0x00004000
#endif


#ifdef CONFIG_NAND_Flash_Large_Page_5cycles_Pages4KB
                 //start from page 2(Due to first 4KB will move to SRAM automatically) , set 3rd cycle=>A14= page2 = from 4KB start (1page= 4KB)
#define NAND_FLASH_START 0x00004000
#endif


#ifdef CONFIG_NAND_Flash_Large_Page_256MBto1GB_5cycles
                 //start from page 2(Due to first 4KB will move to SRAM automatically) , set 3rd cycle=>A13= page2 = from 4KB start (1page= 2KB)
#define NAND_FLASH_START 0x00002000
#endif

#ifdef CONFIG_NAND_Flash_Large_Page_256MBto2GB_5cycles
                 //start from page 2(Due to first 4KB will move to SRAM automatically) , set 3rd cycle=>A13= page2 = from 4KB start (1page= 2KB)
#define NAND_FLASH_START 0x00002000
#endif

#ifdef CONFIG_NAND_Flash_Large_Page_128MB_4cycles
                 //start from page 2(Due to first 4KB will move to SRAM automatically) , set 3rd cycle=>A13= page2 =1 (1page= 2KB)
#define NAND_FLASH_START 0x00002000
#endif

                 //OK
#if (defined (CONFIG_NAND_Flash_Small_Page_32MB_3cycles)||defined (CONFIG_NAND_Flash_Small_Page_64MB_4cycles))
                 //start from page 2(Due to first 4KB will move to SRAM automatically) , set 2rd cycle=>A12= page8 =1 (1page= 512B)
#define NAND_FLASH_START 0x00001000
#endif

#define NAND_MEM_START 0x00000000 //RTL8198C
//#define NAND_MEM_START 0x00100000
#define NAND_CHECK_READY() \
123:; \
la      s0, NAND_CTRL_BASE+0x4; \
lw      t0, 0(s0); \
and     t0, t0, 0x80000000; \
bne     t0, 0x80000000, 123b; \
nop

#--- copy itself to RAM ---#

la      k0, __boot_start                             //k0: Flash's start address
la      t1, __boot_start

#if (defined (CONFIG_NAND_Flash_Small_Page_32MB_3cycles)||defined (CONFIG_NAND_Flash_Small_Page_64MB_4cycles))
la      k1, (__boot_end+512 )                        //k1: Flash's ending address
#endif

#if (defined (CONFIG_NAND_Flash_Large_Page_256MBto1GB_5cycles)||defined (CONFIG_NAND_Flash_Large_Page_128MB_4cycles))
la      k1, (__boot_end+2112 )                       //k1: Flash's ending address
#endif

#if defined(CONFIG_NAND_Flash_Large_Page_256MBto2GB_5cycles)
la      k1, (__boot_end+2112 )                       //k1: Flash's ending address
#endif

#if (defined (CONFIG_NAND_Flash_Large_Page_5cycles_Pages4KB))
la      k1, (__boot_end+4224 )                       //k1: Flash's ending address
#endif


#if (defined (CONFIG_NAND_Flash_Large_Page_5cycles_Pages8KB_4GB))
la      k1, (__boot_end+8640 )                       //k1: Flash's ending address
#endif


#if (defined (CONFIG_NAND_Flash_Large_Page_5cycles_Pages8KB_8GB))
la      k1, (__boot_end+8640 )                       //k1: Flash's ending address
#endif

subu        t2,k1,k0                                 //t2: image size
nop

la      t1, NAND_FLASH_START                         //Move 28(0x1c) pages =56 KB/2kB=28 times  for boot.bin (56 KB)

addu t2,t2,t1                                        //t2=t2+t1 (Flash end address=image size + Flash's start address)
addu t2,t2,t2                                        //t2=t2+t1 (Flash end address=image size + Flash's start address) //JSW

la      t3, BOOT_ADDR                                //DRAM booting address
la      t4, NAND_CTRL_BASE+0x4
la      t5, 0xc00fffff                               //set ECC=1 ,RBO/WBO=0
                 //la		t5, 0x800fffff  //set ECC=0 ,RBO/WBO=0
sw      t5, 0(t4)

li      v1, 0                                        //Calculate DMA times //v1: DMA times
nop
4:

#if (defined (CONFIG_NAND_Flash_Small_Page_32MB_3cycles)||defined (CONFIG_NAND_Flash_Small_Page_64MB_4cycles))

li  t9, 4                                            //t9:DMA 512 Read Loop , 4 * 1 DMA (512 bytes) = 2048 Bytes = 1 pages
#endif


#if   (defined(CONFIG_NAND_Flash_Large_Page_128MB_4cycles) || defined(CONFIG_NAND_Flash_Large_Page_256MBto1GB_5cycles))

 li  t9, 4                                            //t9:DMA 512 Read Loop , 4 * 1 DMA (512 bytes) = 2048 Bytes = 1 pages
#endif

#if defined(CONFIG_NAND_Flash_Large_Page_256MBto2GB_5cycles)
li  t9, 4                                            //t9:DMA 512 Read Loop , 4 * 1 DMA (512 bytes) = 2048 Bytes = 1 pages
#endif


#if (defined (CONFIG_NAND_Flash_Large_Page_5cycles_Pages4KB))
li  t9, 8                                            //t9:DMA 512 Read Loop , 8 * 1 DMA (512 bytes) = 4096 Bytes = 1 pages
#endif

#if (defined (CONFIG_NAND_Flash_Large_Page_5cycles_Pages8KB_4GB))
li  t9, 16                                            //t9:DMA 512 Read Loop , 16 * 1 DMA (512 bytes) = 8192 Bytes = 1 pages
#endif

#if (defined (CONFIG_NAND_Flash_Large_Page_5cycles_Pages8KB_8GB))
li  t9, 16                                            //t9:DMA 512 Read Loop , 16 * 1 DMA (512 bytes) = 8192 Bytes = 1 pages
#endif



nop
nop

//UART_PRINT(nand_page_times);  //print out total DMA times
//UART_PRINT(v1);  //v1: DMA pages count
//UART_BIN2HEX(v1);                                   
addiu   v1, v1, +1                                 

5:
//reset command
//REG32_W(0xb801a008,0x400000FF);

#--- NAND DMA Flash data address ---#
la      t4, NAND_CTRL_BASE+0x18
sw      t1, 0(t4)

#--- NAND DMA SDRAM data address ---#
//la      t4, NAND_CTRL_BASE+0x1c
la      t4, NAND_CTRL_BASE+0x20 //For RTL8198C
and     t3,t3,0x1fffffff
sw      t3, 0(t4)

#--- NAND DMA SDRAM oob address ---#
                 //la		t4, NAND_CTRL_BASE+0x54
                  //la		t4, NAND_CTRL_BASE+0x24 //For RTL8198C
                 //la		s1, 0x700000   //put OOB data to DRAM 7MB address
                 //sw		s1, 0(t4)

#--- NAND DMA Read operation ---#
la      t4, NAND_CTRL_BASE+0x10
la      t5, 0x0000005b                               //disable tag access,Enable DMARE
#la     t5, 0x0000001b                               //Enable tag access,Enable DMARE
sw      t5, 0(t4)
NAND_CHECK_READY()

 
NAND_DMA_Read_GoTo_Next:

#if (defined (CONFIG_NAND_Flash_Small_Page_32MB_3cycles)||defined (CONFIG_NAND_Flash_Small_Page_64MB_4cycles))
 addi    t1, t1, 512                                  //flash address+=0x200 , small page ex:page0:0x0,page1:0x200,page2:0x400
// addi    t1, t1, 528                                  //flash address+=0x210

#endif

#if   (defined(CONFIG_NAND_Flash_Large_Page_128MB_4cycles) || defined(CONFIG_NAND_Flash_Large_Page_256MBto1GB_5cycles))

        	addi    t1, t1, 528                                  //flash address+=0x210
#endif

#if defined(CONFIG_NAND_Flash_Large_Page_256MBto2GB_5cycles)

        	addi    t1, t1, 528                                  //flash address+=0x210
#endif

#if  (defined(CONFIG_NAND_Flash_Large_Page_5cycles_Pages4KB))
	  addi    t1, t1, 528                               
#endif          

#if  (defined(CONFIG_NAND_Flash_Large_Page_5cycles_Pages8KB_4GB))
	//addi    t1, t1, 540   
	 addi    t1, t1, 528   
	
#endif    


#if  (defined(CONFIG_NAND_Flash_Large_Page_5cycles_Pages8KB_8GB))
	//addi    t1, t1, 540   
	 addi    t1, t1, 528   
	
#endif    




addi    t3, t3, 512                                  //DRAMaddress+=0x200

addi    t9, t9, -1
nop
nop

bne     t9, 0, 5b
nop
nop

#if (defined (CONFIG_NAND_Flash_Small_Page_32MB_3cycles)||defined (CONFIG_NAND_Flash_Small_Page_64MB_4cycles))
addi    t1, t1,0                                    //t1(flash start address )translate to next flash Page address,ex:page0:0x0,page1:0x200,page2:0x400
addi t2,t2,0                                         //t2 (flash end )+ 0 Bytes , for  balance the incremental value between t1 and t2
#endif

#if (defined (CONFIG_NAND_Flash_Large_Page_256MBto1GB_5cycles)||defined (CONFIG_NAND_Flash_Large_Page_128MB_4cycles))
addi    t1, t1,1984                                 //t1(flash start address )translate to next flash Page address,ex:page0:0x0,page1:0x1000,page2:0x2000
addi t2,t2,1984                                      //t2 (flash end )+1984 Bytes , for  balance the incremental value between t1 and t2
#endif												//0x1000(1 page+OOB=2048+64=2112 bytes) ; 0x1000 -2112=1984

#if defined(CONFIG_NAND_Flash_Large_Page_256MBto2GB_5cycles)
addi    t1, t1,1984                                 //t1(flash start address )translate to next flash Page address,ex:page0:0x0,page1:0x1000,page2:0x2000
addi t2,t2,1984                                      //t2 (flash end )+1984 Bytes , for  balance the incremental value between t1 and t2
#endif												//0x1000(1 page+OOB=2048+64=2112 bytes) ; 0x1000 -2112=1984

#if (defined (CONFIG_NAND_Flash_Large_Page_5cycles_Pages4KB))
addi    t1, t1,3968                               //t1(flash start address )translate to next flash Page address,ex:page0:0x0,page1:0x2000,page2:0x4000
addi t2,t2,3968                                      //t2 (flash end )+3968 Bytes , for  balance the incremental value between t1 and t2
#endif							   //0x2000(1 page+OOB=4096+128=4224 bytes) ; 0x2000 -4224=3968


#if (defined (CONFIG_NAND_Flash_Large_Page_5cycles_Pages8KB_4GB))
//addi    t1, t1, 7744                               //t1(flash start address )translate to next flash Page address,ex:page0:0x0,page1:0x4000,page2:0x8000
//addi t2,t2,7744                                      //t2 (flash end )+7744 Bytes , for  balance the incremental value between t1 and t2
										//0x4000(1 page+OOB=8192+448=8640 bytes) ; 0x4000 -8640=7744

addi    t1, t1,7936                               //t1(flash start address )translate to next flash Page address,ex:page0:0x0,page1:0x4000,page2:0x8000
addi t2,t2,7936                                      //t2 (flash end )+7744 Bytes , for  balance the incremental value between t1 and t2
									//0x4000(1 page+OOB=8192+(16*16)=8448 bytes) ; 0x4000 -8448=7936

#endif							   


#if (defined (CONFIG_NAND_Flash_Large_Page_5cycles_Pages8KB_8GB))
//addi    t1, t1, 7744                               //t1(flash start address )translate to next flash Page address,ex:page0:0x0,page1:0x4000,page2:0x8000
//addi t2,t2,7744                                      //t2 (flash end )+7744 Bytes , for  balance the incremental value between t1 and t2
										//0x4000(1 page+OOB=8192+448=8640 bytes) ; 0x4000 -8640=7744

addi    t1, t1,7936                               //t1(flash start address )translate to next flash Page address,ex:page0:0x0,page1:0x4000,page2:0x8000
addi t2,t2,7936                                      //t2 (flash end )+7744 Bytes , for  balance the incremental value between t1 and t2
									//0x4000(1 page+OOB=8192+(16*16)=8448 bytes) ; 0x4000 -8448=7936

#endif		




                 //bne		t1, t2, 4b
ble     t1, t2, 4b
//b	4b//test
nop
nop

                 // flush all cache
#if 0
mtc0    zero, $20
nop
nop
li      t0, 0x3
mtc0    t0, $20
nop
nop
mtc0    zero, $20
#endif

                 //		Jump to booting
//UART_PRINT(nand_msg_DMA_done);
li      k0, BOOT_ADDR                                //BOOT_ADDR: Dram's booting address

//or k0,k0,0x80000000                                  //jump to cache address will speed boot-up
or k0,k0,0xa0000000                                  //jump to un-cache address 
jr      k0
nop
#endif
//--------------------------------------------------------------------------------	
#if 0
		la a0,__boot_start
		la a1,(__boot_end+4) 
		la a2, BOOT_ADDR
		jal cmp_flash2mem
		nop
		nop
#endif		
//--------------------------------------------------------------------------------

 
//--------------------------------------------------------------------------------
//======================================================================


flush_cache_r:

	#define START_ADDR 0x80000000
	#define _CACHELINE_SIZE 32
	#define _ICACHE_SIZE		(64 * 1024)		
	#define _DCACHE_SIZE		(32 * 1024)	
	#define _SCACHE_SIZE		(512 * 1024)		

	
#define CACHE_OP( code, type )			( ((code) << 2) | (type) )

#define ICACHE_INDEX_INVALIDATE			CACHE_OP(0x0, 0)
#define ICACHE_INDEX_LOAD_TAG			CACHE_OP(0x1, 0)
#define ICACHE_INDEX_STORE_TAG			CACHE_OP(0x2, 0)
#define DCACHE_INDEX_WRITEBACK_INVALIDATE	CACHE_OP(0x0, 1)
#define DCACHE_INDEX_LOAD_TAG			CACHE_OP(0x1, 1)
#define DCACHE_INDEX_STORE_TAG			CACHE_OP(0x2, 1)
#define SCACHE_INDEX_STORE_TAG			CACHE_OP(0x2, 3)

#define ICACHE_ADDR_HIT_INVALIDATE		CACHE_OP(0x4, 0)
#define ICACHE_ADDR_FILL			CACHE_OP(0x5, 0)
#define ICACHE_ADDR_FETCH_LOCK			CACHE_OP(0x7, 0)
#define DCACHE_ADDR_HIT_INVALIDATE		CACHE_OP(0x4, 1)
#define DCACHE_ADDR_HIT_WRITEBACK_INVALIDATE	CACHE_OP(0x5, 1)
#define DCACHE_ADDR_HIT_WRITEBACK		CACHE_OP(0x6, 1)
#define DCACHE_ADDR_FETCH_LOCK			CACHE_OP(0x7, 1)

#define SCACHE_ADDR_HIT_WRITEBACK_INVALIDATE	CACHE_OP(0x5, 3)


	#define MTC0_SEL_OPCODE(src, dst, sel)\
	  	.##word (0x40800000 | ((src)<<16) | ((dst)<<11) | (sel));\
		sll zero,zero,1;\
		sll zero,zero,1;\
		sll zero,zero,1;\
		sll zero,zero,1
		
	//----------------------------------------
//init_L1_dcahe:

	MTC0_SEL_OPCODE( 0, 29, 2 )   //R_C0_DTagHi
	MTC0_SEL_OPCODE( 0, 28, 2 )

0:	
	li	a2, START_ADDR
	li  a1,_CACHELINE_SIZE
	li  a3,START_ADDR+_DCACHE_SIZE-_CACHELINE_SIZE


	/* Loop through all lines, invalidating each of them */
1:	

	cache	DCACHE_INDEX_STORE_TAG, 0(a2)	/* clear tag */


	bne	a2, a3, 1b
	addu	a2, a1


	//--------------------------------------------
//init_L1_icahe:	
	MTC0_SEL_OPCODE( 0, 29, 0 )   //R_C0_ITagHi
	MTC0_SEL_OPCODE( 0, 28, 0 )

0:	
	li	a2, START_ADDR
	li  a1,_CACHELINE_SIZE
	li  a3,START_ADDR+_ICACHE_SIZE-_CACHELINE_SIZE


	/* Loop through all lines, invalidating each of them */
1:	

	cache	ICACHE_INDEX_STORE_TAG, 0(a2)	/* clear tag */


	bne	a2, a3, 1b
	addu	a2, a1
	//--------------------------------------------
init_L2_cache:

#ifdef CONFIG_SPI_FLASH
#define __disable_L2_cache    0
#endif

#ifdef CONFIG_NAND_FLASH_BOOTING
#define __disable_L2_cache    0
#endif
#if __disable_L2_cache
	//disable L2 cache
	li t0,(1<<12)
	MTC0_SEL_OPCODE( 8,16,  2);
#else	
#define RTL98_V0 0x8198C000
	nop
        REG32_R(0xb8000000,t8);
        nop
	nop
//	IF_EQ(t8, RTL98_V0, lab_disSC); //jason
        nop
	nop
	li t0,(0<<12)
	MTC0_SEL_OPCODE( 0, 28, 4 )  //R_C0_SelL23TagLo
	nop
	nop
0:
	li	a2, START_ADDR
	li  a1,_CACHELINE_SIZE
	li  a3,START_ADDR+_SCACHE_SIZE-_CACHELINE_SIZE
	

	/* Loop through all lines, invalidating each of them */
1:	

	cache	SCACHE_INDEX_STORE_TAG, 0(a2)	/* clear tag */

	bne	a2, a3, 1b
	addu	a2, a1
	nop
	nop
	j SC_EXIT
lab_disSC:
	//disable L2 cache
	li t0,(1<<12)
	MTC0_SEL_OPCODE( 8,16,  2);
	nop
	nop
#endif
	
SC_EXIT:
	nop
	
	j ra
	nop
    nop

//==========================================================================
uart_show:	

	//uart_init:		
  	REG32_W( UART_LCR,0x03000000);
  		
  	REG32_W( UART_FCR,0xc7000000);
  	REG32_W( UART_IER,0x00000000);
  	dl = (SYS_CLK_RATE /16)/BAUD_RATE-1;

  	dll = dl & 0xff;
  	dlm = dl / 0x100;
  	REG32_W( UART_LCR,0x83000000);
  	REG32_W( UART_DLL,dll*0x1000000);
   	REG32_W( UART_DLM,dlm*0x1000000); 
	REG32_W( UART_LCR,0x83000000& 0x7fffffff);


	            //uart show
	#ifdef CONFIG_NAND_FLASH_BOOTING
		UART_PRINT(nand_msg);
	#else
		UART_PRINT(boot_msg);		
	#endif
	j ra 
 	nop

 SPI_show:	

	//uart_init:		
  	REG32_W( UART_LCR,0x03000000);
  		
  	REG32_W( UART_FCR,0xc7000000);
  	REG32_W( UART_IER,0x00000000);
  	dl = (SYS_CLK_RATE /16)/BAUD_RATE-1;

  	dll = dl & 0xff;
  	dlm = dl / 0x100;
  	REG32_W( UART_LCR,0x83000000);
  	REG32_W( UART_DLL,dll*0x1000000);
   	REG32_W( UART_DLM,dlm*0x1000000); 
	REG32_W( UART_LCR,0x83000000& 0x7fffffff);

	    
		
	
//	UART_PRINT_DELAY(SPI_msg);		
	
	j ra 
 	nop

#ifdef CONFIG_NAND_FLASH_BOOTING
nand_msg:	.ascii "Nand booting..\0"	
nand_page_times:    .ascii "\r\nNand DMA pages:\0"
nand_msg_ECC_bit:   .ascii "\r\nECC bit:\r\n\0"
nand_ecc_warning_msg_NRER:  .ascii "   Nand DMA ECC NRER error\0"
nand_ecc_warning_msg_NECN:  .ascii "   Nand DMA ECC NECN error\0"
nand_CDF_msg0:  .ascii "\r\nstart.s:SoC ZQ \r\n\0"
nand_CDF_msg1:  .ascii "\r\nstart.s:DRAM DLL reset\r\n\0"
nand_CDF_msg2:  .ascii "\r\nstart.s:Change PLL clock\r\n\0"
nand_CDF_msg3:  .ascii "\r\nstart.s:Enable DRAM refresh\r\n\0"
nand_CDF_msg4:  .ascii "\r\nstart.s:Enable ZQ DRAM long calibration \r\n\0"
nand_CDF_msg5:  .ascii "\r\nstart.s:NAND init DRAM done \r\n\0"
nand_msg_DMA_done:  .ascii "\r\nNandD-R-Done->Jump to DRAM\r\n\0"
#else
boot_msg:	.ascii "\r\nBooting...\r\n\0"
SPI_done_msg:  .ascii "\r\nSPI image move done ->Jump to DRAM\r\n\0"
SPI_msg:  .ascii "\r\n.\0"
#endif

//==========================================================================


#if 0
/* System registers */
#define SYSREG_SYSTEM_STATUS_REG	(0xB8000044)
#define SYSREG_PIN_STATUS_REG		(0xB8000100)
#define SYSREG_LX_PLL_SEL_REG		(0xB8000228)
#define SYSREG_DRAM_CLK_EN_REG		(0xB800022c)
#define SYSREG_SYSCLK_CONTROL_REG	(0xB8000200)
#define SYSREG_MCKG_PHS_SEL_REG		(0xB8000220)
#define SYSREG_MCKG_FREQ_DIV_REG	(0xB8000224)
#define SYSREG_SYSTEM_STATUS_CF_CKSE_OCP0_FD_S (2)
#define SYSREG_SYSTEM_STATUS_CF_CKSE_OCP0_MASK (1 << SYSREG_SYSTEM_STATUS_CF_CKSE_OCP0_FD_S)
#define SYSREG_SYSTEM_STATUS_CF_CKSE_OCP0_OCP0PLL SYSREG_SYSTEM_STATUS_CF_CKSE_OCP0_MASK
#define SYSREG_SYSTEM_STATUS_CF_CKSE_OCP0_LXPLL (0 << SYSREG_SYSTEM_STATUS_CF_CKSE_OCP0_FD_S)

#define SYSREG_PIN_STATUS_CKSEL_FD_S	(5)
#define SYSREG_PIN_STATUS_CKSEL_25MHZ	(0)
#define SYSREG_PIN_STATUS_CKSEL_40MHZ	(1)
#define SYSREG_PIN_STATUS_CKSEL_MASK	(1 << SYSREG_PIN_STATUS_CKSEL_FD_S)

#define SYSREG_DRAM_CLK_EN_FD_S		(0)
#define SYSREG_DRAM_CLK_EN_MASK		(1 << SYSREG_DRAM_CLK_EN_FD_S)
#define SYSREG_PIN_STATUS_CLSEL__FD_S	(5)
#define SYSREG_PIN_STATUS_CLSEL_MASK	(1 << SYSREG_PIN_STATUS_CLSEL__FD_S)
#define SYSREG_LX_DEFAULT_MHZ		(200)
#define SYSREG_MCKG_FREQ_DIV_FD_S    (0)
#define SYSREG_MCKG_FREQ_DIV_MASK    (0x3 << SYSREG_MCKG_FREQ_DIV_FD_S)

#define SYSREG_MCKG_PHS_SEL_PHS_FD_S	(0)
#define SYSREG_MCKG_PHS_SEL_PHS_MASK	(0x7 << SYSREG_MCKG_PHS_SEL_PHS_FD_S)
#define SYSREG_SYSCLK_CONTROL_SDPLL_FD_S (0)
#define SYSREG_SYSCLK_CONTROL_SDPLL_MASK (0x1f << SYSREG_SYSCLK_CONTROL_SDPLL_FD_S)
#define SYSREG_SYSCLK_CONTROL_OCP1PLL_FD_S (8)
#define SYSREG_SYSCLK_CONTROL_OCP1PLL_MASK (0x1f << SYSREG_SYSCLK_CONTROL_OCP1PLL_FD_S)
#define SYSREG_SYSCLK_CONTROL_OCP0PLL_FD_S (16)
#define SYSREG_SYSCLK_CONTROL_OCP0PLL_MASK (0x1f << SYSREG_SYSCLK_CONTROL_OCP0PLL_FD_S)
#define SYSREG_DDRCKODL_DDRCLM_TAP_FD_S (8)
#define SYSREG_DDRCKODL_DDRCLM_TAP_MASK (0x1f << SYSREG_DDRCKODL_DDRCLM_TAP_FD_S)

#define SYSREG_OCP0_DEFAULT_MHZ		(500)
#define SYSREG_DDRCKODL_REG		(0xB800021c)

#define SYSREG_CMUCTLR_REG		(0xB8000308)
#define SYSREG_OCP0_SMALLER_MASK	(16)
#define SYSREG_OCP1_SMALLER_MASK	(8)
#define SYSREG_LX0_SMALLER_MASK		(4)
#define SYSREG_LX1_SMALLER_MASK		(2)
#define SYSREG_LX2_SMALLER_MASK		(1)
	.set push
	.set noreorder
	.set nomips16
LEAF(lowlevel_init)
        /* Enable flash mapping 0xbd000000 */
        li      t0, 0xB8001000
        lw      t1, 0(t0)
        li      t2, (~(1<<18))
        and     t1, t1, t2
        sw      t1, 0(t0)
        nop

        /* Speed Up SPI clock */
        #li      t0, 0xB8001200
	#li	 t1, 0x5fc00000
        #sw      t1, 0(t0)
        #nop


        /* Configure Zone 0 base address */
        li      t0, 0xB8001700
        #li     t1, 0x2000000
        #li     t2, 0x3ffffff
        #sw     t1, 0(t0)
        #sw     t2, 4(t0)
        sw      zero, 0(t0)
        nop

	/* Configure sarm mapping to tempary stack */
        /* Enable CP3 */
        mfc0 t1, $12
        nop
        la t2, 0x80000000
        or t1, t2
        mtc0 t1, $12
        nop
        nop

        /* Disable DMEM 0 */
        mtc0 zero, $20
        la t1, 0x00000800 # bit 11 of COP0 reg 20, sel = 0
        mtc0 t1, $20
        nop
        nop

        li  a0, 0x10003fff
        li  a1, 0x10000000

        /* Load DMEM0 range */
        move t1, a0
        move t2, a1
        mtc3 t1, $5 # IW top
        mtc3 t2, $4 # IW base
        nop
        nop

        /* Enable DMEM0 */
        mtc0 zero, $20
        la t1, 0x00000400 # bit 10 of COP0 reg 20
        mtc0 t1, $20
        nop
        nop

	jr		ra
	nop	
END(lowlevel_init)
	.set pop

//======================================================================
	.text
        .set noreorder
        .globl  _sys_adj_mem_clk
	.ent _sys_adj_mem_clk
_sys_adj_mem_clk:



	  /* Enable flash mapping 0xbd000000 */
        li      t0, 0xB8001000
        lw      t1, 0(t0)
        li      t2, (~(1<<18))
        and     t1, t1, t2
        sw      t1, 0(t0)
        nop

        
	# We skip the PLL adjustment
        # when it's areadly the target freq.

	li	t0, SYSREG_SYSCLK_CONTROL_REG
	lw	t5, 0(t0)
	nop
	bne	a0, t5, 1f
	nop
	#what if it is the defaul value 0?
	#jr	ra
	#nop

1:
	#OK , we decide to adjust PLL setting
	# (1) CPU CLOCK select LX PLL clock
	li 	t6, SYSREG_SYSTEM_STATUS_REG
	lw	t7, 0(t6)
	li	t8, ~SYSREG_SYSTEM_STATUS_CF_CKSE_OCP0_MASK
	and	t7, t7, t8
	sw	t7, 0(t6)

	# (2) Delay a little bit after switching OCP0 clock to LX clock.
	li	t3, 4000
1:
	add	t3, t3, -1
	bne	zero, t3, 1b
	nop

	
	# (3) Invoke the PLL change.
	sw	a0, 0(t0)
2:
	lw	t1, 0(t0)
	bne	a0, t1, 2b
	nop	


	# (4) Set MEMCLK Phase 90 to 90
	# 0:45, 1:62.5, 2:90, 3:112.5, 4~7:135
	li	t0, SYSREG_MCKG_PHS_SEL_REG
	sw	a1, 0(t0)
2:
	lw	t1, 0(t0)
	bne	a1, t1, 2b
	nop
	

	# (5) Set MEMCLK Clock divison
	# 0: 1, 1: div 2, 2: div 4, 3:div 8
	li	t0, SYSREG_MCKG_FREQ_DIV_REG
	sw	a2, 0(t0)
2:
	lw	t1, 0(t0)
	bne	a2, t1, 2b
	nop


	# (6) Delay 4ms for stable clock.
	li	t0, 0x40000
1:
	add	t0, t0, -1
	bne	zero, t0, 1b
	nop
	

	# (7) CPU CLOCK select OCP0 PLL clock
	li 	t0, SYSREG_SYSTEM_STATUS_REG
	lw	t1, 0(t0)
	li	t2, SYSREG_SYSTEM_STATUS_CF_CKSE_OCP0_MASK
	or	t1, t1, t2
	sw	t1, 0(t0)
2:
	lw	t3, 0(t0)
	bne	t1, t3, 2b
	nop


	# Delay 4ms 
	li	t0, 4000
1:
	add	t0, t0, -1
	bne	zero, t0, 1b
	nop

#if 0
	#reinit CPU again
	li	t9, 0xbfc00000
	jr	t9
	nop
#endif
	jr	ra
	nop
	
_sys_adj_mem_clk_end:
	.end _sys_adj_mem_clk

        .text
        .set noreorder
        .globl  sys_adj_mem_clk
	.ent sys_adj_mem_clk
sys_adj_mem_clk:
        /* Runtime deterministic PLL intialization.
         * Enter PLL initialization if it isn't in DRAM.
         * Determine whether we run in DRAM.
         */
         /* If we run in DRAM, skip DRAM initialization.*/
        la      t0, _sys_adj_mem_clk
        li      t1, 0xF0000000
        li      t2, 0x80000000
        li      t3, 0xA0000000
        and     t1, t1, t0
        beq     t1, t2, skip_pll_init
        nop
        beq     t1, t3, skip_pll_init
        nop

	/* copy adj codes */
	li	t0, 0xa0000000
	la	t1, _sys_adj_mem_clk
	la	t2, _sys_adj_mem_clk_end
1:
	lw	t3, 0(t1)
	add	t1, t1, 4
	sw	t3, 0(t0)
	add	t0, t0, 4
	bne	t1, t2, 1b
	nop

	li	t9, 0xa0000000
	jr	t9
	nop
skip_pll_init:
	jr	ra
	nop

	.end sys_adj_mem_clk
#endif
//==========================================================================

